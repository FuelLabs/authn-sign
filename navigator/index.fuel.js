var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __toCommonJS = (from) => {
  const moduleCache = __toCommonJS.moduleCache ??= new WeakMap;
  var cached = moduleCache.get(from);
  if (cached)
    return cached;
  var to = __defProp({}, "__esModule", { value: true });
  var desc = { enumerable: false };
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key))
        __defProp(to, key, {
          get: () => from[key],
          enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
  }
  moduleCache.set(from, to);
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);

// node_modules/semver/internal/constants.js
var require_constants = __commonJS((exports, module) => {
  var SEMVER_SPEC_VERSION = "2.0.0";
  var MAX_LENGTH = 256;
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH = 16;
  var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
  var RELEASE_TYPES = [
    "major",
    "premajor",
    "minor",
    "preminor",
    "patch",
    "prepatch",
    "prerelease"
  ];
  module.exports = {
    MAX_LENGTH,
    MAX_SAFE_COMPONENT_LENGTH,
    MAX_SAFE_BUILD_LENGTH,
    MAX_SAFE_INTEGER,
    RELEASE_TYPES,
    SEMVER_SPEC_VERSION,
    FLAG_INCLUDE_PRERELEASE: 1,
    FLAG_LOOSE: 2
  };
});

// node_modules/semver/internal/debug.js
var require_debug = __commonJS((exports, module) => {
  var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
  };
  module.exports = debug;
});

// node_modules/semver/internal/re.js
var require_re = __commonJS((exports, module) => {
  var {
    MAX_SAFE_COMPONENT_LENGTH,
    MAX_SAFE_BUILD_LENGTH,
    MAX_LENGTH
  } = require_constants();
  var debug = require_debug();
  exports = module.exports = {};
  var re = exports.re = [];
  var safeRe = exports.safeRe = [];
  var src = exports.src = [];
  var t = exports.t = {};
  var R = 0;
  var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
  var safeRegexReplacements = [
    ["\\s", 1],
    ["\\d", MAX_LENGTH],
    [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
  ];
  var makeSafeRegex = (value) => {
    for (const [token, max] of safeRegexReplacements) {
      value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
    }
    return value;
  };
  var createToken = (name, value, isGlobal) => {
    const safe = makeSafeRegex(value);
    const index = R++;
    debug(name, index, value);
    t[name] = index;
    src[index] = value;
    re[index] = new RegExp(value, isGlobal ? "g" : undefined);
    safeRe[index] = new RegExp(safe, isGlobal ? "g" : undefined);
  };
  createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
  createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
  createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.` + `(${src[t.NUMERICIDENTIFIER]})\\.` + `(${src[t.NUMERICIDENTIFIER]})`);
  createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
  createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
  createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
  createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
  createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
  createToken("FULL", `^${src[t.FULLPLAIN]}\$`);
  createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
  createToken("LOOSE", `^${src[t.LOOSEPLAIN]}\$`);
  createToken("GTLT", "((?:<|>)?=?)");
  createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
  createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
  createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t.XRANGEIDENTIFIER]})` + `(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?` + `)?)?`);
  createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?` + `)?)?`);
  createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}\$`);
  createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}\$`);
  createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` + `(?:\$|[^\\d])`);
  createToken("COERCERTL", src[t.COERCE], true);
  createToken("LONETILDE", "(?:~>?)");
  createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
  exports.tildeTrimReplace = "$1~";
  createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}\$`);
  createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}\$`);
  createToken("LONECARET", "(?:\\^)");
  createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
  exports.caretTrimReplace = "$1^";
  createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}\$`);
  createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}\$`);
  createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})\$|^\$`);
  createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})\$|^\$`);
  createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
  exports.comparatorTrimReplace = "$1$2$3";
  createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})` + `\\s+-\\s+` + `(${src[t.XRANGEPLAIN]})` + `\\s*\$`);
  createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})` + `\\s+-\\s+` + `(${src[t.XRANGEPLAINLOOSE]})` + `\\s*\$`);
  createToken("STAR", "(<|>)?=?\\s*\\*");
  createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
  createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
});

// node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS((exports, module) => {
  var looseOption = Object.freeze({ loose: true });
  var emptyOpts = Object.freeze({});
  var parseOptions = (options) => {
    if (!options) {
      return emptyOpts;
    }
    if (typeof options !== "object") {
      return looseOption;
    }
    return options;
  };
  module.exports = parseOptions;
});

// node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS((exports, module) => {
  var numeric = /^[0-9]+$/;
  var compareIdentifiers = (a, b) => {
    const anum = numeric.test(a);
    const bnum = numeric.test(b);
    if (anum && bnum) {
      a = +a;
      b = +b;
    }
    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  };
  var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
  module.exports = {
    compareIdentifiers,
    rcompareIdentifiers
  };
});

// node_modules/semver/classes/semver.js
var require_semver = __commonJS((exports, module) => {
  var debug = require_debug();
  var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
  var { safeRe: re, t } = require_re();
  var parseOptions = require_parse_options();
  var { compareIdentifiers } = require_identifiers();

  class SemVer {
    constructor(version2, options) {
      options = parseOptions(options);
      if (version2 instanceof SemVer) {
        if (version2.loose === !!options.loose && version2.includePrerelease === !!options.includePrerelease) {
          return version2;
        } else {
          version2 = version2.version;
        }
      } else if (typeof version2 !== "string") {
        throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version2}".`);
      }
      if (version2.length > MAX_LENGTH) {
        throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
      }
      debug("SemVer", version2, options);
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      const m = version2.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
      if (!m) {
        throw new TypeError(`Invalid Version: ${version2}`);
      }
      this.raw = version2;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split(".").map((id) => {
          if (/^[0-9]+$/.test(id)) {
            const num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m[5] ? m[5].split(".") : [];
      this.format();
    }
    format() {
      this.version = `${this.major}.${this.minor}.${this.patch}`;
      if (this.prerelease.length) {
        this.version += `-${this.prerelease.join(".")}`;
      }
      return this.version;
    }
    toString() {
      return this.version;
    }
    compare(other) {
      debug("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        if (typeof other === "string" && other === this.version) {
          return 0;
        }
        other = new SemVer(other, this.options);
      }
      if (other.version === this.version) {
        return 0;
      }
      return this.compareMain(other) || this.comparePre(other);
    }
    compareMain(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    }
    comparePre(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      let i = 0;
      do {
        const a = this.prerelease[i];
        const b = other.prerelease[i];
        debug("prerelease compare", i, a, b);
        if (a === undefined && b === undefined) {
          return 0;
        } else if (b === undefined) {
          return 1;
        } else if (a === undefined) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    }
    compareBuild(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      let i = 0;
      do {
        const a = this.build[i];
        const b = other.build[i];
        debug("prerelease compare", i, a, b);
        if (a === undefined && b === undefined) {
          return 0;
        } else if (b === undefined) {
          return 1;
        } else if (a === undefined) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    }
    inc(release, identifier, identifierBase) {
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier, identifierBase);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier, identifierBase);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier, identifierBase);
          this.inc("pre", identifier, identifierBase);
          break;
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier, identifierBase);
          }
          this.inc("pre", identifier, identifierBase);
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        case "pre": {
          const base = Number(identifierBase) ? 1 : 0;
          if (!identifier && identifierBase === false) {
            throw new Error("invalid increment argument: identifier is empty");
          }
          if (this.prerelease.length === 0) {
            this.prerelease = [base];
          } else {
            let i = this.prerelease.length;
            while (--i >= 0) {
              if (typeof this.prerelease[i] === "number") {
                this.prerelease[i]++;
                i = -2;
              }
            }
            if (i === -1) {
              if (identifier === this.prerelease.join(".") && identifierBase === false) {
                throw new Error("invalid increment argument: identifier already exists");
              }
              this.prerelease.push(base);
            }
          }
          if (identifier) {
            let prerelease = [identifier, base];
            if (identifierBase === false) {
              prerelease = [identifier];
            }
            if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = prerelease;
              }
            } else {
              this.prerelease = prerelease;
            }
          }
          break;
        }
        default:
          throw new Error(`invalid increment argument: ${release}`);
      }
      this.raw = this.format();
      if (this.build.length) {
        this.raw += `+${this.build.join(".")}`;
      }
      return this;
    }
  }
  module.exports = SemVer;
});

// node_modules/semver/functions/parse.js
var require_parse = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var parse = (version2, options, throwErrors = false) => {
    if (version2 instanceof SemVer) {
      return version2;
    }
    try {
      return new SemVer(version2, options);
    } catch (er) {
      if (!throwErrors) {
        return null;
      }
      throw er;
    }
  };
  module.exports = parse;
});

// node_modules/semver/functions/valid.js
var require_valid = __commonJS((exports, module) => {
  var parse = require_parse();
  var valid = (version2, options) => {
    const v = parse(version2, options);
    return v ? v.version : null;
  };
  module.exports = valid;
});

// node_modules/semver/functions/clean.js
var require_clean = __commonJS((exports, module) => {
  var parse = require_parse();
  var clean = (version2, options) => {
    const s = parse(version2.trim().replace(/^[=v]+/, ""), options);
    return s ? s.version : null;
  };
  module.exports = clean;
});

// node_modules/semver/functions/inc.js
var require_inc = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var inc = (version2, release, options, identifier, identifierBase) => {
    if (typeof options === "string") {
      identifierBase = identifier;
      identifier = options;
      options = undefined;
    }
    try {
      return new SemVer(version2 instanceof SemVer ? version2.version : version2, options).inc(release, identifier, identifierBase).version;
    } catch (er) {
      return null;
    }
  };
  module.exports = inc;
});

// node_modules/semver/functions/diff.js
var require_diff = __commonJS((exports, module) => {
  var parse = require_parse();
  var diff = (version1, version2) => {
    const v1 = parse(version1, null, true);
    const v2 = parse(version2, null, true);
    const comparison = v1.compare(v2);
    if (comparison === 0) {
      return null;
    }
    const v1Higher = comparison > 0;
    const highVersion = v1Higher ? v1 : v2;
    const lowVersion = v1Higher ? v2 : v1;
    const highHasPre = !!highVersion.prerelease.length;
    const lowHasPre = !!lowVersion.prerelease.length;
    if (lowHasPre && !highHasPre) {
      if (!lowVersion.patch && !lowVersion.minor) {
        return "major";
      }
      if (highVersion.patch) {
        return "patch";
      }
      if (highVersion.minor) {
        return "minor";
      }
      return "major";
    }
    const prefix = highHasPre ? "pre" : "";
    if (v1.major !== v2.major) {
      return prefix + "major";
    }
    if (v1.minor !== v2.minor) {
      return prefix + "minor";
    }
    if (v1.patch !== v2.patch) {
      return prefix + "patch";
    }
    return "prerelease";
  };
  module.exports = diff;
});

// node_modules/semver/functions/major.js
var require_major = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var major = (a, loose) => new SemVer(a, loose).major;
  module.exports = major;
});

// node_modules/semver/functions/minor.js
var require_minor = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var minor = (a, loose) => new SemVer(a, loose).minor;
  module.exports = minor;
});

// node_modules/semver/functions/patch.js
var require_patch = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var patch = (a, loose) => new SemVer(a, loose).patch;
  module.exports = patch;
});

// node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS((exports, module) => {
  var parse = require_parse();
  var prerelease = (version2, options) => {
    const parsed = parse(version2, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  };
  module.exports = prerelease;
});

// node_modules/semver/functions/compare.js
var require_compare = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
  module.exports = compare;
});

// node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS((exports, module) => {
  var compare = require_compare();
  var rcompare = (a, b, loose) => compare(b, a, loose);
  module.exports = rcompare;
});

// node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS((exports, module) => {
  var compare = require_compare();
  var compareLoose = (a, b) => compare(a, b, true);
  module.exports = compareLoose;
});

// node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var compareBuild = (a, b, loose) => {
    const versionA = new SemVer(a, loose);
    const versionB = new SemVer(b, loose);
    return versionA.compare(versionB) || versionA.compareBuild(versionB);
  };
  module.exports = compareBuild;
});

// node_modules/semver/functions/sort.js
var require_sort = __commonJS((exports, module) => {
  var compareBuild = require_compare_build();
  var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
  module.exports = sort;
});

// node_modules/semver/functions/rsort.js
var require_rsort = __commonJS((exports, module) => {
  var compareBuild = require_compare_build();
  var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
  module.exports = rsort;
});

// node_modules/semver/functions/gt.js
var require_gt = __commonJS((exports, module) => {
  var compare = require_compare();
  var gt = (a, b, loose) => compare(a, b, loose) > 0;
  module.exports = gt;
});

// node_modules/semver/functions/lt.js
var require_lt = __commonJS((exports, module) => {
  var compare = require_compare();
  var lt = (a, b, loose) => compare(a, b, loose) < 0;
  module.exports = lt;
});

// node_modules/semver/functions/eq.js
var require_eq = __commonJS((exports, module) => {
  var compare = require_compare();
  var eq = (a, b, loose) => compare(a, b, loose) === 0;
  module.exports = eq;
});

// node_modules/semver/functions/neq.js
var require_neq = __commonJS((exports, module) => {
  var compare = require_compare();
  var neq = (a, b, loose) => compare(a, b, loose) !== 0;
  module.exports = neq;
});

// node_modules/semver/functions/gte.js
var require_gte = __commonJS((exports, module) => {
  var compare = require_compare();
  var gte = (a, b, loose) => compare(a, b, loose) >= 0;
  module.exports = gte;
});

// node_modules/semver/functions/lte.js
var require_lte = __commonJS((exports, module) => {
  var compare = require_compare();
  var lte = (a, b, loose) => compare(a, b, loose) <= 0;
  module.exports = lte;
});

// node_modules/semver/functions/cmp.js
var require_cmp = __commonJS((exports, module) => {
  var eq = require_eq();
  var neq = require_neq();
  var gt = require_gt();
  var gte = require_gte();
  var lt = require_lt();
  var lte = require_lte();
  var cmp = (a, op, b, loose) => {
    switch (op) {
      case "===":
        if (typeof a === "object") {
          a = a.version;
        }
        if (typeof b === "object") {
          b = b.version;
        }
        return a === b;
      case "!==":
        if (typeof a === "object") {
          a = a.version;
        }
        if (typeof b === "object") {
          b = b.version;
        }
        return a !== b;
      case "":
      case "=":
      case "==":
        return eq(a, b, loose);
      case "!=":
        return neq(a, b, loose);
      case ">":
        return gt(a, b, loose);
      case ">=":
        return gte(a, b, loose);
      case "<":
        return lt(a, b, loose);
      case "<=":
        return lte(a, b, loose);
      default:
        throw new TypeError(`Invalid operator: ${op}`);
    }
  };
  module.exports = cmp;
});

// node_modules/semver/functions/coerce.js
var require_coerce = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var parse = require_parse();
  var { safeRe: re, t } = require_re();
  var coerce = (version2, options) => {
    if (version2 instanceof SemVer) {
      return version2;
    }
    if (typeof version2 === "number") {
      version2 = String(version2);
    }
    if (typeof version2 !== "string") {
      return null;
    }
    options = options || {};
    let match = null;
    if (!options.rtl) {
      match = version2.match(re[t.COERCE]);
    } else {
      let next;
      while ((next = re[t.COERCERTL].exec(version2)) && (!match || match.index + match[0].length !== version2.length)) {
        if (!match || next.index + next[0].length !== match.index + match[0].length) {
          match = next;
        }
        re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
      }
      re[t.COERCERTL].lastIndex = -1;
    }
    if (match === null) {
      return null;
    }
    return parse(`${match[2]}.${match[3] || "0"}.${match[4] || "0"}`, options);
  };
  module.exports = coerce;
});

// node_modules/yallist/iterator.js
var require_iterator = __commonJS((exports, module) => {
  module.exports = function(Yallist) {
    Yallist.prototype[Symbol.iterator] = function* () {
      for (let walker = this.head;walker; walker = walker.next) {
        yield walker.value;
      }
    };
  };
});

// node_modules/yallist/yallist.js
var require_yallist = __commonJS((exports, module) => {
  var Yallist = function(list) {
    var self2 = this;
    if (!(self2 instanceof Yallist)) {
      self2 = new Yallist;
    }
    self2.tail = null;
    self2.head = null;
    self2.length = 0;
    if (list && typeof list.forEach === "function") {
      list.forEach(function(item) {
        self2.push(item);
      });
    } else if (arguments.length > 0) {
      for (var i = 0, l = arguments.length;i < l; i++) {
        self2.push(arguments[i]);
      }
    }
    return self2;
  };
  var insert = function(self2, node, value) {
    var inserted = node === self2.head ? new Node(value, null, node, self2) : new Node(value, node, node.next, self2);
    if (inserted.next === null) {
      self2.tail = inserted;
    }
    if (inserted.prev === null) {
      self2.head = inserted;
    }
    self2.length++;
    return inserted;
  };
  var push = function(self2, item) {
    self2.tail = new Node(item, self2.tail, null, self2);
    if (!self2.head) {
      self2.head = self2.tail;
    }
    self2.length++;
  };
  var unshift = function(self2, item) {
    self2.head = new Node(item, null, self2.head, self2);
    if (!self2.tail) {
      self2.tail = self2.head;
    }
    self2.length++;
  };
  var Node = function(value, prev, next, list) {
    if (!(this instanceof Node)) {
      return new Node(value, prev, next, list);
    }
    this.list = list;
    this.value = value;
    if (prev) {
      prev.next = this;
      this.prev = prev;
    } else {
      this.prev = null;
    }
    if (next) {
      next.prev = this;
      this.next = next;
    } else {
      this.next = null;
    }
  };
  module.exports = Yallist;
  Yallist.Node = Node;
  Yallist.create = Yallist;
  Yallist.prototype.removeNode = function(node) {
    if (node.list !== this) {
      throw new Error("removing node which does not belong to this list");
    }
    var next = node.next;
    var prev = node.prev;
    if (next) {
      next.prev = prev;
    }
    if (prev) {
      prev.next = next;
    }
    if (node === this.head) {
      this.head = next;
    }
    if (node === this.tail) {
      this.tail = prev;
    }
    node.list.length--;
    node.next = null;
    node.prev = null;
    node.list = null;
    return next;
  };
  Yallist.prototype.unshiftNode = function(node) {
    if (node === this.head) {
      return;
    }
    if (node.list) {
      node.list.removeNode(node);
    }
    var head = this.head;
    node.list = this;
    node.next = head;
    if (head) {
      head.prev = node;
    }
    this.head = node;
    if (!this.tail) {
      this.tail = node;
    }
    this.length++;
  };
  Yallist.prototype.pushNode = function(node) {
    if (node === this.tail) {
      return;
    }
    if (node.list) {
      node.list.removeNode(node);
    }
    var tail = this.tail;
    node.list = this;
    node.prev = tail;
    if (tail) {
      tail.next = node;
    }
    this.tail = node;
    if (!this.head) {
      this.head = node;
    }
    this.length++;
  };
  Yallist.prototype.push = function() {
    for (var i = 0, l = arguments.length;i < l; i++) {
      push(this, arguments[i]);
    }
    return this.length;
  };
  Yallist.prototype.unshift = function() {
    for (var i = 0, l = arguments.length;i < l; i++) {
      unshift(this, arguments[i]);
    }
    return this.length;
  };
  Yallist.prototype.pop = function() {
    if (!this.tail) {
      return;
    }
    var res = this.tail.value;
    this.tail = this.tail.prev;
    if (this.tail) {
      this.tail.next = null;
    } else {
      this.head = null;
    }
    this.length--;
    return res;
  };
  Yallist.prototype.shift = function() {
    if (!this.head) {
      return;
    }
    var res = this.head.value;
    this.head = this.head.next;
    if (this.head) {
      this.head.prev = null;
    } else {
      this.tail = null;
    }
    this.length--;
    return res;
  };
  Yallist.prototype.forEach = function(fn, thisp) {
    thisp = thisp || this;
    for (var walker = this.head, i = 0;walker !== null; i++) {
      fn.call(thisp, walker.value, i, this);
      walker = walker.next;
    }
  };
  Yallist.prototype.forEachReverse = function(fn, thisp) {
    thisp = thisp || this;
    for (var walker = this.tail, i = this.length - 1;walker !== null; i--) {
      fn.call(thisp, walker.value, i, this);
      walker = walker.prev;
    }
  };
  Yallist.prototype.get = function(n) {
    for (var i = 0, walker = this.head;walker !== null && i < n; i++) {
      walker = walker.next;
    }
    if (i === n && walker !== null) {
      return walker.value;
    }
  };
  Yallist.prototype.getReverse = function(n) {
    for (var i = 0, walker = this.tail;walker !== null && i < n; i++) {
      walker = walker.prev;
    }
    if (i === n && walker !== null) {
      return walker.value;
    }
  };
  Yallist.prototype.map = function(fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist;
    for (var walker = this.head;walker !== null; ) {
      res.push(fn.call(thisp, walker.value, this));
      walker = walker.next;
    }
    return res;
  };
  Yallist.prototype.mapReverse = function(fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist;
    for (var walker = this.tail;walker !== null; ) {
      res.push(fn.call(thisp, walker.value, this));
      walker = walker.prev;
    }
    return res;
  };
  Yallist.prototype.reduce = function(fn, initial) {
    var acc;
    var walker = this.head;
    if (arguments.length > 1) {
      acc = initial;
    } else if (this.head) {
      walker = this.head.next;
      acc = this.head.value;
    } else {
      throw new TypeError("Reduce of empty list with no initial value");
    }
    for (var i = 0;walker !== null; i++) {
      acc = fn(acc, walker.value, i);
      walker = walker.next;
    }
    return acc;
  };
  Yallist.prototype.reduceReverse = function(fn, initial) {
    var acc;
    var walker = this.tail;
    if (arguments.length > 1) {
      acc = initial;
    } else if (this.tail) {
      walker = this.tail.prev;
      acc = this.tail.value;
    } else {
      throw new TypeError("Reduce of empty list with no initial value");
    }
    for (var i = this.length - 1;walker !== null; i--) {
      acc = fn(acc, walker.value, i);
      walker = walker.prev;
    }
    return acc;
  };
  Yallist.prototype.toArray = function() {
    var arr = new Array(this.length);
    for (var i = 0, walker = this.head;walker !== null; i++) {
      arr[i] = walker.value;
      walker = walker.next;
    }
    return arr;
  };
  Yallist.prototype.toArrayReverse = function() {
    var arr = new Array(this.length);
    for (var i = 0, walker = this.tail;walker !== null; i++) {
      arr[i] = walker.value;
      walker = walker.prev;
    }
    return arr;
  };
  Yallist.prototype.slice = function(from, to) {
    to = to || this.length;
    if (to < 0) {
      to += this.length;
    }
    from = from || 0;
    if (from < 0) {
      from += this.length;
    }
    var ret = new Yallist;
    if (to < from || to < 0) {
      return ret;
    }
    if (from < 0) {
      from = 0;
    }
    if (to > this.length) {
      to = this.length;
    }
    for (var i = 0, walker = this.head;walker !== null && i < from; i++) {
      walker = walker.next;
    }
    for (;walker !== null && i < to; i++, walker = walker.next) {
      ret.push(walker.value);
    }
    return ret;
  };
  Yallist.prototype.sliceReverse = function(from, to) {
    to = to || this.length;
    if (to < 0) {
      to += this.length;
    }
    from = from || 0;
    if (from < 0) {
      from += this.length;
    }
    var ret = new Yallist;
    if (to < from || to < 0) {
      return ret;
    }
    if (from < 0) {
      from = 0;
    }
    if (to > this.length) {
      to = this.length;
    }
    for (var i = this.length, walker = this.tail;walker !== null && i > to; i--) {
      walker = walker.prev;
    }
    for (;walker !== null && i > from; i--, walker = walker.prev) {
      ret.push(walker.value);
    }
    return ret;
  };
  Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
    if (start > this.length) {
      start = this.length - 1;
    }
    if (start < 0) {
      start = this.length + start;
    }
    for (var i = 0, walker = this.head;walker !== null && i < start; i++) {
      walker = walker.next;
    }
    var ret = [];
    for (var i = 0;walker && i < deleteCount; i++) {
      ret.push(walker.value);
      walker = this.removeNode(walker);
    }
    if (walker === null) {
      walker = this.tail;
    }
    if (walker !== this.head && walker !== this.tail) {
      walker = walker.prev;
    }
    for (var i = 0;i < nodes.length; i++) {
      walker = insert(this, walker, nodes[i]);
    }
    return ret;
  };
  Yallist.prototype.reverse = function() {
    var head = this.head;
    var tail = this.tail;
    for (var walker = head;walker !== null; walker = walker.prev) {
      var p = walker.prev;
      walker.prev = walker.next;
      walker.next = p;
    }
    this.head = tail;
    this.tail = head;
    return this;
  };
  try {
    require_iterator()(Yallist);
  } catch (er) {
  }
});

// node_modules/semver/node_modules/lru-cache/index.js
var require_lru_cache = __commonJS((exports, module) => {
  var Yallist = require_yallist();
  var MAX = Symbol("max");
  var LENGTH = Symbol("length");
  var LENGTH_CALCULATOR = Symbol("lengthCalculator");
  var ALLOW_STALE = Symbol("allowStale");
  var MAX_AGE = Symbol("maxAge");
  var DISPOSE = Symbol("dispose");
  var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
  var LRU_LIST = Symbol("lruList");
  var CACHE = Symbol("cache");
  var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
  var naiveLength = () => 1;

  class LRUCache {
    constructor(options) {
      if (typeof options === "number")
        options = { max: options };
      if (!options)
        options = {};
      if (options.max && (typeof options.max !== "number" || options.max < 0))
        throw new TypeError("max must be a non-negative number");
      const max = this[MAX] = options.max || Infinity;
      const lc = options.length || naiveLength;
      this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
      this[ALLOW_STALE] = options.stale || false;
      if (options.maxAge && typeof options.maxAge !== "number")
        throw new TypeError("maxAge must be a number");
      this[MAX_AGE] = options.maxAge || 0;
      this[DISPOSE] = options.dispose;
      this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
      this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
      this.reset();
    }
    set max(mL) {
      if (typeof mL !== "number" || mL < 0)
        throw new TypeError("max must be a non-negative number");
      this[MAX] = mL || Infinity;
      trim(this);
    }
    get max() {
      return this[MAX];
    }
    set allowStale(allowStale) {
      this[ALLOW_STALE] = !!allowStale;
    }
    get allowStale() {
      return this[ALLOW_STALE];
    }
    set maxAge(mA) {
      if (typeof mA !== "number")
        throw new TypeError("maxAge must be a non-negative number");
      this[MAX_AGE] = mA;
      trim(this);
    }
    get maxAge() {
      return this[MAX_AGE];
    }
    set lengthCalculator(lC) {
      if (typeof lC !== "function")
        lC = naiveLength;
      if (lC !== this[LENGTH_CALCULATOR]) {
        this[LENGTH_CALCULATOR] = lC;
        this[LENGTH] = 0;
        this[LRU_LIST].forEach((hit) => {
          hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
          this[LENGTH] += hit.length;
        });
      }
      trim(this);
    }
    get lengthCalculator() {
      return this[LENGTH_CALCULATOR];
    }
    get length() {
      return this[LENGTH];
    }
    get itemCount() {
      return this[LRU_LIST].length;
    }
    rforEach(fn, thisp) {
      thisp = thisp || this;
      for (let walker = this[LRU_LIST].tail;walker !== null; ) {
        const prev = walker.prev;
        forEachStep(this, fn, walker, thisp);
        walker = prev;
      }
    }
    forEach(fn, thisp) {
      thisp = thisp || this;
      for (let walker = this[LRU_LIST].head;walker !== null; ) {
        const next = walker.next;
        forEachStep(this, fn, walker, thisp);
        walker = next;
      }
    }
    keys() {
      return this[LRU_LIST].toArray().map((k) => k.key);
    }
    values() {
      return this[LRU_LIST].toArray().map((k) => k.value);
    }
    reset() {
      if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
        this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
      }
      this[CACHE] = new Map;
      this[LRU_LIST] = new Yallist;
      this[LENGTH] = 0;
    }
    dump() {
      return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
        k: hit.key,
        v: hit.value,
        e: hit.now + (hit.maxAge || 0)
      }).toArray().filter((h) => h);
    }
    dumpLru() {
      return this[LRU_LIST];
    }
    set(key, value, maxAge) {
      maxAge = maxAge || this[MAX_AGE];
      if (maxAge && typeof maxAge !== "number")
        throw new TypeError("maxAge must be a number");
      const now = maxAge ? Date.now() : 0;
      const len = this[LENGTH_CALCULATOR](value, key);
      if (this[CACHE].has(key)) {
        if (len > this[MAX]) {
          del(this, this[CACHE].get(key));
          return false;
        }
        const node = this[CACHE].get(key);
        const item = node.value;
        if (this[DISPOSE]) {
          if (!this[NO_DISPOSE_ON_SET])
            this[DISPOSE](key, item.value);
        }
        item.now = now;
        item.maxAge = maxAge;
        item.value = value;
        this[LENGTH] += len - item.length;
        item.length = len;
        this.get(key);
        trim(this);
        return true;
      }
      const hit = new Entry(key, value, len, now, maxAge);
      if (hit.length > this[MAX]) {
        if (this[DISPOSE])
          this[DISPOSE](key, value);
        return false;
      }
      this[LENGTH] += hit.length;
      this[LRU_LIST].unshift(hit);
      this[CACHE].set(key, this[LRU_LIST].head);
      trim(this);
      return true;
    }
    has(key) {
      if (!this[CACHE].has(key))
        return false;
      const hit = this[CACHE].get(key).value;
      return !isStale(this, hit);
    }
    get(key) {
      return get(this, key, true);
    }
    peek(key) {
      return get(this, key, false);
    }
    pop() {
      const node = this[LRU_LIST].tail;
      if (!node)
        return null;
      del(this, node);
      return node.value;
    }
    del(key) {
      del(this, this[CACHE].get(key));
    }
    load(arr) {
      this.reset();
      const now = Date.now();
      for (let l = arr.length - 1;l >= 0; l--) {
        const hit = arr[l];
        const expiresAt = hit.e || 0;
        if (expiresAt === 0)
          this.set(hit.k, hit.v);
        else {
          const maxAge = expiresAt - now;
          if (maxAge > 0) {
            this.set(hit.k, hit.v, maxAge);
          }
        }
      }
    }
    prune() {
      this[CACHE].forEach((value, key) => get(this, key, false));
    }
  }
  var get = (self2, key, doUse) => {
    const node = self2[CACHE].get(key);
    if (node) {
      const hit = node.value;
      if (isStale(self2, hit)) {
        del(self2, node);
        if (!self2[ALLOW_STALE])
          return;
      } else {
        if (doUse) {
          if (self2[UPDATE_AGE_ON_GET])
            node.value.now = Date.now();
          self2[LRU_LIST].unshiftNode(node);
        }
      }
      return hit.value;
    }
  };
  var isStale = (self2, hit) => {
    if (!hit || !hit.maxAge && !self2[MAX_AGE])
      return false;
    const diff = Date.now() - hit.now;
    return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
  };
  var trim = (self2) => {
    if (self2[LENGTH] > self2[MAX]) {
      for (let walker = self2[LRU_LIST].tail;self2[LENGTH] > self2[MAX] && walker !== null; ) {
        const prev = walker.prev;
        del(self2, walker);
        walker = prev;
      }
    }
  };
  var del = (self2, node) => {
    if (node) {
      const hit = node.value;
      if (self2[DISPOSE])
        self2[DISPOSE](hit.key, hit.value);
      self2[LENGTH] -= hit.length;
      self2[CACHE].delete(hit.key);
      self2[LRU_LIST].removeNode(node);
    }
  };

  class Entry {
    constructor(key, value, length, now, maxAge) {
      this.key = key;
      this.value = value;
      this.length = length;
      this.now = now;
      this.maxAge = maxAge || 0;
    }
  }
  var forEachStep = (self2, fn, node, thisp) => {
    let hit = node.value;
    if (isStale(self2, hit)) {
      del(self2, node);
      if (!self2[ALLOW_STALE])
        hit = undefined;
    }
    if (hit)
      fn.call(thisp, hit.value, hit.key, self2);
  };
  module.exports = LRUCache;
});

// node_modules/semver/classes/range.js
var require_range = __commonJS((exports, module) => {
  class Range {
    constructor(range, options) {
      options = parseOptions(options);
      if (range instanceof Range) {
        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options);
        }
      }
      if (range instanceof Comparator) {
        this.raw = range.value;
        this.set = [[range]];
        this.format();
        return this;
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range.trim().split(/\s+/).join(" ");
      this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
      if (!this.set.length) {
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      }
      if (this.set.length > 1) {
        const first = this.set[0];
        this.set = this.set.filter((c) => !isNullSet(c[0]));
        if (this.set.length === 0) {
          this.set = [first];
        } else if (this.set.length > 1) {
          for (const c of this.set) {
            if (c.length === 1 && isAny(c[0])) {
              this.set = [c];
              break;
            }
          }
        }
      }
      this.format();
    }
    format() {
      this.range = this.set.map((comps) => comps.join(" ").trim()).join("||").trim();
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(range) {
      const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
      const memoKey = memoOpts + ":" + range;
      const cached = cache.get(memoKey);
      if (cached) {
        return cached;
      }
      const loose = this.options.loose;
      const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
      range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
      debug("hyphen replace", range);
      range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
      debug("comparator trim", range);
      range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
      debug("tilde trim", range);
      range = range.replace(re[t.CARETTRIM], caretTrimReplace);
      debug("caret trim", range);
      let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
      if (loose) {
        rangeList = rangeList.filter((comp) => {
          debug("loose invalid filter", comp, this.options);
          return !!comp.match(re[t.COMPARATORLOOSE]);
        });
      }
      debug("range list", rangeList);
      const rangeMap = new Map;
      const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
      for (const comp of comparators) {
        if (isNullSet(comp)) {
          return [comp];
        }
        rangeMap.set(comp.value, comp);
      }
      if (rangeMap.size > 1 && rangeMap.has("")) {
        rangeMap.delete("");
      }
      const result = [...rangeMap.values()];
      cache.set(memoKey, result);
      return result;
    }
    intersects(range, options) {
      if (!(range instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some((thisComparators) => {
        return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
          return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
            return rangeComparators.every((rangeComparator) => {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    }
    test(version2) {
      if (!version2) {
        return false;
      }
      if (typeof version2 === "string") {
        try {
          version2 = new SemVer(version2, this.options);
        } catch (er) {
          return false;
        }
      }
      for (let i = 0;i < this.set.length; i++) {
        if (testSet(this.set[i], version2, this.options)) {
          return true;
        }
      }
      return false;
    }
  }
  module.exports = Range;
  var LRU = require_lru_cache();
  var cache = new LRU({ max: 1000 });
  var parseOptions = require_parse_options();
  var Comparator = require_comparator();
  var debug = require_debug();
  var SemVer = require_semver();
  var {
    safeRe: re,
    t,
    comparatorTrimReplace,
    tildeTrimReplace,
    caretTrimReplace
  } = require_re();
  var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
  var isNullSet = (c) => c.value === "<0.0.0-0";
  var isAny = (c) => c.value === "";
  var isSatisfiable = (comparators, options) => {
    let result = true;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every((otherComparator) => {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  };
  var parseComparator = (comp, options) => {
    debug("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug("caret", comp);
    comp = replaceTildes(comp, options);
    debug("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug("xrange", comp);
    comp = replaceStars(comp, options);
    debug("stars", comp);
    return comp;
  };
  var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
  var replaceTildes = (comp, options) => {
    return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
  };
  var replaceTilde = (comp, options) => {
    const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
    return comp.replace(r, (_, M, m, p, pr) => {
      debug("tilde", comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
      } else if (pr) {
        debug("replaceTilde pr", pr);
        ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
      } else {
        ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
      }
      debug("tilde return", ret);
      return ret;
    });
  };
  var replaceCarets = (comp, options) => {
    return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
  };
  var replaceCaret = (comp, options) => {
    debug("caret", comp, options);
    const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
    const z = options.includePrerelease ? "-0" : "";
    return comp.replace(r, (_, M, m, p, pr) => {
      debug("caret", comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        if (M === "0") {
          ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
        }
      } else if (pr) {
        debug("replaceCaret pr", pr);
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
        }
      } else {
        debug("no pr");
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
        }
      }
      debug("caret return", ret);
      return ret;
    });
  };
  var replaceXRanges = (comp, options) => {
    debug("replaceXRanges", comp, options);
    return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
  };
  var replaceXRange = (comp, options) => {
    comp = comp.trim();
    const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
    return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
      debug("xRange", comp, ret, gtlt, M, m, p, pr);
      const xM = isX(M);
      const xm = xM || isX(m);
      const xp = xm || isX(p);
      const anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }
        if (gtlt === "<") {
          pr = "-0";
        }
        ret = `${gtlt + M}.${m}.${p}${pr}`;
      } else if (xm) {
        ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
      } else if (xp) {
        ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
      }
      debug("xRange return", ret);
      return ret;
    });
  };
  var replaceStars = (comp, options) => {
    debug("replaceStars", comp, options);
    return comp.trim().replace(re[t.STAR], "");
  };
  var replaceGTE0 = (comp, options) => {
    debug("replaceGTE0", comp, options);
    return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
  };
  var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
    } else if (isX(fp)) {
      from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
    } else if (fpr) {
      from = `>=${from}`;
    } else {
      from = `>=${from}${incPr ? "-0" : ""}`;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = `<${+tM + 1}.0.0-0`;
    } else if (isX(tp)) {
      to = `<${tM}.${+tm + 1}.0-0`;
    } else if (tpr) {
      to = `<=${tM}.${tm}.${tp}-${tpr}`;
    } else if (incPr) {
      to = `<${tM}.${tm}.${+tp + 1}-0`;
    } else {
      to = `<=${to}`;
    }
    return `${from} ${to}`.trim();
  };
  var testSet = (set, version2, options) => {
    for (let i = 0;i < set.length; i++) {
      if (!set[i].test(version2)) {
        return false;
      }
    }
    if (version2.prerelease.length && !options.includePrerelease) {
      for (let i = 0;i < set.length; i++) {
        debug(set[i].semver);
        if (set[i].semver === Comparator.ANY) {
          continue;
        }
        if (set[i].semver.prerelease.length > 0) {
          const allowed = set[i].semver;
          if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  };
});

// node_modules/semver/classes/comparator.js
var require_comparator = __commonJS((exports, module) => {
  var ANY = Symbol("SemVer ANY");

  class Comparator {
    static get ANY() {
      return ANY;
    }
    constructor(comp, options) {
      options = parseOptions(options);
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      comp = comp.trim().split(/\s+/).join(" ");
      debug("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug("comp", this);
    }
    parse(comp) {
      const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
      const m = comp.match(r);
      if (!m) {
        throw new TypeError(`Invalid comparator: ${comp}`);
      }
      this.operator = m[1] !== undefined ? m[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    }
    toString() {
      return this.value;
    }
    test(version2) {
      debug("Comparator.test", version2, this.options.loose);
      if (this.semver === ANY || version2 === ANY) {
        return true;
      }
      if (typeof version2 === "string") {
        try {
          version2 = new SemVer(version2, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp(version2, this.operator, this.semver, this.options);
    }
    intersects(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        return new Range(comp.value, options).test(this.value);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        return new Range(this.value, options).test(comp.semver);
      }
      options = parseOptions(options);
      if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
        return false;
      }
      if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
        return false;
      }
      if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
        return true;
      }
      if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
        return true;
      }
      if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
        return true;
      }
      if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
        return true;
      }
      if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
        return true;
      }
      return false;
    }
  }
  module.exports = Comparator;
  var parseOptions = require_parse_options();
  var { safeRe: re, t } = require_re();
  var cmp = require_cmp();
  var debug = require_debug();
  var SemVer = require_semver();
  var Range = require_range();
});

// node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS((exports, module) => {
  var Range = require_range();
  var satisfies = (version2, range, options) => {
    try {
      range = new Range(range, options);
    } catch (er) {
      return false;
    }
    return range.test(version2);
  };
  module.exports = satisfies;
});

// node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS((exports, module) => {
  var Range = require_range();
  var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
  module.exports = toComparators;
});

// node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var Range = require_range();
  var maxSatisfying = (versions, range, options) => {
    let max = null;
    let maxSV = null;
    let rangeObj = null;
    try {
      rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach((v) => {
      if (rangeObj.test(v)) {
        if (!max || maxSV.compare(v) === -1) {
          max = v;
          maxSV = new SemVer(max, options);
        }
      }
    });
    return max;
  };
  module.exports = maxSatisfying;
});

// node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var Range = require_range();
  var minSatisfying = (versions, range, options) => {
    let min = null;
    let minSV = null;
    let rangeObj = null;
    try {
      rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach((v) => {
      if (rangeObj.test(v)) {
        if (!min || minSV.compare(v) === 1) {
          min = v;
          minSV = new SemVer(min, options);
        }
      }
    });
    return min;
  };
  module.exports = minSatisfying;
});

// node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var Range = require_range();
  var gt = require_gt();
  var minVersion = (range, loose) => {
    range = new Range(range, loose);
    let minver = new SemVer("0.0.0");
    if (range.test(minver)) {
      return minver;
    }
    minver = new SemVer("0.0.0-0");
    if (range.test(minver)) {
      return minver;
    }
    minver = null;
    for (let i = 0;i < range.set.length; ++i) {
      const comparators = range.set[i];
      let setMin = null;
      comparators.forEach((comparator) => {
        const compver = new SemVer(comparator.semver.version);
        switch (comparator.operator) {
          case ">":
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }
            compver.raw = compver.format();
          case "":
          case ">=":
            if (!setMin || gt(compver, setMin)) {
              setMin = compver;
            }
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error(`Unexpected operation: ${comparator.operator}`);
        }
      });
      if (setMin && (!minver || gt(minver, setMin))) {
        minver = setMin;
      }
    }
    if (minver && range.test(minver)) {
      return minver;
    }
    return null;
  };
  module.exports = minVersion;
});

// node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS((exports, module) => {
  var Range = require_range();
  var validRange = (range, options) => {
    try {
      return new Range(range, options).range || "*";
    } catch (er) {
      return null;
    }
  };
  module.exports = validRange;
});

// node_modules/semver/ranges/outside.js
var require_outside = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var Comparator = require_comparator();
  var { ANY } = Comparator;
  var Range = require_range();
  var satisfies = require_satisfies();
  var gt = require_gt();
  var lt = require_lt();
  var lte = require_lte();
  var gte = require_gte();
  var outside = (version2, range, hilo, options) => {
    version2 = new SemVer(version2, options);
    range = new Range(range, options);
    let gtfn, ltefn, ltfn, comp, ecomp;
    switch (hilo) {
      case ">":
        gtfn = gt;
        ltefn = lte;
        ltfn = lt;
        comp = ">";
        ecomp = ">=";
        break;
      case "<":
        gtfn = lt;
        ltefn = gte;
        ltfn = gt;
        comp = "<";
        ecomp = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies(version2, range, options)) {
      return false;
    }
    for (let i = 0;i < range.set.length; ++i) {
      const comparators = range.set[i];
      let high = null;
      let low = null;
      comparators.forEach((comparator) => {
        if (comparator.semver === ANY) {
          comparator = new Comparator(">=0.0.0");
        }
        high = high || comparator;
        low = low || comparator;
        if (gtfn(comparator.semver, high.semver, options)) {
          high = comparator;
        } else if (ltfn(comparator.semver, low.semver, options)) {
          low = comparator;
        }
      });
      if (high.operator === comp || high.operator === ecomp) {
        return false;
      }
      if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
        return false;
      } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
        return false;
      }
    }
    return true;
  };
  module.exports = outside;
});

// node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS((exports, module) => {
  var outside = require_outside();
  var gtr = (version2, range, options) => outside(version2, range, ">", options);
  module.exports = gtr;
});

// node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS((exports, module) => {
  var outside = require_outside();
  var ltr = (version2, range, options) => outside(version2, range, "<", options);
  module.exports = ltr;
});

// node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS((exports, module) => {
  var Range = require_range();
  var intersects = (r1, r2, options) => {
    r1 = new Range(r1, options);
    r2 = new Range(r2, options);
    return r1.intersects(r2, options);
  };
  module.exports = intersects;
});

// node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS((exports, module) => {
  var satisfies = require_satisfies();
  var compare = require_compare();
  module.exports = (versions, range, options) => {
    const set = [];
    let first = null;
    let prev = null;
    const v = versions.sort((a, b) => compare(a, b, options));
    for (const version2 of v) {
      const included = satisfies(version2, range, options);
      if (included) {
        prev = version2;
        if (!first) {
          first = version2;
        }
      } else {
        if (prev) {
          set.push([first, prev]);
        }
        prev = null;
        first = null;
      }
    }
    if (first) {
      set.push([first, null]);
    }
    const ranges = [];
    for (const [min, max] of set) {
      if (min === max) {
        ranges.push(min);
      } else if (!max && min === v[0]) {
        ranges.push("*");
      } else if (!max) {
        ranges.push(`>=${min}`);
      } else if (min === v[0]) {
        ranges.push(`<=${max}`);
      } else {
        ranges.push(`${min} - ${max}`);
      }
    }
    const simplified = ranges.join(" || ");
    const original = typeof range.raw === "string" ? range.raw : String(range);
    return simplified.length < original.length ? simplified : range;
  };
});

// node_modules/semver/ranges/subset.js
var require_subset = __commonJS((exports, module) => {
  var Range = require_range();
  var Comparator = require_comparator();
  var { ANY } = Comparator;
  var satisfies = require_satisfies();
  var compare = require_compare();
  var subset = (sub, dom, options = {}) => {
    if (sub === dom) {
      return true;
    }
    sub = new Range(sub, options);
    dom = new Range(dom, options);
    let sawNonNull = false;
    OUTER:
      for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub) {
            continue OUTER;
          }
        }
        if (sawNonNull) {
          return false;
        }
      }
    return true;
  };
  var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
  var minimumVersion = [new Comparator(">=0.0.0")];
  var simpleSubset = (sub, dom, options) => {
    if (sub === dom) {
      return true;
    }
    if (sub.length === 1 && sub[0].semver === ANY) {
      if (dom.length === 1 && dom[0].semver === ANY) {
        return true;
      } else if (options.includePrerelease) {
        sub = minimumVersionWithPreRelease;
      } else {
        sub = minimumVersion;
      }
    }
    if (dom.length === 1 && dom[0].semver === ANY) {
      if (options.includePrerelease) {
        return true;
      } else {
        dom = minimumVersion;
      }
    }
    const eqSet = new Set;
    let gt, lt;
    for (const c of sub) {
      if (c.operator === ">" || c.operator === ">=") {
        gt = higherGT(gt, c, options);
      } else if (c.operator === "<" || c.operator === "<=") {
        lt = lowerLT(lt, c, options);
      } else {
        eqSet.add(c.semver);
      }
    }
    if (eqSet.size > 1) {
      return null;
    }
    let gtltComp;
    if (gt && lt) {
      gtltComp = compare(gt.semver, lt.semver, options);
      if (gtltComp > 0) {
        return null;
      } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
        return null;
      }
    }
    for (const eq of eqSet) {
      if (gt && !satisfies(eq, String(gt), options)) {
        return null;
      }
      if (lt && !satisfies(eq, String(lt), options)) {
        return null;
      }
      for (const c of dom) {
        if (!satisfies(eq, String(c), options)) {
          return false;
        }
      }
      return true;
    }
    let higher, lower;
    let hasDomLT, hasDomGT;
    let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
    let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
    if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
      needDomLTPre = false;
    }
    for (const c of dom) {
      hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
      hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
      if (gt) {
        if (needDomGTPre) {
          if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
            needDomGTPre = false;
          }
        }
        if (c.operator === ">" || c.operator === ">=") {
          higher = higherGT(gt, c, options);
          if (higher === c && higher !== gt) {
            return false;
          }
        } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options)) {
          return false;
        }
      }
      if (lt) {
        if (needDomLTPre) {
          if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
            needDomLTPre = false;
          }
        }
        if (c.operator === "<" || c.operator === "<=") {
          lower = lowerLT(lt, c, options);
          if (lower === c && lower !== lt) {
            return false;
          }
        } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options)) {
          return false;
        }
      }
      if (!c.operator && (lt || gt) && gtltComp !== 0) {
        return false;
      }
    }
    if (gt && hasDomLT && !lt && gtltComp !== 0) {
      return false;
    }
    if (lt && hasDomGT && !gt && gtltComp !== 0) {
      return false;
    }
    if (needDomGTPre || needDomLTPre) {
      return false;
    }
    return true;
  };
  var higherGT = (a, b, options) => {
    if (!a) {
      return b;
    }
    const comp = compare(a.semver, b.semver, options);
    return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
  };
  var lowerLT = (a, b, options) => {
    if (!a) {
      return b;
    }
    const comp = compare(a.semver, b.semver, options);
    return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
  };
  module.exports = subset;
});

// node_modules/semver/index.js
var require_semver2 = __commonJS((exports, module) => {
  var internalRe = require_re();
  var constants = require_constants();
  var SemVer = require_semver();
  var identifiers = require_identifiers();
  var parse = require_parse();
  var valid = require_valid();
  var clean = require_clean();
  var inc = require_inc();
  var diff = require_diff();
  var major = require_major();
  var minor = require_minor();
  var patch = require_patch();
  var prerelease = require_prerelease();
  var compare = require_compare();
  var rcompare = require_rcompare();
  var compareLoose = require_compare_loose();
  var compareBuild = require_compare_build();
  var sort = require_sort();
  var rsort = require_rsort();
  var gt = require_gt();
  var lt = require_lt();
  var eq = require_eq();
  var neq = require_neq();
  var gte = require_gte();
  var lte = require_lte();
  var cmp = require_cmp();
  var coerce = require_coerce();
  var Comparator = require_comparator();
  var Range = require_range();
  var satisfies = require_satisfies();
  var toComparators = require_to_comparators();
  var maxSatisfying = require_max_satisfying();
  var minSatisfying = require_min_satisfying();
  var minVersion = require_min_version();
  var validRange = require_valid2();
  var outside = require_outside();
  var gtr = require_gtr();
  var ltr = require_ltr();
  var intersects = require_intersects();
  var simplifyRange = require_simplify();
  var subset = require_subset();
  module.exports = {
    parse,
    valid,
    clean,
    inc,
    diff,
    major,
    minor,
    patch,
    prerelease,
    compare,
    rcompare,
    compareLoose,
    compareBuild,
    sort,
    rsort,
    gt,
    lt,
    eq,
    neq,
    gte,
    lte,
    cmp,
    coerce,
    Comparator,
    Range,
    satisfies,
    toComparators,
    maxSatisfying,
    minSatisfying,
    minVersion,
    validRange,
    outside,
    gtr,
    ltr,
    intersects,
    simplifyRange,
    subset,
    SemVer,
    re: internalRe.re,
    src: internalRe.src,
    tokens: internalRe.t,
    SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
    RELEASE_TYPES: constants.RELEASE_TYPES,
    compareIdentifiers: identifiers.compareIdentifiers,
    rcompareIdentifiers: identifiers.rcompareIdentifiers
  };
});

// node:buffer
var exports_buffer = {};
__export(exports_buffer, {
  default: () => {
    {
      return export_default;
    }
  }
});
var Er, $, dr, gr, mr, Ir, b, Fr, D, _, J, Q, v, z, S, xr, export_default;
var init_buffer = __esm(() => {
  Er = Object.create;
  $ = Object.defineProperty;
  dr = Object.getOwnPropertyDescriptor;
  gr = Object.getOwnPropertyNames;
  mr = Object.getPrototypeOf;
  Ir = Object.prototype.hasOwnProperty;
  b = (i, r) => () => (r || i((r = { exports: {} }).exports, r), r.exports);
  Fr = (i, r) => {
    for (var t in r)
      $(i, t, { get: r[t], enumerable: true });
  };
  D = (i, r, t, n) => {
    if (r && typeof r == "object" || typeof r == "function")
      for (let e of gr(r))
        !Ir.call(i, e) && e !== t && $(i, e, { get: () => r[e], enumerable: !(n = dr(r, e)) || n.enumerable });
    return i;
  };
  _ = (i, r, t) => (D(i, r, "default"), t && D(t, r, "default"));
  J = (i, r, t) => (t = i != null ? Er(mr(i)) : {}, D(r || !i || !i.__esModule ? $(t, "default", { value: i, enumerable: true }) : t, i));
  Q = b((L) => {
    L.byteLength = Ur;
    L.toByteArray = Tr;
    L.fromByteArray = _r;
    var B = [], w = [], Ar = typeof Uint8Array < "u" ? Uint8Array : Array, P = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (m = 0, K = P.length;m < K; ++m)
      B[m] = P[m], w[P.charCodeAt(m)] = m;
    var m, K;
    w["-".charCodeAt(0)] = 62;
    w["_".charCodeAt(0)] = 63;
    function Z(i) {
      var r = i.length;
      if (r % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4");
      var t = i.indexOf("=");
      t === -1 && (t = r);
      var n = t === r ? 0 : 4 - t % 4;
      return [t, n];
    }
    function Ur(i) {
      var r = Z(i), t = r[0], n = r[1];
      return (t + n) * 3 / 4 - n;
    }
    function Rr(i, r, t) {
      return (r + t) * 3 / 4 - t;
    }
    function Tr(i) {
      var r, t = Z(i), n = t[0], e = t[1], o = new Ar(Rr(i, n, e)), u = 0, f2 = e > 0 ? n - 4 : n, c;
      for (c = 0;c < f2; c += 4)
        r = w[i.charCodeAt(c)] << 18 | w[i.charCodeAt(c + 1)] << 12 | w[i.charCodeAt(c + 2)] << 6 | w[i.charCodeAt(c + 3)], o[u++] = r >> 16 & 255, o[u++] = r >> 8 & 255, o[u++] = r & 255;
      return e === 2 && (r = w[i.charCodeAt(c)] << 2 | w[i.charCodeAt(c + 1)] >> 4, o[u++] = r & 255), e === 1 && (r = w[i.charCodeAt(c)] << 10 | w[i.charCodeAt(c + 1)] << 4 | w[i.charCodeAt(c + 2)] >> 2, o[u++] = r >> 8 & 255, o[u++] = r & 255), o;
    }
    function Cr(i) {
      return B[i >> 18 & 63] + B[i >> 12 & 63] + B[i >> 6 & 63] + B[i & 63];
    }
    function Sr(i, r, t) {
      for (var n, e = [], o = r;o < t; o += 3)
        n = (i[o] << 16 & 16711680) + (i[o + 1] << 8 & 65280) + (i[o + 2] & 255), e.push(Cr(n));
      return e.join("");
    }
    function _r(i) {
      for (var r, t = i.length, n = t % 3, e = [], o = 16383, u = 0, f2 = t - n;u < f2; u += o)
        e.push(Sr(i, u, u + o > f2 ? f2 : u + o));
      return n === 1 ? (r = i[t - 1], e.push(B[r >> 2] + B[r << 4 & 63] + "==")) : n === 2 && (r = (i[t - 2] << 8) + i[t - 1], e.push(B[r >> 10] + B[r >> 4 & 63] + B[r << 2 & 63] + "=")), e.join("");
    }
  });
  v = b((O) => {
    O.read = function(i, r, t, n, e) {
      var o, u, f2 = e * 8 - n - 1, c = (1 << f2) - 1, l = c >> 1, s = -7, p = t ? e - 1 : 0, F = t ? -1 : 1, x = i[r + p];
      for (p += F, o = x & (1 << -s) - 1, x >>= -s, s += f2;s > 0; o = o * 256 + i[r + p], p += F, s -= 8)
        ;
      for (u = o & (1 << -s) - 1, o >>= -s, s += n;s > 0; u = u * 256 + i[r + p], p += F, s -= 8)
        ;
      if (o === 0)
        o = 1 - l;
      else {
        if (o === c)
          return u ? NaN : (x ? -1 : 1) * (1 / 0);
        u = u + Math.pow(2, n), o = o - l;
      }
      return (x ? -1 : 1) * u * Math.pow(2, o - n);
    };
    O.write = function(i, r, t, n, e, o) {
      var u, f2, c, l = o * 8 - e - 1, s = (1 << l) - 1, p = s >> 1, F = e === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, x = n ? 0 : o - 1, k = n ? 1 : -1, Br = r < 0 || r === 0 && 1 / r < 0 ? 1 : 0;
      for (r = Math.abs(r), isNaN(r) || r === 1 / 0 ? (f2 = isNaN(r) ? 1 : 0, u = s) : (u = Math.floor(Math.log(r) / Math.LN2), r * (c = Math.pow(2, -u)) < 1 && (u--, c *= 2), u + p >= 1 ? r += F / c : r += F * Math.pow(2, 1 - p), r * c >= 2 && (u++, c /= 2), u + p >= s ? (f2 = 0, u = s) : u + p >= 1 ? (f2 = (r * c - 1) * Math.pow(2, e), u = u + p) : (f2 = r * Math.pow(2, p - 1) * Math.pow(2, e), u = 0));e >= 8; i[t + x] = f2 & 255, x += k, f2 /= 256, e -= 8)
        ;
      for (u = u << e | f2, l += e;l > 0; i[t + x] = u & 255, x += k, u /= 256, l -= 8)
        ;
      i[t + x - k] |= Br * 128;
    };
  });
  z = b((T) => {
    var G = Q(), U = v(), rr = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    T.Buffer = h;
    T.SlowBuffer = $r;
    T.INSPECT_MAX_BYTES = 50;
    var N = 2147483647;
    T.kMaxLength = N;
    h.TYPED_ARRAY_SUPPORT = Lr();
    !h.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function Lr() {
      try {
        let i = new Uint8Array(1), r = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(r, Uint8Array.prototype), Object.setPrototypeOf(i, r), i.foo() === 42;
      } catch {
        return false;
      }
    }
    Object.defineProperty(h.prototype, "parent", { enumerable: true, get: function() {
      if (!!h.isBuffer(this))
        return this.buffer;
    } });
    Object.defineProperty(h.prototype, "offset", { enumerable: true, get: function() {
      if (!!h.isBuffer(this))
        return this.byteOffset;
    } });
    function d(i) {
      if (i > N)
        throw new RangeError('The value "' + i + '" is invalid for option "size"');
      let r = new Uint8Array(i);
      return Object.setPrototypeOf(r, h.prototype), r;
    }
    function h(i, r, t) {
      if (typeof i == "number") {
        if (typeof r == "string")
          throw new TypeError('The "string" argument must be of type string. Received type number');
        return j(i);
      }
      return er(i, r, t);
    }
    h.poolSize = 8192;
    function er(i, r, t) {
      if (typeof i == "string")
        return Mr(i, r);
      if (ArrayBuffer.isView(i))
        return kr(i);
      if (i == null)
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof i);
      if (E(i, ArrayBuffer) || i && E(i.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (E(i, SharedArrayBuffer) || i && E(i.buffer, SharedArrayBuffer)))
        return q(i, r, t);
      if (typeof i == "number")
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      let n = i.valueOf && i.valueOf();
      if (n != null && n !== i)
        return h.from(n, r, t);
      let e = Dr(i);
      if (e)
        return e;
      if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof i[Symbol.toPrimitive] == "function")
        return h.from(i[Symbol.toPrimitive]("string"), r, t);
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof i);
    }
    h.from = function(i, r, t) {
      return er(i, r, t);
    };
    Object.setPrototypeOf(h.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(h, Uint8Array);
    function or(i) {
      if (typeof i != "number")
        throw new TypeError('"size" argument must be of type number');
      if (i < 0)
        throw new RangeError('The value "' + i + '" is invalid for option "size"');
    }
    function Nr(i, r, t) {
      return or(i), i <= 0 ? d(i) : r !== undefined ? typeof t == "string" ? d(i).fill(r, t) : d(i).fill(r) : d(i);
    }
    h.alloc = function(i, r, t) {
      return Nr(i, r, t);
    };
    function j(i) {
      return or(i), d(i < 0 ? 0 : H(i) | 0);
    }
    h.allocUnsafe = function(i) {
      return j(i);
    };
    h.allocUnsafeSlow = function(i) {
      return j(i);
    };
    function Mr(i, r) {
      if ((typeof r != "string" || r === "") && (r = "utf8"), !h.isEncoding(r))
        throw new TypeError("Unknown encoding: " + r);
      let t = ur(i, r) | 0, n = d(t), e = n.write(i, r);
      return e !== t && (n = n.slice(0, e)), n;
    }
    function Y(i) {
      let r = i.length < 0 ? 0 : H(i.length) | 0, t = d(r);
      for (let n = 0;n < r; n += 1)
        t[n] = i[n] & 255;
      return t;
    }
    function kr(i) {
      if (E(i, Uint8Array)) {
        let r = new Uint8Array(i);
        return q(r.buffer, r.byteOffset, r.byteLength);
      }
      return Y(i);
    }
    function q(i, r, t) {
      if (r < 0 || i.byteLength < r)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (i.byteLength < r + (t || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      let n;
      return r === undefined && t === undefined ? n = new Uint8Array(i) : t === undefined ? n = new Uint8Array(i, r) : n = new Uint8Array(i, r, t), Object.setPrototypeOf(n, h.prototype), n;
    }
    function Dr(i) {
      if (h.isBuffer(i)) {
        let r = H(i.length) | 0, t = d(r);
        return t.length === 0 || i.copy(t, 0, 0, r), t;
      }
      if (i.length !== undefined)
        return typeof i.length != "number" || X(i.length) ? d(0) : Y(i);
      if (i.type === "Buffer" && Array.isArray(i.data))
        return Y(i.data);
    }
    function H(i) {
      if (i >= N)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + N.toString(16) + " bytes");
      return i | 0;
    }
    function $r(i) {
      return +i != i && (i = 0), h.alloc(+i);
    }
    h.isBuffer = function(r) {
      return r != null && r._isBuffer === true && r !== h.prototype;
    };
    h.compare = function(r, t) {
      if (E(r, Uint8Array) && (r = h.from(r, r.offset, r.byteLength)), E(t, Uint8Array) && (t = h.from(t, t.offset, t.byteLength)), !h.isBuffer(r) || !h.isBuffer(t))
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      if (r === t)
        return 0;
      let n = r.length, e = t.length;
      for (let o = 0, u = Math.min(n, e);o < u; ++o)
        if (r[o] !== t[o]) {
          n = r[o], e = t[o];
          break;
        }
      return n < e ? -1 : e < n ? 1 : 0;
    };
    h.isEncoding = function(r) {
      switch (String(r).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    h.concat = function(r, t) {
      if (!Array.isArray(r))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (r.length === 0)
        return h.alloc(0);
      let n;
      if (t === undefined)
        for (t = 0, n = 0;n < r.length; ++n)
          t += r[n].length;
      let e = h.allocUnsafe(t), o = 0;
      for (n = 0;n < r.length; ++n) {
        let u = r[n];
        if (E(u, Uint8Array))
          o + u.length > e.length ? (h.isBuffer(u) || (u = h.from(u)), u.copy(e, o)) : Uint8Array.prototype.set.call(e, u, o);
        else if (h.isBuffer(u))
          u.copy(e, o);
        else
          throw new TypeError('"list" argument must be an Array of Buffers');
        o += u.length;
      }
      return e;
    };
    function ur(i, r) {
      if (h.isBuffer(i))
        return i.length;
      if (ArrayBuffer.isView(i) || E(i, ArrayBuffer))
        return i.byteLength;
      if (typeof i != "string")
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof i);
      let t = i.length, n = arguments.length > 2 && arguments[2] === true;
      if (!n && t === 0)
        return 0;
      let e = false;
      for (;; )
        switch (r) {
          case "ascii":
          case "latin1":
          case "binary":
            return t;
          case "utf8":
          case "utf-8":
            return W(i).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return t * 2;
          case "hex":
            return t >>> 1;
          case "base64":
            return wr(i).length;
          default:
            if (e)
              return n ? -1 : W(i).length;
            r = ("" + r).toLowerCase(), e = true;
        }
    }
    h.byteLength = ur;
    function br(i, r, t) {
      let n = false;
      if ((r === undefined || r < 0) && (r = 0), r > this.length || ((t === undefined || t > this.length) && (t = this.length), t <= 0) || (t >>>= 0, r >>>= 0, t <= r))
        return "";
      for (i || (i = "utf8");; )
        switch (i) {
          case "hex":
            return Xr(this, r, t);
          case "utf8":
          case "utf-8":
            return fr(this, r, t);
          case "ascii":
            return Hr(this, r, t);
          case "latin1":
          case "binary":
            return Vr(this, r, t);
          case "base64":
            return Wr(this, r, t);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return zr(this, r, t);
          default:
            if (n)
              throw new TypeError("Unknown encoding: " + i);
            i = (i + "").toLowerCase(), n = true;
        }
    }
    h.prototype._isBuffer = true;
    function I(i, r, t) {
      let n = i[r];
      i[r] = i[t], i[t] = n;
    }
    h.prototype.swap16 = function() {
      let r = this.length;
      if (r % 2 !== 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (let t = 0;t < r; t += 2)
        I(this, t, t + 1);
      return this;
    };
    h.prototype.swap32 = function() {
      let r = this.length;
      if (r % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (let t = 0;t < r; t += 4)
        I(this, t, t + 3), I(this, t + 1, t + 2);
      return this;
    };
    h.prototype.swap64 = function() {
      let r = this.length;
      if (r % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let t = 0;t < r; t += 8)
        I(this, t, t + 7), I(this, t + 1, t + 6), I(this, t + 2, t + 5), I(this, t + 3, t + 4);
      return this;
    };
    h.prototype.toString = function() {
      let r = this.length;
      return r === 0 ? "" : arguments.length === 0 ? fr(this, 0, r) : br.apply(this, arguments);
    };
    h.prototype.toLocaleString = h.prototype.toString;
    h.prototype.equals = function(r) {
      if (!h.isBuffer(r))
        throw new TypeError("Argument must be a Buffer");
      return this === r ? true : h.compare(this, r) === 0;
    };
    h.prototype.inspect = function() {
      let r = "", t = T.INSPECT_MAX_BYTES;
      return r = this.toString("hex", 0, t).replace(/(.{2})/g, "$1 ").trim(), this.length > t && (r += " ... "), "<Buffer " + r + ">";
    };
    rr && (h.prototype[rr] = h.prototype.inspect);
    h.prototype.compare = function(r, t, n, e, o) {
      if (E(r, Uint8Array) && (r = h.from(r, r.offset, r.byteLength)), !h.isBuffer(r))
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof r);
      if (t === undefined && (t = 0), n === undefined && (n = r ? r.length : 0), e === undefined && (e = 0), o === undefined && (o = this.length), t < 0 || n > r.length || e < 0 || o > this.length)
        throw new RangeError("out of range index");
      if (e >= o && t >= n)
        return 0;
      if (e >= o)
        return -1;
      if (t >= n)
        return 1;
      if (t >>>= 0, n >>>= 0, e >>>= 0, o >>>= 0, this === r)
        return 0;
      let u = o - e, f2 = n - t, c = Math.min(u, f2), l = this.slice(e, o), s = r.slice(t, n);
      for (let p = 0;p < c; ++p)
        if (l[p] !== s[p]) {
          u = l[p], f2 = s[p];
          break;
        }
      return u < f2 ? -1 : f2 < u ? 1 : 0;
    };
    function hr(i, r, t, n, e) {
      if (i.length === 0)
        return -1;
      if (typeof t == "string" ? (n = t, t = 0) : t > 2147483647 ? t = 2147483647 : t < -2147483648 && (t = -2147483648), t = +t, X(t) && (t = e ? 0 : i.length - 1), t < 0 && (t = i.length + t), t >= i.length) {
        if (e)
          return -1;
        t = i.length - 1;
      } else if (t < 0)
        if (e)
          t = 0;
        else
          return -1;
      if (typeof r == "string" && (r = h.from(r, n)), h.isBuffer(r))
        return r.length === 0 ? -1 : tr(i, r, t, n, e);
      if (typeof r == "number")
        return r = r & 255, typeof Uint8Array.prototype.indexOf == "function" ? e ? Uint8Array.prototype.indexOf.call(i, r, t) : Uint8Array.prototype.lastIndexOf.call(i, r, t) : tr(i, [r], t, n, e);
      throw new TypeError("val must be string, number or Buffer");
    }
    function tr(i, r, t, n, e) {
      let o = 1, u = i.length, f2 = r.length;
      if (n !== undefined && (n = String(n).toLowerCase(), n === "ucs2" || n === "ucs-2" || n === "utf16le" || n === "utf-16le")) {
        if (i.length < 2 || r.length < 2)
          return -1;
        o = 2, u /= 2, f2 /= 2, t /= 2;
      }
      function c(s, p) {
        return o === 1 ? s[p] : s.readUInt16BE(p * o);
      }
      let l;
      if (e) {
        let s = -1;
        for (l = t;l < u; l++)
          if (c(i, l) === c(r, s === -1 ? 0 : l - s)) {
            if (s === -1 && (s = l), l - s + 1 === f2)
              return s * o;
          } else
            s !== -1 && (l -= l - s), s = -1;
      } else
        for (t + f2 > u && (t = u - f2), l = t;l >= 0; l--) {
          let s = true;
          for (let p = 0;p < f2; p++)
            if (c(i, l + p) !== c(r, p)) {
              s = false;
              break;
            }
          if (s)
            return l;
        }
      return -1;
    }
    h.prototype.includes = function(r, t, n) {
      return this.indexOf(r, t, n) !== -1;
    };
    h.prototype.indexOf = function(r, t, n) {
      return hr(this, r, t, n, true);
    };
    h.prototype.lastIndexOf = function(r, t, n) {
      return hr(this, r, t, n, false);
    };
    function Pr(i, r, t, n) {
      t = Number(t) || 0;
      let e = i.length - t;
      n ? (n = Number(n), n > e && (n = e)) : n = e;
      let o = r.length;
      n > o / 2 && (n = o / 2);
      let u;
      for (u = 0;u < n; ++u) {
        let f2 = parseInt(r.substr(u * 2, 2), 16);
        if (X(f2))
          return u;
        i[t + u] = f2;
      }
      return u;
    }
    function Or(i, r, t, n) {
      return M(W(r, i.length - t), i, t, n);
    }
    function Gr(i, r, t, n) {
      return M(Qr(r), i, t, n);
    }
    function Yr(i, r, t, n) {
      return M(wr(r), i, t, n);
    }
    function qr(i, r, t, n) {
      return M(vr(r, i.length - t), i, t, n);
    }
    h.prototype.write = function(r, t, n, e) {
      if (t === undefined)
        e = "utf8", n = this.length, t = 0;
      else if (n === undefined && typeof t == "string")
        e = t, n = this.length, t = 0;
      else if (isFinite(t))
        t = t >>> 0, isFinite(n) ? (n = n >>> 0, e === undefined && (e = "utf8")) : (e = n, n = undefined);
      else
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      let o = this.length - t;
      if ((n === undefined || n > o) && (n = o), r.length > 0 && (n < 0 || t < 0) || t > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      e || (e = "utf8");
      let u = false;
      for (;; )
        switch (e) {
          case "hex":
            return Pr(this, r, t, n);
          case "utf8":
          case "utf-8":
            return Or(this, r, t, n);
          case "ascii":
          case "latin1":
          case "binary":
            return Gr(this, r, t, n);
          case "base64":
            return Yr(this, r, t, n);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return qr(this, r, t, n);
          default:
            if (u)
              throw new TypeError("Unknown encoding: " + e);
            e = ("" + e).toLowerCase(), u = true;
        }
    };
    h.prototype.toJSON = function() {
      return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
    };
    function Wr(i, r, t) {
      return r === 0 && t === i.length ? G.fromByteArray(i) : G.fromByteArray(i.slice(r, t));
    }
    function fr(i, r, t) {
      t = Math.min(i.length, t);
      let n = [], e = r;
      for (;e < t; ) {
        let o = i[e], u = null, f2 = o > 239 ? 4 : o > 223 ? 3 : o > 191 ? 2 : 1;
        if (e + f2 <= t) {
          let c, l, s, p;
          switch (f2) {
            case 1:
              o < 128 && (u = o);
              break;
            case 2:
              c = i[e + 1], (c & 192) === 128 && (p = (o & 31) << 6 | c & 63, p > 127 && (u = p));
              break;
            case 3:
              c = i[e + 1], l = i[e + 2], (c & 192) === 128 && (l & 192) === 128 && (p = (o & 15) << 12 | (c & 63) << 6 | l & 63, p > 2047 && (p < 55296 || p > 57343) && (u = p));
              break;
            case 4:
              c = i[e + 1], l = i[e + 2], s = i[e + 3], (c & 192) === 128 && (l & 192) === 128 && (s & 192) === 128 && (p = (o & 15) << 18 | (c & 63) << 12 | (l & 63) << 6 | s & 63, p > 65535 && p < 1114112 && (u = p));
          }
        }
        u === null ? (u = 65533, f2 = 1) : u > 65535 && (u -= 65536, n.push(u >>> 10 & 1023 | 55296), u = 56320 | u & 1023), n.push(u), e += f2;
      }
      return jr(n);
    }
    var ir = 4096;
    function jr(i) {
      let r = i.length;
      if (r <= ir)
        return String.fromCharCode.apply(String, i);
      let t = "", n = 0;
      for (;n < r; )
        t += String.fromCharCode.apply(String, i.slice(n, n += ir));
      return t;
    }
    function Hr(i, r, t) {
      let n = "";
      t = Math.min(i.length, t);
      for (let e = r;e < t; ++e)
        n += String.fromCharCode(i[e] & 127);
      return n;
    }
    function Vr(i, r, t) {
      let n = "";
      t = Math.min(i.length, t);
      for (let e = r;e < t; ++e)
        n += String.fromCharCode(i[e]);
      return n;
    }
    function Xr(i, r, t) {
      let n = i.length;
      (!r || r < 0) && (r = 0), (!t || t < 0 || t > n) && (t = n);
      let e = "";
      for (let o = r;o < t; ++o)
        e += rt[i[o]];
      return e;
    }
    function zr(i, r, t) {
      let n = i.slice(r, t), e = "";
      for (let o = 0;o < n.length - 1; o += 2)
        e += String.fromCharCode(n[o] + n[o + 1] * 256);
      return e;
    }
    h.prototype.slice = function(r, t) {
      let n = this.length;
      r = ~~r, t = t === undefined ? n : ~~t, r < 0 ? (r += n, r < 0 && (r = 0)) : r > n && (r = n), t < 0 ? (t += n, t < 0 && (t = 0)) : t > n && (t = n), t < r && (t = r);
      let e = this.subarray(r, t);
      return Object.setPrototypeOf(e, h.prototype), e;
    };
    function a(i, r, t) {
      if (i % 1 !== 0 || i < 0)
        throw new RangeError("offset is not uint");
      if (i + r > t)
        throw new RangeError("Trying to access beyond buffer length");
    }
    h.prototype.readUintLE = h.prototype.readUIntLE = function(r, t, n) {
      r = r >>> 0, t = t >>> 0, n || a(r, t, this.length);
      let e = this[r], o = 1, u = 0;
      for (;++u < t && (o *= 256); )
        e += this[r + u] * o;
      return e;
    };
    h.prototype.readUintBE = h.prototype.readUIntBE = function(r, t, n) {
      r = r >>> 0, t = t >>> 0, n || a(r, t, this.length);
      let e = this[r + --t], o = 1;
      for (;t > 0 && (o *= 256); )
        e += this[r + --t] * o;
      return e;
    };
    h.prototype.readUint8 = h.prototype.readUInt8 = function(r, t) {
      return r = r >>> 0, t || a(r, 1, this.length), this[r];
    };
    h.prototype.readUint16LE = h.prototype.readUInt16LE = function(r, t) {
      return r = r >>> 0, t || a(r, 2, this.length), this[r] | this[r + 1] << 8;
    };
    h.prototype.readUint16BE = h.prototype.readUInt16BE = function(r, t) {
      return r = r >>> 0, t || a(r, 2, this.length), this[r] << 8 | this[r + 1];
    };
    h.prototype.readUint32LE = h.prototype.readUInt32LE = function(r, t) {
      return r = r >>> 0, t || a(r, 4, this.length), (this[r] | this[r + 1] << 8 | this[r + 2] << 16) + this[r + 3] * 16777216;
    };
    h.prototype.readUint32BE = h.prototype.readUInt32BE = function(r, t) {
      return r = r >>> 0, t || a(r, 4, this.length), this[r] * 16777216 + (this[r + 1] << 16 | this[r + 2] << 8 | this[r + 3]);
    };
    h.prototype.readBigUInt64LE = g(function(r) {
      r = r >>> 0, R(r, "offset");
      let t = this[r], n = this[r + 7];
      (t === undefined || n === undefined) && C(r, this.length - 8);
      let e = t + this[++r] * 2 ** 8 + this[++r] * 2 ** 16 + this[++r] * 2 ** 24, o = this[++r] + this[++r] * 2 ** 8 + this[++r] * 2 ** 16 + n * 2 ** 24;
      return BigInt(e) + (BigInt(o) << BigInt(32));
    });
    h.prototype.readBigUInt64BE = g(function(r) {
      r = r >>> 0, R(r, "offset");
      let t = this[r], n = this[r + 7];
      (t === undefined || n === undefined) && C(r, this.length - 8);
      let e = t * 2 ** 24 + this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + this[++r], o = this[++r] * 2 ** 24 + this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + n;
      return (BigInt(e) << BigInt(32)) + BigInt(o);
    });
    h.prototype.readIntLE = function(r, t, n) {
      r = r >>> 0, t = t >>> 0, n || a(r, t, this.length);
      let e = this[r], o = 1, u = 0;
      for (;++u < t && (o *= 256); )
        e += this[r + u] * o;
      return o *= 128, e >= o && (e -= Math.pow(2, 8 * t)), e;
    };
    h.prototype.readIntBE = function(r, t, n) {
      r = r >>> 0, t = t >>> 0, n || a(r, t, this.length);
      let e = t, o = 1, u = this[r + --e];
      for (;e > 0 && (o *= 256); )
        u += this[r + --e] * o;
      return o *= 128, u >= o && (u -= Math.pow(2, 8 * t)), u;
    };
    h.prototype.readInt8 = function(r, t) {
      return r = r >>> 0, t || a(r, 1, this.length), this[r] & 128 ? (255 - this[r] + 1) * -1 : this[r];
    };
    h.prototype.readInt16LE = function(r, t) {
      r = r >>> 0, t || a(r, 2, this.length);
      let n = this[r] | this[r + 1] << 8;
      return n & 32768 ? n | 4294901760 : n;
    };
    h.prototype.readInt16BE = function(r, t) {
      r = r >>> 0, t || a(r, 2, this.length);
      let n = this[r + 1] | this[r] << 8;
      return n & 32768 ? n | 4294901760 : n;
    };
    h.prototype.readInt32LE = function(r, t) {
      return r = r >>> 0, t || a(r, 4, this.length), this[r] | this[r + 1] << 8 | this[r + 2] << 16 | this[r + 3] << 24;
    };
    h.prototype.readInt32BE = function(r, t) {
      return r = r >>> 0, t || a(r, 4, this.length), this[r] << 24 | this[r + 1] << 16 | this[r + 2] << 8 | this[r + 3];
    };
    h.prototype.readBigInt64LE = g(function(r) {
      r = r >>> 0, R(r, "offset");
      let t = this[r], n = this[r + 7];
      (t === undefined || n === undefined) && C(r, this.length - 8);
      let e = this[r + 4] + this[r + 5] * 2 ** 8 + this[r + 6] * 2 ** 16 + (n << 24);
      return (BigInt(e) << BigInt(32)) + BigInt(t + this[++r] * 2 ** 8 + this[++r] * 2 ** 16 + this[++r] * 2 ** 24);
    });
    h.prototype.readBigInt64BE = g(function(r) {
      r = r >>> 0, R(r, "offset");
      let t = this[r], n = this[r + 7];
      (t === undefined || n === undefined) && C(r, this.length - 8);
      let e = (t << 24) + this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + this[++r];
      return (BigInt(e) << BigInt(32)) + BigInt(this[++r] * 2 ** 24 + this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + n);
    });
    h.prototype.readFloatLE = function(r, t) {
      return r = r >>> 0, t || a(r, 4, this.length), U.read(this, r, true, 23, 4);
    };
    h.prototype.readFloatBE = function(r, t) {
      return r = r >>> 0, t || a(r, 4, this.length), U.read(this, r, false, 23, 4);
    };
    h.prototype.readDoubleLE = function(r, t) {
      return r = r >>> 0, t || a(r, 8, this.length), U.read(this, r, true, 52, 8);
    };
    h.prototype.readDoubleBE = function(r, t) {
      return r = r >>> 0, t || a(r, 8, this.length), U.read(this, r, false, 52, 8);
    };
    function y(i, r, t, n, e, o) {
      if (!h.isBuffer(i))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (r > e || r < o)
        throw new RangeError('"value" argument is out of bounds');
      if (t + n > i.length)
        throw new RangeError("Index out of range");
    }
    h.prototype.writeUintLE = h.prototype.writeUIntLE = function(r, t, n, e) {
      if (r = +r, t = t >>> 0, n = n >>> 0, !e) {
        let f2 = Math.pow(2, 8 * n) - 1;
        y(this, r, t, n, f2, 0);
      }
      let o = 1, u = 0;
      for (this[t] = r & 255;++u < n && (o *= 256); )
        this[t + u] = r / o & 255;
      return t + n;
    };
    h.prototype.writeUintBE = h.prototype.writeUIntBE = function(r, t, n, e) {
      if (r = +r, t = t >>> 0, n = n >>> 0, !e) {
        let f2 = Math.pow(2, 8 * n) - 1;
        y(this, r, t, n, f2, 0);
      }
      let o = n - 1, u = 1;
      for (this[t + o] = r & 255;--o >= 0 && (u *= 256); )
        this[t + o] = r / u & 255;
      return t + n;
    };
    h.prototype.writeUint8 = h.prototype.writeUInt8 = function(r, t, n) {
      return r = +r, t = t >>> 0, n || y(this, r, t, 1, 255, 0), this[t] = r & 255, t + 1;
    };
    h.prototype.writeUint16LE = h.prototype.writeUInt16LE = function(r, t, n) {
      return r = +r, t = t >>> 0, n || y(this, r, t, 2, 65535, 0), this[t] = r & 255, this[t + 1] = r >>> 8, t + 2;
    };
    h.prototype.writeUint16BE = h.prototype.writeUInt16BE = function(r, t, n) {
      return r = +r, t = t >>> 0, n || y(this, r, t, 2, 65535, 0), this[t] = r >>> 8, this[t + 1] = r & 255, t + 2;
    };
    h.prototype.writeUint32LE = h.prototype.writeUInt32LE = function(r, t, n) {
      return r = +r, t = t >>> 0, n || y(this, r, t, 4, 4294967295, 0), this[t + 3] = r >>> 24, this[t + 2] = r >>> 16, this[t + 1] = r >>> 8, this[t] = r & 255, t + 4;
    };
    h.prototype.writeUint32BE = h.prototype.writeUInt32BE = function(r, t, n) {
      return r = +r, t = t >>> 0, n || y(this, r, t, 4, 4294967295, 0), this[t] = r >>> 24, this[t + 1] = r >>> 16, this[t + 2] = r >>> 8, this[t + 3] = r & 255, t + 4;
    };
    function cr(i, r, t, n, e) {
      yr(r, n, e, i, t, 7);
      let o = Number(r & BigInt(4294967295));
      i[t++] = o, o = o >> 8, i[t++] = o, o = o >> 8, i[t++] = o, o = o >> 8, i[t++] = o;
      let u = Number(r >> BigInt(32) & BigInt(4294967295));
      return i[t++] = u, u = u >> 8, i[t++] = u, u = u >> 8, i[t++] = u, u = u >> 8, i[t++] = u, t;
    }
    function pr(i, r, t, n, e) {
      yr(r, n, e, i, t, 7);
      let o = Number(r & BigInt(4294967295));
      i[t + 7] = o, o = o >> 8, i[t + 6] = o, o = o >> 8, i[t + 5] = o, o = o >> 8, i[t + 4] = o;
      let u = Number(r >> BigInt(32) & BigInt(4294967295));
      return i[t + 3] = u, u = u >> 8, i[t + 2] = u, u = u >> 8, i[t + 1] = u, u = u >> 8, i[t] = u, t + 8;
    }
    h.prototype.writeBigUInt64LE = g(function(r, t = 0) {
      return cr(this, r, t, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    h.prototype.writeBigUInt64BE = g(function(r, t = 0) {
      return pr(this, r, t, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    h.prototype.writeIntLE = function(r, t, n, e) {
      if (r = +r, t = t >>> 0, !e) {
        let c = Math.pow(2, 8 * n - 1);
        y(this, r, t, n, c - 1, -c);
      }
      let o = 0, u = 1, f2 = 0;
      for (this[t] = r & 255;++o < n && (u *= 256); )
        r < 0 && f2 === 0 && this[t + o - 1] !== 0 && (f2 = 1), this[t + o] = (r / u >> 0) - f2 & 255;
      return t + n;
    };
    h.prototype.writeIntBE = function(r, t, n, e) {
      if (r = +r, t = t >>> 0, !e) {
        let c = Math.pow(2, 8 * n - 1);
        y(this, r, t, n, c - 1, -c);
      }
      let o = n - 1, u = 1, f2 = 0;
      for (this[t + o] = r & 255;--o >= 0 && (u *= 256); )
        r < 0 && f2 === 0 && this[t + o + 1] !== 0 && (f2 = 1), this[t + o] = (r / u >> 0) - f2 & 255;
      return t + n;
    };
    h.prototype.writeInt8 = function(r, t, n) {
      return r = +r, t = t >>> 0, n || y(this, r, t, 1, 127, -128), r < 0 && (r = 255 + r + 1), this[t] = r & 255, t + 1;
    };
    h.prototype.writeInt16LE = function(r, t, n) {
      return r = +r, t = t >>> 0, n || y(this, r, t, 2, 32767, -32768), this[t] = r & 255, this[t + 1] = r >>> 8, t + 2;
    };
    h.prototype.writeInt16BE = function(r, t, n) {
      return r = +r, t = t >>> 0, n || y(this, r, t, 2, 32767, -32768), this[t] = r >>> 8, this[t + 1] = r & 255, t + 2;
    };
    h.prototype.writeInt32LE = function(r, t, n) {
      return r = +r, t = t >>> 0, n || y(this, r, t, 4, 2147483647, -2147483648), this[t] = r & 255, this[t + 1] = r >>> 8, this[t + 2] = r >>> 16, this[t + 3] = r >>> 24, t + 4;
    };
    h.prototype.writeInt32BE = function(r, t, n) {
      return r = +r, t = t >>> 0, n || y(this, r, t, 4, 2147483647, -2147483648), r < 0 && (r = 4294967295 + r + 1), this[t] = r >>> 24, this[t + 1] = r >>> 16, this[t + 2] = r >>> 8, this[t + 3] = r & 255, t + 4;
    };
    h.prototype.writeBigInt64LE = g(function(r, t = 0) {
      return cr(this, r, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    h.prototype.writeBigInt64BE = g(function(r, t = 0) {
      return pr(this, r, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function sr(i, r, t, n, e, o) {
      if (t + n > i.length)
        throw new RangeError("Index out of range");
      if (t < 0)
        throw new RangeError("Index out of range");
    }
    function lr(i, r, t, n, e) {
      return r = +r, t = t >>> 0, e || sr(i, r, t, 4, 340282346638528860000000000000000000000, -340282346638528860000000000000000000000), U.write(i, r, t, n, 23, 4), t + 4;
    }
    h.prototype.writeFloatLE = function(r, t, n) {
      return lr(this, r, t, true, n);
    };
    h.prototype.writeFloatBE = function(r, t, n) {
      return lr(this, r, t, false, n);
    };
    function ar(i, r, t, n, e) {
      return r = +r, t = t >>> 0, e || sr(i, r, t, 8, 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), U.write(i, r, t, n, 52, 8), t + 8;
    }
    h.prototype.writeDoubleLE = function(r, t, n) {
      return ar(this, r, t, true, n);
    };
    h.prototype.writeDoubleBE = function(r, t, n) {
      return ar(this, r, t, false, n);
    };
    h.prototype.copy = function(r, t, n, e) {
      if (!h.isBuffer(r))
        throw new TypeError("argument should be a Buffer");
      if (n || (n = 0), !e && e !== 0 && (e = this.length), t >= r.length && (t = r.length), t || (t = 0), e > 0 && e < n && (e = n), e === n || r.length === 0 || this.length === 0)
        return 0;
      if (t < 0)
        throw new RangeError("targetStart out of bounds");
      if (n < 0 || n >= this.length)
        throw new RangeError("Index out of range");
      if (e < 0)
        throw new RangeError("sourceEnd out of bounds");
      e > this.length && (e = this.length), r.length - t < e - n && (e = r.length - t + n);
      let o = e - n;
      return this === r && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(t, n, e) : Uint8Array.prototype.set.call(r, this.subarray(n, e), t), o;
    };
    h.prototype.fill = function(r, t, n, e) {
      if (typeof r == "string") {
        if (typeof t == "string" ? (e = t, t = 0, n = this.length) : typeof n == "string" && (e = n, n = this.length), e !== undefined && typeof e != "string")
          throw new TypeError("encoding must be a string");
        if (typeof e == "string" && !h.isEncoding(e))
          throw new TypeError("Unknown encoding: " + e);
        if (r.length === 1) {
          let u = r.charCodeAt(0);
          (e === "utf8" && u < 128 || e === "latin1") && (r = u);
        }
      } else
        typeof r == "number" ? r = r & 255 : typeof r == "boolean" && (r = Number(r));
      if (t < 0 || this.length < t || this.length < n)
        throw new RangeError("Out of range index");
      if (n <= t)
        return this;
      t = t >>> 0, n = n === undefined ? this.length : n >>> 0, r || (r = 0);
      let o;
      if (typeof r == "number")
        for (o = t;o < n; ++o)
          this[o] = r;
      else {
        let u = h.isBuffer(r) ? r : h.from(r, e), f2 = u.length;
        if (f2 === 0)
          throw new TypeError('The value "' + r + '" is invalid for argument "value"');
        for (o = 0;o < n - t; ++o)
          this[o + t] = u[o % f2];
      }
      return this;
    };
    var A = {};
    function V(i, r, t) {
      A[i] = class extends t {
        constructor() {
          super(), Object.defineProperty(this, "message", { value: r.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${i}]`, this.stack, delete this.name;
        }
        get code() {
          return i;
        }
        set code(e) {
          Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: e, writable: true });
        }
        toString() {
          return `${this.name} [${i}]: ${this.message}`;
        }
      };
    }
    V("ERR_BUFFER_OUT_OF_BOUNDS", function(i) {
      return i ? `${i} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    }, RangeError);
    V("ERR_INVALID_ARG_TYPE", function(i, r) {
      return `The "${i}" argument must be of type number. Received type ${typeof r}`;
    }, TypeError);
    V("ERR_OUT_OF_RANGE", function(i, r, t) {
      let n = `The value of "${i}" is out of range.`, e = t;
      return Number.isInteger(t) && Math.abs(t) > 2 ** 32 ? e = nr(String(t)) : typeof t == "bigint" && (e = String(t), (t > BigInt(2) ** BigInt(32) || t < -(BigInt(2) ** BigInt(32))) && (e = nr(e)), e += "n"), n += ` It must be ${r}. Received ${e}`, n;
    }, RangeError);
    function nr(i) {
      let r = "", t = i.length, n = i[0] === "-" ? 1 : 0;
      for (;t >= n + 4; t -= 3)
        r = `_${i.slice(t - 3, t)}${r}`;
      return `${i.slice(0, t)}${r}`;
    }
    function Jr(i, r, t) {
      R(r, "offset"), (i[r] === undefined || i[r + t] === undefined) && C(r, i.length - (t + 1));
    }
    function yr(i, r, t, n, e, o) {
      if (i > t || i < r) {
        let u = typeof r == "bigint" ? "n" : "", f2;
        throw o > 3 ? r === 0 || r === BigInt(0) ? f2 = `>= 0${u} and < 2${u} ** ${(o + 1) * 8}${u}` : f2 = `>= -(2${u} ** ${(o + 1) * 8 - 1}${u}) and < 2 ** ${(o + 1) * 8 - 1}${u}` : f2 = `>= ${r}${u} and <= ${t}${u}`, new A.ERR_OUT_OF_RANGE("value", f2, i);
      }
      Jr(n, e, o);
    }
    function R(i, r) {
      if (typeof i != "number")
        throw new A.ERR_INVALID_ARG_TYPE(r, "number", i);
    }
    function C(i, r, t) {
      throw Math.floor(i) !== i ? (R(i, t), new A.ERR_OUT_OF_RANGE(t || "offset", "an integer", i)) : r < 0 ? new A.ERR_BUFFER_OUT_OF_BOUNDS : new A.ERR_OUT_OF_RANGE(t || "offset", `>= ${t ? 1 : 0} and <= ${r}`, i);
    }
    var Kr2 = /[^+/0-9A-Za-z-_]/g;
    function Zr(i) {
      if (i = i.split("=")[0], i = i.trim().replace(Kr2, ""), i.length < 2)
        return "";
      for (;i.length % 4 !== 0; )
        i = i + "=";
      return i;
    }
    function W(i, r) {
      r = r || 1 / 0;
      let t, n = i.length, e = null, o = [];
      for (let u = 0;u < n; ++u) {
        if (t = i.charCodeAt(u), t > 55295 && t < 57344) {
          if (!e) {
            if (t > 56319) {
              (r -= 3) > -1 && o.push(239, 191, 189);
              continue;
            } else if (u + 1 === n) {
              (r -= 3) > -1 && o.push(239, 191, 189);
              continue;
            }
            e = t;
            continue;
          }
          if (t < 56320) {
            (r -= 3) > -1 && o.push(239, 191, 189), e = t;
            continue;
          }
          t = (e - 55296 << 10 | t - 56320) + 65536;
        } else
          e && (r -= 3) > -1 && o.push(239, 191, 189);
        if (e = null, t < 128) {
          if ((r -= 1) < 0)
            break;
          o.push(t);
        } else if (t < 2048) {
          if ((r -= 2) < 0)
            break;
          o.push(t >> 6 | 192, t & 63 | 128);
        } else if (t < 65536) {
          if ((r -= 3) < 0)
            break;
          o.push(t >> 12 | 224, t >> 6 & 63 | 128, t & 63 | 128);
        } else if (t < 1114112) {
          if ((r -= 4) < 0)
            break;
          o.push(t >> 18 | 240, t >> 12 & 63 | 128, t >> 6 & 63 | 128, t & 63 | 128);
        } else
          throw new Error("Invalid code point");
      }
      return o;
    }
    function Qr(i) {
      let r = [];
      for (let t = 0;t < i.length; ++t)
        r.push(i.charCodeAt(t) & 255);
      return r;
    }
    function vr(i, r) {
      let t, n, e, o = [];
      for (let u = 0;u < i.length && !((r -= 2) < 0); ++u)
        t = i.charCodeAt(u), n = t >> 8, e = t % 256, o.push(e), o.push(n);
      return o;
    }
    function wr(i) {
      return G.toByteArray(Zr(i));
    }
    function M(i, r, t, n) {
      let e;
      for (e = 0;e < n && !(e + t >= r.length || e >= i.length); ++e)
        r[e + t] = i[e];
      return e;
    }
    function E(i, r) {
      return i instanceof r || i != null && i.constructor != null && i.constructor.name != null && i.constructor.name === r.name;
    }
    function X(i) {
      return i !== i;
    }
    var rt = function() {
      let i = "0123456789abcdef", r = new Array(256);
      for (let t = 0;t < 16; ++t) {
        let n = t * 16;
        for (let e = 0;e < 16; ++e)
          r[n + e] = i[t] + i[e];
      }
      return r;
    }();
    function g(i) {
      return typeof BigInt > "u" ? tt : i;
    }
    function tt() {
      throw new Error("BigInt not supported");
    }
  });
  S = {};
  Fr(S, { default: () => xr.Buffer });
  _(S, J(z()));
  xr = J(z());
  export_default = xr.Buffer;
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
});

// node_modules/bn.js/lib/bn.js
var require_bn = __commonJS((exports, module) => {
  (function(module2, exports2) {
    function assert2(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor;
      ctor.prototype.constructor = ctor;
    }
    function BN(number2, base, endian) {
      if (BN.isBN(number2)) {
        return number2;
      }
      this.negative = 0;
      this.words = null;
      this.length = 0;
      this.red = null;
      if (number2 !== null) {
        if (base === "le" || base === "be") {
          endian = base;
          base = 10;
        }
        this._init(number2 || 0, base || 10, endian || "be");
      }
    }
    if (typeof module2 === "object") {
      module2.exports = BN;
    } else {
      exports2.BN = BN;
    }
    BN.BN = BN;
    BN.wordSize = 26;
    var Buffer2;
    try {
      if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
        Buffer2 = window.Buffer;
      } else {
        Buffer2 = (init_buffer(), __toCommonJS(exports_buffer)).Buffer;
      }
    } catch (e) {
    }
    BN.isBN = function isBN(num) {
      if (num instanceof BN) {
        return true;
      }
      return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
    };
    BN.max = function max(left, right) {
      if (left.cmp(right) > 0)
        return left;
      return right;
    };
    BN.min = function min(left, right) {
      if (left.cmp(right) < 0)
        return left;
      return right;
    };
    BN.prototype._init = function init(number2, base, endian) {
      if (typeof number2 === "number") {
        return this._initNumber(number2, base, endian);
      }
      if (typeof number2 === "object") {
        return this._initArray(number2, base, endian);
      }
      if (base === "hex") {
        base = 16;
      }
      assert2(base === (base | 0) && base >= 2 && base <= 36);
      number2 = number2.toString().replace(/\s+/g, "");
      var start = 0;
      if (number2[0] === "-") {
        start++;
        this.negative = 1;
      }
      if (start < number2.length) {
        if (base === 16) {
          this._parseHex(number2, start, endian);
        } else {
          this._parseBase(number2, base, start);
          if (endian === "le") {
            this._initArray(this.toArray(), base, endian);
          }
        }
      }
    };
    BN.prototype._initNumber = function _initNumber(number2, base, endian) {
      if (number2 < 0) {
        this.negative = 1;
        number2 = -number2;
      }
      if (number2 < 67108864) {
        this.words = [number2 & 67108863];
        this.length = 1;
      } else if (number2 < 4503599627370496) {
        this.words = [
          number2 & 67108863,
          number2 / 67108864 & 67108863
        ];
        this.length = 2;
      } else {
        assert2(number2 < 9007199254740992);
        this.words = [
          number2 & 67108863,
          number2 / 67108864 & 67108863,
          1
        ];
        this.length = 3;
      }
      if (endian !== "le")
        return;
      this._initArray(this.toArray(), base, endian);
    };
    BN.prototype._initArray = function _initArray(number2, base, endian) {
      assert2(typeof number2.length === "number");
      if (number2.length <= 0) {
        this.words = [0];
        this.length = 1;
        return this;
      }
      this.length = Math.ceil(number2.length / 3);
      this.words = new Array(this.length);
      for (var i = 0;i < this.length; i++) {
        this.words[i] = 0;
      }
      var j, w;
      var off = 0;
      if (endian === "be") {
        for (i = number2.length - 1, j = 0;i >= 0; i -= 3) {
          w = number2[i] | number2[i - 1] << 8 | number2[i - 2] << 16;
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] = w >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      } else if (endian === "le") {
        for (i = 0, j = 0;i < number2.length; i += 3) {
          w = number2[i] | number2[i + 1] << 8 | number2[i + 2] << 16;
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] = w >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      }
      return this._strip();
    };
    function parseHex4Bits(string, index) {
      var c = string.charCodeAt(index);
      if (c >= 48 && c <= 57) {
        return c - 48;
      } else if (c >= 65 && c <= 70) {
        return c - 55;
      } else if (c >= 97 && c <= 102) {
        return c - 87;
      } else {
        assert2(false, "Invalid character in " + string);
      }
    }
    function parseHexByte(string, lowerBound, index) {
      var r = parseHex4Bits(string, index);
      if (index - 1 >= lowerBound) {
        r |= parseHex4Bits(string, index - 1) << 4;
      }
      return r;
    }
    BN.prototype._parseHex = function _parseHex(number2, start, endian) {
      this.length = Math.ceil((number2.length - start) / 6);
      this.words = new Array(this.length);
      for (var i = 0;i < this.length; i++) {
        this.words[i] = 0;
      }
      var off = 0;
      var j = 0;
      var w;
      if (endian === "be") {
        for (i = number2.length - 1;i >= start; i -= 2) {
          w = parseHexByte(number2, start, i) << off;
          this.words[j] |= w & 67108863;
          if (off >= 18) {
            off -= 18;
            j += 1;
            this.words[j] |= w >>> 26;
          } else {
            off += 8;
          }
        }
      } else {
        var parseLength = number2.length - start;
        for (i = parseLength % 2 === 0 ? start + 1 : start;i < number2.length; i += 2) {
          w = parseHexByte(number2, start, i) << off;
          this.words[j] |= w & 67108863;
          if (off >= 18) {
            off -= 18;
            j += 1;
            this.words[j] |= w >>> 26;
          } else {
            off += 8;
          }
        }
      }
      this._strip();
    };
    function parseBase(str, start, end, mul) {
      var r = 0;
      var b2 = 0;
      var len = Math.min(str.length, end);
      for (var i = start;i < len; i++) {
        var c = str.charCodeAt(i) - 48;
        r *= mul;
        if (c >= 49) {
          b2 = c - 49 + 10;
        } else if (c >= 17) {
          b2 = c - 17 + 10;
        } else {
          b2 = c;
        }
        assert2(c >= 0 && b2 < mul, "Invalid character");
        r += b2;
      }
      return r;
    }
    BN.prototype._parseBase = function _parseBase(number2, base, start) {
      this.words = [0];
      this.length = 1;
      for (var limbLen = 0, limbPow = 1;limbPow <= 67108863; limbPow *= base) {
        limbLen++;
      }
      limbLen--;
      limbPow = limbPow / base | 0;
      var total = number2.length - start;
      var mod = total % limbLen;
      var end = Math.min(total, total - mod) + start;
      var word = 0;
      for (var i = start;i < end; i += limbLen) {
        word = parseBase(number2, i, i + limbLen, base);
        this.imuln(limbPow);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      if (mod !== 0) {
        var pow = 1;
        word = parseBase(number2, i, number2.length, base);
        for (i = 0;i < mod; i++) {
          pow *= base;
        }
        this.imuln(pow);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      this._strip();
    };
    BN.prototype.copy = function copy(dest) {
      dest.words = new Array(this.length);
      for (var i = 0;i < this.length; i++) {
        dest.words[i] = this.words[i];
      }
      dest.length = this.length;
      dest.negative = this.negative;
      dest.red = this.red;
    };
    function move(dest, src) {
      dest.words = src.words;
      dest.length = src.length;
      dest.negative = src.negative;
      dest.red = src.red;
    }
    BN.prototype._move = function _move(dest) {
      move(dest, this);
    };
    BN.prototype.clone = function clone() {
      var r = new BN(null);
      this.copy(r);
      return r;
    };
    BN.prototype._expand = function _expand(size) {
      while (this.length < size) {
        this.words[this.length++] = 0;
      }
      return this;
    };
    BN.prototype._strip = function strip() {
      while (this.length > 1 && this.words[this.length - 1] === 0) {
        this.length--;
      }
      return this._normSign();
    };
    BN.prototype._normSign = function _normSign() {
      if (this.length === 1 && this.words[0] === 0) {
        this.negative = 0;
      }
      return this;
    };
    if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
      try {
        BN.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect;
      } catch (e) {
        BN.prototype.inspect = inspect;
      }
    } else {
      BN.prototype.inspect = inspect;
    }
    function inspect() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var zeros = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ];
    var groupSizes = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ];
    var groupBases = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64000000,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      24300000,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    BN.prototype.toString = function toString(base, padding) {
      base = base || 10;
      padding = padding | 0 || 1;
      var out;
      if (base === 16 || base === "hex") {
        out = "";
        var off = 0;
        var carry = 0;
        for (var i = 0;i < this.length; i++) {
          var w = this.words[i];
          var word = ((w << off | carry) & 16777215).toString(16);
          carry = w >>> 24 - off & 16777215;
          off += 2;
          if (off >= 26) {
            off -= 26;
            i--;
          }
          if (carry !== 0 || i !== this.length - 1) {
            out = zeros[6 - word.length] + word + out;
          } else {
            out = word + out;
          }
        }
        if (carry !== 0) {
          out = carry.toString(16) + out;
        }
        while (out.length % padding !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      if (base === (base | 0) && base >= 2 && base <= 36) {
        var groupSize = groupSizes[base];
        var groupBase = groupBases[base];
        out = "";
        var c = this.clone();
        c.negative = 0;
        while (!c.isZero()) {
          var r = c.modrn(groupBase).toString(base);
          c = c.idivn(groupBase);
          if (!c.isZero()) {
            out = zeros[groupSize - r.length] + r + out;
          } else {
            out = r + out;
          }
        }
        if (this.isZero()) {
          out = "0" + out;
        }
        while (out.length % padding !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      assert2(false, "Base should be between 2 and 36");
    };
    BN.prototype.toNumber = function toNumber() {
      var ret = this.words[0];
      if (this.length === 2) {
        ret += this.words[1] * 67108864;
      } else if (this.length === 3 && this.words[2] === 1) {
        ret += 4503599627370496 + this.words[1] * 67108864;
      } else if (this.length > 2) {
        assert2(false, "Number can only safely store up to 53 bits");
      }
      return this.negative !== 0 ? -ret : ret;
    };
    BN.prototype.toJSON = function toJSON() {
      return this.toString(16, 2);
    };
    if (Buffer2) {
      BN.prototype.toBuffer = function toBuffer(endian, length) {
        return this.toArrayLike(Buffer2, endian, length);
      };
    }
    BN.prototype.toArray = function toArray(endian, length) {
      return this.toArrayLike(Array, endian, length);
    };
    var allocate = function allocate(ArrayType, size) {
      if (ArrayType.allocUnsafe) {
        return ArrayType.allocUnsafe(size);
      }
      return new ArrayType(size);
    };
    BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
      this._strip();
      var byteLength = this.byteLength();
      var reqLength = length || Math.max(1, byteLength);
      assert2(byteLength <= reqLength, "byte array longer than desired length");
      assert2(reqLength > 0, "Requested array length <= 0");
      var res = allocate(ArrayType, reqLength);
      var postfix = endian === "le" ? "LE" : "BE";
      this["_toArrayLike" + postfix](res, byteLength);
      return res;
    };
    BN.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
      var position = 0;
      var carry = 0;
      for (var i = 0, shift = 0;i < this.length; i++) {
        var word = this.words[i] << shift | carry;
        res[position++] = word & 255;
        if (position < res.length) {
          res[position++] = word >> 8 & 255;
        }
        if (position < res.length) {
          res[position++] = word >> 16 & 255;
        }
        if (shift === 6) {
          if (position < res.length) {
            res[position++] = word >> 24 & 255;
          }
          carry = 0;
          shift = 0;
        } else {
          carry = word >>> 24;
          shift += 2;
        }
      }
      if (position < res.length) {
        res[position++] = carry;
        while (position < res.length) {
          res[position++] = 0;
        }
      }
    };
    BN.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
      var position = res.length - 1;
      var carry = 0;
      for (var i = 0, shift = 0;i < this.length; i++) {
        var word = this.words[i] << shift | carry;
        res[position--] = word & 255;
        if (position >= 0) {
          res[position--] = word >> 8 & 255;
        }
        if (position >= 0) {
          res[position--] = word >> 16 & 255;
        }
        if (shift === 6) {
          if (position >= 0) {
            res[position--] = word >> 24 & 255;
          }
          carry = 0;
          shift = 0;
        } else {
          carry = word >>> 24;
          shift += 2;
        }
      }
      if (position >= 0) {
        res[position--] = carry;
        while (position >= 0) {
          res[position--] = 0;
        }
      }
    };
    if (Math.clz32) {
      BN.prototype._countBits = function _countBits(w) {
        return 32 - Math.clz32(w);
      };
    } else {
      BN.prototype._countBits = function _countBits(w) {
        var t = w;
        var r = 0;
        if (t >= 4096) {
          r += 13;
          t >>>= 13;
        }
        if (t >= 64) {
          r += 7;
          t >>>= 7;
        }
        if (t >= 8) {
          r += 4;
          t >>>= 4;
        }
        if (t >= 2) {
          r += 2;
          t >>>= 2;
        }
        return r + t;
      };
    }
    BN.prototype._zeroBits = function _zeroBits(w) {
      if (w === 0)
        return 26;
      var t = w;
      var r = 0;
      if ((t & 8191) === 0) {
        r += 13;
        t >>>= 13;
      }
      if ((t & 127) === 0) {
        r += 7;
        t >>>= 7;
      }
      if ((t & 15) === 0) {
        r += 4;
        t >>>= 4;
      }
      if ((t & 3) === 0) {
        r += 2;
        t >>>= 2;
      }
      if ((t & 1) === 0) {
        r++;
      }
      return r;
    };
    BN.prototype.bitLength = function bitLength() {
      var w = this.words[this.length - 1];
      var hi = this._countBits(w);
      return (this.length - 1) * 26 + hi;
    };
    function toBitArray(num) {
      var w = new Array(num.bitLength());
      for (var bit = 0;bit < w.length; bit++) {
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        w[bit] = num.words[off] >>> wbit & 1;
      }
      return w;
    }
    BN.prototype.zeroBits = function zeroBits() {
      if (this.isZero())
        return 0;
      var r = 0;
      for (var i = 0;i < this.length; i++) {
        var b2 = this._zeroBits(this.words[i]);
        r += b2;
        if (b2 !== 26)
          break;
      }
      return r;
    };
    BN.prototype.byteLength = function byteLength() {
      return Math.ceil(this.bitLength() / 8);
    };
    BN.prototype.toTwos = function toTwos(width) {
      if (this.negative !== 0) {
        return this.abs().inotn(width).iaddn(1);
      }
      return this.clone();
    };
    BN.prototype.fromTwos = function fromTwos(width) {
      if (this.testn(width - 1)) {
        return this.notn(width).iaddn(1).ineg();
      }
      return this.clone();
    };
    BN.prototype.isNeg = function isNeg() {
      return this.negative !== 0;
    };
    BN.prototype.neg = function neg() {
      return this.clone().ineg();
    };
    BN.prototype.ineg = function ineg() {
      if (!this.isZero()) {
        this.negative ^= 1;
      }
      return this;
    };
    BN.prototype.iuor = function iuor(num) {
      while (this.length < num.length) {
        this.words[this.length++] = 0;
      }
      for (var i = 0;i < num.length; i++) {
        this.words[i] = this.words[i] | num.words[i];
      }
      return this._strip();
    };
    BN.prototype.ior = function ior(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuor(num);
    };
    BN.prototype.or = function or(num) {
      if (this.length > num.length)
        return this.clone().ior(num);
      return num.clone().ior(this);
    };
    BN.prototype.uor = function uor(num) {
      if (this.length > num.length)
        return this.clone().iuor(num);
      return num.clone().iuor(this);
    };
    BN.prototype.iuand = function iuand(num) {
      var b2;
      if (this.length > num.length) {
        b2 = num;
      } else {
        b2 = this;
      }
      for (var i = 0;i < b2.length; i++) {
        this.words[i] = this.words[i] & num.words[i];
      }
      this.length = b2.length;
      return this._strip();
    };
    BN.prototype.iand = function iand(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuand(num);
    };
    BN.prototype.and = function and(num) {
      if (this.length > num.length)
        return this.clone().iand(num);
      return num.clone().iand(this);
    };
    BN.prototype.uand = function uand(num) {
      if (this.length > num.length)
        return this.clone().iuand(num);
      return num.clone().iuand(this);
    };
    BN.prototype.iuxor = function iuxor(num) {
      var a;
      var b2;
      if (this.length > num.length) {
        a = this;
        b2 = num;
      } else {
        a = num;
        b2 = this;
      }
      for (var i = 0;i < b2.length; i++) {
        this.words[i] = a.words[i] ^ b2.words[i];
      }
      if (this !== a) {
        for (;i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
      this.length = a.length;
      return this._strip();
    };
    BN.prototype.ixor = function ixor(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuxor(num);
    };
    BN.prototype.xor = function xor(num) {
      if (this.length > num.length)
        return this.clone().ixor(num);
      return num.clone().ixor(this);
    };
    BN.prototype.uxor = function uxor(num) {
      if (this.length > num.length)
        return this.clone().iuxor(num);
      return num.clone().iuxor(this);
    };
    BN.prototype.inotn = function inotn(width) {
      assert2(typeof width === "number" && width >= 0);
      var bytesNeeded = Math.ceil(width / 26) | 0;
      var bitsLeft = width % 26;
      this._expand(bytesNeeded);
      if (bitsLeft > 0) {
        bytesNeeded--;
      }
      for (var i = 0;i < bytesNeeded; i++) {
        this.words[i] = ~this.words[i] & 67108863;
      }
      if (bitsLeft > 0) {
        this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
      }
      return this._strip();
    };
    BN.prototype.notn = function notn(width) {
      return this.clone().inotn(width);
    };
    BN.prototype.setn = function setn(bit, val) {
      assert2(typeof bit === "number" && bit >= 0);
      var off = bit / 26 | 0;
      var wbit = bit % 26;
      this._expand(off + 1);
      if (val) {
        this.words[off] = this.words[off] | 1 << wbit;
      } else {
        this.words[off] = this.words[off] & ~(1 << wbit);
      }
      return this._strip();
    };
    BN.prototype.iadd = function iadd(num) {
      var r;
      if (this.negative !== 0 && num.negative === 0) {
        this.negative = 0;
        r = this.isub(num);
        this.negative ^= 1;
        return this._normSign();
      } else if (this.negative === 0 && num.negative !== 0) {
        num.negative = 0;
        r = this.isub(num);
        num.negative = 1;
        return r._normSign();
      }
      var a, b2;
      if (this.length > num.length) {
        a = this;
        b2 = num;
      } else {
        a = num;
        b2 = this;
      }
      var carry = 0;
      for (var i = 0;i < b2.length; i++) {
        r = (a.words[i] | 0) + (b2.words[i] | 0) + carry;
        this.words[i] = r & 67108863;
        carry = r >>> 26;
      }
      for (;carry !== 0 && i < a.length; i++) {
        r = (a.words[i] | 0) + carry;
        this.words[i] = r & 67108863;
        carry = r >>> 26;
      }
      this.length = a.length;
      if (carry !== 0) {
        this.words[this.length] = carry;
        this.length++;
      } else if (a !== this) {
        for (;i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
      return this;
    };
    BN.prototype.add = function add(num) {
      var res;
      if (num.negative !== 0 && this.negative === 0) {
        num.negative = 0;
        res = this.sub(num);
        num.negative ^= 1;
        return res;
      } else if (num.negative === 0 && this.negative !== 0) {
        this.negative = 0;
        res = num.sub(this);
        this.negative = 1;
        return res;
      }
      if (this.length > num.length)
        return this.clone().iadd(num);
      return num.clone().iadd(this);
    };
    BN.prototype.isub = function isub(num) {
      if (num.negative !== 0) {
        num.negative = 0;
        var r = this.iadd(num);
        num.negative = 1;
        return r._normSign();
      } else if (this.negative !== 0) {
        this.negative = 0;
        this.iadd(num);
        this.negative = 1;
        return this._normSign();
      }
      var cmp = this.cmp(num);
      if (cmp === 0) {
        this.negative = 0;
        this.length = 1;
        this.words[0] = 0;
        return this;
      }
      var a, b2;
      if (cmp > 0) {
        a = this;
        b2 = num;
      } else {
        a = num;
        b2 = this;
      }
      var carry = 0;
      for (var i = 0;i < b2.length; i++) {
        r = (a.words[i] | 0) - (b2.words[i] | 0) + carry;
        carry = r >> 26;
        this.words[i] = r & 67108863;
      }
      for (;carry !== 0 && i < a.length; i++) {
        r = (a.words[i] | 0) + carry;
        carry = r >> 26;
        this.words[i] = r & 67108863;
      }
      if (carry === 0 && i < a.length && a !== this) {
        for (;i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
      this.length = Math.max(this.length, i);
      if (a !== this) {
        this.negative = 1;
      }
      return this._strip();
    };
    BN.prototype.sub = function sub(num) {
      return this.clone().isub(num);
    };
    function smallMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      var len = self2.length + num.length | 0;
      out.length = len;
      len = len - 1 | 0;
      var a = self2.words[0] | 0;
      var b2 = num.words[0] | 0;
      var r = a * b2;
      var lo = r & 67108863;
      var carry = r / 67108864 | 0;
      out.words[0] = lo;
      for (var k = 1;k < len; k++) {
        var ncarry = carry >>> 26;
        var rword = carry & 67108863;
        var maxJ = Math.min(k, num.length - 1);
        for (var j = Math.max(0, k - self2.length + 1);j <= maxJ; j++) {
          var i = k - j | 0;
          a = self2.words[i] | 0;
          b2 = num.words[j] | 0;
          r = a * b2 + rword;
          ncarry += r / 67108864 | 0;
          rword = r & 67108863;
        }
        out.words[k] = rword | 0;
        carry = ncarry | 0;
      }
      if (carry !== 0) {
        out.words[k] = carry | 0;
      } else {
        out.length--;
      }
      return out._strip();
    }
    var comb10MulTo = function comb10MulTo(self2, num, out) {
      var a = self2.words;
      var b2 = num.words;
      var o = out.words;
      var c = 0;
      var lo;
      var mid;
      var hi;
      var a0 = a[0] | 0;
      var al0 = a0 & 8191;
      var ah0 = a0 >>> 13;
      var a1 = a[1] | 0;
      var al1 = a1 & 8191;
      var ah1 = a1 >>> 13;
      var a2 = a[2] | 0;
      var al2 = a2 & 8191;
      var ah2 = a2 >>> 13;
      var a3 = a[3] | 0;
      var al3 = a3 & 8191;
      var ah3 = a3 >>> 13;
      var a4 = a[4] | 0;
      var al4 = a4 & 8191;
      var ah4 = a4 >>> 13;
      var a5 = a[5] | 0;
      var al5 = a5 & 8191;
      var ah5 = a5 >>> 13;
      var a6 = a[6] | 0;
      var al6 = a6 & 8191;
      var ah6 = a6 >>> 13;
      var a7 = a[7] | 0;
      var al7 = a7 & 8191;
      var ah7 = a7 >>> 13;
      var a8 = a[8] | 0;
      var al8 = a8 & 8191;
      var ah8 = a8 >>> 13;
      var a9 = a[9] | 0;
      var al9 = a9 & 8191;
      var ah9 = a9 >>> 13;
      var b0 = b2[0] | 0;
      var bl0 = b0 & 8191;
      var bh0 = b0 >>> 13;
      var b1 = b2[1] | 0;
      var bl1 = b1 & 8191;
      var bh1 = b1 >>> 13;
      var b22 = b2[2] | 0;
      var bl2 = b22 & 8191;
      var bh2 = b22 >>> 13;
      var b3 = b2[3] | 0;
      var bl3 = b3 & 8191;
      var bh3 = b3 >>> 13;
      var b4 = b2[4] | 0;
      var bl4 = b4 & 8191;
      var bh4 = b4 >>> 13;
      var b5 = b2[5] | 0;
      var bl5 = b5 & 8191;
      var bh5 = b5 >>> 13;
      var b6 = b2[6] | 0;
      var bl6 = b6 & 8191;
      var bh6 = b6 >>> 13;
      var b7 = b2[7] | 0;
      var bl7 = b7 & 8191;
      var bh7 = b7 >>> 13;
      var b8 = b2[8] | 0;
      var bl8 = b8 & 8191;
      var bh8 = b8 >>> 13;
      var b9 = b2[9] | 0;
      var bl9 = b9 & 8191;
      var bh9 = b9 >>> 13;
      out.negative = self2.negative ^ num.negative;
      out.length = 19;
      lo = Math.imul(al0, bl0);
      mid = Math.imul(al0, bh0);
      mid = mid + Math.imul(ah0, bl0) | 0;
      hi = Math.imul(ah0, bh0);
      var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
      w0 &= 67108863;
      lo = Math.imul(al1, bl0);
      mid = Math.imul(al1, bh0);
      mid = mid + Math.imul(ah1, bl0) | 0;
      hi = Math.imul(ah1, bh0);
      lo = lo + Math.imul(al0, bl1) | 0;
      mid = mid + Math.imul(al0, bh1) | 0;
      mid = mid + Math.imul(ah0, bl1) | 0;
      hi = hi + Math.imul(ah0, bh1) | 0;
      var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
      w1 &= 67108863;
      lo = Math.imul(al2, bl0);
      mid = Math.imul(al2, bh0);
      mid = mid + Math.imul(ah2, bl0) | 0;
      hi = Math.imul(ah2, bh0);
      lo = lo + Math.imul(al1, bl1) | 0;
      mid = mid + Math.imul(al1, bh1) | 0;
      mid = mid + Math.imul(ah1, bl1) | 0;
      hi = hi + Math.imul(ah1, bh1) | 0;
      lo = lo + Math.imul(al0, bl2) | 0;
      mid = mid + Math.imul(al0, bh2) | 0;
      mid = mid + Math.imul(ah0, bl2) | 0;
      hi = hi + Math.imul(ah0, bh2) | 0;
      var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
      w2 &= 67108863;
      lo = Math.imul(al3, bl0);
      mid = Math.imul(al3, bh0);
      mid = mid + Math.imul(ah3, bl0) | 0;
      hi = Math.imul(ah3, bh0);
      lo = lo + Math.imul(al2, bl1) | 0;
      mid = mid + Math.imul(al2, bh1) | 0;
      mid = mid + Math.imul(ah2, bl1) | 0;
      hi = hi + Math.imul(ah2, bh1) | 0;
      lo = lo + Math.imul(al1, bl2) | 0;
      mid = mid + Math.imul(al1, bh2) | 0;
      mid = mid + Math.imul(ah1, bl2) | 0;
      hi = hi + Math.imul(ah1, bh2) | 0;
      lo = lo + Math.imul(al0, bl3) | 0;
      mid = mid + Math.imul(al0, bh3) | 0;
      mid = mid + Math.imul(ah0, bl3) | 0;
      hi = hi + Math.imul(ah0, bh3) | 0;
      var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
      w3 &= 67108863;
      lo = Math.imul(al4, bl0);
      mid = Math.imul(al4, bh0);
      mid = mid + Math.imul(ah4, bl0) | 0;
      hi = Math.imul(ah4, bh0);
      lo = lo + Math.imul(al3, bl1) | 0;
      mid = mid + Math.imul(al3, bh1) | 0;
      mid = mid + Math.imul(ah3, bl1) | 0;
      hi = hi + Math.imul(ah3, bh1) | 0;
      lo = lo + Math.imul(al2, bl2) | 0;
      mid = mid + Math.imul(al2, bh2) | 0;
      mid = mid + Math.imul(ah2, bl2) | 0;
      hi = hi + Math.imul(ah2, bh2) | 0;
      lo = lo + Math.imul(al1, bl3) | 0;
      mid = mid + Math.imul(al1, bh3) | 0;
      mid = mid + Math.imul(ah1, bl3) | 0;
      hi = hi + Math.imul(ah1, bh3) | 0;
      lo = lo + Math.imul(al0, bl4) | 0;
      mid = mid + Math.imul(al0, bh4) | 0;
      mid = mid + Math.imul(ah0, bl4) | 0;
      hi = hi + Math.imul(ah0, bh4) | 0;
      var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
      w4 &= 67108863;
      lo = Math.imul(al5, bl0);
      mid = Math.imul(al5, bh0);
      mid = mid + Math.imul(ah5, bl0) | 0;
      hi = Math.imul(ah5, bh0);
      lo = lo + Math.imul(al4, bl1) | 0;
      mid = mid + Math.imul(al4, bh1) | 0;
      mid = mid + Math.imul(ah4, bl1) | 0;
      hi = hi + Math.imul(ah4, bh1) | 0;
      lo = lo + Math.imul(al3, bl2) | 0;
      mid = mid + Math.imul(al3, bh2) | 0;
      mid = mid + Math.imul(ah3, bl2) | 0;
      hi = hi + Math.imul(ah3, bh2) | 0;
      lo = lo + Math.imul(al2, bl3) | 0;
      mid = mid + Math.imul(al2, bh3) | 0;
      mid = mid + Math.imul(ah2, bl3) | 0;
      hi = hi + Math.imul(ah2, bh3) | 0;
      lo = lo + Math.imul(al1, bl4) | 0;
      mid = mid + Math.imul(al1, bh4) | 0;
      mid = mid + Math.imul(ah1, bl4) | 0;
      hi = hi + Math.imul(ah1, bh4) | 0;
      lo = lo + Math.imul(al0, bl5) | 0;
      mid = mid + Math.imul(al0, bh5) | 0;
      mid = mid + Math.imul(ah0, bl5) | 0;
      hi = hi + Math.imul(ah0, bh5) | 0;
      var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
      w5 &= 67108863;
      lo = Math.imul(al6, bl0);
      mid = Math.imul(al6, bh0);
      mid = mid + Math.imul(ah6, bl0) | 0;
      hi = Math.imul(ah6, bh0);
      lo = lo + Math.imul(al5, bl1) | 0;
      mid = mid + Math.imul(al5, bh1) | 0;
      mid = mid + Math.imul(ah5, bl1) | 0;
      hi = hi + Math.imul(ah5, bh1) | 0;
      lo = lo + Math.imul(al4, bl2) | 0;
      mid = mid + Math.imul(al4, bh2) | 0;
      mid = mid + Math.imul(ah4, bl2) | 0;
      hi = hi + Math.imul(ah4, bh2) | 0;
      lo = lo + Math.imul(al3, bl3) | 0;
      mid = mid + Math.imul(al3, bh3) | 0;
      mid = mid + Math.imul(ah3, bl3) | 0;
      hi = hi + Math.imul(ah3, bh3) | 0;
      lo = lo + Math.imul(al2, bl4) | 0;
      mid = mid + Math.imul(al2, bh4) | 0;
      mid = mid + Math.imul(ah2, bl4) | 0;
      hi = hi + Math.imul(ah2, bh4) | 0;
      lo = lo + Math.imul(al1, bl5) | 0;
      mid = mid + Math.imul(al1, bh5) | 0;
      mid = mid + Math.imul(ah1, bl5) | 0;
      hi = hi + Math.imul(ah1, bh5) | 0;
      lo = lo + Math.imul(al0, bl6) | 0;
      mid = mid + Math.imul(al0, bh6) | 0;
      mid = mid + Math.imul(ah0, bl6) | 0;
      hi = hi + Math.imul(ah0, bh6) | 0;
      var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
      w6 &= 67108863;
      lo = Math.imul(al7, bl0);
      mid = Math.imul(al7, bh0);
      mid = mid + Math.imul(ah7, bl0) | 0;
      hi = Math.imul(ah7, bh0);
      lo = lo + Math.imul(al6, bl1) | 0;
      mid = mid + Math.imul(al6, bh1) | 0;
      mid = mid + Math.imul(ah6, bl1) | 0;
      hi = hi + Math.imul(ah6, bh1) | 0;
      lo = lo + Math.imul(al5, bl2) | 0;
      mid = mid + Math.imul(al5, bh2) | 0;
      mid = mid + Math.imul(ah5, bl2) | 0;
      hi = hi + Math.imul(ah5, bh2) | 0;
      lo = lo + Math.imul(al4, bl3) | 0;
      mid = mid + Math.imul(al4, bh3) | 0;
      mid = mid + Math.imul(ah4, bl3) | 0;
      hi = hi + Math.imul(ah4, bh3) | 0;
      lo = lo + Math.imul(al3, bl4) | 0;
      mid = mid + Math.imul(al3, bh4) | 0;
      mid = mid + Math.imul(ah3, bl4) | 0;
      hi = hi + Math.imul(ah3, bh4) | 0;
      lo = lo + Math.imul(al2, bl5) | 0;
      mid = mid + Math.imul(al2, bh5) | 0;
      mid = mid + Math.imul(ah2, bl5) | 0;
      hi = hi + Math.imul(ah2, bh5) | 0;
      lo = lo + Math.imul(al1, bl6) | 0;
      mid = mid + Math.imul(al1, bh6) | 0;
      mid = mid + Math.imul(ah1, bl6) | 0;
      hi = hi + Math.imul(ah1, bh6) | 0;
      lo = lo + Math.imul(al0, bl7) | 0;
      mid = mid + Math.imul(al0, bh7) | 0;
      mid = mid + Math.imul(ah0, bl7) | 0;
      hi = hi + Math.imul(ah0, bh7) | 0;
      var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
      w7 &= 67108863;
      lo = Math.imul(al8, bl0);
      mid = Math.imul(al8, bh0);
      mid = mid + Math.imul(ah8, bl0) | 0;
      hi = Math.imul(ah8, bh0);
      lo = lo + Math.imul(al7, bl1) | 0;
      mid = mid + Math.imul(al7, bh1) | 0;
      mid = mid + Math.imul(ah7, bl1) | 0;
      hi = hi + Math.imul(ah7, bh1) | 0;
      lo = lo + Math.imul(al6, bl2) | 0;
      mid = mid + Math.imul(al6, bh2) | 0;
      mid = mid + Math.imul(ah6, bl2) | 0;
      hi = hi + Math.imul(ah6, bh2) | 0;
      lo = lo + Math.imul(al5, bl3) | 0;
      mid = mid + Math.imul(al5, bh3) | 0;
      mid = mid + Math.imul(ah5, bl3) | 0;
      hi = hi + Math.imul(ah5, bh3) | 0;
      lo = lo + Math.imul(al4, bl4) | 0;
      mid = mid + Math.imul(al4, bh4) | 0;
      mid = mid + Math.imul(ah4, bl4) | 0;
      hi = hi + Math.imul(ah4, bh4) | 0;
      lo = lo + Math.imul(al3, bl5) | 0;
      mid = mid + Math.imul(al3, bh5) | 0;
      mid = mid + Math.imul(ah3, bl5) | 0;
      hi = hi + Math.imul(ah3, bh5) | 0;
      lo = lo + Math.imul(al2, bl6) | 0;
      mid = mid + Math.imul(al2, bh6) | 0;
      mid = mid + Math.imul(ah2, bl6) | 0;
      hi = hi + Math.imul(ah2, bh6) | 0;
      lo = lo + Math.imul(al1, bl7) | 0;
      mid = mid + Math.imul(al1, bh7) | 0;
      mid = mid + Math.imul(ah1, bl7) | 0;
      hi = hi + Math.imul(ah1, bh7) | 0;
      lo = lo + Math.imul(al0, bl8) | 0;
      mid = mid + Math.imul(al0, bh8) | 0;
      mid = mid + Math.imul(ah0, bl8) | 0;
      hi = hi + Math.imul(ah0, bh8) | 0;
      var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
      w8 &= 67108863;
      lo = Math.imul(al9, bl0);
      mid = Math.imul(al9, bh0);
      mid = mid + Math.imul(ah9, bl0) | 0;
      hi = Math.imul(ah9, bh0);
      lo = lo + Math.imul(al8, bl1) | 0;
      mid = mid + Math.imul(al8, bh1) | 0;
      mid = mid + Math.imul(ah8, bl1) | 0;
      hi = hi + Math.imul(ah8, bh1) | 0;
      lo = lo + Math.imul(al7, bl2) | 0;
      mid = mid + Math.imul(al7, bh2) | 0;
      mid = mid + Math.imul(ah7, bl2) | 0;
      hi = hi + Math.imul(ah7, bh2) | 0;
      lo = lo + Math.imul(al6, bl3) | 0;
      mid = mid + Math.imul(al6, bh3) | 0;
      mid = mid + Math.imul(ah6, bl3) | 0;
      hi = hi + Math.imul(ah6, bh3) | 0;
      lo = lo + Math.imul(al5, bl4) | 0;
      mid = mid + Math.imul(al5, bh4) | 0;
      mid = mid + Math.imul(ah5, bl4) | 0;
      hi = hi + Math.imul(ah5, bh4) | 0;
      lo = lo + Math.imul(al4, bl5) | 0;
      mid = mid + Math.imul(al4, bh5) | 0;
      mid = mid + Math.imul(ah4, bl5) | 0;
      hi = hi + Math.imul(ah4, bh5) | 0;
      lo = lo + Math.imul(al3, bl6) | 0;
      mid = mid + Math.imul(al3, bh6) | 0;
      mid = mid + Math.imul(ah3, bl6) | 0;
      hi = hi + Math.imul(ah3, bh6) | 0;
      lo = lo + Math.imul(al2, bl7) | 0;
      mid = mid + Math.imul(al2, bh7) | 0;
      mid = mid + Math.imul(ah2, bl7) | 0;
      hi = hi + Math.imul(ah2, bh7) | 0;
      lo = lo + Math.imul(al1, bl8) | 0;
      mid = mid + Math.imul(al1, bh8) | 0;
      mid = mid + Math.imul(ah1, bl8) | 0;
      hi = hi + Math.imul(ah1, bh8) | 0;
      lo = lo + Math.imul(al0, bl9) | 0;
      mid = mid + Math.imul(al0, bh9) | 0;
      mid = mid + Math.imul(ah0, bl9) | 0;
      hi = hi + Math.imul(ah0, bh9) | 0;
      var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
      w9 &= 67108863;
      lo = Math.imul(al9, bl1);
      mid = Math.imul(al9, bh1);
      mid = mid + Math.imul(ah9, bl1) | 0;
      hi = Math.imul(ah9, bh1);
      lo = lo + Math.imul(al8, bl2) | 0;
      mid = mid + Math.imul(al8, bh2) | 0;
      mid = mid + Math.imul(ah8, bl2) | 0;
      hi = hi + Math.imul(ah8, bh2) | 0;
      lo = lo + Math.imul(al7, bl3) | 0;
      mid = mid + Math.imul(al7, bh3) | 0;
      mid = mid + Math.imul(ah7, bl3) | 0;
      hi = hi + Math.imul(ah7, bh3) | 0;
      lo = lo + Math.imul(al6, bl4) | 0;
      mid = mid + Math.imul(al6, bh4) | 0;
      mid = mid + Math.imul(ah6, bl4) | 0;
      hi = hi + Math.imul(ah6, bh4) | 0;
      lo = lo + Math.imul(al5, bl5) | 0;
      mid = mid + Math.imul(al5, bh5) | 0;
      mid = mid + Math.imul(ah5, bl5) | 0;
      hi = hi + Math.imul(ah5, bh5) | 0;
      lo = lo + Math.imul(al4, bl6) | 0;
      mid = mid + Math.imul(al4, bh6) | 0;
      mid = mid + Math.imul(ah4, bl6) | 0;
      hi = hi + Math.imul(ah4, bh6) | 0;
      lo = lo + Math.imul(al3, bl7) | 0;
      mid = mid + Math.imul(al3, bh7) | 0;
      mid = mid + Math.imul(ah3, bl7) | 0;
      hi = hi + Math.imul(ah3, bh7) | 0;
      lo = lo + Math.imul(al2, bl8) | 0;
      mid = mid + Math.imul(al2, bh8) | 0;
      mid = mid + Math.imul(ah2, bl8) | 0;
      hi = hi + Math.imul(ah2, bh8) | 0;
      lo = lo + Math.imul(al1, bl9) | 0;
      mid = mid + Math.imul(al1, bh9) | 0;
      mid = mid + Math.imul(ah1, bl9) | 0;
      hi = hi + Math.imul(ah1, bh9) | 0;
      var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
      w10 &= 67108863;
      lo = Math.imul(al9, bl2);
      mid = Math.imul(al9, bh2);
      mid = mid + Math.imul(ah9, bl2) | 0;
      hi = Math.imul(ah9, bh2);
      lo = lo + Math.imul(al8, bl3) | 0;
      mid = mid + Math.imul(al8, bh3) | 0;
      mid = mid + Math.imul(ah8, bl3) | 0;
      hi = hi + Math.imul(ah8, bh3) | 0;
      lo = lo + Math.imul(al7, bl4) | 0;
      mid = mid + Math.imul(al7, bh4) | 0;
      mid = mid + Math.imul(ah7, bl4) | 0;
      hi = hi + Math.imul(ah7, bh4) | 0;
      lo = lo + Math.imul(al6, bl5) | 0;
      mid = mid + Math.imul(al6, bh5) | 0;
      mid = mid + Math.imul(ah6, bl5) | 0;
      hi = hi + Math.imul(ah6, bh5) | 0;
      lo = lo + Math.imul(al5, bl6) | 0;
      mid = mid + Math.imul(al5, bh6) | 0;
      mid = mid + Math.imul(ah5, bl6) | 0;
      hi = hi + Math.imul(ah5, bh6) | 0;
      lo = lo + Math.imul(al4, bl7) | 0;
      mid = mid + Math.imul(al4, bh7) | 0;
      mid = mid + Math.imul(ah4, bl7) | 0;
      hi = hi + Math.imul(ah4, bh7) | 0;
      lo = lo + Math.imul(al3, bl8) | 0;
      mid = mid + Math.imul(al3, bh8) | 0;
      mid = mid + Math.imul(ah3, bl8) | 0;
      hi = hi + Math.imul(ah3, bh8) | 0;
      lo = lo + Math.imul(al2, bl9) | 0;
      mid = mid + Math.imul(al2, bh9) | 0;
      mid = mid + Math.imul(ah2, bl9) | 0;
      hi = hi + Math.imul(ah2, bh9) | 0;
      var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
      w11 &= 67108863;
      lo = Math.imul(al9, bl3);
      mid = Math.imul(al9, bh3);
      mid = mid + Math.imul(ah9, bl3) | 0;
      hi = Math.imul(ah9, bh3);
      lo = lo + Math.imul(al8, bl4) | 0;
      mid = mid + Math.imul(al8, bh4) | 0;
      mid = mid + Math.imul(ah8, bl4) | 0;
      hi = hi + Math.imul(ah8, bh4) | 0;
      lo = lo + Math.imul(al7, bl5) | 0;
      mid = mid + Math.imul(al7, bh5) | 0;
      mid = mid + Math.imul(ah7, bl5) | 0;
      hi = hi + Math.imul(ah7, bh5) | 0;
      lo = lo + Math.imul(al6, bl6) | 0;
      mid = mid + Math.imul(al6, bh6) | 0;
      mid = mid + Math.imul(ah6, bl6) | 0;
      hi = hi + Math.imul(ah6, bh6) | 0;
      lo = lo + Math.imul(al5, bl7) | 0;
      mid = mid + Math.imul(al5, bh7) | 0;
      mid = mid + Math.imul(ah5, bl7) | 0;
      hi = hi + Math.imul(ah5, bh7) | 0;
      lo = lo + Math.imul(al4, bl8) | 0;
      mid = mid + Math.imul(al4, bh8) | 0;
      mid = mid + Math.imul(ah4, bl8) | 0;
      hi = hi + Math.imul(ah4, bh8) | 0;
      lo = lo + Math.imul(al3, bl9) | 0;
      mid = mid + Math.imul(al3, bh9) | 0;
      mid = mid + Math.imul(ah3, bl9) | 0;
      hi = hi + Math.imul(ah3, bh9) | 0;
      var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
      w12 &= 67108863;
      lo = Math.imul(al9, bl4);
      mid = Math.imul(al9, bh4);
      mid = mid + Math.imul(ah9, bl4) | 0;
      hi = Math.imul(ah9, bh4);
      lo = lo + Math.imul(al8, bl5) | 0;
      mid = mid + Math.imul(al8, bh5) | 0;
      mid = mid + Math.imul(ah8, bl5) | 0;
      hi = hi + Math.imul(ah8, bh5) | 0;
      lo = lo + Math.imul(al7, bl6) | 0;
      mid = mid + Math.imul(al7, bh6) | 0;
      mid = mid + Math.imul(ah7, bl6) | 0;
      hi = hi + Math.imul(ah7, bh6) | 0;
      lo = lo + Math.imul(al6, bl7) | 0;
      mid = mid + Math.imul(al6, bh7) | 0;
      mid = mid + Math.imul(ah6, bl7) | 0;
      hi = hi + Math.imul(ah6, bh7) | 0;
      lo = lo + Math.imul(al5, bl8) | 0;
      mid = mid + Math.imul(al5, bh8) | 0;
      mid = mid + Math.imul(ah5, bl8) | 0;
      hi = hi + Math.imul(ah5, bh8) | 0;
      lo = lo + Math.imul(al4, bl9) | 0;
      mid = mid + Math.imul(al4, bh9) | 0;
      mid = mid + Math.imul(ah4, bl9) | 0;
      hi = hi + Math.imul(ah4, bh9) | 0;
      var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
      w13 &= 67108863;
      lo = Math.imul(al9, bl5);
      mid = Math.imul(al9, bh5);
      mid = mid + Math.imul(ah9, bl5) | 0;
      hi = Math.imul(ah9, bh5);
      lo = lo + Math.imul(al8, bl6) | 0;
      mid = mid + Math.imul(al8, bh6) | 0;
      mid = mid + Math.imul(ah8, bl6) | 0;
      hi = hi + Math.imul(ah8, bh6) | 0;
      lo = lo + Math.imul(al7, bl7) | 0;
      mid = mid + Math.imul(al7, bh7) | 0;
      mid = mid + Math.imul(ah7, bl7) | 0;
      hi = hi + Math.imul(ah7, bh7) | 0;
      lo = lo + Math.imul(al6, bl8) | 0;
      mid = mid + Math.imul(al6, bh8) | 0;
      mid = mid + Math.imul(ah6, bl8) | 0;
      hi = hi + Math.imul(ah6, bh8) | 0;
      lo = lo + Math.imul(al5, bl9) | 0;
      mid = mid + Math.imul(al5, bh9) | 0;
      mid = mid + Math.imul(ah5, bl9) | 0;
      hi = hi + Math.imul(ah5, bh9) | 0;
      var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
      w14 &= 67108863;
      lo = Math.imul(al9, bl6);
      mid = Math.imul(al9, bh6);
      mid = mid + Math.imul(ah9, bl6) | 0;
      hi = Math.imul(ah9, bh6);
      lo = lo + Math.imul(al8, bl7) | 0;
      mid = mid + Math.imul(al8, bh7) | 0;
      mid = mid + Math.imul(ah8, bl7) | 0;
      hi = hi + Math.imul(ah8, bh7) | 0;
      lo = lo + Math.imul(al7, bl8) | 0;
      mid = mid + Math.imul(al7, bh8) | 0;
      mid = mid + Math.imul(ah7, bl8) | 0;
      hi = hi + Math.imul(ah7, bh8) | 0;
      lo = lo + Math.imul(al6, bl9) | 0;
      mid = mid + Math.imul(al6, bh9) | 0;
      mid = mid + Math.imul(ah6, bl9) | 0;
      hi = hi + Math.imul(ah6, bh9) | 0;
      var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
      w15 &= 67108863;
      lo = Math.imul(al9, bl7);
      mid = Math.imul(al9, bh7);
      mid = mid + Math.imul(ah9, bl7) | 0;
      hi = Math.imul(ah9, bh7);
      lo = lo + Math.imul(al8, bl8) | 0;
      mid = mid + Math.imul(al8, bh8) | 0;
      mid = mid + Math.imul(ah8, bl8) | 0;
      hi = hi + Math.imul(ah8, bh8) | 0;
      lo = lo + Math.imul(al7, bl9) | 0;
      mid = mid + Math.imul(al7, bh9) | 0;
      mid = mid + Math.imul(ah7, bl9) | 0;
      hi = hi + Math.imul(ah7, bh9) | 0;
      var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
      w16 &= 67108863;
      lo = Math.imul(al9, bl8);
      mid = Math.imul(al9, bh8);
      mid = mid + Math.imul(ah9, bl8) | 0;
      hi = Math.imul(ah9, bh8);
      lo = lo + Math.imul(al8, bl9) | 0;
      mid = mid + Math.imul(al8, bh9) | 0;
      mid = mid + Math.imul(ah8, bl9) | 0;
      hi = hi + Math.imul(ah8, bh9) | 0;
      var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
      w17 &= 67108863;
      lo = Math.imul(al9, bl9);
      mid = Math.imul(al9, bh9);
      mid = mid + Math.imul(ah9, bl9) | 0;
      hi = Math.imul(ah9, bh9);
      var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
      w18 &= 67108863;
      o[0] = w0;
      o[1] = w1;
      o[2] = w2;
      o[3] = w3;
      o[4] = w4;
      o[5] = w5;
      o[6] = w6;
      o[7] = w7;
      o[8] = w8;
      o[9] = w9;
      o[10] = w10;
      o[11] = w11;
      o[12] = w12;
      o[13] = w13;
      o[14] = w14;
      o[15] = w15;
      o[16] = w16;
      o[17] = w17;
      o[18] = w18;
      if (c !== 0) {
        o[19] = c;
        out.length++;
      }
      return out;
    };
    if (!Math.imul) {
      comb10MulTo = smallMulTo;
    }
    function bigMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      out.length = self2.length + num.length;
      var carry = 0;
      var hncarry = 0;
      for (var k = 0;k < out.length - 1; k++) {
        var ncarry = hncarry;
        hncarry = 0;
        var rword = carry & 67108863;
        var maxJ = Math.min(k, num.length - 1);
        for (var j = Math.max(0, k - self2.length + 1);j <= maxJ; j++) {
          var i = k - j;
          var a = self2.words[i] | 0;
          var b2 = num.words[j] | 0;
          var r = a * b2;
          var lo = r & 67108863;
          ncarry = ncarry + (r / 67108864 | 0) | 0;
          lo = lo + rword | 0;
          rword = lo & 67108863;
          ncarry = ncarry + (lo >>> 26) | 0;
          hncarry += ncarry >>> 26;
          ncarry &= 67108863;
        }
        out.words[k] = rword;
        carry = ncarry;
        ncarry = hncarry;
      }
      if (carry !== 0) {
        out.words[k] = carry;
      } else {
        out.length--;
      }
      return out._strip();
    }
    function jumboMulTo(self2, num, out) {
      return bigMulTo(self2, num, out);
    }
    BN.prototype.mulTo = function mulTo(num, out) {
      var res;
      var len = this.length + num.length;
      if (this.length === 10 && num.length === 10) {
        res = comb10MulTo(this, num, out);
      } else if (len < 63) {
        res = smallMulTo(this, num, out);
      } else if (len < 1024) {
        res = bigMulTo(this, num, out);
      } else {
        res = jumboMulTo(this, num, out);
      }
      return res;
    };
    function FFTM(x, y) {
      this.x = x;
      this.y = y;
    }
    FFTM.prototype.makeRBT = function makeRBT(N) {
      var t = new Array(N);
      var l = BN.prototype._countBits(N) - 1;
      for (var i = 0;i < N; i++) {
        t[i] = this.revBin(i, l, N);
      }
      return t;
    };
    FFTM.prototype.revBin = function revBin(x, l, N) {
      if (x === 0 || x === N - 1)
        return x;
      var rb = 0;
      for (var i = 0;i < l; i++) {
        rb |= (x & 1) << l - i - 1;
        x >>= 1;
      }
      return rb;
    };
    FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
      for (var i = 0;i < N; i++) {
        rtws[i] = rws[rbt[i]];
        itws[i] = iws[rbt[i]];
      }
    };
    FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
      this.permute(rbt, rws, iws, rtws, itws, N);
      for (var s = 1;s < N; s <<= 1) {
        var l = s << 1;
        var rtwdf = Math.cos(2 * Math.PI / l);
        var itwdf = Math.sin(2 * Math.PI / l);
        for (var p = 0;p < N; p += l) {
          var rtwdf_ = rtwdf;
          var itwdf_ = itwdf;
          for (var j = 0;j < s; j++) {
            var re = rtws[p + j];
            var ie = itws[p + j];
            var ro = rtws[p + j + s];
            var io = itws[p + j + s];
            var rx = rtwdf_ * ro - itwdf_ * io;
            io = rtwdf_ * io + itwdf_ * ro;
            ro = rx;
            rtws[p + j] = re + ro;
            itws[p + j] = ie + io;
            rtws[p + j + s] = re - ro;
            itws[p + j + s] = ie - io;
            if (j !== l) {
              rx = rtwdf * rtwdf_ - itwdf * itwdf_;
              itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
              rtwdf_ = rx;
            }
          }
        }
      }
    };
    FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
      var N = Math.max(m, n) | 1;
      var odd = N & 1;
      var i = 0;
      for (N = N / 2 | 0;N; N = N >>> 1) {
        i++;
      }
      return 1 << i + 1 + odd;
    };
    FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
      if (N <= 1)
        return;
      for (var i = 0;i < N / 2; i++) {
        var t = rws[i];
        rws[i] = rws[N - i - 1];
        rws[N - i - 1] = t;
        t = iws[i];
        iws[i] = -iws[N - i - 1];
        iws[N - i - 1] = -t;
      }
    };
    FFTM.prototype.normalize13b = function normalize13b(ws, N) {
      var carry = 0;
      for (var i = 0;i < N / 2; i++) {
        var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
        ws[i] = w & 67108863;
        if (w < 67108864) {
          carry = 0;
        } else {
          carry = w / 67108864 | 0;
        }
      }
      return ws;
    };
    FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
      var carry = 0;
      for (var i = 0;i < len; i++) {
        carry = carry + (ws[i] | 0);
        rws[2 * i] = carry & 8191;
        carry = carry >>> 13;
        rws[2 * i + 1] = carry & 8191;
        carry = carry >>> 13;
      }
      for (i = 2 * len;i < N; ++i) {
        rws[i] = 0;
      }
      assert2(carry === 0);
      assert2((carry & ~8191) === 0);
    };
    FFTM.prototype.stub = function stub(N) {
      var ph = new Array(N);
      for (var i = 0;i < N; i++) {
        ph[i] = 0;
      }
      return ph;
    };
    FFTM.prototype.mulp = function mulp(x, y, out) {
      var N = 2 * this.guessLen13b(x.length, y.length);
      var rbt = this.makeRBT(N);
      var _2 = this.stub(N);
      var rws = new Array(N);
      var rwst = new Array(N);
      var iwst = new Array(N);
      var nrws = new Array(N);
      var nrwst = new Array(N);
      var niwst = new Array(N);
      var rmws = out.words;
      rmws.length = N;
      this.convert13b(x.words, x.length, rws, N);
      this.convert13b(y.words, y.length, nrws, N);
      this.transform(rws, _2, rwst, iwst, N, rbt);
      this.transform(nrws, _2, nrwst, niwst, N, rbt);
      for (var i = 0;i < N; i++) {
        var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
        iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
        rwst[i] = rx;
      }
      this.conjugate(rwst, iwst, N);
      this.transform(rwst, iwst, rmws, _2, N, rbt);
      this.conjugate(rmws, _2, N);
      this.normalize13b(rmws, N);
      out.negative = x.negative ^ y.negative;
      out.length = x.length + y.length;
      return out._strip();
    };
    BN.prototype.mul = function mul(num) {
      var out = new BN(null);
      out.words = new Array(this.length + num.length);
      return this.mulTo(num, out);
    };
    BN.prototype.mulf = function mulf(num) {
      var out = new BN(null);
      out.words = new Array(this.length + num.length);
      return jumboMulTo(this, num, out);
    };
    BN.prototype.imul = function imul(num) {
      return this.clone().mulTo(num, this);
    };
    BN.prototype.imuln = function imuln(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert2(typeof num === "number");
      assert2(num < 67108864);
      var carry = 0;
      for (var i = 0;i < this.length; i++) {
        var w = (this.words[i] | 0) * num;
        var lo = (w & 67108863) + (carry & 67108863);
        carry >>= 26;
        carry += w / 67108864 | 0;
        carry += lo >>> 26;
        this.words[i] = lo & 67108863;
      }
      if (carry !== 0) {
        this.words[i] = carry;
        this.length++;
      }
      return isNegNum ? this.ineg() : this;
    };
    BN.prototype.muln = function muln(num) {
      return this.clone().imuln(num);
    };
    BN.prototype.sqr = function sqr() {
      return this.mul(this);
    };
    BN.prototype.isqr = function isqr() {
      return this.imul(this.clone());
    };
    BN.prototype.pow = function pow(num) {
      var w = toBitArray(num);
      if (w.length === 0)
        return new BN(1);
      var res = this;
      for (var i = 0;i < w.length; i++, res = res.sqr()) {
        if (w[i] !== 0)
          break;
      }
      if (++i < w.length) {
        for (var q = res.sqr();i < w.length; i++, q = q.sqr()) {
          if (w[i] === 0)
            continue;
          res = res.mul(q);
        }
      }
      return res;
    };
    BN.prototype.iushln = function iushln(bits) {
      assert2(typeof bits === "number" && bits >= 0);
      var r = bits % 26;
      var s = (bits - r) / 26;
      var carryMask = 67108863 >>> 26 - r << 26 - r;
      var i;
      if (r !== 0) {
        var carry = 0;
        for (i = 0;i < this.length; i++) {
          var newCarry = this.words[i] & carryMask;
          var c = (this.words[i] | 0) - newCarry << r;
          this.words[i] = c | carry;
          carry = newCarry >>> 26 - r;
        }
        if (carry) {
          this.words[i] = carry;
          this.length++;
        }
      }
      if (s !== 0) {
        for (i = this.length - 1;i >= 0; i--) {
          this.words[i + s] = this.words[i];
        }
        for (i = 0;i < s; i++) {
          this.words[i] = 0;
        }
        this.length += s;
      }
      return this._strip();
    };
    BN.prototype.ishln = function ishln(bits) {
      assert2(this.negative === 0);
      return this.iushln(bits);
    };
    BN.prototype.iushrn = function iushrn(bits, hint, extended) {
      assert2(typeof bits === "number" && bits >= 0);
      var h;
      if (hint) {
        h = (hint - hint % 26) / 26;
      } else {
        h = 0;
      }
      var r = bits % 26;
      var s = Math.min((bits - r) / 26, this.length);
      var mask2 = 67108863 ^ 67108863 >>> r << r;
      var maskedWords = extended;
      h -= s;
      h = Math.max(0, h);
      if (maskedWords) {
        for (var i = 0;i < s; i++) {
          maskedWords.words[i] = this.words[i];
        }
        maskedWords.length = s;
      }
      if (s === 0) {
      } else if (this.length > s) {
        this.length -= s;
        for (i = 0;i < this.length; i++) {
          this.words[i] = this.words[i + s];
        }
      } else {
        this.words[0] = 0;
        this.length = 1;
      }
      var carry = 0;
      for (i = this.length - 1;i >= 0 && (carry !== 0 || i >= h); i--) {
        var word = this.words[i] | 0;
        this.words[i] = carry << 26 - r | word >>> r;
        carry = word & mask2;
      }
      if (maskedWords && carry !== 0) {
        maskedWords.words[maskedWords.length++] = carry;
      }
      if (this.length === 0) {
        this.words[0] = 0;
        this.length = 1;
      }
      return this._strip();
    };
    BN.prototype.ishrn = function ishrn(bits, hint, extended) {
      assert2(this.negative === 0);
      return this.iushrn(bits, hint, extended);
    };
    BN.prototype.shln = function shln(bits) {
      return this.clone().ishln(bits);
    };
    BN.prototype.ushln = function ushln(bits) {
      return this.clone().iushln(bits);
    };
    BN.prototype.shrn = function shrn(bits) {
      return this.clone().ishrn(bits);
    };
    BN.prototype.ushrn = function ushrn(bits) {
      return this.clone().iushrn(bits);
    };
    BN.prototype.testn = function testn(bit) {
      assert2(typeof bit === "number" && bit >= 0);
      var r = bit % 26;
      var s = (bit - r) / 26;
      var q = 1 << r;
      if (this.length <= s)
        return false;
      var w = this.words[s];
      return !!(w & q);
    };
    BN.prototype.imaskn = function imaskn(bits) {
      assert2(typeof bits === "number" && bits >= 0);
      var r = bits % 26;
      var s = (bits - r) / 26;
      assert2(this.negative === 0, "imaskn works only with positive numbers");
      if (this.length <= s) {
        return this;
      }
      if (r !== 0) {
        s++;
      }
      this.length = Math.min(s, this.length);
      if (r !== 0) {
        var mask2 = 67108863 ^ 67108863 >>> r << r;
        this.words[this.length - 1] &= mask2;
      }
      return this._strip();
    };
    BN.prototype.maskn = function maskn(bits) {
      return this.clone().imaskn(bits);
    };
    BN.prototype.iaddn = function iaddn(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      if (num < 0)
        return this.isubn(-num);
      if (this.negative !== 0) {
        if (this.length === 1 && (this.words[0] | 0) <= num) {
          this.words[0] = num - (this.words[0] | 0);
          this.negative = 0;
          return this;
        }
        this.negative = 0;
        this.isubn(num);
        this.negative = 1;
        return this;
      }
      return this._iaddn(num);
    };
    BN.prototype._iaddn = function _iaddn(num) {
      this.words[0] += num;
      for (var i = 0;i < this.length && this.words[i] >= 67108864; i++) {
        this.words[i] -= 67108864;
        if (i === this.length - 1) {
          this.words[i + 1] = 1;
        } else {
          this.words[i + 1]++;
        }
      }
      this.length = Math.max(this.length, i + 1);
      return this;
    };
    BN.prototype.isubn = function isubn(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      if (num < 0)
        return this.iaddn(-num);
      if (this.negative !== 0) {
        this.negative = 0;
        this.iaddn(num);
        this.negative = 1;
        return this;
      }
      this.words[0] -= num;
      if (this.length === 1 && this.words[0] < 0) {
        this.words[0] = -this.words[0];
        this.negative = 1;
      } else {
        for (var i = 0;i < this.length && this.words[i] < 0; i++) {
          this.words[i] += 67108864;
          this.words[i + 1] -= 1;
        }
      }
      return this._strip();
    };
    BN.prototype.addn = function addn(num) {
      return this.clone().iaddn(num);
    };
    BN.prototype.subn = function subn(num) {
      return this.clone().isubn(num);
    };
    BN.prototype.iabs = function iabs() {
      this.negative = 0;
      return this;
    };
    BN.prototype.abs = function abs() {
      return this.clone().iabs();
    };
    BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
      var len = num.length + shift;
      var i;
      this._expand(len);
      var w;
      var carry = 0;
      for (i = 0;i < num.length; i++) {
        w = (this.words[i + shift] | 0) + carry;
        var right = (num.words[i] | 0) * mul;
        w -= right & 67108863;
        carry = (w >> 26) - (right / 67108864 | 0);
        this.words[i + shift] = w & 67108863;
      }
      for (;i < this.length - shift; i++) {
        w = (this.words[i + shift] | 0) + carry;
        carry = w >> 26;
        this.words[i + shift] = w & 67108863;
      }
      if (carry === 0)
        return this._strip();
      assert2(carry === -1);
      carry = 0;
      for (i = 0;i < this.length; i++) {
        w = -(this.words[i] | 0) + carry;
        carry = w >> 26;
        this.words[i] = w & 67108863;
      }
      this.negative = 1;
      return this._strip();
    };
    BN.prototype._wordDiv = function _wordDiv(num, mode) {
      var shift = this.length - num.length;
      var a = this.clone();
      var b2 = num;
      var bhi = b2.words[b2.length - 1] | 0;
      var bhiBits = this._countBits(bhi);
      shift = 26 - bhiBits;
      if (shift !== 0) {
        b2 = b2.ushln(shift);
        a.iushln(shift);
        bhi = b2.words[b2.length - 1] | 0;
      }
      var m = a.length - b2.length;
      var q;
      if (mode !== "mod") {
        q = new BN(null);
        q.length = m + 1;
        q.words = new Array(q.length);
        for (var i = 0;i < q.length; i++) {
          q.words[i] = 0;
        }
      }
      var diff = a.clone()._ishlnsubmul(b2, 1, m);
      if (diff.negative === 0) {
        a = diff;
        if (q) {
          q.words[m] = 1;
        }
      }
      for (var j = m - 1;j >= 0; j--) {
        var qj = (a.words[b2.length + j] | 0) * 67108864 + (a.words[b2.length + j - 1] | 0);
        qj = Math.min(qj / bhi | 0, 67108863);
        a._ishlnsubmul(b2, qj, j);
        while (a.negative !== 0) {
          qj--;
          a.negative = 0;
          a._ishlnsubmul(b2, 1, j);
          if (!a.isZero()) {
            a.negative ^= 1;
          }
        }
        if (q) {
          q.words[j] = qj;
        }
      }
      if (q) {
        q._strip();
      }
      a._strip();
      if (mode !== "div" && shift !== 0) {
        a.iushrn(shift);
      }
      return {
        div: q || null,
        mod: a
      };
    };
    BN.prototype.divmod = function divmod(num, mode, positive) {
      assert2(!num.isZero());
      if (this.isZero()) {
        return {
          div: new BN(0),
          mod: new BN(0)
        };
      }
      var div, mod, res;
      if (this.negative !== 0 && num.negative === 0) {
        res = this.neg().divmod(num, mode);
        if (mode !== "mod") {
          div = res.div.neg();
        }
        if (mode !== "div") {
          mod = res.mod.neg();
          if (positive && mod.negative !== 0) {
            mod.iadd(num);
          }
        }
        return {
          div,
          mod
        };
      }
      if (this.negative === 0 && num.negative !== 0) {
        res = this.divmod(num.neg(), mode);
        if (mode !== "mod") {
          div = res.div.neg();
        }
        return {
          div,
          mod: res.mod
        };
      }
      if ((this.negative & num.negative) !== 0) {
        res = this.neg().divmod(num.neg(), mode);
        if (mode !== "div") {
          mod = res.mod.neg();
          if (positive && mod.negative !== 0) {
            mod.isub(num);
          }
        }
        return {
          div: res.div,
          mod
        };
      }
      if (num.length > this.length || this.cmp(num) < 0) {
        return {
          div: new BN(0),
          mod: this
        };
      }
      if (num.length === 1) {
        if (mode === "div") {
          return {
            div: this.divn(num.words[0]),
            mod: null
          };
        }
        if (mode === "mod") {
          return {
            div: null,
            mod: new BN(this.modrn(num.words[0]))
          };
        }
        return {
          div: this.divn(num.words[0]),
          mod: new BN(this.modrn(num.words[0]))
        };
      }
      return this._wordDiv(num, mode);
    };
    BN.prototype.div = function div(num) {
      return this.divmod(num, "div", false).div;
    };
    BN.prototype.mod = function mod(num) {
      return this.divmod(num, "mod", false).mod;
    };
    BN.prototype.umod = function umod(num) {
      return this.divmod(num, "mod", true).mod;
    };
    BN.prototype.divRound = function divRound(num) {
      var dm = this.divmod(num);
      if (dm.mod.isZero())
        return dm.div;
      var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
      var half = num.ushrn(1);
      var r2 = num.andln(1);
      var cmp = mod.cmp(half);
      if (cmp < 0 || r2 === 1 && cmp === 0)
        return dm.div;
      return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    };
    BN.prototype.modrn = function modrn(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert2(num <= 67108863);
      var p = (1 << 26) % num;
      var acc = 0;
      for (var i = this.length - 1;i >= 0; i--) {
        acc = (p * acc + (this.words[i] | 0)) % num;
      }
      return isNegNum ? -acc : acc;
    };
    BN.prototype.modn = function modn(num) {
      return this.modrn(num);
    };
    BN.prototype.idivn = function idivn(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert2(num <= 67108863);
      var carry = 0;
      for (var i = this.length - 1;i >= 0; i--) {
        var w = (this.words[i] | 0) + carry * 67108864;
        this.words[i] = w / num | 0;
        carry = w % num;
      }
      this._strip();
      return isNegNum ? this.ineg() : this;
    };
    BN.prototype.divn = function divn(num) {
      return this.clone().idivn(num);
    };
    BN.prototype.egcd = function egcd(p) {
      assert2(p.negative === 0);
      assert2(!p.isZero());
      var x = this;
      var y = p.clone();
      if (x.negative !== 0) {
        x = x.umod(p);
      } else {
        x = x.clone();
      }
      var A = new BN(1);
      var B = new BN(0);
      var C = new BN(0);
      var D2 = new BN(1);
      var g = 0;
      while (x.isEven() && y.isEven()) {
        x.iushrn(1);
        y.iushrn(1);
        ++g;
      }
      var yp = y.clone();
      var xp = x.clone();
      while (!x.isZero()) {
        for (var i = 0, im = 1;(x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
          ;
        if (i > 0) {
          x.iushrn(i);
          while (i-- > 0) {
            if (A.isOdd() || B.isOdd()) {
              A.iadd(yp);
              B.isub(xp);
            }
            A.iushrn(1);
            B.iushrn(1);
          }
        }
        for (var j = 0, jm = 1;(y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
          ;
        if (j > 0) {
          y.iushrn(j);
          while (j-- > 0) {
            if (C.isOdd() || D2.isOdd()) {
              C.iadd(yp);
              D2.isub(xp);
            }
            C.iushrn(1);
            D2.iushrn(1);
          }
        }
        if (x.cmp(y) >= 0) {
          x.isub(y);
          A.isub(C);
          B.isub(D2);
        } else {
          y.isub(x);
          C.isub(A);
          D2.isub(B);
        }
      }
      return {
        a: C,
        b: D2,
        gcd: y.iushln(g)
      };
    };
    BN.prototype._invmp = function _invmp(p) {
      assert2(p.negative === 0);
      assert2(!p.isZero());
      var a = this;
      var b2 = p.clone();
      if (a.negative !== 0) {
        a = a.umod(p);
      } else {
        a = a.clone();
      }
      var x1 = new BN(1);
      var x2 = new BN(0);
      var delta = b2.clone();
      while (a.cmpn(1) > 0 && b2.cmpn(1) > 0) {
        for (var i = 0, im = 1;(a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
          ;
        if (i > 0) {
          a.iushrn(i);
          while (i-- > 0) {
            if (x1.isOdd()) {
              x1.iadd(delta);
            }
            x1.iushrn(1);
          }
        }
        for (var j = 0, jm = 1;(b2.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
          ;
        if (j > 0) {
          b2.iushrn(j);
          while (j-- > 0) {
            if (x2.isOdd()) {
              x2.iadd(delta);
            }
            x2.iushrn(1);
          }
        }
        if (a.cmp(b2) >= 0) {
          a.isub(b2);
          x1.isub(x2);
        } else {
          b2.isub(a);
          x2.isub(x1);
        }
      }
      var res;
      if (a.cmpn(1) === 0) {
        res = x1;
      } else {
        res = x2;
      }
      if (res.cmpn(0) < 0) {
        res.iadd(p);
      }
      return res;
    };
    BN.prototype.gcd = function gcd(num) {
      if (this.isZero())
        return num.abs();
      if (num.isZero())
        return this.abs();
      var a = this.clone();
      var b2 = num.clone();
      a.negative = 0;
      b2.negative = 0;
      for (var shift = 0;a.isEven() && b2.isEven(); shift++) {
        a.iushrn(1);
        b2.iushrn(1);
      }
      do {
        while (a.isEven()) {
          a.iushrn(1);
        }
        while (b2.isEven()) {
          b2.iushrn(1);
        }
        var r = a.cmp(b2);
        if (r < 0) {
          var t = a;
          a = b2;
          b2 = t;
        } else if (r === 0 || b2.cmpn(1) === 0) {
          break;
        }
        a.isub(b2);
      } while (true);
      return b2.iushln(shift);
    };
    BN.prototype.invm = function invm(num) {
      return this.egcd(num).a.umod(num);
    };
    BN.prototype.isEven = function isEven() {
      return (this.words[0] & 1) === 0;
    };
    BN.prototype.isOdd = function isOdd() {
      return (this.words[0] & 1) === 1;
    };
    BN.prototype.andln = function andln(num) {
      return this.words[0] & num;
    };
    BN.prototype.bincn = function bincn(bit) {
      assert2(typeof bit === "number");
      var r = bit % 26;
      var s = (bit - r) / 26;
      var q = 1 << r;
      if (this.length <= s) {
        this._expand(s + 1);
        this.words[s] |= q;
        return this;
      }
      var carry = q;
      for (var i = s;carry !== 0 && i < this.length; i++) {
        var w = this.words[i] | 0;
        w += carry;
        carry = w >>> 26;
        w &= 67108863;
        this.words[i] = w;
      }
      if (carry !== 0) {
        this.words[i] = carry;
        this.length++;
      }
      return this;
    };
    BN.prototype.isZero = function isZero() {
      return this.length === 1 && this.words[0] === 0;
    };
    BN.prototype.cmpn = function cmpn(num) {
      var negative = num < 0;
      if (this.negative !== 0 && !negative)
        return -1;
      if (this.negative === 0 && negative)
        return 1;
      this._strip();
      var res;
      if (this.length > 1) {
        res = 1;
      } else {
        if (negative) {
          num = -num;
        }
        assert2(num <= 67108863, "Number is too big");
        var w = this.words[0] | 0;
        res = w === num ? 0 : w < num ? -1 : 1;
      }
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN.prototype.cmp = function cmp(num) {
      if (this.negative !== 0 && num.negative === 0)
        return -1;
      if (this.negative === 0 && num.negative !== 0)
        return 1;
      var res = this.ucmp(num);
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN.prototype.ucmp = function ucmp(num) {
      if (this.length > num.length)
        return 1;
      if (this.length < num.length)
        return -1;
      var res = 0;
      for (var i = this.length - 1;i >= 0; i--) {
        var a = this.words[i] | 0;
        var b2 = num.words[i] | 0;
        if (a === b2)
          continue;
        if (a < b2) {
          res = -1;
        } else if (a > b2) {
          res = 1;
        }
        break;
      }
      return res;
    };
    BN.prototype.gtn = function gtn(num) {
      return this.cmpn(num) === 1;
    };
    BN.prototype.gt = function gt(num) {
      return this.cmp(num) === 1;
    };
    BN.prototype.gten = function gten(num) {
      return this.cmpn(num) >= 0;
    };
    BN.prototype.gte = function gte(num) {
      return this.cmp(num) >= 0;
    };
    BN.prototype.ltn = function ltn(num) {
      return this.cmpn(num) === -1;
    };
    BN.prototype.lt = function lt(num) {
      return this.cmp(num) === -1;
    };
    BN.prototype.lten = function lten(num) {
      return this.cmpn(num) <= 0;
    };
    BN.prototype.lte = function lte(num) {
      return this.cmp(num) <= 0;
    };
    BN.prototype.eqn = function eqn(num) {
      return this.cmpn(num) === 0;
    };
    BN.prototype.eq = function eq(num) {
      return this.cmp(num) === 0;
    };
    BN.red = function red(num) {
      return new Red(num);
    };
    BN.prototype.toRed = function toRed(ctx) {
      assert2(!this.red, "Already a number in reduction context");
      assert2(this.negative === 0, "red works only with positives");
      return ctx.convertTo(this)._forceRed(ctx);
    };
    BN.prototype.fromRed = function fromRed() {
      assert2(this.red, "fromRed works only with numbers in reduction context");
      return this.red.convertFrom(this);
    };
    BN.prototype._forceRed = function _forceRed(ctx) {
      this.red = ctx;
      return this;
    };
    BN.prototype.forceRed = function forceRed(ctx) {
      assert2(!this.red, "Already a number in reduction context");
      return this._forceRed(ctx);
    };
    BN.prototype.redAdd = function redAdd(num) {
      assert2(this.red, "redAdd works only with red numbers");
      return this.red.add(this, num);
    };
    BN.prototype.redIAdd = function redIAdd(num) {
      assert2(this.red, "redIAdd works only with red numbers");
      return this.red.iadd(this, num);
    };
    BN.prototype.redSub = function redSub(num) {
      assert2(this.red, "redSub works only with red numbers");
      return this.red.sub(this, num);
    };
    BN.prototype.redISub = function redISub(num) {
      assert2(this.red, "redISub works only with red numbers");
      return this.red.isub(this, num);
    };
    BN.prototype.redShl = function redShl(num) {
      assert2(this.red, "redShl works only with red numbers");
      return this.red.shl(this, num);
    };
    BN.prototype.redMul = function redMul(num) {
      assert2(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.mul(this, num);
    };
    BN.prototype.redIMul = function redIMul(num) {
      assert2(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.imul(this, num);
    };
    BN.prototype.redSqr = function redSqr() {
      assert2(this.red, "redSqr works only with red numbers");
      this.red._verify1(this);
      return this.red.sqr(this);
    };
    BN.prototype.redISqr = function redISqr() {
      assert2(this.red, "redISqr works only with red numbers");
      this.red._verify1(this);
      return this.red.isqr(this);
    };
    BN.prototype.redSqrt = function redSqrt() {
      assert2(this.red, "redSqrt works only with red numbers");
      this.red._verify1(this);
      return this.red.sqrt(this);
    };
    BN.prototype.redInvm = function redInvm() {
      assert2(this.red, "redInvm works only with red numbers");
      this.red._verify1(this);
      return this.red.invm(this);
    };
    BN.prototype.redNeg = function redNeg() {
      assert2(this.red, "redNeg works only with red numbers");
      this.red._verify1(this);
      return this.red.neg(this);
    };
    BN.prototype.redPow = function redPow(num) {
      assert2(this.red && !num.red, "redPow(normalNum)");
      this.red._verify1(this);
      return this.red.pow(this, num);
    };
    var primes = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function MPrime(name, p) {
      this.name = name;
      this.p = new BN(p, 16);
      this.n = this.p.bitLength();
      this.k = new BN(1).iushln(this.n).isub(this.p);
      this.tmp = this._tmp();
    }
    MPrime.prototype._tmp = function _tmp() {
      var tmp = new BN(null);
      tmp.words = new Array(Math.ceil(this.n / 13));
      return tmp;
    };
    MPrime.prototype.ireduce = function ireduce(num) {
      var r = num;
      var rlen;
      do {
        this.split(r, this.tmp);
        r = this.imulK(r);
        r = r.iadd(this.tmp);
        rlen = r.bitLength();
      } while (rlen > this.n);
      var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
      if (cmp === 0) {
        r.words[0] = 0;
        r.length = 1;
      } else if (cmp > 0) {
        r.isub(this.p);
      } else {
        if (r.strip !== undefined) {
          r.strip();
        } else {
          r._strip();
        }
      }
      return r;
    };
    MPrime.prototype.split = function split(input, out) {
      input.iushrn(this.n, 0, out);
    };
    MPrime.prototype.imulK = function imulK(num) {
      return num.imul(this.k);
    };
    function K256() {
      MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    inherits(K256, MPrime);
    K256.prototype.split = function split(input, output2) {
      var mask2 = 4194303;
      var outLen = Math.min(input.length, 9);
      for (var i = 0;i < outLen; i++) {
        output2.words[i] = input.words[i];
      }
      output2.length = outLen;
      if (input.length <= 9) {
        input.words[0] = 0;
        input.length = 1;
        return;
      }
      var prev = input.words[9];
      output2.words[output2.length++] = prev & mask2;
      for (i = 10;i < input.length; i++) {
        var next = input.words[i] | 0;
        input.words[i - 10] = (next & mask2) << 4 | prev >>> 22;
        prev = next;
      }
      prev >>>= 22;
      input.words[i - 10] = prev;
      if (prev === 0 && input.length > 10) {
        input.length -= 10;
      } else {
        input.length -= 9;
      }
    };
    K256.prototype.imulK = function imulK(num) {
      num.words[num.length] = 0;
      num.words[num.length + 1] = 0;
      num.length += 2;
      var lo = 0;
      for (var i = 0;i < num.length; i++) {
        var w = num.words[i] | 0;
        lo += w * 977;
        num.words[i] = lo & 67108863;
        lo = w * 64 + (lo / 67108864 | 0);
      }
      if (num.words[num.length - 1] === 0) {
        num.length--;
        if (num.words[num.length - 1] === 0) {
          num.length--;
        }
      }
      return num;
    };
    function P224() {
      MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    inherits(P224, MPrime);
    function P192() {
      MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    inherits(P192, MPrime);
    function P25519() {
      MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    inherits(P25519, MPrime);
    P25519.prototype.imulK = function imulK(num) {
      var carry = 0;
      for (var i = 0;i < num.length; i++) {
        var hi = (num.words[i] | 0) * 19 + carry;
        var lo = hi & 67108863;
        hi >>>= 26;
        num.words[i] = lo;
        carry = hi;
      }
      if (carry !== 0) {
        num.words[num.length++] = carry;
      }
      return num;
    };
    BN._prime = function prime(name) {
      if (primes[name])
        return primes[name];
      var prime;
      if (name === "k256") {
        prime = new K256;
      } else if (name === "p224") {
        prime = new P224;
      } else if (name === "p192") {
        prime = new P192;
      } else if (name === "p25519") {
        prime = new P25519;
      } else {
        throw new Error("Unknown prime " + name);
      }
      primes[name] = prime;
      return prime;
    };
    function Red(m) {
      if (typeof m === "string") {
        var prime = BN._prime(m);
        this.m = prime.p;
        this.prime = prime;
      } else {
        assert2(m.gtn(1), "modulus must be greater than 1");
        this.m = m;
        this.prime = null;
      }
    }
    Red.prototype._verify1 = function _verify1(a) {
      assert2(a.negative === 0, "red works only with positives");
      assert2(a.red, "red works only with red numbers");
    };
    Red.prototype._verify2 = function _verify2(a, b2) {
      assert2((a.negative | b2.negative) === 0, "red works only with positives");
      assert2(a.red && a.red === b2.red, "red works only with red numbers");
    };
    Red.prototype.imod = function imod(a) {
      if (this.prime)
        return this.prime.ireduce(a)._forceRed(this);
      move(a, a.umod(this.m)._forceRed(this));
      return a;
    };
    Red.prototype.neg = function neg(a) {
      if (a.isZero()) {
        return a.clone();
      }
      return this.m.sub(a)._forceRed(this);
    };
    Red.prototype.add = function add(a, b2) {
      this._verify2(a, b2);
      var res = a.add(b2);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.iadd = function iadd(a, b2) {
      this._verify2(a, b2);
      var res = a.iadd(b2);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res;
    };
    Red.prototype.sub = function sub(a, b2) {
      this._verify2(a, b2);
      var res = a.sub(b2);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.isub = function isub(a, b2) {
      this._verify2(a, b2);
      var res = a.isub(b2);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res;
    };
    Red.prototype.shl = function shl(a, num) {
      this._verify1(a);
      return this.imod(a.ushln(num));
    };
    Red.prototype.imul = function imul(a, b2) {
      this._verify2(a, b2);
      return this.imod(a.imul(b2));
    };
    Red.prototype.mul = function mul(a, b2) {
      this._verify2(a, b2);
      return this.imod(a.mul(b2));
    };
    Red.prototype.isqr = function isqr(a) {
      return this.imul(a, a.clone());
    };
    Red.prototype.sqr = function sqr(a) {
      return this.mul(a, a);
    };
    Red.prototype.sqrt = function sqrt(a) {
      if (a.isZero())
        return a.clone();
      var mod3 = this.m.andln(3);
      assert2(mod3 % 2 === 1);
      if (mod3 === 3) {
        var pow = this.m.add(new BN(1)).iushrn(2);
        return this.pow(a, pow);
      }
      var q = this.m.subn(1);
      var s = 0;
      while (!q.isZero() && q.andln(1) === 0) {
        s++;
        q.iushrn(1);
      }
      assert2(!q.isZero());
      var one = new BN(1).toRed(this);
      var nOne = one.redNeg();
      var lpow = this.m.subn(1).iushrn(1);
      var z2 = this.m.bitLength();
      z2 = new BN(2 * z2 * z2).toRed(this);
      while (this.pow(z2, lpow).cmp(nOne) !== 0) {
        z2.redIAdd(nOne);
      }
      var c = this.pow(z2, q);
      var r = this.pow(a, q.addn(1).iushrn(1));
      var t = this.pow(a, q);
      var m = s;
      while (t.cmp(one) !== 0) {
        var tmp = t;
        for (var i = 0;tmp.cmp(one) !== 0; i++) {
          tmp = tmp.redSqr();
        }
        assert2(i < m);
        var b2 = this.pow(c, new BN(1).iushln(m - i - 1));
        r = r.redMul(b2);
        c = b2.redSqr();
        t = t.redMul(c);
        m = i;
      }
      return r;
    };
    Red.prototype.invm = function invm(a) {
      var inv = a._invmp(this.m);
      if (inv.negative !== 0) {
        inv.negative = 0;
        return this.imod(inv).redNeg();
      } else {
        return this.imod(inv);
      }
    };
    Red.prototype.pow = function pow(a, num) {
      if (num.isZero())
        return new BN(1).toRed(this);
      if (num.cmpn(1) === 0)
        return a.clone();
      var windowSize = 4;
      var wnd = new Array(1 << windowSize);
      wnd[0] = new BN(1).toRed(this);
      wnd[1] = a;
      for (var i = 2;i < wnd.length; i++) {
        wnd[i] = this.mul(wnd[i - 1], a);
      }
      var res = wnd[0];
      var current = 0;
      var currentLen = 0;
      var start = num.bitLength() % 26;
      if (start === 0) {
        start = 26;
      }
      for (i = num.length - 1;i >= 0; i--) {
        var word = num.words[i];
        for (var j = start - 1;j >= 0; j--) {
          var bit = word >> j & 1;
          if (res !== wnd[0]) {
            res = this.sqr(res);
          }
          if (bit === 0 && current === 0) {
            currentLen = 0;
            continue;
          }
          current <<= 1;
          current |= bit;
          currentLen++;
          if (currentLen !== windowSize && (i !== 0 || j !== 0))
            continue;
          res = this.mul(res, wnd[current]);
          currentLen = 0;
          current = 0;
        }
        start = 26;
      }
      return res;
    };
    Red.prototype.convertTo = function convertTo(num) {
      var r = num.umod(this.m);
      return r === num ? r.clone() : r;
    };
    Red.prototype.convertFrom = function convertFrom(num) {
      var res = num.clone();
      res.red = null;
      return res;
    };
    BN.mont = function mont(num) {
      return new Mont(num);
    };
    function Mont(m) {
      Red.call(this, m);
      this.shift = this.m.bitLength();
      if (this.shift % 26 !== 0) {
        this.shift += 26 - this.shift % 26;
      }
      this.r = new BN(1).iushln(this.shift);
      this.r2 = this.imod(this.r.sqr());
      this.rinv = this.r._invmp(this.m);
      this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
      this.minv = this.minv.umod(this.r);
      this.minv = this.r.sub(this.minv);
    }
    inherits(Mont, Red);
    Mont.prototype.convertTo = function convertTo(num) {
      return this.imod(num.ushln(this.shift));
    };
    Mont.prototype.convertFrom = function convertFrom(num) {
      var r = this.imod(num.mul(this.rinv));
      r.red = null;
      return r;
    };
    Mont.prototype.imul = function imul(a, b2) {
      if (a.isZero() || b2.isZero()) {
        a.words[0] = 0;
        a.length = 1;
        return a;
      }
      var t = a.imul(b2);
      var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u = t.isub(c).iushrn(this.shift);
      var res = u;
      if (u.cmp(this.m) >= 0) {
        res = u.isub(this.m);
      } else if (u.cmpn(0) < 0) {
        res = u.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.mul = function mul(a, b2) {
      if (a.isZero() || b2.isZero())
        return new BN(0)._forceRed(this);
      var t = a.mul(b2);
      var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u = t.isub(c).iushrn(this.shift);
      var res = u;
      if (u.cmp(this.m) >= 0) {
        res = u.isub(this.m);
      } else if (u.cmpn(0) < 0) {
        res = u.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.invm = function invm(a) {
      var res = this.imod(a._invmp(this.m).mul(this.r2));
      return res._forceRed(this);
    };
  })(typeof module === "undefined" || module, exports);
});

// node_modules/bech32/dist/index.js
var require_dist = __commonJS((exports) => {
  var polymodStep = function(pre) {
    const b2 = pre >> 25;
    return (pre & 33554431) << 5 ^ -(b2 >> 0 & 1) & 996825010 ^ -(b2 >> 1 & 1) & 642813549 ^ -(b2 >> 2 & 1) & 513874426 ^ -(b2 >> 3 & 1) & 1027748829 ^ -(b2 >> 4 & 1) & 705979059;
  };
  var prefixChk = function(prefix) {
    let chk = 1;
    for (let i = 0;i < prefix.length; ++i) {
      const c = prefix.charCodeAt(i);
      if (c < 33 || c > 126)
        return "Invalid prefix (" + prefix + ")";
      chk = polymodStep(chk) ^ c >> 5;
    }
    chk = polymodStep(chk);
    for (let i = 0;i < prefix.length; ++i) {
      const v2 = prefix.charCodeAt(i);
      chk = polymodStep(chk) ^ v2 & 31;
    }
    return chk;
  };
  var convert = function(data3, inBits, outBits, pad) {
    let value = 0;
    let bits = 0;
    const maxV = (1 << outBits) - 1;
    const result = [];
    for (let i = 0;i < data3.length; ++i) {
      value = value << inBits | data3[i];
      bits += inBits;
      while (bits >= outBits) {
        bits -= outBits;
        result.push(value >> bits & maxV);
      }
    }
    if (pad) {
      if (bits > 0) {
        result.push(value << outBits - bits & maxV);
      }
    } else {
      if (bits >= inBits)
        return "Excess padding";
      if (value << outBits - bits & maxV)
        return "Non-zero padding";
    }
    return result;
  };
  var toWords = function(bytes3) {
    return convert(bytes3, 8, 5, true);
  };
  var fromWordsUnsafe = function(words) {
    const res = convert(words, 5, 8, false);
    if (Array.isArray(res))
      return res;
  };
  var fromWords = function(words) {
    const res = convert(words, 5, 8, false);
    if (Array.isArray(res))
      return res;
    throw new Error(res);
  };
  var getLibraryFromEncoding = function(encoding) {
    let ENCODING_CONST;
    if (encoding === "bech32") {
      ENCODING_CONST = 1;
    } else {
      ENCODING_CONST = 734539939;
    }
    function encode(prefix, words, LIMIT) {
      LIMIT = LIMIT || 90;
      if (prefix.length + 7 + words.length > LIMIT)
        throw new TypeError("Exceeds length limit");
      prefix = prefix.toLowerCase();
      let chk = prefixChk(prefix);
      if (typeof chk === "string")
        throw new Error(chk);
      let result = prefix + "1";
      for (let i = 0;i < words.length; ++i) {
        const x = words[i];
        if (x >> 5 !== 0)
          throw new Error("Non 5-bit word");
        chk = polymodStep(chk) ^ x;
        result += ALPHABET.charAt(x);
      }
      for (let i = 0;i < 6; ++i) {
        chk = polymodStep(chk);
      }
      chk ^= ENCODING_CONST;
      for (let i = 0;i < 6; ++i) {
        const v2 = chk >> (5 - i) * 5 & 31;
        result += ALPHABET.charAt(v2);
      }
      return result;
    }
    function __decode(str, LIMIT) {
      LIMIT = LIMIT || 90;
      if (str.length < 8)
        return str + " too short";
      if (str.length > LIMIT)
        return "Exceeds length limit";
      const lowered = str.toLowerCase();
      const uppered = str.toUpperCase();
      if (str !== lowered && str !== uppered)
        return "Mixed-case string " + str;
      str = lowered;
      const split3 = str.lastIndexOf("1");
      if (split3 === -1)
        return "No separator character for " + str;
      if (split3 === 0)
        return "Missing prefix for " + str;
      const prefix = str.slice(0, split3);
      const wordChars = str.slice(split3 + 1);
      if (wordChars.length < 6)
        return "Data too short";
      let chk = prefixChk(prefix);
      if (typeof chk === "string")
        return chk;
      const words = [];
      for (let i = 0;i < wordChars.length; ++i) {
        const c = wordChars.charAt(i);
        const v2 = ALPHABET_MAP[c];
        if (v2 === undefined)
          return "Unknown character " + c;
        chk = polymodStep(chk) ^ v2;
        if (i + 6 >= wordChars.length)
          continue;
        words.push(v2);
      }
      if (chk !== ENCODING_CONST)
        return "Invalid checksum for " + str;
      return { prefix, words };
    }
    function decodeUnsafe(str, LIMIT) {
      const res = __decode(str, LIMIT);
      if (typeof res === "object")
        return res;
    }
    function decode(str, LIMIT) {
      const res = __decode(str, LIMIT);
      if (typeof res === "object")
        return res;
      throw new Error(res);
    }
    return {
      decodeUnsafe,
      decode,
      encode,
      toWords,
      fromWordsUnsafe,
      fromWords
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bech32m = exports.bech32 = undefined;
  var ALPHABET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
  var ALPHABET_MAP = {};
  for (let z2 = 0;z2 < ALPHABET.length; z2++) {
    const x = ALPHABET.charAt(z2);
    ALPHABET_MAP[x] = z2;
  }
  exports.bech32 = getLibraryFromEncoding("bech32");
  exports.bech32m = getLibraryFromEncoding("bech32m");
});

// node_modules/extract-files/public/ReactNativeFile.js
var require_ReactNativeFile = __commonJS((exports, module) => {
  module.exports = function ReactNativeFile(_ref) {
    var { uri, name, type } = _ref;
    this.uri = uri;
    this.name = name;
    this.type = type;
  };
});

// node_modules/extract-files/public/isExtractableFile.js
var require_isExtractableFile = __commonJS((exports, module) => {
  var ReactNativeFile = require_ReactNativeFile();
  module.exports = function isExtractableFile(value) {
    return typeof File !== "undefined" && value instanceof File || typeof Blob !== "undefined" && value instanceof Blob || value instanceof ReactNativeFile;
  };
});

// node_modules/extract-files/public/extractFiles.js
var require_extractFiles = __commonJS((exports, module) => {
  var defaultIsExtractableFile = require_isExtractableFile();
  module.exports = function extractFiles(value, path, isExtractableFile) {
    if (path === undefined) {
      path = "";
    }
    if (isExtractableFile === undefined) {
      isExtractableFile = defaultIsExtractableFile;
    }
    var clone;
    var files = new Map;
    function addFile(paths, file) {
      var storedPaths = files.get(file);
      if (storedPaths)
        storedPaths.push.apply(storedPaths, paths);
      else
        files.set(file, paths);
    }
    if (isExtractableFile(value)) {
      clone = null;
      addFile([path], value);
    } else {
      var prefix = path ? path + "." : "";
      if (typeof FileList !== "undefined" && value instanceof FileList)
        clone = Array.prototype.map.call(value, function(file, i2) {
          addFile(["" + prefix + i2], file);
          return null;
        });
      else if (Array.isArray(value))
        clone = value.map(function(child, i2) {
          var result2 = extractFiles(child, "" + prefix + i2, isExtractableFile);
          result2.files.forEach(addFile);
          return result2.clone;
        });
      else if (value && value.constructor === Object) {
        clone = {};
        for (var i in value) {
          var result = extractFiles(value[i], "" + prefix + i, isExtractableFile);
          result.files.forEach(addFile);
          clone[i] = result.clone;
        }
      } else
        clone = value;
    }
    return {
      clone,
      files
    };
  };
});

// node_modules/form-data/lib/browser.js
var require_browser = __commonJS((exports, module) => {
  module.exports = typeof self == "object" ? self.FormData : window.FormData;
});

// node_modules/cross-fetch/dist/browser-ponyfill.js
var require_browser_ponyfill = __commonJS((exports, module) => {
  var global2 = typeof self !== "undefined" ? self : exports;
  var __self__ = function() {
    function F() {
      this.fetch = false;
      this.DOMException = global2.DOMException;
    }
    F.prototype = global2;
    return new F;
  }();
  (function(self2) {
    var irrelevant = function(exports2) {
      var support = {
        searchParams: "URLSearchParams" in self2,
        iterable: ("Symbol" in self2) && ("iterator" in Symbol),
        blob: ("FileReader" in self2) && ("Blob" in self2) && function() {
          try {
            new Blob;
            return true;
          } catch (e) {
            return false;
          }
        }(),
        formData: "FormData" in self2,
        arrayBuffer: "ArrayBuffer" in self2
      };
      function isDataView(obj) {
        return obj && DataView.prototype.isPrototypeOf(obj);
      }
      if (support.arrayBuffer) {
        var viewClasses = [
          "[object Int8Array]",
          "[object Uint8Array]",
          "[object Uint8ClampedArray]",
          "[object Int16Array]",
          "[object Uint16Array]",
          "[object Int32Array]",
          "[object Uint32Array]",
          "[object Float32Array]",
          "[object Float64Array]"
        ];
        var isArrayBufferView = ArrayBuffer.isView || function(obj) {
          return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
        };
      }
      function normalizeName(name) {
        if (typeof name !== "string") {
          name = String(name);
        }
        if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
          throw new TypeError("Invalid character in header field name");
        }
        return name.toLowerCase();
      }
      function normalizeValue(value) {
        if (typeof value !== "string") {
          value = String(value);
        }
        return value;
      }
      function iteratorFor(items) {
        var iterator = {
          next: function() {
            var value = items.shift();
            return { done: value === undefined, value };
          }
        };
        if (support.iterable) {
          iterator[Symbol.iterator] = function() {
            return iterator;
          };
        }
        return iterator;
      }
      function Headers2(headers) {
        this.map = {};
        if (headers instanceof Headers2) {
          headers.forEach(function(value, name) {
            this.append(name, value);
          }, this);
        } else if (Array.isArray(headers)) {
          headers.forEach(function(header) {
            this.append(header[0], header[1]);
          }, this);
        } else if (headers) {
          Object.getOwnPropertyNames(headers).forEach(function(name) {
            this.append(name, headers[name]);
          }, this);
        }
      }
      Headers2.prototype.append = function(name, value) {
        name = normalizeName(name);
        value = normalizeValue(value);
        var oldValue = this.map[name];
        this.map[name] = oldValue ? oldValue + ", " + value : value;
      };
      Headers2.prototype["delete"] = function(name) {
        delete this.map[normalizeName(name)];
      };
      Headers2.prototype.get = function(name) {
        name = normalizeName(name);
        return this.has(name) ? this.map[name] : null;
      };
      Headers2.prototype.has = function(name) {
        return this.map.hasOwnProperty(normalizeName(name));
      };
      Headers2.prototype.set = function(name, value) {
        this.map[normalizeName(name)] = normalizeValue(value);
      };
      Headers2.prototype.forEach = function(callback, thisArg) {
        for (var name in this.map) {
          if (this.map.hasOwnProperty(name)) {
            callback.call(thisArg, this.map[name], name, this);
          }
        }
      };
      Headers2.prototype.keys = function() {
        var items = [];
        this.forEach(function(value, name) {
          items.push(name);
        });
        return iteratorFor(items);
      };
      Headers2.prototype.values = function() {
        var items = [];
        this.forEach(function(value) {
          items.push(value);
        });
        return iteratorFor(items);
      };
      Headers2.prototype.entries = function() {
        var items = [];
        this.forEach(function(value, name) {
          items.push([name, value]);
        });
        return iteratorFor(items);
      };
      if (support.iterable) {
        Headers2.prototype[Symbol.iterator] = Headers2.prototype.entries;
      }
      function consumed(body) {
        if (body.bodyUsed) {
          return Promise.reject(new TypeError("Already read"));
        }
        body.bodyUsed = true;
      }
      function fileReaderReady(reader) {
        return new Promise(function(resolve, reject) {
          reader.onload = function() {
            resolve(reader.result);
          };
          reader.onerror = function() {
            reject(reader.error);
          };
        });
      }
      function readBlobAsArrayBuffer(blob) {
        var reader = new FileReader;
        var promise = fileReaderReady(reader);
        reader.readAsArrayBuffer(blob);
        return promise;
      }
      function readBlobAsText(blob) {
        var reader = new FileReader;
        var promise = fileReaderReady(reader);
        reader.readAsText(blob);
        return promise;
      }
      function readArrayBufferAsText(buf) {
        var view = new Uint8Array(buf);
        var chars = new Array(view.length);
        for (var i = 0;i < view.length; i++) {
          chars[i] = String.fromCharCode(view[i]);
        }
        return chars.join("");
      }
      function bufferClone(buf) {
        if (buf.slice) {
          return buf.slice(0);
        } else {
          var view = new Uint8Array(buf.byteLength);
          view.set(new Uint8Array(buf));
          return view.buffer;
        }
      }
      function Body() {
        this.bodyUsed = false;
        this._initBody = function(body) {
          this._bodyInit = body;
          if (!body) {
            this._bodyText = "";
          } else if (typeof body === "string") {
            this._bodyText = body;
          } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
            this._bodyBlob = body;
          } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
            this._bodyFormData = body;
          } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
            this._bodyText = body.toString();
          } else if (support.arrayBuffer && support.blob && isDataView(body)) {
            this._bodyArrayBuffer = bufferClone(body.buffer);
            this._bodyInit = new Blob([this._bodyArrayBuffer]);
          } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
            this._bodyArrayBuffer = bufferClone(body);
          } else {
            this._bodyText = body = Object.prototype.toString.call(body);
          }
          if (!this.headers.get("content-type")) {
            if (typeof body === "string") {
              this.headers.set("content-type", "text/plain;charset=UTF-8");
            } else if (this._bodyBlob && this._bodyBlob.type) {
              this.headers.set("content-type", this._bodyBlob.type);
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
            }
          }
        };
        if (support.blob) {
          this.blob = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return Promise.resolve(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(new Blob([this._bodyArrayBuffer]));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as blob");
            } else {
              return Promise.resolve(new Blob([this._bodyText]));
            }
          };
          this.arrayBuffer = function() {
            if (this._bodyArrayBuffer) {
              return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
            } else {
              return this.blob().then(readBlobAsArrayBuffer);
            }
          };
        }
        this.text = function() {
          var rejected = consumed(this);
          if (rejected) {
            return rejected;
          }
          if (this._bodyBlob) {
            return readBlobAsText(this._bodyBlob);
          } else if (this._bodyArrayBuffer) {
            return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
          } else if (this._bodyFormData) {
            throw new Error("could not read FormData body as text");
          } else {
            return Promise.resolve(this._bodyText);
          }
        };
        if (support.formData) {
          this.formData = function() {
            return this.text().then(decode);
          };
        }
        this.json = function() {
          return this.text().then(JSON.parse);
        };
        return this;
      }
      var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
      function normalizeMethod(method) {
        var upcased = method.toUpperCase();
        return methods.indexOf(upcased) > -1 ? upcased : method;
      }
      function Request(input, options) {
        options = options || {};
        var body = options.body;
        if (input instanceof Request) {
          if (input.bodyUsed) {
            throw new TypeError("Already read");
          }
          this.url = input.url;
          this.credentials = input.credentials;
          if (!options.headers) {
            this.headers = new Headers2(input.headers);
          }
          this.method = input.method;
          this.mode = input.mode;
          this.signal = input.signal;
          if (!body && input._bodyInit != null) {
            body = input._bodyInit;
            input.bodyUsed = true;
          }
        } else {
          this.url = String(input);
        }
        this.credentials = options.credentials || this.credentials || "same-origin";
        if (options.headers || !this.headers) {
          this.headers = new Headers2(options.headers);
        }
        this.method = normalizeMethod(options.method || this.method || "GET");
        this.mode = options.mode || this.mode || null;
        this.signal = options.signal || this.signal;
        this.referrer = null;
        if ((this.method === "GET" || this.method === "HEAD") && body) {
          throw new TypeError("Body not allowed for GET or HEAD requests");
        }
        this._initBody(body);
      }
      Request.prototype.clone = function() {
        return new Request(this, { body: this._bodyInit });
      };
      function decode(body) {
        var form = new FormData;
        body.trim().split("&").forEach(function(bytes3) {
          if (bytes3) {
            var split3 = bytes3.split("=");
            var name = split3.shift().replace(/\+/g, " ");
            var value = split3.join("=").replace(/\+/g, " ");
            form.append(decodeURIComponent(name), decodeURIComponent(value));
          }
        });
        return form;
      }
      function parseHeaders(rawHeaders) {
        var headers = new Headers2;
        var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
        preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
          var parts = line.split(":");
          var key = parts.shift().trim();
          if (key) {
            var value = parts.join(":").trim();
            headers.append(key, value);
          }
        });
        return headers;
      }
      Body.call(Request.prototype);
      function Response2(bodyInit, options) {
        if (!options) {
          options = {};
        }
        this.type = "default";
        this.status = options.status === undefined ? 200 : options.status;
        this.ok = this.status >= 200 && this.status < 300;
        this.statusText = ("statusText" in options) ? options.statusText : "OK";
        this.headers = new Headers2(options.headers);
        this.url = options.url || "";
        this._initBody(bodyInit);
      }
      Body.call(Response2.prototype);
      Response2.prototype.clone = function() {
        return new Response2(this._bodyInit, {
          status: this.status,
          statusText: this.statusText,
          headers: new Headers2(this.headers),
          url: this.url
        });
      };
      Response2.error = function() {
        var response = new Response2(null, { status: 0, statusText: "" });
        response.type = "error";
        return response;
      };
      var redirectStatuses = [301, 302, 303, 307, 308];
      Response2.redirect = function(url, status) {
        if (redirectStatuses.indexOf(status) === -1) {
          throw new RangeError("Invalid status code");
        }
        return new Response2(null, { status, headers: { location: url } });
      };
      exports2.DOMException = self2.DOMException;
      try {
        new exports2.DOMException;
      } catch (err) {
        exports2.DOMException = function(message, name) {
          this.message = message;
          this.name = name;
          var error = Error(message);
          this.stack = error.stack;
        };
        exports2.DOMException.prototype = Object.create(Error.prototype);
        exports2.DOMException.prototype.constructor = exports2.DOMException;
      }
      function fetch(input, init) {
        return new Promise(function(resolve, reject) {
          var request = new Request(input, init);
          if (request.signal && request.signal.aborted) {
            return reject(new exports2.DOMException("Aborted", "AbortError"));
          }
          var xhr = new XMLHttpRequest;
          function abortXhr() {
            xhr.abort();
          }
          xhr.onload = function() {
            var options = {
              status: xhr.status,
              statusText: xhr.statusText,
              headers: parseHeaders(xhr.getAllResponseHeaders() || "")
            };
            options.url = ("responseURL" in xhr) ? xhr.responseURL : options.headers.get("X-Request-URL");
            var body = "response" in xhr ? xhr.response : xhr.responseText;
            resolve(new Response2(body, options));
          };
          xhr.onerror = function() {
            reject(new TypeError("Network request failed"));
          };
          xhr.ontimeout = function() {
            reject(new TypeError("Network request failed"));
          };
          xhr.onabort = function() {
            reject(new exports2.DOMException("Aborted", "AbortError"));
          };
          xhr.open(request.method, request.url, true);
          if (request.credentials === "include") {
            xhr.withCredentials = true;
          } else if (request.credentials === "omit") {
            xhr.withCredentials = false;
          }
          if (("responseType" in xhr) && support.blob) {
            xhr.responseType = "blob";
          }
          request.headers.forEach(function(value, name) {
            xhr.setRequestHeader(name, value);
          });
          if (request.signal) {
            request.signal.addEventListener("abort", abortXhr);
            xhr.onreadystatechange = function() {
              if (xhr.readyState === 4) {
                request.signal.removeEventListener("abort", abortXhr);
              }
            };
          }
          xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
        });
      }
      fetch.polyfill = true;
      if (!self2.fetch) {
        self2.fetch = fetch;
        self2.Headers = Headers2;
        self2.Request = Request;
        self2.Response = Response2;
      }
      exports2.Headers = Headers2;
      exports2.Request = Request;
      exports2.Response = Response2;
      exports2.fetch = fetch;
      Object.defineProperty(exports2, "__esModule", { value: true });
      return exports2;
    }({});
  })(__self__);
  __self__.fetch.ponyfill = true;
  delete __self__.fetch.polyfill;
  var ctx = __self__;
  exports = ctx.fetch;
  exports.default = ctx.fetch;
  exports.fetch = ctx.fetch;
  exports.Headers = ctx.Headers;
  exports.Request = ctx.Request;
  exports.Response = ctx.Response;
  module.exports = exports;
});

// node_modules/long/src/long.js
var require_long = __commonJS((exports, module) => {
  var Long = function(low, high, unsigned) {
    this.low = low | 0;
    this.high = high | 0;
    this.unsigned = !!unsigned;
  };
  var isLong = function(obj) {
    return (obj && obj["__isLong__"]) === true;
  };
  var fromInt = function(value, unsigned) {
    var obj, cachedObj, cache;
    if (unsigned) {
      value >>>= 0;
      if (cache = 0 <= value && value < 256) {
        cachedObj = UINT_CACHE[value];
        if (cachedObj)
          return cachedObj;
      }
      obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
      if (cache)
        UINT_CACHE[value] = obj;
      return obj;
    } else {
      value |= 0;
      if (cache = -128 <= value && value < 128) {
        cachedObj = INT_CACHE[value];
        if (cachedObj)
          return cachedObj;
      }
      obj = fromBits(value, value < 0 ? -1 : 0, false);
      if (cache)
        INT_CACHE[value] = obj;
      return obj;
    }
  };
  var fromNumber = function(value, unsigned) {
    if (isNaN(value))
      return unsigned ? UZERO : ZERO;
    if (unsigned) {
      if (value < 0)
        return UZERO;
      if (value >= TWO_PWR_64_DBL)
        return MAX_UNSIGNED_VALUE;
    } else {
      if (value <= -TWO_PWR_63_DBL)
        return MIN_VALUE;
      if (value + 1 >= TWO_PWR_63_DBL)
        return MAX_VALUE;
    }
    if (value < 0)
      return fromNumber(-value, unsigned).neg();
    return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
  };
  var fromBits = function(lowBits, highBits, unsigned) {
    return new Long(lowBits, highBits, unsigned);
  };
  var fromString = function(str, unsigned, radix) {
    if (str.length === 0)
      throw Error("empty string");
    if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
      return ZERO;
    if (typeof unsigned === "number") {
      radix = unsigned, unsigned = false;
    } else {
      unsigned = !!unsigned;
    }
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
      throw RangeError("radix");
    var p;
    if ((p = str.indexOf("-")) > 0)
      throw Error("interior hyphen");
    else if (p === 0) {
      return fromString(str.substring(1), unsigned, radix).neg();
    }
    var radixToPower = fromNumber(pow_dbl(radix, 8));
    var result = ZERO;
    for (var i = 0;i < str.length; i += 8) {
      var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
      if (size < 8) {
        var power = fromNumber(pow_dbl(radix, size));
        result = result.mul(power).add(fromNumber(value));
      } else {
        result = result.mul(radixToPower);
        result = result.add(fromNumber(value));
      }
    }
    result.unsigned = unsigned;
    return result;
  };
  var fromValue = function(val, unsigned) {
    if (typeof val === "number")
      return fromNumber(val, unsigned);
    if (typeof val === "string")
      return fromString(val, unsigned);
    return fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
  };
  module.exports = Long;
  var wasm = null;
  try {
    wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
      0,
      97,
      115,
      109,
      1,
      0,
      0,
      0,
      1,
      13,
      2,
      96,
      0,
      1,
      127,
      96,
      4,
      127,
      127,
      127,
      127,
      1,
      127,
      3,
      7,
      6,
      0,
      1,
      1,
      1,
      1,
      1,
      6,
      6,
      1,
      127,
      1,
      65,
      0,
      11,
      7,
      50,
      6,
      3,
      109,
      117,
      108,
      0,
      1,
      5,
      100,
      105,
      118,
      95,
      115,
      0,
      2,
      5,
      100,
      105,
      118,
      95,
      117,
      0,
      3,
      5,
      114,
      101,
      109,
      95,
      115,
      0,
      4,
      5,
      114,
      101,
      109,
      95,
      117,
      0,
      5,
      8,
      103,
      101,
      116,
      95,
      104,
      105,
      103,
      104,
      0,
      0,
      10,
      191,
      1,
      6,
      4,
      0,
      35,
      0,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      126,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      127,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      128,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      129,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      130,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11
    ])), {}).exports;
  } catch (e) {
  }
  Long.prototype.__isLong__;
  Object.defineProperty(Long.prototype, "__isLong__", { value: true });
  Long.isLong = isLong;
  var INT_CACHE = {};
  var UINT_CACHE = {};
  Long.fromInt = fromInt;
  Long.fromNumber = fromNumber;
  Long.fromBits = fromBits;
  var pow_dbl = Math.pow;
  Long.fromString = fromString;
  Long.fromValue = fromValue;
  var TWO_PWR_16_DBL = 1 << 16;
  var TWO_PWR_24_DBL = 1 << 24;
  var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
  var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
  var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
  var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
  var ZERO = fromInt(0);
  Long.ZERO = ZERO;
  var UZERO = fromInt(0, true);
  Long.UZERO = UZERO;
  var ONE = fromInt(1);
  Long.ONE = ONE;
  var UONE = fromInt(1, true);
  Long.UONE = UONE;
  var NEG_ONE = fromInt(-1);
  Long.NEG_ONE = NEG_ONE;
  var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
  Long.MAX_VALUE = MAX_VALUE;
  var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
  Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
  var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
  Long.MIN_VALUE = MIN_VALUE;
  var LongPrototype = Long.prototype;
  LongPrototype.toInt = function toInt() {
    return this.unsigned ? this.low >>> 0 : this.low;
  };
  LongPrototype.toNumber = function toNumber() {
    if (this.unsigned)
      return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
  };
  LongPrototype.toString = function toString(radix) {
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
      throw RangeError("radix");
    if (this.isZero())
      return "0";
    if (this.isNegative()) {
      if (this.eq(MIN_VALUE)) {
        var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
        return div.toString(radix) + rem1.toInt().toString(radix);
      } else
        return "-" + this.neg().toString(radix);
    }
    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
    var result = "";
    while (true) {
      var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
      rem = remDiv;
      if (rem.isZero())
        return digits + result;
      else {
        while (digits.length < 6)
          digits = "0" + digits;
        result = "" + digits + result;
      }
    }
  };
  LongPrototype.getHighBits = function getHighBits() {
    return this.high;
  };
  LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
    return this.high >>> 0;
  };
  LongPrototype.getLowBits = function getLowBits() {
    return this.low;
  };
  LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
    return this.low >>> 0;
  };
  LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
    if (this.isNegative())
      return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
    var val = this.high != 0 ? this.high : this.low;
    for (var bit = 31;bit > 0; bit--)
      if ((val & 1 << bit) != 0)
        break;
    return this.high != 0 ? bit + 33 : bit + 1;
  };
  LongPrototype.isZero = function isZero() {
    return this.high === 0 && this.low === 0;
  };
  LongPrototype.eqz = LongPrototype.isZero;
  LongPrototype.isNegative = function isNegative() {
    return !this.unsigned && this.high < 0;
  };
  LongPrototype.isPositive = function isPositive() {
    return this.unsigned || this.high >= 0;
  };
  LongPrototype.isOdd = function isOdd() {
    return (this.low & 1) === 1;
  };
  LongPrototype.isEven = function isEven() {
    return (this.low & 1) === 0;
  };
  LongPrototype.equals = function equals(other) {
    if (!isLong(other))
      other = fromValue(other);
    if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
      return false;
    return this.high === other.high && this.low === other.low;
  };
  LongPrototype.eq = LongPrototype.equals;
  LongPrototype.notEquals = function notEquals(other) {
    return !this.eq(other);
  };
  LongPrototype.neq = LongPrototype.notEquals;
  LongPrototype.ne = LongPrototype.notEquals;
  LongPrototype.lessThan = function lessThan(other) {
    return this.comp(other) < 0;
  };
  LongPrototype.lt = LongPrototype.lessThan;
  LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
    return this.comp(other) <= 0;
  };
  LongPrototype.lte = LongPrototype.lessThanOrEqual;
  LongPrototype.le = LongPrototype.lessThanOrEqual;
  LongPrototype.greaterThan = function greaterThan(other) {
    return this.comp(other) > 0;
  };
  LongPrototype.gt = LongPrototype.greaterThan;
  LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
    return this.comp(other) >= 0;
  };
  LongPrototype.gte = LongPrototype.greaterThanOrEqual;
  LongPrototype.ge = LongPrototype.greaterThanOrEqual;
  LongPrototype.compare = function compare(other) {
    if (!isLong(other))
      other = fromValue(other);
    if (this.eq(other))
      return 0;
    var thisNeg = this.isNegative(), otherNeg = other.isNegative();
    if (thisNeg && !otherNeg)
      return -1;
    if (!thisNeg && otherNeg)
      return 1;
    if (!this.unsigned)
      return this.sub(other).isNegative() ? -1 : 1;
    return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
  };
  LongPrototype.comp = LongPrototype.compare;
  LongPrototype.negate = function negate() {
    if (!this.unsigned && this.eq(MIN_VALUE))
      return MIN_VALUE;
    return this.not().add(ONE);
  };
  LongPrototype.neg = LongPrototype.negate;
  LongPrototype.add = function add(addend) {
    if (!isLong(addend))
      addend = fromValue(addend);
    var a48 = this.high >>> 16;
    var a32 = this.high & 65535;
    var a16 = this.low >>> 16;
    var a00 = this.low & 65535;
    var b48 = addend.high >>> 16;
    var b32 = addend.high & 65535;
    var b16 = addend.low >>> 16;
    var b00 = addend.low & 65535;
    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 65535;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 65535;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c48 += a48 + b48;
    c48 &= 65535;
    return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
  };
  LongPrototype.subtract = function subtract(subtrahend) {
    if (!isLong(subtrahend))
      subtrahend = fromValue(subtrahend);
    return this.add(subtrahend.neg());
  };
  LongPrototype.sub = LongPrototype.subtract;
  LongPrototype.multiply = function multiply(multiplier) {
    if (this.isZero())
      return ZERO;
    if (!isLong(multiplier))
      multiplier = fromValue(multiplier);
    if (wasm) {
      var low = wasm.mul(this.low, this.high, multiplier.low, multiplier.high);
      return fromBits(low, wasm.get_high(), this.unsigned);
    }
    if (multiplier.isZero())
      return ZERO;
    if (this.eq(MIN_VALUE))
      return multiplier.isOdd() ? MIN_VALUE : ZERO;
    if (multiplier.eq(MIN_VALUE))
      return this.isOdd() ? MIN_VALUE : ZERO;
    if (this.isNegative()) {
      if (multiplier.isNegative())
        return this.neg().mul(multiplier.neg());
      else
        return this.neg().mul(multiplier).neg();
    } else if (multiplier.isNegative())
      return this.mul(multiplier.neg()).neg();
    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
      return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
    var a48 = this.high >>> 16;
    var a32 = this.high & 65535;
    var a16 = this.low >>> 16;
    var a00 = this.low & 65535;
    var b48 = multiplier.high >>> 16;
    var b32 = multiplier.high & 65535;
    var b16 = multiplier.low >>> 16;
    var b00 = multiplier.low & 65535;
    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 65535;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 65535;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 65535;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 65535;
    return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
  };
  LongPrototype.mul = LongPrototype.multiply;
  LongPrototype.divide = function divide(divisor) {
    if (!isLong(divisor))
      divisor = fromValue(divisor);
    if (divisor.isZero())
      throw Error("division by zero");
    if (wasm) {
      if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
        return this;
      }
      var low = (this.unsigned ? wasm.div_u : wasm.div_s)(this.low, this.high, divisor.low, divisor.high);
      return fromBits(low, wasm.get_high(), this.unsigned);
    }
    if (this.isZero())
      return this.unsigned ? UZERO : ZERO;
    var approx, rem, res;
    if (!this.unsigned) {
      if (this.eq(MIN_VALUE)) {
        if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
          return MIN_VALUE;
        else if (divisor.eq(MIN_VALUE))
          return ONE;
        else {
          var halfThis = this.shr(1);
          approx = halfThis.div(divisor).shl(1);
          if (approx.eq(ZERO)) {
            return divisor.isNegative() ? ONE : NEG_ONE;
          } else {
            rem = this.sub(divisor.mul(approx));
            res = approx.add(rem.div(divisor));
            return res;
          }
        }
      } else if (divisor.eq(MIN_VALUE))
        return this.unsigned ? UZERO : ZERO;
      if (this.isNegative()) {
        if (divisor.isNegative())
          return this.neg().div(divisor.neg());
        return this.neg().div(divisor).neg();
      } else if (divisor.isNegative())
        return this.div(divisor.neg()).neg();
      res = ZERO;
    } else {
      if (!divisor.unsigned)
        divisor = divisor.toUnsigned();
      if (divisor.gt(this))
        return UZERO;
      if (divisor.gt(this.shru(1)))
        return UONE;
      res = UZERO;
    }
    rem = this;
    while (rem.gte(divisor)) {
      approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
      var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
      while (approxRem.isNegative() || approxRem.gt(rem)) {
        approx -= delta;
        approxRes = fromNumber(approx, this.unsigned);
        approxRem = approxRes.mul(divisor);
      }
      if (approxRes.isZero())
        approxRes = ONE;
      res = res.add(approxRes);
      rem = rem.sub(approxRem);
    }
    return res;
  };
  LongPrototype.div = LongPrototype.divide;
  LongPrototype.modulo = function modulo(divisor) {
    if (!isLong(divisor))
      divisor = fromValue(divisor);
    if (wasm) {
      var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(this.low, this.high, divisor.low, divisor.high);
      return fromBits(low, wasm.get_high(), this.unsigned);
    }
    return this.sub(this.div(divisor).mul(divisor));
  };
  LongPrototype.mod = LongPrototype.modulo;
  LongPrototype.rem = LongPrototype.modulo;
  LongPrototype.not = function not() {
    return fromBits(~this.low, ~this.high, this.unsigned);
  };
  LongPrototype.and = function and(other) {
    if (!isLong(other))
      other = fromValue(other);
    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
  };
  LongPrototype.or = function or(other) {
    if (!isLong(other))
      other = fromValue(other);
    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
  };
  LongPrototype.xor = function xor(other) {
    if (!isLong(other))
      other = fromValue(other);
    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
  };
  LongPrototype.shiftLeft = function shiftLeft(numBits) {
    if (isLong(numBits))
      numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
      return this;
    else if (numBits < 32)
      return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
    else
      return fromBits(0, this.low << numBits - 32, this.unsigned);
  };
  LongPrototype.shl = LongPrototype.shiftLeft;
  LongPrototype.shiftRight = function shiftRight(numBits) {
    if (isLong(numBits))
      numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
      return this;
    else if (numBits < 32)
      return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
    else
      return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
  };
  LongPrototype.shr = LongPrototype.shiftRight;
  LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
    if (isLong(numBits))
      numBits = numBits.toInt();
    numBits &= 63;
    if (numBits === 0)
      return this;
    else {
      var high = this.high;
      if (numBits < 32) {
        var low = this.low;
        return fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
      } else if (numBits === 32)
        return fromBits(high, 0, this.unsigned);
      else
        return fromBits(high >>> numBits - 32, 0, this.unsigned);
    }
  };
  LongPrototype.shru = LongPrototype.shiftRightUnsigned;
  LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
  LongPrototype.toSigned = function toSigned() {
    if (!this.unsigned)
      return this;
    return fromBits(this.low, this.high, false);
  };
  LongPrototype.toUnsigned = function toUnsigned() {
    if (this.unsigned)
      return this;
    return fromBits(this.low, this.high, true);
  };
  LongPrototype.toBytes = function toBytes(le) {
    return le ? this.toBytesLE() : this.toBytesBE();
  };
  LongPrototype.toBytesLE = function toBytesLE() {
    var hi = this.high, lo = this.low;
    return [
      lo & 255,
      lo >>> 8 & 255,
      lo >>> 16 & 255,
      lo >>> 24,
      hi & 255,
      hi >>> 8 & 255,
      hi >>> 16 & 255,
      hi >>> 24
    ];
  };
  LongPrototype.toBytesBE = function toBytesBE() {
    var hi = this.high, lo = this.low;
    return [
      hi >>> 24,
      hi >>> 16 & 255,
      hi >>> 8 & 255,
      hi & 255,
      lo >>> 24,
      lo >>> 16 & 255,
      lo >>> 8 & 255,
      lo & 255
    ];
  };
  Long.fromBytes = function fromBytes(bytes3, unsigned, le) {
    return le ? Long.fromBytesLE(bytes3, unsigned) : Long.fromBytesBE(bytes3, unsigned);
  };
  Long.fromBytesLE = function fromBytesLE(bytes3, unsigned) {
    return new Long(bytes3[0] | bytes3[1] << 8 | bytes3[2] << 16 | bytes3[3] << 24, bytes3[4] | bytes3[5] << 8 | bytes3[6] << 16 | bytes3[7] << 24, unsigned);
  };
  Long.fromBytesBE = function fromBytesBE(bytes3, unsigned) {
    return new Long(bytes3[4] << 24 | bytes3[5] << 16 | bytes3[6] << 8 | bytes3[7], bytes3[0] << 24 | bytes3[1] << 16 | bytes3[2] << 8 | bytes3[3], unsigned);
  };
});

// node_modules/tai64/lib/leapSeconds.js
var require_leapSeconds = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var leapSeconds = [
    [1483228800, 37],
    [1435708800, 36],
    [1341100800, 35],
    [1230768000, 34],
    [1136073600, 33],
    [915148800, 32],
    [867715200, 31],
    [820454400, 30],
    [773020800, 29],
    [741484800, 28],
    [709948800, 27],
    [662688000, 26],
    [631152000, 25],
    [567993600, 24],
    [489024000, 23],
    [425865600, 22],
    [394329600, 21],
    [362793600, 20],
    [315532800, 19],
    [283996800, 18],
    [252460800, 17],
    [220924800, 16],
    [189302400, 15],
    [157766400, 14],
    [126230400, 13],
    [94694400, 12],
    [78796800, 11],
    [63072000, 10]
  ];
  var addLeapSeconds = (timestamp) => {
    const leapSecond = leapSeconds.find(([ts]) => timestamp >= ts);
    return timestamp + (leapSecond ? leapSecond[1] : 0);
  };
  exports.addLeapSeconds = addLeapSeconds;
  var removeLeapSeconds = (timestamp) => {
    const leapSecond = leapSeconds.find(([ts, offset]) => timestamp - offset >= ts);
    return timestamp - (leapSecond ? leapSecond[1] : 0);
  };
  exports.removeLeapSeconds = removeLeapSeconds;
});

// node_modules/tai64/lib/TAI64.js
var require_TAI64 = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var long_1 = __importDefault(require_long());
  var leapSeconds_1 = require_leapSeconds();

  class TAI64 {
    constructor(label) {
      this.label = label;
      if (label.lt(long_1.default.ZERO) || label.gte(long_1.default.MAX_VALUE)) {
        throw new RangeError("Label must be an integer between 0 and 2^63-1, inclusive");
      }
    }
    static now() {
      const unixTimestamp = Math.floor(Date.now() / 1000);
      return TAI64.fromUnix(unixTimestamp);
    }
    static fromUnix(timestamp) {
      const seconds = leapSeconds_1.addLeapSeconds(timestamp);
      const label = TAI64.EPOCH.label.add(seconds);
      return new TAI64(label);
    }
    static fromHexString(hexString) {
      return TAI64.fromString(hexString);
    }
    static fromString(str, radix = 16) {
      const label = long_1.default.fromString(str, false, radix);
      return new TAI64(label);
    }
    static fromByteArray(bytes3) {
      const label = long_1.default.fromBytes(bytes3, false);
      return new TAI64(label);
    }
    isAfter(other) {
      return this.compareTo(other) > 0;
    }
    isBefore(other) {
      return this.compareTo(other) < 0;
    }
    isEqual(other) {
      return this.compareTo(other) === 0;
    }
    compareTo(other) {
      return this.label.compare(other.label);
    }
    toByteArray() {
      return this.label.toBytes();
    }
    toHexString() {
      return this.toString();
    }
    toString(radix = 16) {
      return this.label.toString(radix);
    }
    toUnix() {
      const elapsedSeconds = this.label.sub(TAI64.EPOCH.label);
      return leapSeconds_1.removeLeapSeconds(elapsedSeconds.toNumber());
    }
  }
  TAI64.EPOCH = new TAI64(long_1.default.MAX_VALUE.shiftRight(1).add(1));
  exports.TAI64 = TAI64;
});

// node_modules/tai64/lib/index.js
var require_lib = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var TAI64_1 = require_TAI64();
  exports.TAI64 = TAI64_1.TAI64;
});

// node_modules/elliptic/package.json
var require_package = __commonJS((exports, module) => {
  module.exports = {
    name: "elliptic",
    version: "6.5.4",
    description: "EC cryptography",
    main: "lib/elliptic.js",
    files: [
      "lib"
    ],
    scripts: {
      lint: "eslint lib test",
      "lint:fix": "npm run lint -- --fix",
      unit: "istanbul test _mocha --reporter=spec test/index.js",
      test: "npm run lint && npm run unit",
      version: "grunt dist && git add dist/"
    },
    repository: {
      type: "git",
      url: "git@github.com:indutny/elliptic"
    },
    keywords: [
      "EC",
      "Elliptic",
      "curve",
      "Cryptography"
    ],
    author: "Fedor Indutny <fedor@indutny.com>",
    license: "MIT",
    bugs: {
      url: "https://github.com/indutny/elliptic/issues"
    },
    homepage: "https://github.com/indutny/elliptic",
    devDependencies: {
      brfs: "^2.0.2",
      coveralls: "^3.1.0",
      eslint: "^7.6.0",
      grunt: "^1.2.1",
      "grunt-browserify": "^5.3.0",
      "grunt-cli": "^1.3.2",
      "grunt-contrib-connect": "^3.0.0",
      "grunt-contrib-copy": "^1.0.0",
      "grunt-contrib-uglify": "^5.0.0",
      "grunt-mocha-istanbul": "^5.0.2",
      "grunt-saucelabs": "^9.0.1",
      istanbul: "^0.4.5",
      mocha: "^8.0.1"
    },
    dependencies: {
      "bn.js": "^4.11.9",
      brorand: "^1.1.0",
      "hash.js": "^1.0.0",
      "hmac-drbg": "^1.0.1",
      inherits: "^2.0.4",
      "minimalistic-assert": "^1.0.1",
      "minimalistic-crypto-utils": "^1.0.1"
    }
  };
});

// node_modules/elliptic/node_modules/bn.js/lib/bn.js
var require_bn2 = __commonJS((exports, module) => {
  (function(module2, exports2) {
    function assert4(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor;
      ctor.prototype.constructor = ctor;
    }
    function BN2(number3, base, endian) {
      if (BN2.isBN(number3)) {
        return number3;
      }
      this.negative = 0;
      this.words = null;
      this.length = 0;
      this.red = null;
      if (number3 !== null) {
        if (base === "le" || base === "be") {
          endian = base;
          base = 10;
        }
        this._init(number3 || 0, base || 10, endian || "be");
      }
    }
    if (typeof module2 === "object") {
      module2.exports = BN2;
    } else {
      exports2.BN = BN2;
    }
    BN2.BN = BN2;
    BN2.wordSize = 26;
    var Buffer2;
    try {
      if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
        Buffer2 = window.Buffer;
      } else {
        Buffer2 = (init_buffer(), __toCommonJS(exports_buffer)).Buffer;
      }
    } catch (e) {
    }
    BN2.isBN = function isBN(num) {
      if (num instanceof BN2) {
        return true;
      }
      return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
    };
    BN2.max = function max(left, right) {
      if (left.cmp(right) > 0)
        return left;
      return right;
    };
    BN2.min = function min(left, right) {
      if (left.cmp(right) < 0)
        return left;
      return right;
    };
    BN2.prototype._init = function init(number3, base, endian) {
      if (typeof number3 === "number") {
        return this._initNumber(number3, base, endian);
      }
      if (typeof number3 === "object") {
        return this._initArray(number3, base, endian);
      }
      if (base === "hex") {
        base = 16;
      }
      assert4(base === (base | 0) && base >= 2 && base <= 36);
      number3 = number3.toString().replace(/\s+/g, "");
      var start = 0;
      if (number3[0] === "-") {
        start++;
        this.negative = 1;
      }
      if (start < number3.length) {
        if (base === 16) {
          this._parseHex(number3, start, endian);
        } else {
          this._parseBase(number3, base, start);
          if (endian === "le") {
            this._initArray(this.toArray(), base, endian);
          }
        }
      }
    };
    BN2.prototype._initNumber = function _initNumber(number3, base, endian) {
      if (number3 < 0) {
        this.negative = 1;
        number3 = -number3;
      }
      if (number3 < 67108864) {
        this.words = [number3 & 67108863];
        this.length = 1;
      } else if (number3 < 4503599627370496) {
        this.words = [
          number3 & 67108863,
          number3 / 67108864 & 67108863
        ];
        this.length = 2;
      } else {
        assert4(number3 < 9007199254740992);
        this.words = [
          number3 & 67108863,
          number3 / 67108864 & 67108863,
          1
        ];
        this.length = 3;
      }
      if (endian !== "le")
        return;
      this._initArray(this.toArray(), base, endian);
    };
    BN2.prototype._initArray = function _initArray(number3, base, endian) {
      assert4(typeof number3.length === "number");
      if (number3.length <= 0) {
        this.words = [0];
        this.length = 1;
        return this;
      }
      this.length = Math.ceil(number3.length / 3);
      this.words = new Array(this.length);
      for (var i = 0;i < this.length; i++) {
        this.words[i] = 0;
      }
      var j, w;
      var off = 0;
      if (endian === "be") {
        for (i = number3.length - 1, j = 0;i >= 0; i -= 3) {
          w = number3[i] | number3[i - 1] << 8 | number3[i - 2] << 16;
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] = w >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      } else if (endian === "le") {
        for (i = 0, j = 0;i < number3.length; i += 3) {
          w = number3[i] | number3[i + 1] << 8 | number3[i + 2] << 16;
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] = w >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      }
      return this.strip();
    };
    function parseHex4Bits(string, index) {
      var c = string.charCodeAt(index);
      if (c >= 65 && c <= 70) {
        return c - 55;
      } else if (c >= 97 && c <= 102) {
        return c - 87;
      } else {
        return c - 48 & 15;
      }
    }
    function parseHexByte(string, lowerBound, index) {
      var r = parseHex4Bits(string, index);
      if (index - 1 >= lowerBound) {
        r |= parseHex4Bits(string, index - 1) << 4;
      }
      return r;
    }
    BN2.prototype._parseHex = function _parseHex(number3, start, endian) {
      this.length = Math.ceil((number3.length - start) / 6);
      this.words = new Array(this.length);
      for (var i = 0;i < this.length; i++) {
        this.words[i] = 0;
      }
      var off = 0;
      var j = 0;
      var w;
      if (endian === "be") {
        for (i = number3.length - 1;i >= start; i -= 2) {
          w = parseHexByte(number3, start, i) << off;
          this.words[j] |= w & 67108863;
          if (off >= 18) {
            off -= 18;
            j += 1;
            this.words[j] |= w >>> 26;
          } else {
            off += 8;
          }
        }
      } else {
        var parseLength = number3.length - start;
        for (i = parseLength % 2 === 0 ? start + 1 : start;i < number3.length; i += 2) {
          w = parseHexByte(number3, start, i) << off;
          this.words[j] |= w & 67108863;
          if (off >= 18) {
            off -= 18;
            j += 1;
            this.words[j] |= w >>> 26;
          } else {
            off += 8;
          }
        }
      }
      this.strip();
    };
    function parseBase(str, start, end, mul) {
      var r = 0;
      var len = Math.min(str.length, end);
      for (var i = start;i < len; i++) {
        var c = str.charCodeAt(i) - 48;
        r *= mul;
        if (c >= 49) {
          r += c - 49 + 10;
        } else if (c >= 17) {
          r += c - 17 + 10;
        } else {
          r += c;
        }
      }
      return r;
    }
    BN2.prototype._parseBase = function _parseBase(number3, base, start) {
      this.words = [0];
      this.length = 1;
      for (var limbLen = 0, limbPow = 1;limbPow <= 67108863; limbPow *= base) {
        limbLen++;
      }
      limbLen--;
      limbPow = limbPow / base | 0;
      var total = number3.length - start;
      var mod = total % limbLen;
      var end = Math.min(total, total - mod) + start;
      var word = 0;
      for (var i = start;i < end; i += limbLen) {
        word = parseBase(number3, i, i + limbLen, base);
        this.imuln(limbPow);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      if (mod !== 0) {
        var pow = 1;
        word = parseBase(number3, i, number3.length, base);
        for (i = 0;i < mod; i++) {
          pow *= base;
        }
        this.imuln(pow);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      this.strip();
    };
    BN2.prototype.copy = function copy(dest) {
      dest.words = new Array(this.length);
      for (var i = 0;i < this.length; i++) {
        dest.words[i] = this.words[i];
      }
      dest.length = this.length;
      dest.negative = this.negative;
      dest.red = this.red;
    };
    BN2.prototype.clone = function clone() {
      var r = new BN2(null);
      this.copy(r);
      return r;
    };
    BN2.prototype._expand = function _expand(size) {
      while (this.length < size) {
        this.words[this.length++] = 0;
      }
      return this;
    };
    BN2.prototype.strip = function strip() {
      while (this.length > 1 && this.words[this.length - 1] === 0) {
        this.length--;
      }
      return this._normSign();
    };
    BN2.prototype._normSign = function _normSign() {
      if (this.length === 1 && this.words[0] === 0) {
        this.negative = 0;
      }
      return this;
    };
    BN2.prototype.inspect = function inspect() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var zeros = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ];
    var groupSizes = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ];
    var groupBases = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64000000,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      24300000,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    BN2.prototype.toString = function toString(base, padding) {
      base = base || 10;
      padding = padding | 0 || 1;
      var out;
      if (base === 16 || base === "hex") {
        out = "";
        var off = 0;
        var carry = 0;
        for (var i = 0;i < this.length; i++) {
          var w = this.words[i];
          var word = ((w << off | carry) & 16777215).toString(16);
          carry = w >>> 24 - off & 16777215;
          if (carry !== 0 || i !== this.length - 1) {
            out = zeros[6 - word.length] + word + out;
          } else {
            out = word + out;
          }
          off += 2;
          if (off >= 26) {
            off -= 26;
            i--;
          }
        }
        if (carry !== 0) {
          out = carry.toString(16) + out;
        }
        while (out.length % padding !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      if (base === (base | 0) && base >= 2 && base <= 36) {
        var groupSize = groupSizes[base];
        var groupBase = groupBases[base];
        out = "";
        var c = this.clone();
        c.negative = 0;
        while (!c.isZero()) {
          var r = c.modn(groupBase).toString(base);
          c = c.idivn(groupBase);
          if (!c.isZero()) {
            out = zeros[groupSize - r.length] + r + out;
          } else {
            out = r + out;
          }
        }
        if (this.isZero()) {
          out = "0" + out;
        }
        while (out.length % padding !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      assert4(false, "Base should be between 2 and 36");
    };
    BN2.prototype.toNumber = function toNumber() {
      var ret2 = this.words[0];
      if (this.length === 2) {
        ret2 += this.words[1] * 67108864;
      } else if (this.length === 3 && this.words[2] === 1) {
        ret2 += 4503599627370496 + this.words[1] * 67108864;
      } else if (this.length > 2) {
        assert4(false, "Number can only safely store up to 53 bits");
      }
      return this.negative !== 0 ? -ret2 : ret2;
    };
    BN2.prototype.toJSON = function toJSON() {
      return this.toString(16);
    };
    BN2.prototype.toBuffer = function toBuffer(endian, length) {
      assert4(typeof Buffer2 !== "undefined");
      return this.toArrayLike(Buffer2, endian, length);
    };
    BN2.prototype.toArray = function toArray(endian, length) {
      return this.toArrayLike(Array, endian, length);
    };
    BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
      var byteLength = this.byteLength();
      var reqLength = length || Math.max(1, byteLength);
      assert4(byteLength <= reqLength, "byte array longer than desired length");
      assert4(reqLength > 0, "Requested array length <= 0");
      this.strip();
      var littleEndian = endian === "le";
      var res = new ArrayType(reqLength);
      var b2, i;
      var q = this.clone();
      if (!littleEndian) {
        for (i = 0;i < reqLength - byteLength; i++) {
          res[i] = 0;
        }
        for (i = 0;!q.isZero(); i++) {
          b2 = q.andln(255);
          q.iushrn(8);
          res[reqLength - i - 1] = b2;
        }
      } else {
        for (i = 0;!q.isZero(); i++) {
          b2 = q.andln(255);
          q.iushrn(8);
          res[i] = b2;
        }
        for (;i < reqLength; i++) {
          res[i] = 0;
        }
      }
      return res;
    };
    if (Math.clz32) {
      BN2.prototype._countBits = function _countBits(w) {
        return 32 - Math.clz32(w);
      };
    } else {
      BN2.prototype._countBits = function _countBits(w) {
        var t = w;
        var r = 0;
        if (t >= 4096) {
          r += 13;
          t >>>= 13;
        }
        if (t >= 64) {
          r += 7;
          t >>>= 7;
        }
        if (t >= 8) {
          r += 4;
          t >>>= 4;
        }
        if (t >= 2) {
          r += 2;
          t >>>= 2;
        }
        return r + t;
      };
    }
    BN2.prototype._zeroBits = function _zeroBits(w) {
      if (w === 0)
        return 26;
      var t = w;
      var r = 0;
      if ((t & 8191) === 0) {
        r += 13;
        t >>>= 13;
      }
      if ((t & 127) === 0) {
        r += 7;
        t >>>= 7;
      }
      if ((t & 15) === 0) {
        r += 4;
        t >>>= 4;
      }
      if ((t & 3) === 0) {
        r += 2;
        t >>>= 2;
      }
      if ((t & 1) === 0) {
        r++;
      }
      return r;
    };
    BN2.prototype.bitLength = function bitLength() {
      var w = this.words[this.length - 1];
      var hi = this._countBits(w);
      return (this.length - 1) * 26 + hi;
    };
    function toBitArray(num) {
      var w = new Array(num.bitLength());
      for (var bit = 0;bit < w.length; bit++) {
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
      }
      return w;
    }
    BN2.prototype.zeroBits = function zeroBits() {
      if (this.isZero())
        return 0;
      var r = 0;
      for (var i = 0;i < this.length; i++) {
        var b2 = this._zeroBits(this.words[i]);
        r += b2;
        if (b2 !== 26)
          break;
      }
      return r;
    };
    BN2.prototype.byteLength = function byteLength() {
      return Math.ceil(this.bitLength() / 8);
    };
    BN2.prototype.toTwos = function toTwos(width) {
      if (this.negative !== 0) {
        return this.abs().inotn(width).iaddn(1);
      }
      return this.clone();
    };
    BN2.prototype.fromTwos = function fromTwos(width) {
      if (this.testn(width - 1)) {
        return this.notn(width).iaddn(1).ineg();
      }
      return this.clone();
    };
    BN2.prototype.isNeg = function isNeg() {
      return this.negative !== 0;
    };
    BN2.prototype.neg = function neg() {
      return this.clone().ineg();
    };
    BN2.prototype.ineg = function ineg() {
      if (!this.isZero()) {
        this.negative ^= 1;
      }
      return this;
    };
    BN2.prototype.iuor = function iuor(num) {
      while (this.length < num.length) {
        this.words[this.length++] = 0;
      }
      for (var i = 0;i < num.length; i++) {
        this.words[i] = this.words[i] | num.words[i];
      }
      return this.strip();
    };
    BN2.prototype.ior = function ior(num) {
      assert4((this.negative | num.negative) === 0);
      return this.iuor(num);
    };
    BN2.prototype.or = function or(num) {
      if (this.length > num.length)
        return this.clone().ior(num);
      return num.clone().ior(this);
    };
    BN2.prototype.uor = function uor(num) {
      if (this.length > num.length)
        return this.clone().iuor(num);
      return num.clone().iuor(this);
    };
    BN2.prototype.iuand = function iuand(num) {
      var b2;
      if (this.length > num.length) {
        b2 = num;
      } else {
        b2 = this;
      }
      for (var i = 0;i < b2.length; i++) {
        this.words[i] = this.words[i] & num.words[i];
      }
      this.length = b2.length;
      return this.strip();
    };
    BN2.prototype.iand = function iand(num) {
      assert4((this.negative | num.negative) === 0);
      return this.iuand(num);
    };
    BN2.prototype.and = function and(num) {
      if (this.length > num.length)
        return this.clone().iand(num);
      return num.clone().iand(this);
    };
    BN2.prototype.uand = function uand(num) {
      if (this.length > num.length)
        return this.clone().iuand(num);
      return num.clone().iuand(this);
    };
    BN2.prototype.iuxor = function iuxor(num) {
      var a;
      var b2;
      if (this.length > num.length) {
        a = this;
        b2 = num;
      } else {
        a = num;
        b2 = this;
      }
      for (var i = 0;i < b2.length; i++) {
        this.words[i] = a.words[i] ^ b2.words[i];
      }
      if (this !== a) {
        for (;i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
      this.length = a.length;
      return this.strip();
    };
    BN2.prototype.ixor = function ixor(num) {
      assert4((this.negative | num.negative) === 0);
      return this.iuxor(num);
    };
    BN2.prototype.xor = function xor(num) {
      if (this.length > num.length)
        return this.clone().ixor(num);
      return num.clone().ixor(this);
    };
    BN2.prototype.uxor = function uxor(num) {
      if (this.length > num.length)
        return this.clone().iuxor(num);
      return num.clone().iuxor(this);
    };
    BN2.prototype.inotn = function inotn(width) {
      assert4(typeof width === "number" && width >= 0);
      var bytesNeeded = Math.ceil(width / 26) | 0;
      var bitsLeft = width % 26;
      this._expand(bytesNeeded);
      if (bitsLeft > 0) {
        bytesNeeded--;
      }
      for (var i = 0;i < bytesNeeded; i++) {
        this.words[i] = ~this.words[i] & 67108863;
      }
      if (bitsLeft > 0) {
        this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
      }
      return this.strip();
    };
    BN2.prototype.notn = function notn(width) {
      return this.clone().inotn(width);
    };
    BN2.prototype.setn = function setn(bit, val) {
      assert4(typeof bit === "number" && bit >= 0);
      var off = bit / 26 | 0;
      var wbit = bit % 26;
      this._expand(off + 1);
      if (val) {
        this.words[off] = this.words[off] | 1 << wbit;
      } else {
        this.words[off] = this.words[off] & ~(1 << wbit);
      }
      return this.strip();
    };
    BN2.prototype.iadd = function iadd(num) {
      var r;
      if (this.negative !== 0 && num.negative === 0) {
        this.negative = 0;
        r = this.isub(num);
        this.negative ^= 1;
        return this._normSign();
      } else if (this.negative === 0 && num.negative !== 0) {
        num.negative = 0;
        r = this.isub(num);
        num.negative = 1;
        return r._normSign();
      }
      var a, b2;
      if (this.length > num.length) {
        a = this;
        b2 = num;
      } else {
        a = num;
        b2 = this;
      }
      var carry = 0;
      for (var i = 0;i < b2.length; i++) {
        r = (a.words[i] | 0) + (b2.words[i] | 0) + carry;
        this.words[i] = r & 67108863;
        carry = r >>> 26;
      }
      for (;carry !== 0 && i < a.length; i++) {
        r = (a.words[i] | 0) + carry;
        this.words[i] = r & 67108863;
        carry = r >>> 26;
      }
      this.length = a.length;
      if (carry !== 0) {
        this.words[this.length] = carry;
        this.length++;
      } else if (a !== this) {
        for (;i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
      return this;
    };
    BN2.prototype.add = function add(num) {
      var res;
      if (num.negative !== 0 && this.negative === 0) {
        num.negative = 0;
        res = this.sub(num);
        num.negative ^= 1;
        return res;
      } else if (num.negative === 0 && this.negative !== 0) {
        this.negative = 0;
        res = num.sub(this);
        this.negative = 1;
        return res;
      }
      if (this.length > num.length)
        return this.clone().iadd(num);
      return num.clone().iadd(this);
    };
    BN2.prototype.isub = function isub(num) {
      if (num.negative !== 0) {
        num.negative = 0;
        var r = this.iadd(num);
        num.negative = 1;
        return r._normSign();
      } else if (this.negative !== 0) {
        this.negative = 0;
        this.iadd(num);
        this.negative = 1;
        return this._normSign();
      }
      var cmp = this.cmp(num);
      if (cmp === 0) {
        this.negative = 0;
        this.length = 1;
        this.words[0] = 0;
        return this;
      }
      var a, b2;
      if (cmp > 0) {
        a = this;
        b2 = num;
      } else {
        a = num;
        b2 = this;
      }
      var carry = 0;
      for (var i = 0;i < b2.length; i++) {
        r = (a.words[i] | 0) - (b2.words[i] | 0) + carry;
        carry = r >> 26;
        this.words[i] = r & 67108863;
      }
      for (;carry !== 0 && i < a.length; i++) {
        r = (a.words[i] | 0) + carry;
        carry = r >> 26;
        this.words[i] = r & 67108863;
      }
      if (carry === 0 && i < a.length && a !== this) {
        for (;i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
      this.length = Math.max(this.length, i);
      if (a !== this) {
        this.negative = 1;
      }
      return this.strip();
    };
    BN2.prototype.sub = function sub(num) {
      return this.clone().isub(num);
    };
    function smallMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      var len = self2.length + num.length | 0;
      out.length = len;
      len = len - 1 | 0;
      var a = self2.words[0] | 0;
      var b2 = num.words[0] | 0;
      var r = a * b2;
      var lo = r & 67108863;
      var carry = r / 67108864 | 0;
      out.words[0] = lo;
      for (var k = 1;k < len; k++) {
        var ncarry = carry >>> 26;
        var rword = carry & 67108863;
        var maxJ = Math.min(k, num.length - 1);
        for (var j = Math.max(0, k - self2.length + 1);j <= maxJ; j++) {
          var i = k - j | 0;
          a = self2.words[i] | 0;
          b2 = num.words[j] | 0;
          r = a * b2 + rword;
          ncarry += r / 67108864 | 0;
          rword = r & 67108863;
        }
        out.words[k] = rword | 0;
        carry = ncarry | 0;
      }
      if (carry !== 0) {
        out.words[k] = carry | 0;
      } else {
        out.length--;
      }
      return out.strip();
    }
    var comb10MulTo = function comb10MulTo(self2, num, out) {
      var a = self2.words;
      var b2 = num.words;
      var o = out.words;
      var c = 0;
      var lo;
      var mid;
      var hi;
      var a0 = a[0] | 0;
      var al0 = a0 & 8191;
      var ah0 = a0 >>> 13;
      var a1 = a[1] | 0;
      var al1 = a1 & 8191;
      var ah1 = a1 >>> 13;
      var a2 = a[2] | 0;
      var al2 = a2 & 8191;
      var ah2 = a2 >>> 13;
      var a3 = a[3] | 0;
      var al3 = a3 & 8191;
      var ah3 = a3 >>> 13;
      var a4 = a[4] | 0;
      var al4 = a4 & 8191;
      var ah4 = a4 >>> 13;
      var a5 = a[5] | 0;
      var al5 = a5 & 8191;
      var ah5 = a5 >>> 13;
      var a6 = a[6] | 0;
      var al6 = a6 & 8191;
      var ah6 = a6 >>> 13;
      var a7 = a[7] | 0;
      var al7 = a7 & 8191;
      var ah7 = a7 >>> 13;
      var a8 = a[8] | 0;
      var al8 = a8 & 8191;
      var ah8 = a8 >>> 13;
      var a9 = a[9] | 0;
      var al9 = a9 & 8191;
      var ah9 = a9 >>> 13;
      var b0 = b2[0] | 0;
      var bl0 = b0 & 8191;
      var bh0 = b0 >>> 13;
      var b1 = b2[1] | 0;
      var bl1 = b1 & 8191;
      var bh1 = b1 >>> 13;
      var b22 = b2[2] | 0;
      var bl2 = b22 & 8191;
      var bh2 = b22 >>> 13;
      var b3 = b2[3] | 0;
      var bl3 = b3 & 8191;
      var bh3 = b3 >>> 13;
      var b4 = b2[4] | 0;
      var bl4 = b4 & 8191;
      var bh4 = b4 >>> 13;
      var b5 = b2[5] | 0;
      var bl5 = b5 & 8191;
      var bh5 = b5 >>> 13;
      var b6 = b2[6] | 0;
      var bl6 = b6 & 8191;
      var bh6 = b6 >>> 13;
      var b7 = b2[7] | 0;
      var bl7 = b7 & 8191;
      var bh7 = b7 >>> 13;
      var b8 = b2[8] | 0;
      var bl8 = b8 & 8191;
      var bh8 = b8 >>> 13;
      var b9 = b2[9] | 0;
      var bl9 = b9 & 8191;
      var bh9 = b9 >>> 13;
      out.negative = self2.negative ^ num.negative;
      out.length = 19;
      lo = Math.imul(al0, bl0);
      mid = Math.imul(al0, bh0);
      mid = mid + Math.imul(ah0, bl0) | 0;
      hi = Math.imul(ah0, bh0);
      var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
      w0 &= 67108863;
      lo = Math.imul(al1, bl0);
      mid = Math.imul(al1, bh0);
      mid = mid + Math.imul(ah1, bl0) | 0;
      hi = Math.imul(ah1, bh0);
      lo = lo + Math.imul(al0, bl1) | 0;
      mid = mid + Math.imul(al0, bh1) | 0;
      mid = mid + Math.imul(ah0, bl1) | 0;
      hi = hi + Math.imul(ah0, bh1) | 0;
      var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
      w1 &= 67108863;
      lo = Math.imul(al2, bl0);
      mid = Math.imul(al2, bh0);
      mid = mid + Math.imul(ah2, bl0) | 0;
      hi = Math.imul(ah2, bh0);
      lo = lo + Math.imul(al1, bl1) | 0;
      mid = mid + Math.imul(al1, bh1) | 0;
      mid = mid + Math.imul(ah1, bl1) | 0;
      hi = hi + Math.imul(ah1, bh1) | 0;
      lo = lo + Math.imul(al0, bl2) | 0;
      mid = mid + Math.imul(al0, bh2) | 0;
      mid = mid + Math.imul(ah0, bl2) | 0;
      hi = hi + Math.imul(ah0, bh2) | 0;
      var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
      w2 &= 67108863;
      lo = Math.imul(al3, bl0);
      mid = Math.imul(al3, bh0);
      mid = mid + Math.imul(ah3, bl0) | 0;
      hi = Math.imul(ah3, bh0);
      lo = lo + Math.imul(al2, bl1) | 0;
      mid = mid + Math.imul(al2, bh1) | 0;
      mid = mid + Math.imul(ah2, bl1) | 0;
      hi = hi + Math.imul(ah2, bh1) | 0;
      lo = lo + Math.imul(al1, bl2) | 0;
      mid = mid + Math.imul(al1, bh2) | 0;
      mid = mid + Math.imul(ah1, bl2) | 0;
      hi = hi + Math.imul(ah1, bh2) | 0;
      lo = lo + Math.imul(al0, bl3) | 0;
      mid = mid + Math.imul(al0, bh3) | 0;
      mid = mid + Math.imul(ah0, bl3) | 0;
      hi = hi + Math.imul(ah0, bh3) | 0;
      var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
      w3 &= 67108863;
      lo = Math.imul(al4, bl0);
      mid = Math.imul(al4, bh0);
      mid = mid + Math.imul(ah4, bl0) | 0;
      hi = Math.imul(ah4, bh0);
      lo = lo + Math.imul(al3, bl1) | 0;
      mid = mid + Math.imul(al3, bh1) | 0;
      mid = mid + Math.imul(ah3, bl1) | 0;
      hi = hi + Math.imul(ah3, bh1) | 0;
      lo = lo + Math.imul(al2, bl2) | 0;
      mid = mid + Math.imul(al2, bh2) | 0;
      mid = mid + Math.imul(ah2, bl2) | 0;
      hi = hi + Math.imul(ah2, bh2) | 0;
      lo = lo + Math.imul(al1, bl3) | 0;
      mid = mid + Math.imul(al1, bh3) | 0;
      mid = mid + Math.imul(ah1, bl3) | 0;
      hi = hi + Math.imul(ah1, bh3) | 0;
      lo = lo + Math.imul(al0, bl4) | 0;
      mid = mid + Math.imul(al0, bh4) | 0;
      mid = mid + Math.imul(ah0, bl4) | 0;
      hi = hi + Math.imul(ah0, bh4) | 0;
      var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
      w4 &= 67108863;
      lo = Math.imul(al5, bl0);
      mid = Math.imul(al5, bh0);
      mid = mid + Math.imul(ah5, bl0) | 0;
      hi = Math.imul(ah5, bh0);
      lo = lo + Math.imul(al4, bl1) | 0;
      mid = mid + Math.imul(al4, bh1) | 0;
      mid = mid + Math.imul(ah4, bl1) | 0;
      hi = hi + Math.imul(ah4, bh1) | 0;
      lo = lo + Math.imul(al3, bl2) | 0;
      mid = mid + Math.imul(al3, bh2) | 0;
      mid = mid + Math.imul(ah3, bl2) | 0;
      hi = hi + Math.imul(ah3, bh2) | 0;
      lo = lo + Math.imul(al2, bl3) | 0;
      mid = mid + Math.imul(al2, bh3) | 0;
      mid = mid + Math.imul(ah2, bl3) | 0;
      hi = hi + Math.imul(ah2, bh3) | 0;
      lo = lo + Math.imul(al1, bl4) | 0;
      mid = mid + Math.imul(al1, bh4) | 0;
      mid = mid + Math.imul(ah1, bl4) | 0;
      hi = hi + Math.imul(ah1, bh4) | 0;
      lo = lo + Math.imul(al0, bl5) | 0;
      mid = mid + Math.imul(al0, bh5) | 0;
      mid = mid + Math.imul(ah0, bl5) | 0;
      hi = hi + Math.imul(ah0, bh5) | 0;
      var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
      w5 &= 67108863;
      lo = Math.imul(al6, bl0);
      mid = Math.imul(al6, bh0);
      mid = mid + Math.imul(ah6, bl0) | 0;
      hi = Math.imul(ah6, bh0);
      lo = lo + Math.imul(al5, bl1) | 0;
      mid = mid + Math.imul(al5, bh1) | 0;
      mid = mid + Math.imul(ah5, bl1) | 0;
      hi = hi + Math.imul(ah5, bh1) | 0;
      lo = lo + Math.imul(al4, bl2) | 0;
      mid = mid + Math.imul(al4, bh2) | 0;
      mid = mid + Math.imul(ah4, bl2) | 0;
      hi = hi + Math.imul(ah4, bh2) | 0;
      lo = lo + Math.imul(al3, bl3) | 0;
      mid = mid + Math.imul(al3, bh3) | 0;
      mid = mid + Math.imul(ah3, bl3) | 0;
      hi = hi + Math.imul(ah3, bh3) | 0;
      lo = lo + Math.imul(al2, bl4) | 0;
      mid = mid + Math.imul(al2, bh4) | 0;
      mid = mid + Math.imul(ah2, bl4) | 0;
      hi = hi + Math.imul(ah2, bh4) | 0;
      lo = lo + Math.imul(al1, bl5) | 0;
      mid = mid + Math.imul(al1, bh5) | 0;
      mid = mid + Math.imul(ah1, bl5) | 0;
      hi = hi + Math.imul(ah1, bh5) | 0;
      lo = lo + Math.imul(al0, bl6) | 0;
      mid = mid + Math.imul(al0, bh6) | 0;
      mid = mid + Math.imul(ah0, bl6) | 0;
      hi = hi + Math.imul(ah0, bh6) | 0;
      var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
      w6 &= 67108863;
      lo = Math.imul(al7, bl0);
      mid = Math.imul(al7, bh0);
      mid = mid + Math.imul(ah7, bl0) | 0;
      hi = Math.imul(ah7, bh0);
      lo = lo + Math.imul(al6, bl1) | 0;
      mid = mid + Math.imul(al6, bh1) | 0;
      mid = mid + Math.imul(ah6, bl1) | 0;
      hi = hi + Math.imul(ah6, bh1) | 0;
      lo = lo + Math.imul(al5, bl2) | 0;
      mid = mid + Math.imul(al5, bh2) | 0;
      mid = mid + Math.imul(ah5, bl2) | 0;
      hi = hi + Math.imul(ah5, bh2) | 0;
      lo = lo + Math.imul(al4, bl3) | 0;
      mid = mid + Math.imul(al4, bh3) | 0;
      mid = mid + Math.imul(ah4, bl3) | 0;
      hi = hi + Math.imul(ah4, bh3) | 0;
      lo = lo + Math.imul(al3, bl4) | 0;
      mid = mid + Math.imul(al3, bh4) | 0;
      mid = mid + Math.imul(ah3, bl4) | 0;
      hi = hi + Math.imul(ah3, bh4) | 0;
      lo = lo + Math.imul(al2, bl5) | 0;
      mid = mid + Math.imul(al2, bh5) | 0;
      mid = mid + Math.imul(ah2, bl5) | 0;
      hi = hi + Math.imul(ah2, bh5) | 0;
      lo = lo + Math.imul(al1, bl6) | 0;
      mid = mid + Math.imul(al1, bh6) | 0;
      mid = mid + Math.imul(ah1, bl6) | 0;
      hi = hi + Math.imul(ah1, bh6) | 0;
      lo = lo + Math.imul(al0, bl7) | 0;
      mid = mid + Math.imul(al0, bh7) | 0;
      mid = mid + Math.imul(ah0, bl7) | 0;
      hi = hi + Math.imul(ah0, bh7) | 0;
      var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
      w7 &= 67108863;
      lo = Math.imul(al8, bl0);
      mid = Math.imul(al8, bh0);
      mid = mid + Math.imul(ah8, bl0) | 0;
      hi = Math.imul(ah8, bh0);
      lo = lo + Math.imul(al7, bl1) | 0;
      mid = mid + Math.imul(al7, bh1) | 0;
      mid = mid + Math.imul(ah7, bl1) | 0;
      hi = hi + Math.imul(ah7, bh1) | 0;
      lo = lo + Math.imul(al6, bl2) | 0;
      mid = mid + Math.imul(al6, bh2) | 0;
      mid = mid + Math.imul(ah6, bl2) | 0;
      hi = hi + Math.imul(ah6, bh2) | 0;
      lo = lo + Math.imul(al5, bl3) | 0;
      mid = mid + Math.imul(al5, bh3) | 0;
      mid = mid + Math.imul(ah5, bl3) | 0;
      hi = hi + Math.imul(ah5, bh3) | 0;
      lo = lo + Math.imul(al4, bl4) | 0;
      mid = mid + Math.imul(al4, bh4) | 0;
      mid = mid + Math.imul(ah4, bl4) | 0;
      hi = hi + Math.imul(ah4, bh4) | 0;
      lo = lo + Math.imul(al3, bl5) | 0;
      mid = mid + Math.imul(al3, bh5) | 0;
      mid = mid + Math.imul(ah3, bl5) | 0;
      hi = hi + Math.imul(ah3, bh5) | 0;
      lo = lo + Math.imul(al2, bl6) | 0;
      mid = mid + Math.imul(al2, bh6) | 0;
      mid = mid + Math.imul(ah2, bl6) | 0;
      hi = hi + Math.imul(ah2, bh6) | 0;
      lo = lo + Math.imul(al1, bl7) | 0;
      mid = mid + Math.imul(al1, bh7) | 0;
      mid = mid + Math.imul(ah1, bl7) | 0;
      hi = hi + Math.imul(ah1, bh7) | 0;
      lo = lo + Math.imul(al0, bl8) | 0;
      mid = mid + Math.imul(al0, bh8) | 0;
      mid = mid + Math.imul(ah0, bl8) | 0;
      hi = hi + Math.imul(ah0, bh8) | 0;
      var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
      w8 &= 67108863;
      lo = Math.imul(al9, bl0);
      mid = Math.imul(al9, bh0);
      mid = mid + Math.imul(ah9, bl0) | 0;
      hi = Math.imul(ah9, bh0);
      lo = lo + Math.imul(al8, bl1) | 0;
      mid = mid + Math.imul(al8, bh1) | 0;
      mid = mid + Math.imul(ah8, bl1) | 0;
      hi = hi + Math.imul(ah8, bh1) | 0;
      lo = lo + Math.imul(al7, bl2) | 0;
      mid = mid + Math.imul(al7, bh2) | 0;
      mid = mid + Math.imul(ah7, bl2) | 0;
      hi = hi + Math.imul(ah7, bh2) | 0;
      lo = lo + Math.imul(al6, bl3) | 0;
      mid = mid + Math.imul(al6, bh3) | 0;
      mid = mid + Math.imul(ah6, bl3) | 0;
      hi = hi + Math.imul(ah6, bh3) | 0;
      lo = lo + Math.imul(al5, bl4) | 0;
      mid = mid + Math.imul(al5, bh4) | 0;
      mid = mid + Math.imul(ah5, bl4) | 0;
      hi = hi + Math.imul(ah5, bh4) | 0;
      lo = lo + Math.imul(al4, bl5) | 0;
      mid = mid + Math.imul(al4, bh5) | 0;
      mid = mid + Math.imul(ah4, bl5) | 0;
      hi = hi + Math.imul(ah4, bh5) | 0;
      lo = lo + Math.imul(al3, bl6) | 0;
      mid = mid + Math.imul(al3, bh6) | 0;
      mid = mid + Math.imul(ah3, bl6) | 0;
      hi = hi + Math.imul(ah3, bh6) | 0;
      lo = lo + Math.imul(al2, bl7) | 0;
      mid = mid + Math.imul(al2, bh7) | 0;
      mid = mid + Math.imul(ah2, bl7) | 0;
      hi = hi + Math.imul(ah2, bh7) | 0;
      lo = lo + Math.imul(al1, bl8) | 0;
      mid = mid + Math.imul(al1, bh8) | 0;
      mid = mid + Math.imul(ah1, bl8) | 0;
      hi = hi + Math.imul(ah1, bh8) | 0;
      lo = lo + Math.imul(al0, bl9) | 0;
      mid = mid + Math.imul(al0, bh9) | 0;
      mid = mid + Math.imul(ah0, bl9) | 0;
      hi = hi + Math.imul(ah0, bh9) | 0;
      var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
      w9 &= 67108863;
      lo = Math.imul(al9, bl1);
      mid = Math.imul(al9, bh1);
      mid = mid + Math.imul(ah9, bl1) | 0;
      hi = Math.imul(ah9, bh1);
      lo = lo + Math.imul(al8, bl2) | 0;
      mid = mid + Math.imul(al8, bh2) | 0;
      mid = mid + Math.imul(ah8, bl2) | 0;
      hi = hi + Math.imul(ah8, bh2) | 0;
      lo = lo + Math.imul(al7, bl3) | 0;
      mid = mid + Math.imul(al7, bh3) | 0;
      mid = mid + Math.imul(ah7, bl3) | 0;
      hi = hi + Math.imul(ah7, bh3) | 0;
      lo = lo + Math.imul(al6, bl4) | 0;
      mid = mid + Math.imul(al6, bh4) | 0;
      mid = mid + Math.imul(ah6, bl4) | 0;
      hi = hi + Math.imul(ah6, bh4) | 0;
      lo = lo + Math.imul(al5, bl5) | 0;
      mid = mid + Math.imul(al5, bh5) | 0;
      mid = mid + Math.imul(ah5, bl5) | 0;
      hi = hi + Math.imul(ah5, bh5) | 0;
      lo = lo + Math.imul(al4, bl6) | 0;
      mid = mid + Math.imul(al4, bh6) | 0;
      mid = mid + Math.imul(ah4, bl6) | 0;
      hi = hi + Math.imul(ah4, bh6) | 0;
      lo = lo + Math.imul(al3, bl7) | 0;
      mid = mid + Math.imul(al3, bh7) | 0;
      mid = mid + Math.imul(ah3, bl7) | 0;
      hi = hi + Math.imul(ah3, bh7) | 0;
      lo = lo + Math.imul(al2, bl8) | 0;
      mid = mid + Math.imul(al2, bh8) | 0;
      mid = mid + Math.imul(ah2, bl8) | 0;
      hi = hi + Math.imul(ah2, bh8) | 0;
      lo = lo + Math.imul(al1, bl9) | 0;
      mid = mid + Math.imul(al1, bh9) | 0;
      mid = mid + Math.imul(ah1, bl9) | 0;
      hi = hi + Math.imul(ah1, bh9) | 0;
      var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
      w10 &= 67108863;
      lo = Math.imul(al9, bl2);
      mid = Math.imul(al9, bh2);
      mid = mid + Math.imul(ah9, bl2) | 0;
      hi = Math.imul(ah9, bh2);
      lo = lo + Math.imul(al8, bl3) | 0;
      mid = mid + Math.imul(al8, bh3) | 0;
      mid = mid + Math.imul(ah8, bl3) | 0;
      hi = hi + Math.imul(ah8, bh3) | 0;
      lo = lo + Math.imul(al7, bl4) | 0;
      mid = mid + Math.imul(al7, bh4) | 0;
      mid = mid + Math.imul(ah7, bl4) | 0;
      hi = hi + Math.imul(ah7, bh4) | 0;
      lo = lo + Math.imul(al6, bl5) | 0;
      mid = mid + Math.imul(al6, bh5) | 0;
      mid = mid + Math.imul(ah6, bl5) | 0;
      hi = hi + Math.imul(ah6, bh5) | 0;
      lo = lo + Math.imul(al5, bl6) | 0;
      mid = mid + Math.imul(al5, bh6) | 0;
      mid = mid + Math.imul(ah5, bl6) | 0;
      hi = hi + Math.imul(ah5, bh6) | 0;
      lo = lo + Math.imul(al4, bl7) | 0;
      mid = mid + Math.imul(al4, bh7) | 0;
      mid = mid + Math.imul(ah4, bl7) | 0;
      hi = hi + Math.imul(ah4, bh7) | 0;
      lo = lo + Math.imul(al3, bl8) | 0;
      mid = mid + Math.imul(al3, bh8) | 0;
      mid = mid + Math.imul(ah3, bl8) | 0;
      hi = hi + Math.imul(ah3, bh8) | 0;
      lo = lo + Math.imul(al2, bl9) | 0;
      mid = mid + Math.imul(al2, bh9) | 0;
      mid = mid + Math.imul(ah2, bl9) | 0;
      hi = hi + Math.imul(ah2, bh9) | 0;
      var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
      w11 &= 67108863;
      lo = Math.imul(al9, bl3);
      mid = Math.imul(al9, bh3);
      mid = mid + Math.imul(ah9, bl3) | 0;
      hi = Math.imul(ah9, bh3);
      lo = lo + Math.imul(al8, bl4) | 0;
      mid = mid + Math.imul(al8, bh4) | 0;
      mid = mid + Math.imul(ah8, bl4) | 0;
      hi = hi + Math.imul(ah8, bh4) | 0;
      lo = lo + Math.imul(al7, bl5) | 0;
      mid = mid + Math.imul(al7, bh5) | 0;
      mid = mid + Math.imul(ah7, bl5) | 0;
      hi = hi + Math.imul(ah7, bh5) | 0;
      lo = lo + Math.imul(al6, bl6) | 0;
      mid = mid + Math.imul(al6, bh6) | 0;
      mid = mid + Math.imul(ah6, bl6) | 0;
      hi = hi + Math.imul(ah6, bh6) | 0;
      lo = lo + Math.imul(al5, bl7) | 0;
      mid = mid + Math.imul(al5, bh7) | 0;
      mid = mid + Math.imul(ah5, bl7) | 0;
      hi = hi + Math.imul(ah5, bh7) | 0;
      lo = lo + Math.imul(al4, bl8) | 0;
      mid = mid + Math.imul(al4, bh8) | 0;
      mid = mid + Math.imul(ah4, bl8) | 0;
      hi = hi + Math.imul(ah4, bh8) | 0;
      lo = lo + Math.imul(al3, bl9) | 0;
      mid = mid + Math.imul(al3, bh9) | 0;
      mid = mid + Math.imul(ah3, bl9) | 0;
      hi = hi + Math.imul(ah3, bh9) | 0;
      var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
      w12 &= 67108863;
      lo = Math.imul(al9, bl4);
      mid = Math.imul(al9, bh4);
      mid = mid + Math.imul(ah9, bl4) | 0;
      hi = Math.imul(ah9, bh4);
      lo = lo + Math.imul(al8, bl5) | 0;
      mid = mid + Math.imul(al8, bh5) | 0;
      mid = mid + Math.imul(ah8, bl5) | 0;
      hi = hi + Math.imul(ah8, bh5) | 0;
      lo = lo + Math.imul(al7, bl6) | 0;
      mid = mid + Math.imul(al7, bh6) | 0;
      mid = mid + Math.imul(ah7, bl6) | 0;
      hi = hi + Math.imul(ah7, bh6) | 0;
      lo = lo + Math.imul(al6, bl7) | 0;
      mid = mid + Math.imul(al6, bh7) | 0;
      mid = mid + Math.imul(ah6, bl7) | 0;
      hi = hi + Math.imul(ah6, bh7) | 0;
      lo = lo + Math.imul(al5, bl8) | 0;
      mid = mid + Math.imul(al5, bh8) | 0;
      mid = mid + Math.imul(ah5, bl8) | 0;
      hi = hi + Math.imul(ah5, bh8) | 0;
      lo = lo + Math.imul(al4, bl9) | 0;
      mid = mid + Math.imul(al4, bh9) | 0;
      mid = mid + Math.imul(ah4, bl9) | 0;
      hi = hi + Math.imul(ah4, bh9) | 0;
      var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
      w13 &= 67108863;
      lo = Math.imul(al9, bl5);
      mid = Math.imul(al9, bh5);
      mid = mid + Math.imul(ah9, bl5) | 0;
      hi = Math.imul(ah9, bh5);
      lo = lo + Math.imul(al8, bl6) | 0;
      mid = mid + Math.imul(al8, bh6) | 0;
      mid = mid + Math.imul(ah8, bl6) | 0;
      hi = hi + Math.imul(ah8, bh6) | 0;
      lo = lo + Math.imul(al7, bl7) | 0;
      mid = mid + Math.imul(al7, bh7) | 0;
      mid = mid + Math.imul(ah7, bl7) | 0;
      hi = hi + Math.imul(ah7, bh7) | 0;
      lo = lo + Math.imul(al6, bl8) | 0;
      mid = mid + Math.imul(al6, bh8) | 0;
      mid = mid + Math.imul(ah6, bl8) | 0;
      hi = hi + Math.imul(ah6, bh8) | 0;
      lo = lo + Math.imul(al5, bl9) | 0;
      mid = mid + Math.imul(al5, bh9) | 0;
      mid = mid + Math.imul(ah5, bl9) | 0;
      hi = hi + Math.imul(ah5, bh9) | 0;
      var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
      w14 &= 67108863;
      lo = Math.imul(al9, bl6);
      mid = Math.imul(al9, bh6);
      mid = mid + Math.imul(ah9, bl6) | 0;
      hi = Math.imul(ah9, bh6);
      lo = lo + Math.imul(al8, bl7) | 0;
      mid = mid + Math.imul(al8, bh7) | 0;
      mid = mid + Math.imul(ah8, bl7) | 0;
      hi = hi + Math.imul(ah8, bh7) | 0;
      lo = lo + Math.imul(al7, bl8) | 0;
      mid = mid + Math.imul(al7, bh8) | 0;
      mid = mid + Math.imul(ah7, bl8) | 0;
      hi = hi + Math.imul(ah7, bh8) | 0;
      lo = lo + Math.imul(al6, bl9) | 0;
      mid = mid + Math.imul(al6, bh9) | 0;
      mid = mid + Math.imul(ah6, bl9) | 0;
      hi = hi + Math.imul(ah6, bh9) | 0;
      var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
      w15 &= 67108863;
      lo = Math.imul(al9, bl7);
      mid = Math.imul(al9, bh7);
      mid = mid + Math.imul(ah9, bl7) | 0;
      hi = Math.imul(ah9, bh7);
      lo = lo + Math.imul(al8, bl8) | 0;
      mid = mid + Math.imul(al8, bh8) | 0;
      mid = mid + Math.imul(ah8, bl8) | 0;
      hi = hi + Math.imul(ah8, bh8) | 0;
      lo = lo + Math.imul(al7, bl9) | 0;
      mid = mid + Math.imul(al7, bh9) | 0;
      mid = mid + Math.imul(ah7, bl9) | 0;
      hi = hi + Math.imul(ah7, bh9) | 0;
      var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
      w16 &= 67108863;
      lo = Math.imul(al9, bl8);
      mid = Math.imul(al9, bh8);
      mid = mid + Math.imul(ah9, bl8) | 0;
      hi = Math.imul(ah9, bh8);
      lo = lo + Math.imul(al8, bl9) | 0;
      mid = mid + Math.imul(al8, bh9) | 0;
      mid = mid + Math.imul(ah8, bl9) | 0;
      hi = hi + Math.imul(ah8, bh9) | 0;
      var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
      w17 &= 67108863;
      lo = Math.imul(al9, bl9);
      mid = Math.imul(al9, bh9);
      mid = mid + Math.imul(ah9, bl9) | 0;
      hi = Math.imul(ah9, bh9);
      var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
      w18 &= 67108863;
      o[0] = w0;
      o[1] = w1;
      o[2] = w2;
      o[3] = w3;
      o[4] = w4;
      o[5] = w5;
      o[6] = w6;
      o[7] = w7;
      o[8] = w8;
      o[9] = w9;
      o[10] = w10;
      o[11] = w11;
      o[12] = w12;
      o[13] = w13;
      o[14] = w14;
      o[15] = w15;
      o[16] = w16;
      o[17] = w17;
      o[18] = w18;
      if (c !== 0) {
        o[19] = c;
        out.length++;
      }
      return out;
    };
    if (!Math.imul) {
      comb10MulTo = smallMulTo;
    }
    function bigMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      out.length = self2.length + num.length;
      var carry = 0;
      var hncarry = 0;
      for (var k = 0;k < out.length - 1; k++) {
        var ncarry = hncarry;
        hncarry = 0;
        var rword = carry & 67108863;
        var maxJ = Math.min(k, num.length - 1);
        for (var j = Math.max(0, k - self2.length + 1);j <= maxJ; j++) {
          var i = k - j;
          var a = self2.words[i] | 0;
          var b2 = num.words[j] | 0;
          var r = a * b2;
          var lo = r & 67108863;
          ncarry = ncarry + (r / 67108864 | 0) | 0;
          lo = lo + rword | 0;
          rword = lo & 67108863;
          ncarry = ncarry + (lo >>> 26) | 0;
          hncarry += ncarry >>> 26;
          ncarry &= 67108863;
        }
        out.words[k] = rword;
        carry = ncarry;
        ncarry = hncarry;
      }
      if (carry !== 0) {
        out.words[k] = carry;
      } else {
        out.length--;
      }
      return out.strip();
    }
    function jumboMulTo(self2, num, out) {
      var fftm = new FFTM;
      return fftm.mulp(self2, num, out);
    }
    BN2.prototype.mulTo = function mulTo(num, out) {
      var res;
      var len = this.length + num.length;
      if (this.length === 10 && num.length === 10) {
        res = comb10MulTo(this, num, out);
      } else if (len < 63) {
        res = smallMulTo(this, num, out);
      } else if (len < 1024) {
        res = bigMulTo(this, num, out);
      } else {
        res = jumboMulTo(this, num, out);
      }
      return res;
    };
    function FFTM(x, y) {
      this.x = x;
      this.y = y;
    }
    FFTM.prototype.makeRBT = function makeRBT(N) {
      var t = new Array(N);
      var l = BN2.prototype._countBits(N) - 1;
      for (var i = 0;i < N; i++) {
        t[i] = this.revBin(i, l, N);
      }
      return t;
    };
    FFTM.prototype.revBin = function revBin(x, l, N) {
      if (x === 0 || x === N - 1)
        return x;
      var rb = 0;
      for (var i = 0;i < l; i++) {
        rb |= (x & 1) << l - i - 1;
        x >>= 1;
      }
      return rb;
    };
    FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
      for (var i = 0;i < N; i++) {
        rtws[i] = rws[rbt[i]];
        itws[i] = iws[rbt[i]];
      }
    };
    FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
      this.permute(rbt, rws, iws, rtws, itws, N);
      for (var s = 1;s < N; s <<= 1) {
        var l = s << 1;
        var rtwdf = Math.cos(2 * Math.PI / l);
        var itwdf = Math.sin(2 * Math.PI / l);
        for (var p = 0;p < N; p += l) {
          var rtwdf_ = rtwdf;
          var itwdf_ = itwdf;
          for (var j = 0;j < s; j++) {
            var re = rtws[p + j];
            var ie = itws[p + j];
            var ro = rtws[p + j + s];
            var io = itws[p + j + s];
            var rx = rtwdf_ * ro - itwdf_ * io;
            io = rtwdf_ * io + itwdf_ * ro;
            ro = rx;
            rtws[p + j] = re + ro;
            itws[p + j] = ie + io;
            rtws[p + j + s] = re - ro;
            itws[p + j + s] = ie - io;
            if (j !== l) {
              rx = rtwdf * rtwdf_ - itwdf * itwdf_;
              itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
              rtwdf_ = rx;
            }
          }
        }
      }
    };
    FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
      var N = Math.max(m, n) | 1;
      var odd = N & 1;
      var i = 0;
      for (N = N / 2 | 0;N; N = N >>> 1) {
        i++;
      }
      return 1 << i + 1 + odd;
    };
    FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
      if (N <= 1)
        return;
      for (var i = 0;i < N / 2; i++) {
        var t = rws[i];
        rws[i] = rws[N - i - 1];
        rws[N - i - 1] = t;
        t = iws[i];
        iws[i] = -iws[N - i - 1];
        iws[N - i - 1] = -t;
      }
    };
    FFTM.prototype.normalize13b = function normalize13b(ws, N) {
      var carry = 0;
      for (var i = 0;i < N / 2; i++) {
        var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
        ws[i] = w & 67108863;
        if (w < 67108864) {
          carry = 0;
        } else {
          carry = w / 67108864 | 0;
        }
      }
      return ws;
    };
    FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
      var carry = 0;
      for (var i = 0;i < len; i++) {
        carry = carry + (ws[i] | 0);
        rws[2 * i] = carry & 8191;
        carry = carry >>> 13;
        rws[2 * i + 1] = carry & 8191;
        carry = carry >>> 13;
      }
      for (i = 2 * len;i < N; ++i) {
        rws[i] = 0;
      }
      assert4(carry === 0);
      assert4((carry & ~8191) === 0);
    };
    FFTM.prototype.stub = function stub(N) {
      var ph = new Array(N);
      for (var i = 0;i < N; i++) {
        ph[i] = 0;
      }
      return ph;
    };
    FFTM.prototype.mulp = function mulp(x, y, out) {
      var N = 2 * this.guessLen13b(x.length, y.length);
      var rbt = this.makeRBT(N);
      var _2 = this.stub(N);
      var rws = new Array(N);
      var rwst = new Array(N);
      var iwst = new Array(N);
      var nrws = new Array(N);
      var nrwst = new Array(N);
      var niwst = new Array(N);
      var rmws = out.words;
      rmws.length = N;
      this.convert13b(x.words, x.length, rws, N);
      this.convert13b(y.words, y.length, nrws, N);
      this.transform(rws, _2, rwst, iwst, N, rbt);
      this.transform(nrws, _2, nrwst, niwst, N, rbt);
      for (var i = 0;i < N; i++) {
        var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
        iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
        rwst[i] = rx;
      }
      this.conjugate(rwst, iwst, N);
      this.transform(rwst, iwst, rmws, _2, N, rbt);
      this.conjugate(rmws, _2, N);
      this.normalize13b(rmws, N);
      out.negative = x.negative ^ y.negative;
      out.length = x.length + y.length;
      return out.strip();
    };
    BN2.prototype.mul = function mul(num) {
      var out = new BN2(null);
      out.words = new Array(this.length + num.length);
      return this.mulTo(num, out);
    };
    BN2.prototype.mulf = function mulf(num) {
      var out = new BN2(null);
      out.words = new Array(this.length + num.length);
      return jumboMulTo(this, num, out);
    };
    BN2.prototype.imul = function imul(num) {
      return this.clone().mulTo(num, this);
    };
    BN2.prototype.imuln = function imuln(num) {
      assert4(typeof num === "number");
      assert4(num < 67108864);
      var carry = 0;
      for (var i = 0;i < this.length; i++) {
        var w = (this.words[i] | 0) * num;
        var lo = (w & 67108863) + (carry & 67108863);
        carry >>= 26;
        carry += w / 67108864 | 0;
        carry += lo >>> 26;
        this.words[i] = lo & 67108863;
      }
      if (carry !== 0) {
        this.words[i] = carry;
        this.length++;
      }
      return this;
    };
    BN2.prototype.muln = function muln(num) {
      return this.clone().imuln(num);
    };
    BN2.prototype.sqr = function sqr() {
      return this.mul(this);
    };
    BN2.prototype.isqr = function isqr() {
      return this.imul(this.clone());
    };
    BN2.prototype.pow = function pow(num) {
      var w = toBitArray(num);
      if (w.length === 0)
        return new BN2(1);
      var res = this;
      for (var i = 0;i < w.length; i++, res = res.sqr()) {
        if (w[i] !== 0)
          break;
      }
      if (++i < w.length) {
        for (var q = res.sqr();i < w.length; i++, q = q.sqr()) {
          if (w[i] === 0)
            continue;
          res = res.mul(q);
        }
      }
      return res;
    };
    BN2.prototype.iushln = function iushln(bits) {
      assert4(typeof bits === "number" && bits >= 0);
      var r = bits % 26;
      var s = (bits - r) / 26;
      var carryMask = 67108863 >>> 26 - r << 26 - r;
      var i;
      if (r !== 0) {
        var carry = 0;
        for (i = 0;i < this.length; i++) {
          var newCarry = this.words[i] & carryMask;
          var c = (this.words[i] | 0) - newCarry << r;
          this.words[i] = c | carry;
          carry = newCarry >>> 26 - r;
        }
        if (carry) {
          this.words[i] = carry;
          this.length++;
        }
      }
      if (s !== 0) {
        for (i = this.length - 1;i >= 0; i--) {
          this.words[i + s] = this.words[i];
        }
        for (i = 0;i < s; i++) {
          this.words[i] = 0;
        }
        this.length += s;
      }
      return this.strip();
    };
    BN2.prototype.ishln = function ishln(bits) {
      assert4(this.negative === 0);
      return this.iushln(bits);
    };
    BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
      assert4(typeof bits === "number" && bits >= 0);
      var h;
      if (hint) {
        h = (hint - hint % 26) / 26;
      } else {
        h = 0;
      }
      var r = bits % 26;
      var s = Math.min((bits - r) / 26, this.length);
      var mask2 = 67108863 ^ 67108863 >>> r << r;
      var maskedWords = extended;
      h -= s;
      h = Math.max(0, h);
      if (maskedWords) {
        for (var i = 0;i < s; i++) {
          maskedWords.words[i] = this.words[i];
        }
        maskedWords.length = s;
      }
      if (s === 0) {
      } else if (this.length > s) {
        this.length -= s;
        for (i = 0;i < this.length; i++) {
          this.words[i] = this.words[i + s];
        }
      } else {
        this.words[0] = 0;
        this.length = 1;
      }
      var carry = 0;
      for (i = this.length - 1;i >= 0 && (carry !== 0 || i >= h); i--) {
        var word = this.words[i] | 0;
        this.words[i] = carry << 26 - r | word >>> r;
        carry = word & mask2;
      }
      if (maskedWords && carry !== 0) {
        maskedWords.words[maskedWords.length++] = carry;
      }
      if (this.length === 0) {
        this.words[0] = 0;
        this.length = 1;
      }
      return this.strip();
    };
    BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
      assert4(this.negative === 0);
      return this.iushrn(bits, hint, extended);
    };
    BN2.prototype.shln = function shln(bits) {
      return this.clone().ishln(bits);
    };
    BN2.prototype.ushln = function ushln(bits) {
      return this.clone().iushln(bits);
    };
    BN2.prototype.shrn = function shrn(bits) {
      return this.clone().ishrn(bits);
    };
    BN2.prototype.ushrn = function ushrn(bits) {
      return this.clone().iushrn(bits);
    };
    BN2.prototype.testn = function testn(bit) {
      assert4(typeof bit === "number" && bit >= 0);
      var r = bit % 26;
      var s = (bit - r) / 26;
      var q = 1 << r;
      if (this.length <= s)
        return false;
      var w = this.words[s];
      return !!(w & q);
    };
    BN2.prototype.imaskn = function imaskn(bits) {
      assert4(typeof bits === "number" && bits >= 0);
      var r = bits % 26;
      var s = (bits - r) / 26;
      assert4(this.negative === 0, "imaskn works only with positive numbers");
      if (this.length <= s) {
        return this;
      }
      if (r !== 0) {
        s++;
      }
      this.length = Math.min(s, this.length);
      if (r !== 0) {
        var mask2 = 67108863 ^ 67108863 >>> r << r;
        this.words[this.length - 1] &= mask2;
      }
      return this.strip();
    };
    BN2.prototype.maskn = function maskn(bits) {
      return this.clone().imaskn(bits);
    };
    BN2.prototype.iaddn = function iaddn(num) {
      assert4(typeof num === "number");
      assert4(num < 67108864);
      if (num < 0)
        return this.isubn(-num);
      if (this.negative !== 0) {
        if (this.length === 1 && (this.words[0] | 0) < num) {
          this.words[0] = num - (this.words[0] | 0);
          this.negative = 0;
          return this;
        }
        this.negative = 0;
        this.isubn(num);
        this.negative = 1;
        return this;
      }
      return this._iaddn(num);
    };
    BN2.prototype._iaddn = function _iaddn(num) {
      this.words[0] += num;
      for (var i = 0;i < this.length && this.words[i] >= 67108864; i++) {
        this.words[i] -= 67108864;
        if (i === this.length - 1) {
          this.words[i + 1] = 1;
        } else {
          this.words[i + 1]++;
        }
      }
      this.length = Math.max(this.length, i + 1);
      return this;
    };
    BN2.prototype.isubn = function isubn(num) {
      assert4(typeof num === "number");
      assert4(num < 67108864);
      if (num < 0)
        return this.iaddn(-num);
      if (this.negative !== 0) {
        this.negative = 0;
        this.iaddn(num);
        this.negative = 1;
        return this;
      }
      this.words[0] -= num;
      if (this.length === 1 && this.words[0] < 0) {
        this.words[0] = -this.words[0];
        this.negative = 1;
      } else {
        for (var i = 0;i < this.length && this.words[i] < 0; i++) {
          this.words[i] += 67108864;
          this.words[i + 1] -= 1;
        }
      }
      return this.strip();
    };
    BN2.prototype.addn = function addn(num) {
      return this.clone().iaddn(num);
    };
    BN2.prototype.subn = function subn(num) {
      return this.clone().isubn(num);
    };
    BN2.prototype.iabs = function iabs() {
      this.negative = 0;
      return this;
    };
    BN2.prototype.abs = function abs() {
      return this.clone().iabs();
    };
    BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
      var len = num.length + shift;
      var i;
      this._expand(len);
      var w;
      var carry = 0;
      for (i = 0;i < num.length; i++) {
        w = (this.words[i + shift] | 0) + carry;
        var right = (num.words[i] | 0) * mul;
        w -= right & 67108863;
        carry = (w >> 26) - (right / 67108864 | 0);
        this.words[i + shift] = w & 67108863;
      }
      for (;i < this.length - shift; i++) {
        w = (this.words[i + shift] | 0) + carry;
        carry = w >> 26;
        this.words[i + shift] = w & 67108863;
      }
      if (carry === 0)
        return this.strip();
      assert4(carry === -1);
      carry = 0;
      for (i = 0;i < this.length; i++) {
        w = -(this.words[i] | 0) + carry;
        carry = w >> 26;
        this.words[i] = w & 67108863;
      }
      this.negative = 1;
      return this.strip();
    };
    BN2.prototype._wordDiv = function _wordDiv(num, mode) {
      var shift = this.length - num.length;
      var a = this.clone();
      var b2 = num;
      var bhi = b2.words[b2.length - 1] | 0;
      var bhiBits = this._countBits(bhi);
      shift = 26 - bhiBits;
      if (shift !== 0) {
        b2 = b2.ushln(shift);
        a.iushln(shift);
        bhi = b2.words[b2.length - 1] | 0;
      }
      var m = a.length - b2.length;
      var q;
      if (mode !== "mod") {
        q = new BN2(null);
        q.length = m + 1;
        q.words = new Array(q.length);
        for (var i = 0;i < q.length; i++) {
          q.words[i] = 0;
        }
      }
      var diff = a.clone()._ishlnsubmul(b2, 1, m);
      if (diff.negative === 0) {
        a = diff;
        if (q) {
          q.words[m] = 1;
        }
      }
      for (var j = m - 1;j >= 0; j--) {
        var qj = (a.words[b2.length + j] | 0) * 67108864 + (a.words[b2.length + j - 1] | 0);
        qj = Math.min(qj / bhi | 0, 67108863);
        a._ishlnsubmul(b2, qj, j);
        while (a.negative !== 0) {
          qj--;
          a.negative = 0;
          a._ishlnsubmul(b2, 1, j);
          if (!a.isZero()) {
            a.negative ^= 1;
          }
        }
        if (q) {
          q.words[j] = qj;
        }
      }
      if (q) {
        q.strip();
      }
      a.strip();
      if (mode !== "div" && shift !== 0) {
        a.iushrn(shift);
      }
      return {
        div: q || null,
        mod: a
      };
    };
    BN2.prototype.divmod = function divmod(num, mode, positive) {
      assert4(!num.isZero());
      if (this.isZero()) {
        return {
          div: new BN2(0),
          mod: new BN2(0)
        };
      }
      var div, mod, res;
      if (this.negative !== 0 && num.negative === 0) {
        res = this.neg().divmod(num, mode);
        if (mode !== "mod") {
          div = res.div.neg();
        }
        if (mode !== "div") {
          mod = res.mod.neg();
          if (positive && mod.negative !== 0) {
            mod.iadd(num);
          }
        }
        return {
          div,
          mod
        };
      }
      if (this.negative === 0 && num.negative !== 0) {
        res = this.divmod(num.neg(), mode);
        if (mode !== "mod") {
          div = res.div.neg();
        }
        return {
          div,
          mod: res.mod
        };
      }
      if ((this.negative & num.negative) !== 0) {
        res = this.neg().divmod(num.neg(), mode);
        if (mode !== "div") {
          mod = res.mod.neg();
          if (positive && mod.negative !== 0) {
            mod.isub(num);
          }
        }
        return {
          div: res.div,
          mod
        };
      }
      if (num.length > this.length || this.cmp(num) < 0) {
        return {
          div: new BN2(0),
          mod: this
        };
      }
      if (num.length === 1) {
        if (mode === "div") {
          return {
            div: this.divn(num.words[0]),
            mod: null
          };
        }
        if (mode === "mod") {
          return {
            div: null,
            mod: new BN2(this.modn(num.words[0]))
          };
        }
        return {
          div: this.divn(num.words[0]),
          mod: new BN2(this.modn(num.words[0]))
        };
      }
      return this._wordDiv(num, mode);
    };
    BN2.prototype.div = function div(num) {
      return this.divmod(num, "div", false).div;
    };
    BN2.prototype.mod = function mod(num) {
      return this.divmod(num, "mod", false).mod;
    };
    BN2.prototype.umod = function umod(num) {
      return this.divmod(num, "mod", true).mod;
    };
    BN2.prototype.divRound = function divRound(num) {
      var dm = this.divmod(num);
      if (dm.mod.isZero())
        return dm.div;
      var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
      var half = num.ushrn(1);
      var r2 = num.andln(1);
      var cmp = mod.cmp(half);
      if (cmp < 0 || r2 === 1 && cmp === 0)
        return dm.div;
      return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    };
    BN2.prototype.modn = function modn(num) {
      assert4(num <= 67108863);
      var p = (1 << 26) % num;
      var acc = 0;
      for (var i = this.length - 1;i >= 0; i--) {
        acc = (p * acc + (this.words[i] | 0)) % num;
      }
      return acc;
    };
    BN2.prototype.idivn = function idivn(num) {
      assert4(num <= 67108863);
      var carry = 0;
      for (var i = this.length - 1;i >= 0; i--) {
        var w = (this.words[i] | 0) + carry * 67108864;
        this.words[i] = w / num | 0;
        carry = w % num;
      }
      return this.strip();
    };
    BN2.prototype.divn = function divn(num) {
      return this.clone().idivn(num);
    };
    BN2.prototype.egcd = function egcd(p) {
      assert4(p.negative === 0);
      assert4(!p.isZero());
      var x = this;
      var y = p.clone();
      if (x.negative !== 0) {
        x = x.umod(p);
      } else {
        x = x.clone();
      }
      var A = new BN2(1);
      var B = new BN2(0);
      var C = new BN2(0);
      var D2 = new BN2(1);
      var g = 0;
      while (x.isEven() && y.isEven()) {
        x.iushrn(1);
        y.iushrn(1);
        ++g;
      }
      var yp = y.clone();
      var xp = x.clone();
      while (!x.isZero()) {
        for (var i = 0, im = 1;(x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
          ;
        if (i > 0) {
          x.iushrn(i);
          while (i-- > 0) {
            if (A.isOdd() || B.isOdd()) {
              A.iadd(yp);
              B.isub(xp);
            }
            A.iushrn(1);
            B.iushrn(1);
          }
        }
        for (var j = 0, jm = 1;(y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
          ;
        if (j > 0) {
          y.iushrn(j);
          while (j-- > 0) {
            if (C.isOdd() || D2.isOdd()) {
              C.iadd(yp);
              D2.isub(xp);
            }
            C.iushrn(1);
            D2.iushrn(1);
          }
        }
        if (x.cmp(y) >= 0) {
          x.isub(y);
          A.isub(C);
          B.isub(D2);
        } else {
          y.isub(x);
          C.isub(A);
          D2.isub(B);
        }
      }
      return {
        a: C,
        b: D2,
        gcd: y.iushln(g)
      };
    };
    BN2.prototype._invmp = function _invmp(p) {
      assert4(p.negative === 0);
      assert4(!p.isZero());
      var a = this;
      var b2 = p.clone();
      if (a.negative !== 0) {
        a = a.umod(p);
      } else {
        a = a.clone();
      }
      var x1 = new BN2(1);
      var x2 = new BN2(0);
      var delta = b2.clone();
      while (a.cmpn(1) > 0 && b2.cmpn(1) > 0) {
        for (var i = 0, im = 1;(a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
          ;
        if (i > 0) {
          a.iushrn(i);
          while (i-- > 0) {
            if (x1.isOdd()) {
              x1.iadd(delta);
            }
            x1.iushrn(1);
          }
        }
        for (var j = 0, jm = 1;(b2.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
          ;
        if (j > 0) {
          b2.iushrn(j);
          while (j-- > 0) {
            if (x2.isOdd()) {
              x2.iadd(delta);
            }
            x2.iushrn(1);
          }
        }
        if (a.cmp(b2) >= 0) {
          a.isub(b2);
          x1.isub(x2);
        } else {
          b2.isub(a);
          x2.isub(x1);
        }
      }
      var res;
      if (a.cmpn(1) === 0) {
        res = x1;
      } else {
        res = x2;
      }
      if (res.cmpn(0) < 0) {
        res.iadd(p);
      }
      return res;
    };
    BN2.prototype.gcd = function gcd(num) {
      if (this.isZero())
        return num.abs();
      if (num.isZero())
        return this.abs();
      var a = this.clone();
      var b2 = num.clone();
      a.negative = 0;
      b2.negative = 0;
      for (var shift = 0;a.isEven() && b2.isEven(); shift++) {
        a.iushrn(1);
        b2.iushrn(1);
      }
      do {
        while (a.isEven()) {
          a.iushrn(1);
        }
        while (b2.isEven()) {
          b2.iushrn(1);
        }
        var r = a.cmp(b2);
        if (r < 0) {
          var t = a;
          a = b2;
          b2 = t;
        } else if (r === 0 || b2.cmpn(1) === 0) {
          break;
        }
        a.isub(b2);
      } while (true);
      return b2.iushln(shift);
    };
    BN2.prototype.invm = function invm(num) {
      return this.egcd(num).a.umod(num);
    };
    BN2.prototype.isEven = function isEven() {
      return (this.words[0] & 1) === 0;
    };
    BN2.prototype.isOdd = function isOdd() {
      return (this.words[0] & 1) === 1;
    };
    BN2.prototype.andln = function andln(num) {
      return this.words[0] & num;
    };
    BN2.prototype.bincn = function bincn(bit) {
      assert4(typeof bit === "number");
      var r = bit % 26;
      var s = (bit - r) / 26;
      var q = 1 << r;
      if (this.length <= s) {
        this._expand(s + 1);
        this.words[s] |= q;
        return this;
      }
      var carry = q;
      for (var i = s;carry !== 0 && i < this.length; i++) {
        var w = this.words[i] | 0;
        w += carry;
        carry = w >>> 26;
        w &= 67108863;
        this.words[i] = w;
      }
      if (carry !== 0) {
        this.words[i] = carry;
        this.length++;
      }
      return this;
    };
    BN2.prototype.isZero = function isZero() {
      return this.length === 1 && this.words[0] === 0;
    };
    BN2.prototype.cmpn = function cmpn(num) {
      var negative = num < 0;
      if (this.negative !== 0 && !negative)
        return -1;
      if (this.negative === 0 && negative)
        return 1;
      this.strip();
      var res;
      if (this.length > 1) {
        res = 1;
      } else {
        if (negative) {
          num = -num;
        }
        assert4(num <= 67108863, "Number is too big");
        var w = this.words[0] | 0;
        res = w === num ? 0 : w < num ? -1 : 1;
      }
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN2.prototype.cmp = function cmp(num) {
      if (this.negative !== 0 && num.negative === 0)
        return -1;
      if (this.negative === 0 && num.negative !== 0)
        return 1;
      var res = this.ucmp(num);
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN2.prototype.ucmp = function ucmp(num) {
      if (this.length > num.length)
        return 1;
      if (this.length < num.length)
        return -1;
      var res = 0;
      for (var i = this.length - 1;i >= 0; i--) {
        var a = this.words[i] | 0;
        var b2 = num.words[i] | 0;
        if (a === b2)
          continue;
        if (a < b2) {
          res = -1;
        } else if (a > b2) {
          res = 1;
        }
        break;
      }
      return res;
    };
    BN2.prototype.gtn = function gtn(num) {
      return this.cmpn(num) === 1;
    };
    BN2.prototype.gt = function gt(num) {
      return this.cmp(num) === 1;
    };
    BN2.prototype.gten = function gten(num) {
      return this.cmpn(num) >= 0;
    };
    BN2.prototype.gte = function gte(num) {
      return this.cmp(num) >= 0;
    };
    BN2.prototype.ltn = function ltn(num) {
      return this.cmpn(num) === -1;
    };
    BN2.prototype.lt = function lt(num) {
      return this.cmp(num) === -1;
    };
    BN2.prototype.lten = function lten(num) {
      return this.cmpn(num) <= 0;
    };
    BN2.prototype.lte = function lte(num) {
      return this.cmp(num) <= 0;
    };
    BN2.prototype.eqn = function eqn(num) {
      return this.cmpn(num) === 0;
    };
    BN2.prototype.eq = function eq(num) {
      return this.cmp(num) === 0;
    };
    BN2.red = function red(num) {
      return new Red(num);
    };
    BN2.prototype.toRed = function toRed(ctx) {
      assert4(!this.red, "Already a number in reduction context");
      assert4(this.negative === 0, "red works only with positives");
      return ctx.convertTo(this)._forceRed(ctx);
    };
    BN2.prototype.fromRed = function fromRed() {
      assert4(this.red, "fromRed works only with numbers in reduction context");
      return this.red.convertFrom(this);
    };
    BN2.prototype._forceRed = function _forceRed(ctx) {
      this.red = ctx;
      return this;
    };
    BN2.prototype.forceRed = function forceRed(ctx) {
      assert4(!this.red, "Already a number in reduction context");
      return this._forceRed(ctx);
    };
    BN2.prototype.redAdd = function redAdd(num) {
      assert4(this.red, "redAdd works only with red numbers");
      return this.red.add(this, num);
    };
    BN2.prototype.redIAdd = function redIAdd(num) {
      assert4(this.red, "redIAdd works only with red numbers");
      return this.red.iadd(this, num);
    };
    BN2.prototype.redSub = function redSub(num) {
      assert4(this.red, "redSub works only with red numbers");
      return this.red.sub(this, num);
    };
    BN2.prototype.redISub = function redISub(num) {
      assert4(this.red, "redISub works only with red numbers");
      return this.red.isub(this, num);
    };
    BN2.prototype.redShl = function redShl(num) {
      assert4(this.red, "redShl works only with red numbers");
      return this.red.shl(this, num);
    };
    BN2.prototype.redMul = function redMul(num) {
      assert4(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.mul(this, num);
    };
    BN2.prototype.redIMul = function redIMul(num) {
      assert4(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.imul(this, num);
    };
    BN2.prototype.redSqr = function redSqr() {
      assert4(this.red, "redSqr works only with red numbers");
      this.red._verify1(this);
      return this.red.sqr(this);
    };
    BN2.prototype.redISqr = function redISqr() {
      assert4(this.red, "redISqr works only with red numbers");
      this.red._verify1(this);
      return this.red.isqr(this);
    };
    BN2.prototype.redSqrt = function redSqrt() {
      assert4(this.red, "redSqrt works only with red numbers");
      this.red._verify1(this);
      return this.red.sqrt(this);
    };
    BN2.prototype.redInvm = function redInvm() {
      assert4(this.red, "redInvm works only with red numbers");
      this.red._verify1(this);
      return this.red.invm(this);
    };
    BN2.prototype.redNeg = function redNeg() {
      assert4(this.red, "redNeg works only with red numbers");
      this.red._verify1(this);
      return this.red.neg(this);
    };
    BN2.prototype.redPow = function redPow(num) {
      assert4(this.red && !num.red, "redPow(normalNum)");
      this.red._verify1(this);
      return this.red.pow(this, num);
    };
    var primes = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function MPrime(name, p) {
      this.name = name;
      this.p = new BN2(p, 16);
      this.n = this.p.bitLength();
      this.k = new BN2(1).iushln(this.n).isub(this.p);
      this.tmp = this._tmp();
    }
    MPrime.prototype._tmp = function _tmp() {
      var tmp = new BN2(null);
      tmp.words = new Array(Math.ceil(this.n / 13));
      return tmp;
    };
    MPrime.prototype.ireduce = function ireduce(num) {
      var r = num;
      var rlen;
      do {
        this.split(r, this.tmp);
        r = this.imulK(r);
        r = r.iadd(this.tmp);
        rlen = r.bitLength();
      } while (rlen > this.n);
      var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
      if (cmp === 0) {
        r.words[0] = 0;
        r.length = 1;
      } else if (cmp > 0) {
        r.isub(this.p);
      } else {
        if (r.strip !== undefined) {
          r.strip();
        } else {
          r._strip();
        }
      }
      return r;
    };
    MPrime.prototype.split = function split(input, out) {
      input.iushrn(this.n, 0, out);
    };
    MPrime.prototype.imulK = function imulK(num) {
      return num.imul(this.k);
    };
    function K256() {
      MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    inherits(K256, MPrime);
    K256.prototype.split = function split(input, output3) {
      var mask2 = 4194303;
      var outLen = Math.min(input.length, 9);
      for (var i = 0;i < outLen; i++) {
        output3.words[i] = input.words[i];
      }
      output3.length = outLen;
      if (input.length <= 9) {
        input.words[0] = 0;
        input.length = 1;
        return;
      }
      var prev = input.words[9];
      output3.words[output3.length++] = prev & mask2;
      for (i = 10;i < input.length; i++) {
        var next = input.words[i] | 0;
        input.words[i - 10] = (next & mask2) << 4 | prev >>> 22;
        prev = next;
      }
      prev >>>= 22;
      input.words[i - 10] = prev;
      if (prev === 0 && input.length > 10) {
        input.length -= 10;
      } else {
        input.length -= 9;
      }
    };
    K256.prototype.imulK = function imulK(num) {
      num.words[num.length] = 0;
      num.words[num.length + 1] = 0;
      num.length += 2;
      var lo = 0;
      for (var i = 0;i < num.length; i++) {
        var w = num.words[i] | 0;
        lo += w * 977;
        num.words[i] = lo & 67108863;
        lo = w * 64 + (lo / 67108864 | 0);
      }
      if (num.words[num.length - 1] === 0) {
        num.length--;
        if (num.words[num.length - 1] === 0) {
          num.length--;
        }
      }
      return num;
    };
    function P224() {
      MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    inherits(P224, MPrime);
    function P192() {
      MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    inherits(P192, MPrime);
    function P25519() {
      MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    inherits(P25519, MPrime);
    P25519.prototype.imulK = function imulK(num) {
      var carry = 0;
      for (var i = 0;i < num.length; i++) {
        var hi = (num.words[i] | 0) * 19 + carry;
        var lo = hi & 67108863;
        hi >>>= 26;
        num.words[i] = lo;
        carry = hi;
      }
      if (carry !== 0) {
        num.words[num.length++] = carry;
      }
      return num;
    };
    BN2._prime = function prime(name) {
      if (primes[name])
        return primes[name];
      var prime;
      if (name === "k256") {
        prime = new K256;
      } else if (name === "p224") {
        prime = new P224;
      } else if (name === "p192") {
        prime = new P192;
      } else if (name === "p25519") {
        prime = new P25519;
      } else {
        throw new Error("Unknown prime " + name);
      }
      primes[name] = prime;
      return prime;
    };
    function Red(m) {
      if (typeof m === "string") {
        var prime = BN2._prime(m);
        this.m = prime.p;
        this.prime = prime;
      } else {
        assert4(m.gtn(1), "modulus must be greater than 1");
        this.m = m;
        this.prime = null;
      }
    }
    Red.prototype._verify1 = function _verify1(a) {
      assert4(a.negative === 0, "red works only with positives");
      assert4(a.red, "red works only with red numbers");
    };
    Red.prototype._verify2 = function _verify2(a, b2) {
      assert4((a.negative | b2.negative) === 0, "red works only with positives");
      assert4(a.red && a.red === b2.red, "red works only with red numbers");
    };
    Red.prototype.imod = function imod(a) {
      if (this.prime)
        return this.prime.ireduce(a)._forceRed(this);
      return a.umod(this.m)._forceRed(this);
    };
    Red.prototype.neg = function neg(a) {
      if (a.isZero()) {
        return a.clone();
      }
      return this.m.sub(a)._forceRed(this);
    };
    Red.prototype.add = function add(a, b2) {
      this._verify2(a, b2);
      var res = a.add(b2);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.iadd = function iadd(a, b2) {
      this._verify2(a, b2);
      var res = a.iadd(b2);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res;
    };
    Red.prototype.sub = function sub(a, b2) {
      this._verify2(a, b2);
      var res = a.sub(b2);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.isub = function isub(a, b2) {
      this._verify2(a, b2);
      var res = a.isub(b2);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res;
    };
    Red.prototype.shl = function shl(a, num) {
      this._verify1(a);
      return this.imod(a.ushln(num));
    };
    Red.prototype.imul = function imul(a, b2) {
      this._verify2(a, b2);
      return this.imod(a.imul(b2));
    };
    Red.prototype.mul = function mul(a, b2) {
      this._verify2(a, b2);
      return this.imod(a.mul(b2));
    };
    Red.prototype.isqr = function isqr(a) {
      return this.imul(a, a.clone());
    };
    Red.prototype.sqr = function sqr(a) {
      return this.mul(a, a);
    };
    Red.prototype.sqrt = function sqrt(a) {
      if (a.isZero())
        return a.clone();
      var mod3 = this.m.andln(3);
      assert4(mod3 % 2 === 1);
      if (mod3 === 3) {
        var pow = this.m.add(new BN2(1)).iushrn(2);
        return this.pow(a, pow);
      }
      var q = this.m.subn(1);
      var s = 0;
      while (!q.isZero() && q.andln(1) === 0) {
        s++;
        q.iushrn(1);
      }
      assert4(!q.isZero());
      var one = new BN2(1).toRed(this);
      var nOne = one.redNeg();
      var lpow = this.m.subn(1).iushrn(1);
      var z2 = this.m.bitLength();
      z2 = new BN2(2 * z2 * z2).toRed(this);
      while (this.pow(z2, lpow).cmp(nOne) !== 0) {
        z2.redIAdd(nOne);
      }
      var c = this.pow(z2, q);
      var r = this.pow(a, q.addn(1).iushrn(1));
      var t = this.pow(a, q);
      var m = s;
      while (t.cmp(one) !== 0) {
        var tmp = t;
        for (var i = 0;tmp.cmp(one) !== 0; i++) {
          tmp = tmp.redSqr();
        }
        assert4(i < m);
        var b2 = this.pow(c, new BN2(1).iushln(m - i - 1));
        r = r.redMul(b2);
        c = b2.redSqr();
        t = t.redMul(c);
        m = i;
      }
      return r;
    };
    Red.prototype.invm = function invm(a) {
      var inv = a._invmp(this.m);
      if (inv.negative !== 0) {
        inv.negative = 0;
        return this.imod(inv).redNeg();
      } else {
        return this.imod(inv);
      }
    };
    Red.prototype.pow = function pow(a, num) {
      if (num.isZero())
        return new BN2(1).toRed(this);
      if (num.cmpn(1) === 0)
        return a.clone();
      var windowSize = 4;
      var wnd = new Array(1 << windowSize);
      wnd[0] = new BN2(1).toRed(this);
      wnd[1] = a;
      for (var i = 2;i < wnd.length; i++) {
        wnd[i] = this.mul(wnd[i - 1], a);
      }
      var res = wnd[0];
      var current = 0;
      var currentLen = 0;
      var start = num.bitLength() % 26;
      if (start === 0) {
        start = 26;
      }
      for (i = num.length - 1;i >= 0; i--) {
        var word = num.words[i];
        for (var j = start - 1;j >= 0; j--) {
          var bit = word >> j & 1;
          if (res !== wnd[0]) {
            res = this.sqr(res);
          }
          if (bit === 0 && current === 0) {
            currentLen = 0;
            continue;
          }
          current <<= 1;
          current |= bit;
          currentLen++;
          if (currentLen !== windowSize && (i !== 0 || j !== 0))
            continue;
          res = this.mul(res, wnd[current]);
          currentLen = 0;
          current = 0;
        }
        start = 26;
      }
      return res;
    };
    Red.prototype.convertTo = function convertTo(num) {
      var r = num.umod(this.m);
      return r === num ? r.clone() : r;
    };
    Red.prototype.convertFrom = function convertFrom(num) {
      var res = num.clone();
      res.red = null;
      return res;
    };
    BN2.mont = function mont(num) {
      return new Mont(num);
    };
    function Mont(m) {
      Red.call(this, m);
      this.shift = this.m.bitLength();
      if (this.shift % 26 !== 0) {
        this.shift += 26 - this.shift % 26;
      }
      this.r = new BN2(1).iushln(this.shift);
      this.r2 = this.imod(this.r.sqr());
      this.rinv = this.r._invmp(this.m);
      this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
      this.minv = this.minv.umod(this.r);
      this.minv = this.r.sub(this.minv);
    }
    inherits(Mont, Red);
    Mont.prototype.convertTo = function convertTo(num) {
      return this.imod(num.ushln(this.shift));
    };
    Mont.prototype.convertFrom = function convertFrom(num) {
      var r = this.imod(num.mul(this.rinv));
      r.red = null;
      return r;
    };
    Mont.prototype.imul = function imul(a, b2) {
      if (a.isZero() || b2.isZero()) {
        a.words[0] = 0;
        a.length = 1;
        return a;
      }
      var t = a.imul(b2);
      var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u = t.isub(c).iushrn(this.shift);
      var res = u;
      if (u.cmp(this.m) >= 0) {
        res = u.isub(this.m);
      } else if (u.cmpn(0) < 0) {
        res = u.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.mul = function mul(a, b2) {
      if (a.isZero() || b2.isZero())
        return new BN2(0)._forceRed(this);
      var t = a.mul(b2);
      var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u = t.isub(c).iushrn(this.shift);
      var res = u;
      if (u.cmp(this.m) >= 0) {
        res = u.isub(this.m);
      } else if (u.cmpn(0) < 0) {
        res = u.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.invm = function invm(a) {
      var res = this.imod(a._invmp(this.m).mul(this.r2));
      return res._forceRed(this);
    };
  })(typeof module === "undefined" || module, exports);
});

// node_modules/minimalistic-assert/index.js
var require_minimalistic_assert = __commonJS((exports, module) => {
  var assert4 = function(val, msg) {
    if (!val)
      throw new Error(msg || "Assertion failed");
  };
  module.exports = assert4;
  assert4.equal = function assertEqual(l, r, msg) {
    if (l != r)
      throw new Error(msg || "Assertion failed: " + l + " != " + r);
  };
});

// node_modules/minimalistic-crypto-utils/lib/utils.js
var require_utils = __commonJS((exports) => {
  var toArray = function(msg, enc) {
    if (Array.isArray(msg))
      return msg.slice();
    if (!msg)
      return [];
    var res = [];
    if (typeof msg !== "string") {
      for (var i = 0;i < msg.length; i++)
        res[i] = msg[i] | 0;
      return res;
    }
    if (enc === "hex") {
      msg = msg.replace(/[^a-z0-9]+/ig, "");
      if (msg.length % 2 !== 0)
        msg = "0" + msg;
      for (var i = 0;i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    } else {
      for (var i = 0;i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        var hi = c >> 8;
        var lo = c & 255;
        if (hi)
          res.push(hi, lo);
        else
          res.push(lo);
      }
    }
    return res;
  };
  var zero2 = function(word) {
    if (word.length === 1)
      return "0" + word;
    else
      return word;
  };
  var toHex2 = function(msg) {
    var res = "";
    for (var i = 0;i < msg.length; i++)
      res += zero2(msg[i].toString(16));
    return res;
  };
  var utils41 = exports;
  utils41.toArray = toArray;
  utils41.zero2 = zero2;
  utils41.toHex = toHex2;
  utils41.encode = function encode(arr, enc) {
    if (enc === "hex")
      return toHex2(arr);
    else
      return arr;
  };
});

// node_modules/elliptic/lib/elliptic/utils.js
var require_utils2 = __commonJS((exports) => {
  var getNAF = function(num, w, bits) {
    var naf = new Array(Math.max(num.bitLength(), bits) + 1);
    naf.fill(0);
    var ws = 1 << w + 1;
    var k = num.clone();
    for (var i = 0;i < naf.length; i++) {
      var z2;
      var mod = k.andln(ws - 1);
      if (k.isOdd()) {
        if (mod > (ws >> 1) - 1)
          z2 = (ws >> 1) - mod;
        else
          z2 = mod;
        k.isubn(z2);
      } else {
        z2 = 0;
      }
      naf[i] = z2;
      k.iushrn(1);
    }
    return naf;
  };
  var getJSF = function(k1, k2) {
    var jsf = [
      [],
      []
    ];
    k1 = k1.clone();
    k2 = k2.clone();
    var d1 = 0;
    var d2 = 0;
    var m8;
    while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
      var m14 = k1.andln(3) + d1 & 3;
      var m24 = k2.andln(3) + d2 & 3;
      if (m14 === 3)
        m14 = -1;
      if (m24 === 3)
        m24 = -1;
      var u1;
      if ((m14 & 1) === 0) {
        u1 = 0;
      } else {
        m8 = k1.andln(7) + d1 & 7;
        if ((m8 === 3 || m8 === 5) && m24 === 2)
          u1 = -m14;
        else
          u1 = m14;
      }
      jsf[0].push(u1);
      var u2;
      if ((m24 & 1) === 0) {
        u2 = 0;
      } else {
        m8 = k2.andln(7) + d2 & 7;
        if ((m8 === 3 || m8 === 5) && m14 === 2)
          u2 = -m24;
        else
          u2 = m24;
      }
      jsf[1].push(u2);
      if (2 * d1 === u1 + 1)
        d1 = 1 - d1;
      if (2 * d2 === u2 + 1)
        d2 = 1 - d2;
      k1.iushrn(1);
      k2.iushrn(1);
    }
    return jsf;
  };
  var cachedProperty = function(obj, name, computer) {
    var key = "_" + name;
    obj.prototype[name] = function cachedProperty() {
      return this[key] !== undefined ? this[key] : this[key] = computer.call(this);
    };
  };
  var parseBytes = function(bytes3) {
    return typeof bytes3 === "string" ? utils41.toArray(bytes3, "hex") : bytes3;
  };
  var intFromLE = function(bytes3) {
    return new BN2(bytes3, "hex", "le");
  };
  var utils41 = exports;
  var BN2 = require_bn2();
  var minAssert = require_minimalistic_assert();
  var minUtils = require_utils();
  utils41.assert = minAssert;
  utils41.toArray = minUtils.toArray;
  utils41.zero2 = minUtils.zero2;
  utils41.toHex = minUtils.toHex;
  utils41.encode = minUtils.encode;
  utils41.getNAF = getNAF;
  utils41.getJSF = getJSF;
  utils41.cachedProperty = cachedProperty;
  utils41.parseBytes = parseBytes;
  utils41.intFromLE = intFromLE;
});

// node:crypto
var exports_crypto = {};
__export(exports_crypto, {
  webcrypto: () => {
    {
      return U3;
    }
  },
  timingSafeEqual: () => {
    {
      return B0;
    }
  },
  scryptSync: () => {
    {
      return Vd;
    }
  },
  scrypt: () => {
    {
      return $d;
    }
  },
  randomUUID: () => {
    {
      return O3;
    }
  },
  getRandomValues: () => {
    {
      return C3;
    }
  },
  getCurves: () => {
    {
      return F3;
    }
  },
  default: () => {
    {
      return PI;
    }
  },
  DEFAULT_ENCODING: () => {
    {
      return eo;
    }
  }
});
var F3, z3, ro, H3, W3, K3, j3, k0, k, io, to, ot, fn, ur, Xd, Jd, Ut, Te, hn, Ie, Di, $0, Xf, Lc, X0, un, J0, eh, ih, ln, go, ta, yo, ra, wo, tp, ip, ah, yh, gp, xp, Ep, Mh, To, Lo, bn2, zp, Kp, xh, $p, Sh, i1, Co, Tt, Gr, Fo, Jt, ma, Ph, vr, R8, Hi, Qr, yi, wn, Go, ga, lv, Jo, Vh, ya, au, eb, ti, cu, vu, hs, Eu, Ab, qu, Iu, Lu, gf, p9, Cb, xi, yf, jb, Nu, Cu, Ou, Yb, Fu, Uu, Hu, Wu, lm, Vu, $u, ar, ws, Gu, Mm, Sm, Em, Bm, qm, _f, km, Pm, Cm, Fm, zm, Qu, tl, rl, Es, Ta, Ym, al, sl, La, ag, ug, Is, cg, gg, Vi, cl, Mg, _g, Ts, gl, Sl, Rg, Tg, Ng, Al, zg, ql, Cn, Il, Ll, On, Us, a2, s2, Dl, Vl, x2, B2, I2, $s, Gs, P2, fi, Xl, or, Wa, W2, Z2, G2, Ql, Cr, Nf, ed, oy, rd, dy, ad, yy, wy, Ay, By, f0, Ty, a0, Cy, Fy, Hy, Zy, Yy, Jy, iw, d0, gd, p0, v0, Vf, m0, g0, Md, vw, Sd, Ad, Ew, qd, qw, Tw, Nw, Id2, Fw, zw, Hw, Kw, Va, Ld, Gw, Qw, f3, o3, h3, Fd, Ud, E0, Hd, g3, x3, S3, N3, Zd, Xt, LI, eo, C3, O3, NI, B0, Vd, $d, U3, PI;
var init_crypto = __esm(() => {
  F3 = function() {
    return NI;
  };
  z3 = Object.create;
  ro = Object.defineProperty;
  H3 = Object.getOwnPropertyDescriptor;
  W3 = Object.getOwnPropertyNames;
  K3 = Object.getPrototypeOf;
  j3 = Object.prototype.hasOwnProperty;
  k0 = (t, e) => () => (t && (e = t(t = 0)), e);
  k = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports);
  io = (t, e) => {
    for (var r in e)
      ro(t, r, { get: e[r], enumerable: true });
  };
  to = (t, e, r, o) => {
    if (e && typeof e == "object" || typeof e == "function")
      for (let f2 of W3(e))
        !j3.call(t, f2) && f2 !== r && ro(t, f2, { get: () => e[f2], enumerable: !(o = H3(e, f2)) || o.enumerable });
    return t;
  };
  ot = (t, e, r) => (to(t, e, "default"), r && to(r, e, "default"));
  fn = (t, e, r) => (r = t != null ? z3(K3(t)) : {}, to(e || !t || !t.__esModule ? ro(r, "default", { value: t, enumerable: true }) : r, t));
  ur = (t) => to(ro({}, "__esModule", { value: true }), t);
  Xd = k((no) => {
    no.byteLength = V3;
    no.toByteArray = G3;
    no.fromByteArray = J3;
    var jr = [], lr = [], Z3 = typeof Uint8Array < "u" ? Uint8Array : Array, L0 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (an = 0, Gd = L0.length;an < Gd; ++an)
      jr[an] = L0[an], lr[L0.charCodeAt(an)] = an;
    var an, Gd;
    lr["-".charCodeAt(0)] = 62;
    lr["_".charCodeAt(0)] = 63;
    function Yd(t) {
      var e = t.length;
      if (e % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4");
      var r = t.indexOf("=");
      r === -1 && (r = e);
      var o = r === e ? 0 : 4 - r % 4;
      return [r, o];
    }
    function V3(t) {
      var e = Yd(t), r = e[0], o = e[1];
      return (r + o) * 3 / 4 - o;
    }
    function $3(t, e, r) {
      return (e + r) * 3 / 4 - r;
    }
    function G3(t) {
      var e, r = Yd(t), o = r[0], f2 = r[1], p = new Z3($3(t, o, f2)), m = 0, y = f2 > 0 ? o - 4 : o, M;
      for (M = 0;M < y; M += 4)
        e = lr[t.charCodeAt(M)] << 18 | lr[t.charCodeAt(M + 1)] << 12 | lr[t.charCodeAt(M + 2)] << 6 | lr[t.charCodeAt(M + 3)], p[m++] = e >> 16 & 255, p[m++] = e >> 8 & 255, p[m++] = e & 255;
      return f2 === 2 && (e = lr[t.charCodeAt(M)] << 2 | lr[t.charCodeAt(M + 1)] >> 4, p[m++] = e & 255), f2 === 1 && (e = lr[t.charCodeAt(M)] << 10 | lr[t.charCodeAt(M + 1)] << 4 | lr[t.charCodeAt(M + 2)] >> 2, p[m++] = e >> 8 & 255, p[m++] = e & 255), p;
    }
    function Y3(t) {
      return jr[t >> 18 & 63] + jr[t >> 12 & 63] + jr[t >> 6 & 63] + jr[t & 63];
    }
    function X3(t, e, r) {
      for (var o, f2 = [], p = e;p < r; p += 3)
        o = (t[p] << 16 & 16711680) + (t[p + 1] << 8 & 65280) + (t[p + 2] & 255), f2.push(Y3(o));
      return f2.join("");
    }
    function J3(t) {
      for (var e, r = t.length, o = r % 3, f2 = [], p = 16383, m = 0, y = r - o;m < y; m += p)
        f2.push(X3(t, m, m + p > y ? y : m + p));
      return o === 1 ? (e = t[r - 1], f2.push(jr[e >> 2] + jr[e << 4 & 63] + "==")) : o === 2 && (e = (t[r - 2] << 8) + t[r - 1], f2.push(jr[e >> 10] + jr[e >> 4 & 63] + jr[e << 2 & 63] + "=")), f2.join("");
    }
  });
  Jd = k((N0) => {
    N0.read = function(t, e, r, o, f2) {
      var p, m, y = f2 * 8 - o - 1, M = (1 << y) - 1, x = M >> 1, S2 = -7, E = r ? f2 - 1 : 0, R = r ? -1 : 1, q = t[e + E];
      for (E += R, p = q & (1 << -S2) - 1, q >>= -S2, S2 += y;S2 > 0; p = p * 256 + t[e + E], E += R, S2 -= 8)
        ;
      for (m = p & (1 << -S2) - 1, p >>= -S2, S2 += o;S2 > 0; m = m * 256 + t[e + E], E += R, S2 -= 8)
        ;
      if (p === 0)
        p = 1 - x;
      else {
        if (p === M)
          return m ? NaN : (q ? -1 : 1) * (1 / 0);
        m = m + Math.pow(2, o), p = p - x;
      }
      return (q ? -1 : 1) * m * Math.pow(2, p - o);
    };
    N0.write = function(t, e, r, o, f2, p) {
      var m, y, M, x = p * 8 - f2 - 1, S2 = (1 << x) - 1, E = S2 >> 1, R = f2 === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, q = o ? 0 : p - 1, T = o ? 1 : -1, ye = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
      for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (y = isNaN(e) ? 1 : 0, m = S2) : (m = Math.floor(Math.log(e) / Math.LN2), e * (M = Math.pow(2, -m)) < 1 && (m--, M *= 2), m + E >= 1 ? e += R / M : e += R * Math.pow(2, 1 - E), e * M >= 2 && (m++, M /= 2), m + E >= S2 ? (y = 0, m = S2) : m + E >= 1 ? (y = (e * M - 1) * Math.pow(2, f2), m = m + E) : (y = e * Math.pow(2, E - 1) * Math.pow(2, f2), m = 0));f2 >= 8; t[r + q] = y & 255, q += T, y /= 256, f2 -= 8)
        ;
      for (m = m << f2 | y, x += f2;x > 0; t[r + q] = m & 255, q += T, m /= 256, x -= 8)
        ;
      t[r + q - T] |= ye * 128;
    };
  });
  Ut = k((rf) => {
    var P0 = Xd(), ef = Jd(), Qd = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    rf.Buffer = ge;
    rf.SlowBuffer = n6;
    rf.INSPECT_MAX_BYTES = 50;
    var fo = 2147483647;
    rf.kMaxLength = fo;
    ge.TYPED_ARRAY_SUPPORT = Q3();
    !ge.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function Q3() {
      try {
        let t = new Uint8Array(1), e = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(e, Uint8Array.prototype), Object.setPrototypeOf(t, e), t.foo() === 42;
      } catch {
        return false;
      }
    }
    Object.defineProperty(ge.prototype, "parent", { enumerable: true, get: function() {
      if (!!ge.isBuffer(this))
        return this.buffer;
    } });
    Object.defineProperty(ge.prototype, "offset", { enumerable: true, get: function() {
      if (!!ge.isBuffer(this))
        return this.byteOffset;
    } });
    function pi(t) {
      if (t > fo)
        throw new RangeError('The value "' + t + '" is invalid for option "size"');
      let e = new Uint8Array(t);
      return Object.setPrototypeOf(e, ge.prototype), e;
    }
    function ge(t, e, r) {
      if (typeof t == "number") {
        if (typeof e == "string")
          throw new TypeError('The "string" argument must be of type string. Received type number');
        return F0(t);
      }
      return ic(t, e, r);
    }
    ge.poolSize = 8192;
    function ic(t, e, r) {
      if (typeof t == "string")
        return t6(t, e);
      if (ArrayBuffer.isView(t))
        return r6(t);
      if (t == null)
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t);
      if (Zr(t, ArrayBuffer) || t && Zr(t.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (Zr(t, SharedArrayBuffer) || t && Zr(t.buffer, SharedArrayBuffer)))
        return C0(t, e, r);
      if (typeof t == "number")
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      let o = t.valueOf && t.valueOf();
      if (o != null && o !== t)
        return ge.from(o, e, r);
      let f2 = i6(t);
      if (f2)
        return f2;
      if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof t[Symbol.toPrimitive] == "function")
        return ge.from(t[Symbol.toPrimitive]("string"), e, r);
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t);
    }
    ge.from = function(t, e, r) {
      return ic(t, e, r);
    };
    Object.setPrototypeOf(ge.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(ge, Uint8Array);
    function nc(t) {
      if (typeof t != "number")
        throw new TypeError('"size" argument must be of type number');
      if (t < 0)
        throw new RangeError('The value "' + t + '" is invalid for option "size"');
    }
    function e6(t, e, r) {
      return nc(t), t <= 0 ? pi(t) : e !== undefined ? typeof r == "string" ? pi(t).fill(e, r) : pi(t).fill(e) : pi(t);
    }
    ge.alloc = function(t, e, r) {
      return e6(t, e, r);
    };
    function F0(t) {
      return nc(t), pi(t < 0 ? 0 : U0(t) | 0);
    }
    ge.allocUnsafe = function(t) {
      return F0(t);
    };
    ge.allocUnsafeSlow = function(t) {
      return F0(t);
    };
    function t6(t, e) {
      if ((typeof e != "string" || e === "") && (e = "utf8"), !ge.isEncoding(e))
        throw new TypeError("Unknown encoding: " + e);
      let r = fc(t, e) | 0, o = pi(r), f2 = o.write(t, e);
      return f2 !== r && (o = o.slice(0, f2)), o;
    }
    function D0(t) {
      let e = t.length < 0 ? 0 : U0(t.length) | 0, r = pi(e);
      for (let o = 0;o < e; o += 1)
        r[o] = t[o] & 255;
      return r;
    }
    function r6(t) {
      if (Zr(t, Uint8Array)) {
        let e = new Uint8Array(t);
        return C0(e.buffer, e.byteOffset, e.byteLength);
      }
      return D0(t);
    }
    function C0(t, e, r) {
      if (e < 0 || t.byteLength < e)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (t.byteLength < e + (r || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      let o;
      return e === undefined && r === undefined ? o = new Uint8Array(t) : r === undefined ? o = new Uint8Array(t, e) : o = new Uint8Array(t, e, r), Object.setPrototypeOf(o, ge.prototype), o;
    }
    function i6(t) {
      if (ge.isBuffer(t)) {
        let e = U0(t.length) | 0, r = pi(e);
        return r.length === 0 || t.copy(r, 0, 0, e), r;
      }
      if (t.length !== undefined)
        return typeof t.length != "number" || H0(t.length) ? pi(0) : D0(t);
      if (t.type === "Buffer" && Array.isArray(t.data))
        return D0(t.data);
    }
    function U0(t) {
      if (t >= fo)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + fo.toString(16) + " bytes");
      return t | 0;
    }
    function n6(t) {
      return +t != t && (t = 0), ge.alloc(+t);
    }
    ge.isBuffer = function(e) {
      return e != null && e._isBuffer === true && e !== ge.prototype;
    };
    ge.compare = function(e, r) {
      if (Zr(e, Uint8Array) && (e = ge.from(e, e.offset, e.byteLength)), Zr(r, Uint8Array) && (r = ge.from(r, r.offset, r.byteLength)), !ge.isBuffer(e) || !ge.isBuffer(r))
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      if (e === r)
        return 0;
      let o = e.length, f2 = r.length;
      for (let p = 0, m = Math.min(o, f2);p < m; ++p)
        if (e[p] !== r[p]) {
          o = e[p], f2 = r[p];
          break;
        }
      return o < f2 ? -1 : f2 < o ? 1 : 0;
    };
    ge.isEncoding = function(e) {
      switch (String(e).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    ge.concat = function(e, r) {
      if (!Array.isArray(e))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (e.length === 0)
        return ge.alloc(0);
      let o;
      if (r === undefined)
        for (r = 0, o = 0;o < e.length; ++o)
          r += e[o].length;
      let f2 = ge.allocUnsafe(r), p = 0;
      for (o = 0;o < e.length; ++o) {
        let m = e[o];
        if (Zr(m, Uint8Array))
          p + m.length > f2.length ? (ge.isBuffer(m) || (m = ge.from(m)), m.copy(f2, p)) : Uint8Array.prototype.set.call(f2, m, p);
        else if (ge.isBuffer(m))
          m.copy(f2, p);
        else
          throw new TypeError('"list" argument must be an Array of Buffers');
        p += m.length;
      }
      return f2;
    };
    function fc(t, e) {
      if (ge.isBuffer(t))
        return t.length;
      if (ArrayBuffer.isView(t) || Zr(t, ArrayBuffer))
        return t.byteLength;
      if (typeof t != "string")
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof t);
      let r = t.length, o = arguments.length > 2 && arguments[2] === true;
      if (!o && r === 0)
        return 0;
      let f2 = false;
      for (;; )
        switch (e) {
          case "ascii":
          case "latin1":
          case "binary":
            return r;
          case "utf8":
          case "utf-8":
            return O0(t).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return r * 2;
          case "hex":
            return r >>> 1;
          case "base64":
            return pc(t).length;
          default:
            if (f2)
              return o ? -1 : O0(t).length;
            e = ("" + e).toLowerCase(), f2 = true;
        }
    }
    ge.byteLength = fc;
    function f6(t, e, r) {
      let o = false;
      if ((e === undefined || e < 0) && (e = 0), e > this.length || ((r === undefined || r > this.length) && (r = this.length), r <= 0) || (r >>>= 0, e >>>= 0, r <= e))
        return "";
      for (t || (t = "utf8");; )
        switch (t) {
          case "hex":
            return v6(this, e, r);
          case "utf8":
          case "utf-8":
            return oc(this, e, r);
          case "ascii":
            return c6(this, e, r);
          case "latin1":
          case "binary":
            return p6(this, e, r);
          case "base64":
            return l6(this, e, r);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return b6(this, e, r);
          default:
            if (o)
              throw new TypeError("Unknown encoding: " + t);
            t = (t + "").toLowerCase(), o = true;
        }
    }
    ge.prototype._isBuffer = true;
    function on(t, e, r) {
      let o = t[e];
      t[e] = t[r], t[r] = o;
    }
    ge.prototype.swap16 = function() {
      let e = this.length;
      if (e % 2 !== 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (let r = 0;r < e; r += 2)
        on(this, r, r + 1);
      return this;
    };
    ge.prototype.swap32 = function() {
      let e = this.length;
      if (e % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (let r = 0;r < e; r += 4)
        on(this, r, r + 3), on(this, r + 1, r + 2);
      return this;
    };
    ge.prototype.swap64 = function() {
      let e = this.length;
      if (e % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let r = 0;r < e; r += 8)
        on(this, r, r + 7), on(this, r + 1, r + 6), on(this, r + 2, r + 5), on(this, r + 3, r + 4);
      return this;
    };
    ge.prototype.toString = function() {
      let e = this.length;
      return e === 0 ? "" : arguments.length === 0 ? oc(this, 0, e) : f6.apply(this, arguments);
    };
    ge.prototype.toLocaleString = ge.prototype.toString;
    ge.prototype.equals = function(e) {
      if (!ge.isBuffer(e))
        throw new TypeError("Argument must be a Buffer");
      return this === e ? true : ge.compare(this, e) === 0;
    };
    ge.prototype.inspect = function() {
      let e = "", r = rf.INSPECT_MAX_BYTES;
      return e = this.toString("hex", 0, r).replace(/(.{2})/g, "$1 ").trim(), this.length > r && (e += " ... "), "<Buffer " + e + ">";
    };
    Qd && (ge.prototype[Qd] = ge.prototype.inspect);
    ge.prototype.compare = function(e, r, o, f2, p) {
      if (Zr(e, Uint8Array) && (e = ge.from(e, e.offset, e.byteLength)), !ge.isBuffer(e))
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e);
      if (r === undefined && (r = 0), o === undefined && (o = e ? e.length : 0), f2 === undefined && (f2 = 0), p === undefined && (p = this.length), r < 0 || o > e.length || f2 < 0 || p > this.length)
        throw new RangeError("out of range index");
      if (f2 >= p && r >= o)
        return 0;
      if (f2 >= p)
        return -1;
      if (r >= o)
        return 1;
      if (r >>>= 0, o >>>= 0, f2 >>>= 0, p >>>= 0, this === e)
        return 0;
      let m = p - f2, y = o - r, M = Math.min(m, y), x = this.slice(f2, p), S2 = e.slice(r, o);
      for (let E = 0;E < M; ++E)
        if (x[E] !== S2[E]) {
          m = x[E], y = S2[E];
          break;
        }
      return m < y ? -1 : y < m ? 1 : 0;
    };
    function ac(t, e, r, o, f2) {
      if (t.length === 0)
        return -1;
      if (typeof r == "string" ? (o = r, r = 0) : r > 2147483647 ? r = 2147483647 : r < -2147483648 && (r = -2147483648), r = +r, H0(r) && (r = f2 ? 0 : t.length - 1), r < 0 && (r = t.length + r), r >= t.length) {
        if (f2)
          return -1;
        r = t.length - 1;
      } else if (r < 0)
        if (f2)
          r = 0;
        else
          return -1;
      if (typeof e == "string" && (e = ge.from(e, o)), ge.isBuffer(e))
        return e.length === 0 ? -1 : ec(t, e, r, o, f2);
      if (typeof e == "number")
        return e = e & 255, typeof Uint8Array.prototype.indexOf == "function" ? f2 ? Uint8Array.prototype.indexOf.call(t, e, r) : Uint8Array.prototype.lastIndexOf.call(t, e, r) : ec(t, [e], r, o, f2);
      throw new TypeError("val must be string, number or Buffer");
    }
    function ec(t, e, r, o, f2) {
      let p = 1, m = t.length, y = e.length;
      if (o !== undefined && (o = String(o).toLowerCase(), o === "ucs2" || o === "ucs-2" || o === "utf16le" || o === "utf-16le")) {
        if (t.length < 2 || e.length < 2)
          return -1;
        p = 2, m /= 2, y /= 2, r /= 2;
      }
      function M(S2, E) {
        return p === 1 ? S2[E] : S2.readUInt16BE(E * p);
      }
      let x;
      if (f2) {
        let S2 = -1;
        for (x = r;x < m; x++)
          if (M(t, x) === M(e, S2 === -1 ? 0 : x - S2)) {
            if (S2 === -1 && (S2 = x), x - S2 + 1 === y)
              return S2 * p;
          } else
            S2 !== -1 && (x -= x - S2), S2 = -1;
      } else
        for (r + y > m && (r = m - y), x = r;x >= 0; x--) {
          let S2 = true;
          for (let E = 0;E < y; E++)
            if (M(t, x + E) !== M(e, E)) {
              S2 = false;
              break;
            }
          if (S2)
            return x;
        }
      return -1;
    }
    ge.prototype.includes = function(e, r, o) {
      return this.indexOf(e, r, o) !== -1;
    };
    ge.prototype.indexOf = function(e, r, o) {
      return ac(this, e, r, o, true);
    };
    ge.prototype.lastIndexOf = function(e, r, o) {
      return ac(this, e, r, o, false);
    };
    function a6(t, e, r, o) {
      r = Number(r) || 0;
      let f2 = t.length - r;
      o ? (o = Number(o), o > f2 && (o = f2)) : o = f2;
      let p = e.length;
      o > p / 2 && (o = p / 2);
      let m;
      for (m = 0;m < o; ++m) {
        let y = parseInt(e.substr(m * 2, 2), 16);
        if (H0(y))
          return m;
        t[r + m] = y;
      }
      return m;
    }
    function o6(t, e, r, o) {
      return ao(O0(e, t.length - r), t, r, o);
    }
    function s6(t, e, r, o) {
      return ao(w6(e), t, r, o);
    }
    function h6(t, e, r, o) {
      return ao(pc(e), t, r, o);
    }
    function u6(t, e, r, o) {
      return ao(M6(e, t.length - r), t, r, o);
    }
    ge.prototype.write = function(e, r, o, f2) {
      if (r === undefined)
        f2 = "utf8", o = this.length, r = 0;
      else if (o === undefined && typeof r == "string")
        f2 = r, o = this.length, r = 0;
      else if (isFinite(r))
        r = r >>> 0, isFinite(o) ? (o = o >>> 0, f2 === undefined && (f2 = "utf8")) : (f2 = o, o = undefined);
      else
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      let p = this.length - r;
      if ((o === undefined || o > p) && (o = p), e.length > 0 && (o < 0 || r < 0) || r > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      f2 || (f2 = "utf8");
      let m = false;
      for (;; )
        switch (f2) {
          case "hex":
            return a6(this, e, r, o);
          case "utf8":
          case "utf-8":
            return o6(this, e, r, o);
          case "ascii":
          case "latin1":
          case "binary":
            return s6(this, e, r, o);
          case "base64":
            return h6(this, e, r, o);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return u6(this, e, r, o);
          default:
            if (m)
              throw new TypeError("Unknown encoding: " + f2);
            f2 = ("" + f2).toLowerCase(), m = true;
        }
    };
    ge.prototype.toJSON = function() {
      return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
    };
    function l6(t, e, r) {
      return e === 0 && r === t.length ? P0.fromByteArray(t) : P0.fromByteArray(t.slice(e, r));
    }
    function oc(t, e, r) {
      r = Math.min(t.length, r);
      let o = [], f2 = e;
      for (;f2 < r; ) {
        let p = t[f2], m = null, y = p > 239 ? 4 : p > 223 ? 3 : p > 191 ? 2 : 1;
        if (f2 + y <= r) {
          let M, x, S2, E;
          switch (y) {
            case 1:
              p < 128 && (m = p);
              break;
            case 2:
              M = t[f2 + 1], (M & 192) === 128 && (E = (p & 31) << 6 | M & 63, E > 127 && (m = E));
              break;
            case 3:
              M = t[f2 + 1], x = t[f2 + 2], (M & 192) === 128 && (x & 192) === 128 && (E = (p & 15) << 12 | (M & 63) << 6 | x & 63, E > 2047 && (E < 55296 || E > 57343) && (m = E));
              break;
            case 4:
              M = t[f2 + 1], x = t[f2 + 2], S2 = t[f2 + 3], (M & 192) === 128 && (x & 192) === 128 && (S2 & 192) === 128 && (E = (p & 15) << 18 | (M & 63) << 12 | (x & 63) << 6 | S2 & 63, E > 65535 && E < 1114112 && (m = E));
          }
        }
        m === null ? (m = 65533, y = 1) : m > 65535 && (m -= 65536, o.push(m >>> 10 & 1023 | 55296), m = 56320 | m & 1023), o.push(m), f2 += y;
      }
      return d6(o);
    }
    var tc = 4096;
    function d6(t) {
      let e = t.length;
      if (e <= tc)
        return String.fromCharCode.apply(String, t);
      let r = "", o = 0;
      for (;o < e; )
        r += String.fromCharCode.apply(String, t.slice(o, o += tc));
      return r;
    }
    function c6(t, e, r) {
      let o = "";
      r = Math.min(t.length, r);
      for (let f2 = e;f2 < r; ++f2)
        o += String.fromCharCode(t[f2] & 127);
      return o;
    }
    function p6(t, e, r) {
      let o = "";
      r = Math.min(t.length, r);
      for (let f2 = e;f2 < r; ++f2)
        o += String.fromCharCode(t[f2]);
      return o;
    }
    function v6(t, e, r) {
      let o = t.length;
      (!e || e < 0) && (e = 0), (!r || r < 0 || r > o) && (r = o);
      let f2 = "";
      for (let p = e;p < r; ++p)
        f2 += _6[t[p]];
      return f2;
    }
    function b6(t, e, r) {
      let o = t.slice(e, r), f2 = "";
      for (let p = 0;p < o.length - 1; p += 2)
        f2 += String.fromCharCode(o[p] + o[p + 1] * 256);
      return f2;
    }
    ge.prototype.slice = function(e, r) {
      let o = this.length;
      e = ~~e, r = r === undefined ? o : ~~r, e < 0 ? (e += o, e < 0 && (e = 0)) : e > o && (e = o), r < 0 ? (r += o, r < 0 && (r = 0)) : r > o && (r = o), r < e && (r = e);
      let f2 = this.subarray(e, r);
      return Object.setPrototypeOf(f2, ge.prototype), f2;
    };
    function Pt(t, e, r) {
      if (t % 1 !== 0 || t < 0)
        throw new RangeError("offset is not uint");
      if (t + e > r)
        throw new RangeError("Trying to access beyond buffer length");
    }
    ge.prototype.readUintLE = ge.prototype.readUIntLE = function(e, r, o) {
      e = e >>> 0, r = r >>> 0, o || Pt(e, r, this.length);
      let f2 = this[e], p = 1, m = 0;
      for (;++m < r && (p *= 256); )
        f2 += this[e + m] * p;
      return f2;
    };
    ge.prototype.readUintBE = ge.prototype.readUIntBE = function(e, r, o) {
      e = e >>> 0, r = r >>> 0, o || Pt(e, r, this.length);
      let f2 = this[e + --r], p = 1;
      for (;r > 0 && (p *= 256); )
        f2 += this[e + --r] * p;
      return f2;
    };
    ge.prototype.readUint8 = ge.prototype.readUInt8 = function(e, r) {
      return e = e >>> 0, r || Pt(e, 1, this.length), this[e];
    };
    ge.prototype.readUint16LE = ge.prototype.readUInt16LE = function(e, r) {
      return e = e >>> 0, r || Pt(e, 2, this.length), this[e] | this[e + 1] << 8;
    };
    ge.prototype.readUint16BE = ge.prototype.readUInt16BE = function(e, r) {
      return e = e >>> 0, r || Pt(e, 2, this.length), this[e] << 8 | this[e + 1];
    };
    ge.prototype.readUint32LE = ge.prototype.readUInt32LE = function(e, r) {
      return e = e >>> 0, r || Pt(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + this[e + 3] * 16777216;
    };
    ge.prototype.readUint32BE = ge.prototype.readUInt32BE = function(e, r) {
      return e = e >>> 0, r || Pt(e, 4, this.length), this[e] * 16777216 + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]);
    };
    ge.prototype.readBigUInt64LE = Pi2(function(e) {
      e = e >>> 0, tf(e, "offset");
      let r = this[e], o = this[e + 7];
      (r === undefined || o === undefined) && Yf(e, this.length - 8);
      let f2 = r + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + this[++e] * 2 ** 24, p = this[++e] + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + o * 2 ** 24;
      return BigInt(f2) + (BigInt(p) << BigInt(32));
    });
    ge.prototype.readBigUInt64BE = Pi2(function(e) {
      e = e >>> 0, tf(e, "offset");
      let r = this[e], o = this[e + 7];
      (r === undefined || o === undefined) && Yf(e, this.length - 8);
      let f2 = r * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + this[++e], p = this[++e] * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + o;
      return (BigInt(f2) << BigInt(32)) + BigInt(p);
    });
    ge.prototype.readIntLE = function(e, r, o) {
      e = e >>> 0, r = r >>> 0, o || Pt(e, r, this.length);
      let f2 = this[e], p = 1, m = 0;
      for (;++m < r && (p *= 256); )
        f2 += this[e + m] * p;
      return p *= 128, f2 >= p && (f2 -= Math.pow(2, 8 * r)), f2;
    };
    ge.prototype.readIntBE = function(e, r, o) {
      e = e >>> 0, r = r >>> 0, o || Pt(e, r, this.length);
      let f2 = r, p = 1, m = this[e + --f2];
      for (;f2 > 0 && (p *= 256); )
        m += this[e + --f2] * p;
      return p *= 128, m >= p && (m -= Math.pow(2, 8 * r)), m;
    };
    ge.prototype.readInt8 = function(e, r) {
      return e = e >>> 0, r || Pt(e, 1, this.length), this[e] & 128 ? (255 - this[e] + 1) * -1 : this[e];
    };
    ge.prototype.readInt16LE = function(e, r) {
      e = e >>> 0, r || Pt(e, 2, this.length);
      let o = this[e] | this[e + 1] << 8;
      return o & 32768 ? o | 4294901760 : o;
    };
    ge.prototype.readInt16BE = function(e, r) {
      e = e >>> 0, r || Pt(e, 2, this.length);
      let o = this[e + 1] | this[e] << 8;
      return o & 32768 ? o | 4294901760 : o;
    };
    ge.prototype.readInt32LE = function(e, r) {
      return e = e >>> 0, r || Pt(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24;
    };
    ge.prototype.readInt32BE = function(e, r) {
      return e = e >>> 0, r || Pt(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3];
    };
    ge.prototype.readBigInt64LE = Pi2(function(e) {
      e = e >>> 0, tf(e, "offset");
      let r = this[e], o = this[e + 7];
      (r === undefined || o === undefined) && Yf(e, this.length - 8);
      let f2 = this[e + 4] + this[e + 5] * 2 ** 8 + this[e + 6] * 2 ** 16 + (o << 24);
      return (BigInt(f2) << BigInt(32)) + BigInt(r + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + this[++e] * 2 ** 24);
    });
    ge.prototype.readBigInt64BE = Pi2(function(e) {
      e = e >>> 0, tf(e, "offset");
      let r = this[e], o = this[e + 7];
      (r === undefined || o === undefined) && Yf(e, this.length - 8);
      let f2 = (r << 24) + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + this[++e];
      return (BigInt(f2) << BigInt(32)) + BigInt(this[++e] * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + o);
    });
    ge.prototype.readFloatLE = function(e, r) {
      return e = e >>> 0, r || Pt(e, 4, this.length), ef.read(this, e, true, 23, 4);
    };
    ge.prototype.readFloatBE = function(e, r) {
      return e = e >>> 0, r || Pt(e, 4, this.length), ef.read(this, e, false, 23, 4);
    };
    ge.prototype.readDoubleLE = function(e, r) {
      return e = e >>> 0, r || Pt(e, 8, this.length), ef.read(this, e, true, 52, 8);
    };
    ge.prototype.readDoubleBE = function(e, r) {
      return e = e >>> 0, r || Pt(e, 8, this.length), ef.read(this, e, false, 52, 8);
    };
    function tr2(t, e, r, o, f2, p) {
      if (!ge.isBuffer(t))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (e > f2 || e < p)
        throw new RangeError('"value" argument is out of bounds');
      if (r + o > t.length)
        throw new RangeError("Index out of range");
    }
    ge.prototype.writeUintLE = ge.prototype.writeUIntLE = function(e, r, o, f2) {
      if (e = +e, r = r >>> 0, o = o >>> 0, !f2) {
        let y = Math.pow(2, 8 * o) - 1;
        tr2(this, e, r, o, y, 0);
      }
      let p = 1, m = 0;
      for (this[r] = e & 255;++m < o && (p *= 256); )
        this[r + m] = e / p & 255;
      return r + o;
    };
    ge.prototype.writeUintBE = ge.prototype.writeUIntBE = function(e, r, o, f2) {
      if (e = +e, r = r >>> 0, o = o >>> 0, !f2) {
        let y = Math.pow(2, 8 * o) - 1;
        tr2(this, e, r, o, y, 0);
      }
      let p = o - 1, m = 1;
      for (this[r + p] = e & 255;--p >= 0 && (m *= 256); )
        this[r + p] = e / m & 255;
      return r + o;
    };
    ge.prototype.writeUint8 = ge.prototype.writeUInt8 = function(e, r, o) {
      return e = +e, r = r >>> 0, o || tr2(this, e, r, 1, 255, 0), this[r] = e & 255, r + 1;
    };
    ge.prototype.writeUint16LE = ge.prototype.writeUInt16LE = function(e, r, o) {
      return e = +e, r = r >>> 0, o || tr2(this, e, r, 2, 65535, 0), this[r] = e & 255, this[r + 1] = e >>> 8, r + 2;
    };
    ge.prototype.writeUint16BE = ge.prototype.writeUInt16BE = function(e, r, o) {
      return e = +e, r = r >>> 0, o || tr2(this, e, r, 2, 65535, 0), this[r] = e >>> 8, this[r + 1] = e & 255, r + 2;
    };
    ge.prototype.writeUint32LE = ge.prototype.writeUInt32LE = function(e, r, o) {
      return e = +e, r = r >>> 0, o || tr2(this, e, r, 4, 4294967295, 0), this[r + 3] = e >>> 24, this[r + 2] = e >>> 16, this[r + 1] = e >>> 8, this[r] = e & 255, r + 4;
    };
    ge.prototype.writeUint32BE = ge.prototype.writeUInt32BE = function(e, r, o) {
      return e = +e, r = r >>> 0, o || tr2(this, e, r, 4, 4294967295, 0), this[r] = e >>> 24, this[r + 1] = e >>> 16, this[r + 2] = e >>> 8, this[r + 3] = e & 255, r + 4;
    };
    function sc(t, e, r, o, f2) {
      cc(e, o, f2, t, r, 7);
      let p = Number(e & BigInt(4294967295));
      t[r++] = p, p = p >> 8, t[r++] = p, p = p >> 8, t[r++] = p, p = p >> 8, t[r++] = p;
      let m = Number(e >> BigInt(32) & BigInt(4294967295));
      return t[r++] = m, m = m >> 8, t[r++] = m, m = m >> 8, t[r++] = m, m = m >> 8, t[r++] = m, r;
    }
    function hc(t, e, r, o, f2) {
      cc(e, o, f2, t, r, 7);
      let p = Number(e & BigInt(4294967295));
      t[r + 7] = p, p = p >> 8, t[r + 6] = p, p = p >> 8, t[r + 5] = p, p = p >> 8, t[r + 4] = p;
      let m = Number(e >> BigInt(32) & BigInt(4294967295));
      return t[r + 3] = m, m = m >> 8, t[r + 2] = m, m = m >> 8, t[r + 1] = m, m = m >> 8, t[r] = m, r + 8;
    }
    ge.prototype.writeBigUInt64LE = Pi2(function(e, r = 0) {
      return sc(this, e, r, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    ge.prototype.writeBigUInt64BE = Pi2(function(e, r = 0) {
      return hc(this, e, r, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    ge.prototype.writeIntLE = function(e, r, o, f2) {
      if (e = +e, r = r >>> 0, !f2) {
        let M = Math.pow(2, 8 * o - 1);
        tr2(this, e, r, o, M - 1, -M);
      }
      let p = 0, m = 1, y = 0;
      for (this[r] = e & 255;++p < o && (m *= 256); )
        e < 0 && y === 0 && this[r + p - 1] !== 0 && (y = 1), this[r + p] = (e / m >> 0) - y & 255;
      return r + o;
    };
    ge.prototype.writeIntBE = function(e, r, o, f2) {
      if (e = +e, r = r >>> 0, !f2) {
        let M = Math.pow(2, 8 * o - 1);
        tr2(this, e, r, o, M - 1, -M);
      }
      let p = o - 1, m = 1, y = 0;
      for (this[r + p] = e & 255;--p >= 0 && (m *= 256); )
        e < 0 && y === 0 && this[r + p + 1] !== 0 && (y = 1), this[r + p] = (e / m >> 0) - y & 255;
      return r + o;
    };
    ge.prototype.writeInt8 = function(e, r, o) {
      return e = +e, r = r >>> 0, o || tr2(this, e, r, 1, 127, -128), e < 0 && (e = 255 + e + 1), this[r] = e & 255, r + 1;
    };
    ge.prototype.writeInt16LE = function(e, r, o) {
      return e = +e, r = r >>> 0, o || tr2(this, e, r, 2, 32767, -32768), this[r] = e & 255, this[r + 1] = e >>> 8, r + 2;
    };
    ge.prototype.writeInt16BE = function(e, r, o) {
      return e = +e, r = r >>> 0, o || tr2(this, e, r, 2, 32767, -32768), this[r] = e >>> 8, this[r + 1] = e & 255, r + 2;
    };
    ge.prototype.writeInt32LE = function(e, r, o) {
      return e = +e, r = r >>> 0, o || tr2(this, e, r, 4, 2147483647, -2147483648), this[r] = e & 255, this[r + 1] = e >>> 8, this[r + 2] = e >>> 16, this[r + 3] = e >>> 24, r + 4;
    };
    ge.prototype.writeInt32BE = function(e, r, o) {
      return e = +e, r = r >>> 0, o || tr2(this, e, r, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), this[r] = e >>> 24, this[r + 1] = e >>> 16, this[r + 2] = e >>> 8, this[r + 3] = e & 255, r + 4;
    };
    ge.prototype.writeBigInt64LE = Pi2(function(e, r = 0) {
      return sc(this, e, r, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    ge.prototype.writeBigInt64BE = Pi2(function(e, r = 0) {
      return hc(this, e, r, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function uc(t, e, r, o, f2, p) {
      if (r + o > t.length)
        throw new RangeError("Index out of range");
      if (r < 0)
        throw new RangeError("Index out of range");
    }
    function lc(t, e, r, o, f2) {
      return e = +e, r = r >>> 0, f2 || uc(t, e, r, 4, 340282346638528860000000000000000000000, -340282346638528860000000000000000000000), ef.write(t, e, r, o, 23, 4), r + 4;
    }
    ge.prototype.writeFloatLE = function(e, r, o) {
      return lc(this, e, r, true, o);
    };
    ge.prototype.writeFloatBE = function(e, r, o) {
      return lc(this, e, r, false, o);
    };
    function dc(t, e, r, o, f2) {
      return e = +e, r = r >>> 0, f2 || uc(t, e, r, 8, 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), ef.write(t, e, r, o, 52, 8), r + 8;
    }
    ge.prototype.writeDoubleLE = function(e, r, o) {
      return dc(this, e, r, true, o);
    };
    ge.prototype.writeDoubleBE = function(e, r, o) {
      return dc(this, e, r, false, o);
    };
    ge.prototype.copy = function(e, r, o, f2) {
      if (!ge.isBuffer(e))
        throw new TypeError("argument should be a Buffer");
      if (o || (o = 0), !f2 && f2 !== 0 && (f2 = this.length), r >= e.length && (r = e.length), r || (r = 0), f2 > 0 && f2 < o && (f2 = o), f2 === o || e.length === 0 || this.length === 0)
        return 0;
      if (r < 0)
        throw new RangeError("targetStart out of bounds");
      if (o < 0 || o >= this.length)
        throw new RangeError("Index out of range");
      if (f2 < 0)
        throw new RangeError("sourceEnd out of bounds");
      f2 > this.length && (f2 = this.length), e.length - r < f2 - o && (f2 = e.length - r + o);
      let p = f2 - o;
      return this === e && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(r, o, f2) : Uint8Array.prototype.set.call(e, this.subarray(o, f2), r), p;
    };
    ge.prototype.fill = function(e, r, o, f2) {
      if (typeof e == "string") {
        if (typeof r == "string" ? (f2 = r, r = 0, o = this.length) : typeof o == "string" && (f2 = o, o = this.length), f2 !== undefined && typeof f2 != "string")
          throw new TypeError("encoding must be a string");
        if (typeof f2 == "string" && !ge.isEncoding(f2))
          throw new TypeError("Unknown encoding: " + f2);
        if (e.length === 1) {
          let m = e.charCodeAt(0);
          (f2 === "utf8" && m < 128 || f2 === "latin1") && (e = m);
        }
      } else
        typeof e == "number" ? e = e & 255 : typeof e == "boolean" && (e = Number(e));
      if (r < 0 || this.length < r || this.length < o)
        throw new RangeError("Out of range index");
      if (o <= r)
        return this;
      r = r >>> 0, o = o === undefined ? this.length : o >>> 0, e || (e = 0);
      let p;
      if (typeof e == "number")
        for (p = r;p < o; ++p)
          this[p] = e;
      else {
        let m = ge.isBuffer(e) ? e : ge.from(e, f2), y = m.length;
        if (y === 0)
          throw new TypeError('The value "' + e + '" is invalid for argument "value"');
        for (p = 0;p < o - r; ++p)
          this[p + r] = m[p % y];
      }
      return this;
    };
    var Qn = {};
    function z0(t, e, r) {
      Qn[t] = class extends r {
        constructor() {
          super(), Object.defineProperty(this, "message", { value: e.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${t}]`, this.stack, delete this.name;
        }
        get code() {
          return t;
        }
        set code(f2) {
          Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: f2, writable: true });
        }
        toString() {
          return `${this.name} [${t}]: ${this.message}`;
        }
      };
    }
    z0("ERR_BUFFER_OUT_OF_BOUNDS", function(t) {
      return t ? `${t} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    }, RangeError);
    z0("ERR_INVALID_ARG_TYPE", function(t, e) {
      return `The "${t}" argument must be of type number. Received type ${typeof e}`;
    }, TypeError);
    z0("ERR_OUT_OF_RANGE", function(t, e, r) {
      let o = `The value of "${t}" is out of range.`, f2 = r;
      return Number.isInteger(r) && Math.abs(r) > 2 ** 32 ? f2 = rc(String(r)) : typeof r == "bigint" && (f2 = String(r), (r > BigInt(2) ** BigInt(32) || r < -(BigInt(2) ** BigInt(32))) && (f2 = rc(f2)), f2 += "n"), o += ` It must be ${e}. Received ${f2}`, o;
    }, RangeError);
    function rc(t) {
      let e = "", r = t.length, o = t[0] === "-" ? 1 : 0;
      for (;r >= o + 4; r -= 3)
        e = `_${t.slice(r - 3, r)}${e}`;
      return `${t.slice(0, r)}${e}`;
    }
    function m6(t, e, r) {
      tf(e, "offset"), (t[e] === undefined || t[e + r] === undefined) && Yf(e, t.length - (r + 1));
    }
    function cc(t, e, r, o, f2, p) {
      if (t > r || t < e) {
        let m = typeof e == "bigint" ? "n" : "", y;
        throw p > 3 ? e === 0 || e === BigInt(0) ? y = `>= 0${m} and < 2${m} ** ${(p + 1) * 8}${m}` : y = `>= -(2${m} ** ${(p + 1) * 8 - 1}${m}) and < 2 ** ${(p + 1) * 8 - 1}${m}` : y = `>= ${e}${m} and <= ${r}${m}`, new Qn.ERR_OUT_OF_RANGE("value", y, t);
      }
      m6(o, f2, p);
    }
    function tf(t, e) {
      if (typeof t != "number")
        throw new Qn.ERR_INVALID_ARG_TYPE(e, "number", t);
    }
    function Yf(t, e, r) {
      throw Math.floor(t) !== t ? (tf(t, r), new Qn.ERR_OUT_OF_RANGE(r || "offset", "an integer", t)) : e < 0 ? new Qn.ERR_BUFFER_OUT_OF_BOUNDS : new Qn.ERR_OUT_OF_RANGE(r || "offset", `>= ${r ? 1 : 0} and <= ${e}`, t);
    }
    var g6 = /[^+/0-9A-Za-z-_]/g;
    function y6(t) {
      if (t = t.split("=")[0], t = t.trim().replace(g6, ""), t.length < 2)
        return "";
      for (;t.length % 4 !== 0; )
        t = t + "=";
      return t;
    }
    function O0(t, e) {
      e = e || 1 / 0;
      let r, o = t.length, f2 = null, p = [];
      for (let m = 0;m < o; ++m) {
        if (r = t.charCodeAt(m), r > 55295 && r < 57344) {
          if (!f2) {
            if (r > 56319) {
              (e -= 3) > -1 && p.push(239, 191, 189);
              continue;
            } else if (m + 1 === o) {
              (e -= 3) > -1 && p.push(239, 191, 189);
              continue;
            }
            f2 = r;
            continue;
          }
          if (r < 56320) {
            (e -= 3) > -1 && p.push(239, 191, 189), f2 = r;
            continue;
          }
          r = (f2 - 55296 << 10 | r - 56320) + 65536;
        } else
          f2 && (e -= 3) > -1 && p.push(239, 191, 189);
        if (f2 = null, r < 128) {
          if ((e -= 1) < 0)
            break;
          p.push(r);
        } else if (r < 2048) {
          if ((e -= 2) < 0)
            break;
          p.push(r >> 6 | 192, r & 63 | 128);
        } else if (r < 65536) {
          if ((e -= 3) < 0)
            break;
          p.push(r >> 12 | 224, r >> 6 & 63 | 128, r & 63 | 128);
        } else if (r < 1114112) {
          if ((e -= 4) < 0)
            break;
          p.push(r >> 18 | 240, r >> 12 & 63 | 128, r >> 6 & 63 | 128, r & 63 | 128);
        } else
          throw new Error("Invalid code point");
      }
      return p;
    }
    function w6(t) {
      let e = [];
      for (let r = 0;r < t.length; ++r)
        e.push(t.charCodeAt(r) & 255);
      return e;
    }
    function M6(t, e) {
      let r, o, f2, p = [];
      for (let m = 0;m < t.length && !((e -= 2) < 0); ++m)
        r = t.charCodeAt(m), o = r >> 8, f2 = r % 256, p.push(f2), p.push(o);
      return p;
    }
    function pc(t) {
      return P0.toByteArray(y6(t));
    }
    function ao(t, e, r, o) {
      let f2;
      for (f2 = 0;f2 < o && !(f2 + r >= e.length || f2 >= t.length); ++f2)
        e[f2 + r] = t[f2];
      return f2;
    }
    function Zr(t, e) {
      return t instanceof e || t != null && t.constructor != null && t.constructor.name != null && t.constructor.name === e.name;
    }
    function H0(t) {
      return t !== t;
    }
    var _6 = function() {
      let t = "0123456789abcdef", e = new Array(256);
      for (let r = 0;r < 16; ++r) {
        let o = r * 16;
        for (let f2 = 0;f2 < 16; ++f2)
          e[o + f2] = t[r] + t[f2];
      }
      return e;
    }();
    function Pi2(t) {
      return typeof BigInt > "u" ? x6 : t;
    }
    function x6() {
      throw new Error("BigInt not supported");
    }
  });
  Te = k((W0, bc) => {
    var oo = Ut(), Vr = oo.Buffer;
    function vc(t, e) {
      for (var r in t)
        e[r] = t[r];
    }
    Vr.from && Vr.alloc && Vr.allocUnsafe && Vr.allocUnsafeSlow ? bc.exports = oo : (vc(oo, W0), W0.Buffer = sn);
    function sn(t, e, r) {
      return Vr(t, e, r);
    }
    sn.prototype = Object.create(Vr.prototype);
    vc(Vr, sn);
    sn.from = function(t, e, r) {
      if (typeof t == "number")
        throw new TypeError("Argument must not be a number");
      return Vr(t, e, r);
    };
    sn.alloc = function(t, e, r) {
      if (typeof t != "number")
        throw new TypeError("Argument must be a number");
      var o = Vr(t);
      return e !== undefined ? typeof r == "string" ? o.fill(e, r) : o.fill(e) : o.fill(0), o;
    };
    sn.allocUnsafe = function(t) {
      if (typeof t != "number")
        throw new TypeError("Argument must be a number");
      return Vr(t);
    };
    sn.allocUnsafeSlow = function(t) {
      if (typeof t != "number")
        throw new TypeError("Argument must be a number");
      return oo.SlowBuffer(t);
    };
  });
  hn = k((zI, j0) => {
    var K0 = 65536, S6 = 4294967295;
    function E6() {
      throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
    }
    var A6 = Te().Buffer, so = global.crypto || global.msCrypto;
    so && so.getRandomValues ? j0.exports = R6 : j0.exports = E6;
    function R6(t, e) {
      if (t > S6)
        throw new RangeError("requested too many random bytes");
      var r = A6.allocUnsafe(t);
      if (t > 0)
        if (t > K0)
          for (var o = 0;o < t; o += K0)
            so.getRandomValues(r.slice(o, o + K0));
        else
          so.getRandomValues(r);
      return typeof e == "function" ? process.nextTick(function() {
        e(null, r);
      }) : r;
    }
  });
  Ie = k((HI, Z0) => {
    typeof Object.create == "function" ? Z0.exports = function(e, r) {
      r && (e.super_ = r, e.prototype = Object.create(r.prototype, { constructor: { value: e, enumerable: false, writable: true, configurable: true } }));
    } : Z0.exports = function(e, r) {
      if (r) {
        e.super_ = r;
        var o = function() {
        };
        o.prototype = r.prototype, e.prototype = new o, e.prototype.constructor = e;
      }
    };
  });
  Di = k((WI, V0) => {
    var nf = typeof Reflect == "object" ? Reflect : null, mc = nf && typeof nf.apply == "function" ? nf.apply : function(e, r, o) {
      return Function.prototype.apply.call(e, r, o);
    }, ho;
    nf && typeof nf.ownKeys == "function" ? ho = nf.ownKeys : Object.getOwnPropertySymbols ? ho = function(e) {
      return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
    } : ho = function(e) {
      return Object.getOwnPropertyNames(e);
    };
    function B6(t) {
      console && console.warn && console.warn(t);
    }
    var yc = Number.isNaN || function(e) {
      return e !== e;
    };
    function Fe() {
      Fe.init.call(this);
    }
    V0.exports = Fe;
    V0.exports.once = k6;
    Fe.EventEmitter = Fe;
    Fe.prototype._events = undefined;
    Fe.prototype._eventsCount = 0;
    Fe.prototype._maxListeners = undefined;
    var gc = 10;
    function uo(t) {
      if (typeof t != "function")
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t);
    }
    Object.defineProperty(Fe, "defaultMaxListeners", { enumerable: true, get: function() {
      return gc;
    }, set: function(t) {
      if (typeof t != "number" || t < 0 || yc(t))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t + ".");
      gc = t;
    } });
    Fe.init = function() {
      (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || undefined;
    };
    Fe.prototype.setMaxListeners = function(e) {
      if (typeof e != "number" || e < 0 || yc(e))
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
      return this._maxListeners = e, this;
    };
    function wc(t) {
      return t._maxListeners === undefined ? Fe.defaultMaxListeners : t._maxListeners;
    }
    Fe.prototype.getMaxListeners = function() {
      return wc(this);
    };
    Fe.prototype.emit = function(e) {
      for (var r = [], o = 1;o < arguments.length; o++)
        r.push(arguments[o]);
      var f2 = e === "error", p = this._events;
      if (p !== undefined)
        f2 = f2 && p.error === undefined;
      else if (!f2)
        return false;
      if (f2) {
        var m;
        if (r.length > 0 && (m = r[0]), m instanceof Error)
          throw m;
        var y = new Error("Unhandled error." + (m ? " (" + m.message + ")" : ""));
        throw y.context = m, y;
      }
      var M = p[e];
      if (M === undefined)
        return false;
      if (typeof M == "function")
        mc(M, this, r);
      else
        for (var x = M.length, S2 = Ec(M, x), o = 0;o < x; ++o)
          mc(S2[o], this, r);
      return true;
    };
    function Mc(t, e, r, o) {
      var f2, p, m;
      if (uo(r), p = t._events, p === undefined ? (p = t._events = Object.create(null), t._eventsCount = 0) : (p.newListener !== undefined && (t.emit("newListener", e, r.listener ? r.listener : r), p = t._events), m = p[e]), m === undefined)
        m = p[e] = r, ++t._eventsCount;
      else if (typeof m == "function" ? m = p[e] = o ? [r, m] : [m, r] : o ? m.unshift(r) : m.push(r), f2 = wc(t), f2 > 0 && m.length > f2 && !m.warned) {
        m.warned = true;
        var y = new Error("Possible EventEmitter memory leak detected. " + m.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
        y.name = "MaxListenersExceededWarning", y.emitter = t, y.type = e, y.count = m.length, B6(y);
      }
      return t;
    }
    Fe.prototype.addListener = function(e, r) {
      return Mc(this, e, r, false);
    };
    Fe.prototype.on = Fe.prototype.addListener;
    Fe.prototype.prependListener = function(e, r) {
      return Mc(this, e, r, true);
    };
    function q6() {
      if (!this.fired)
        return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
    }
    function _c(t, e, r) {
      var o = { fired: false, wrapFn: undefined, target: t, type: e, listener: r }, f2 = q6.bind(o);
      return f2.listener = r, o.wrapFn = f2, f2;
    }
    Fe.prototype.once = function(e, r) {
      return uo(r), this.on(e, _c(this, e, r)), this;
    };
    Fe.prototype.prependOnceListener = function(e, r) {
      return uo(r), this.prependListener(e, _c(this, e, r)), this;
    };
    Fe.prototype.removeListener = function(e, r) {
      var o, f2, p, m, y;
      if (uo(r), f2 = this._events, f2 === undefined)
        return this;
      if (o = f2[e], o === undefined)
        return this;
      if (o === r || o.listener === r)
        --this._eventsCount === 0 ? this._events = Object.create(null) : (delete f2[e], f2.removeListener && this.emit("removeListener", e, o.listener || r));
      else if (typeof o != "function") {
        for (p = -1, m = o.length - 1;m >= 0; m--)
          if (o[m] === r || o[m].listener === r) {
            y = o[m].listener, p = m;
            break;
          }
        if (p < 0)
          return this;
        p === 0 ? o.shift() : I6(o, p), o.length === 1 && (f2[e] = o[0]), f2.removeListener !== undefined && this.emit("removeListener", e, y || r);
      }
      return this;
    };
    Fe.prototype.off = Fe.prototype.removeListener;
    Fe.prototype.removeAllListeners = function(e) {
      var r, o, f2;
      if (o = this._events, o === undefined)
        return this;
      if (o.removeListener === undefined)
        return arguments.length === 0 ? (this._events = Object.create(null), this._eventsCount = 0) : o[e] !== undefined && (--this._eventsCount === 0 ? this._events = Object.create(null) : delete o[e]), this;
      if (arguments.length === 0) {
        var p = Object.keys(o), m;
        for (f2 = 0;f2 < p.length; ++f2)
          m = p[f2], m !== "removeListener" && this.removeAllListeners(m);
        return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this;
      }
      if (r = o[e], typeof r == "function")
        this.removeListener(e, r);
      else if (r !== undefined)
        for (f2 = r.length - 1;f2 >= 0; f2--)
          this.removeListener(e, r[f2]);
      return this;
    };
    function xc(t, e, r) {
      var o = t._events;
      if (o === undefined)
        return [];
      var f2 = o[e];
      return f2 === undefined ? [] : typeof f2 == "function" ? r ? [f2.listener || f2] : [f2] : r ? T6(f2) : Ec(f2, f2.length);
    }
    Fe.prototype.listeners = function(e) {
      return xc(this, e, true);
    };
    Fe.prototype.rawListeners = function(e) {
      return xc(this, e, false);
    };
    Fe.listenerCount = function(t, e) {
      return typeof t.listenerCount == "function" ? t.listenerCount(e) : Sc.call(t, e);
    };
    Fe.prototype.listenerCount = Sc;
    function Sc(t) {
      var e = this._events;
      if (e !== undefined) {
        var r = e[t];
        if (typeof r == "function")
          return 1;
        if (r !== undefined)
          return r.length;
      }
      return 0;
    }
    Fe.prototype.eventNames = function() {
      return this._eventsCount > 0 ? ho(this._events) : [];
    };
    function Ec(t, e) {
      for (var r = new Array(e), o = 0;o < e; ++o)
        r[o] = t[o];
      return r;
    }
    function I6(t, e) {
      for (;e + 1 < t.length; e++)
        t[e] = t[e + 1];
      t.pop();
    }
    function T6(t) {
      for (var e = new Array(t.length), r = 0;r < e.length; ++r)
        e[r] = t[r].listener || t[r];
      return e;
    }
    function k6(t, e) {
      return new Promise(function(r, o) {
        function f2(m) {
          t.removeListener(e, p), o(m);
        }
        function p() {
          typeof t.removeListener == "function" && t.removeListener("error", f2), r([].slice.call(arguments));
        }
        Ac(t, e, p, { once: true }), e !== "error" && L6(t, f2, { once: true });
      });
    }
    function L6(t, e, r) {
      typeof t.on == "function" && Ac(t, "error", e, r);
    }
    function Ac(t, e, r, o) {
      if (typeof t.on == "function")
        o.once ? t.once(e, r) : t.on(e, r);
      else if (typeof t.addEventListener == "function")
        t.addEventListener(e, function f(p) {
          o.once && t.removeEventListener(e, f), r(p);
        });
      else
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t);
    }
  });
  $0 = k((KI, Rc) => {
    Rc.exports = Di().EventEmitter;
  });
  Xf = k(() => {
  });
  Lc = k((VI, kc) => {
    function Bc(t, e) {
      var r = Object.keys(t);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(t);
        e && (o = o.filter(function(f2) {
          return Object.getOwnPropertyDescriptor(t, f2).enumerable;
        })), r.push.apply(r, o);
      }
      return r;
    }
    function qc(t) {
      for (var e = 1;e < arguments.length; e++) {
        var r = arguments[e] != null ? arguments[e] : {};
        e % 2 ? Bc(Object(r), true).forEach(function(o) {
          N6(t, o, r[o]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : Bc(Object(r)).forEach(function(o) {
          Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(r, o));
        });
      }
      return t;
    }
    function N6(t, e, r) {
      return e = Tc(e), (e in t) ? Object.defineProperty(t, e, { value: r, enumerable: true, configurable: true, writable: true }) : t[e] = r, t;
    }
    function P6(t, e) {
      if (!(t instanceof e))
        throw new TypeError("Cannot call a class as a function");
    }
    function Ic(t, e) {
      for (var r = 0;r < e.length; r++) {
        var o = e[r];
        o.enumerable = o.enumerable || false, o.configurable = true, ("value" in o) && (o.writable = true), Object.defineProperty(t, Tc(o.key), o);
      }
    }
    function D6(t, e, r) {
      return e && Ic(t.prototype, e), r && Ic(t, r), Object.defineProperty(t, "prototype", { writable: false }), t;
    }
    function Tc(t) {
      var e = C6(t, "string");
      return typeof e == "symbol" ? e : String(e);
    }
    function C6(t, e) {
      if (typeof t != "object" || t === null)
        return t;
      var r = t[Symbol.toPrimitive];
      if (r !== undefined) {
        var o = r.call(t, e || "default");
        if (typeof o != "object")
          return o;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (e === "string" ? String : Number)(t);
    }
    var O6 = Ut(), lo = O6.Buffer, F6 = Xf(), G0 = F6.inspect, U6 = G0 && G0.custom || "inspect";
    function z6(t, e, r) {
      lo.prototype.copy.call(t, e, r);
    }
    kc.exports = function() {
      function t() {
        P6(this, t), this.head = null, this.tail = null, this.length = 0;
      }
      return D6(t, [{ key: "push", value: function(r) {
        var o = { data: r, next: null };
        this.length > 0 ? this.tail.next = o : this.head = o, this.tail = o, ++this.length;
      } }, { key: "unshift", value: function(r) {
        var o = { data: r, next: this.head };
        this.length === 0 && (this.tail = o), this.head = o, ++this.length;
      } }, { key: "shift", value: function() {
        if (this.length !== 0) {
          var r = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, r;
        }
      } }, { key: "clear", value: function() {
        this.head = this.tail = null, this.length = 0;
      } }, { key: "join", value: function(r) {
        if (this.length === 0)
          return "";
        for (var o = this.head, f2 = "" + o.data;o = o.next; )
          f2 += r + o.data;
        return f2;
      } }, { key: "concat", value: function(r) {
        if (this.length === 0)
          return lo.alloc(0);
        for (var o = lo.allocUnsafe(r >>> 0), f2 = this.head, p = 0;f2; )
          z6(f2.data, o, p), p += f2.data.length, f2 = f2.next;
        return o;
      } }, { key: "consume", value: function(r, o) {
        var f2;
        return r < this.head.data.length ? (f2 = this.head.data.slice(0, r), this.head.data = this.head.data.slice(r)) : r === this.head.data.length ? f2 = this.shift() : f2 = o ? this._getString(r) : this._getBuffer(r), f2;
      } }, { key: "first", value: function() {
        return this.head.data;
      } }, { key: "_getString", value: function(r) {
        var o = this.head, f2 = 1, p = o.data;
        for (r -= p.length;o = o.next; ) {
          var m = o.data, y = r > m.length ? m.length : r;
          if (y === m.length ? p += m : p += m.slice(0, r), r -= y, r === 0) {
            y === m.length ? (++f2, o.next ? this.head = o.next : this.head = this.tail = null) : (this.head = o, o.data = m.slice(y));
            break;
          }
          ++f2;
        }
        return this.length -= f2, p;
      } }, { key: "_getBuffer", value: function(r) {
        var o = lo.allocUnsafe(r), f2 = this.head, p = 1;
        for (f2.data.copy(o), r -= f2.data.length;f2 = f2.next; ) {
          var m = f2.data, y = r > m.length ? m.length : r;
          if (m.copy(o, o.length - r, 0, y), r -= y, r === 0) {
            y === m.length ? (++p, f2.next ? this.head = f2.next : this.head = this.tail = null) : (this.head = f2, f2.data = m.slice(y));
            break;
          }
          ++p;
        }
        return this.length -= p, o;
      } }, { key: U6, value: function(r, o) {
        return G0(this, qc(qc({}, o), {}, { depth: 0, customInspect: false }));
      } }]), t;
    }();
  });
  X0 = k(($I, Pc) => {
    function H6(t, e) {
      var r = this, o = this._readableState && this._readableState.destroyed, f2 = this._writableState && this._writableState.destroyed;
      return o || f2 ? (e ? e(t) : t && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = true, process.nextTick(Y0, this, t)) : process.nextTick(Y0, this, t)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(t || null, function(p) {
        !e && p ? r._writableState ? r._writableState.errorEmitted ? process.nextTick(co, r) : (r._writableState.errorEmitted = true, process.nextTick(Nc, r, p)) : process.nextTick(Nc, r, p) : e ? (process.nextTick(co, r), e(p)) : process.nextTick(co, r);
      }), this);
    }
    function Nc(t, e) {
      Y0(t, e), co(t);
    }
    function co(t) {
      t._writableState && !t._writableState.emitClose || t._readableState && !t._readableState.emitClose || t.emit("close");
    }
    function W6() {
      this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
    }
    function Y0(t, e) {
      t.emit("error", e);
    }
    function K6(t, e) {
      var { _readableState: r, _writableState: o } = t;
      r && r.autoDestroy || o && o.autoDestroy ? t.destroy(e) : t.emit("error", e);
    }
    Pc.exports = { destroy: H6, undestroy: W6, errorOrDestroy: K6 };
  });
  un = k((GI, Oc) => {
    function j6(t, e) {
      t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;
    }
    var Cc = {};
    function dr2(t, e, r) {
      r || (r = Error);
      function o(p, m, y) {
        return typeof e == "string" ? e : e(p, m, y);
      }
      var f2 = function(p) {
        j6(m, p);
        function m(y, M, x) {
          return p.call(this, o(y, M, x)) || this;
        }
        return m;
      }(r);
      f2.prototype.name = r.name, f2.prototype.code = t, Cc[t] = f2;
    }
    function Dc(t, e) {
      if (Array.isArray(t)) {
        var r = t.length;
        return t = t.map(function(o) {
          return String(o);
        }), r > 2 ? "one of ".concat(e, " ").concat(t.slice(0, r - 1).join(", "), ", or ") + t[r - 1] : r === 2 ? "one of ".concat(e, " ").concat(t[0], " or ").concat(t[1]) : "of ".concat(e, " ").concat(t[0]);
      } else
        return "of ".concat(e, " ").concat(String(t));
    }
    function Z6(t, e, r) {
      return t.substr(!r || r < 0 ? 0 : +r, e.length) === e;
    }
    function V6(t, e, r) {
      return (r === undefined || r > t.length) && (r = t.length), t.substring(r - e.length, r) === e;
    }
    function $6(t, e, r) {
      return typeof r != "number" && (r = 0), r + e.length > t.length ? false : t.indexOf(e, r) !== -1;
    }
    dr2("ERR_INVALID_OPT_VALUE", function(t, e) {
      return 'The value "' + e + '" is invalid for option "' + t + '"';
    }, TypeError);
    dr2("ERR_INVALID_ARG_TYPE", function(t, e, r) {
      var o;
      typeof e == "string" && Z6(e, "not ") ? (o = "must not be", e = e.replace(/^not /, "")) : o = "must be";
      var f2;
      if (V6(t, " argument"))
        f2 = "The ".concat(t, " ").concat(o, " ").concat(Dc(e, "type"));
      else {
        var p = $6(t, ".") ? "property" : "argument";
        f2 = 'The "'.concat(t, '" ').concat(p, " ").concat(o, " ").concat(Dc(e, "type"));
      }
      return f2 += ". Received type ".concat(typeof r), f2;
    }, TypeError);
    dr2("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    dr2("ERR_METHOD_NOT_IMPLEMENTED", function(t) {
      return "The " + t + " method is not implemented";
    });
    dr2("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    dr2("ERR_STREAM_DESTROYED", function(t) {
      return "Cannot call " + t + " after a stream was destroyed";
    });
    dr2("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    dr2("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    dr2("ERR_STREAM_WRITE_AFTER_END", "write after end");
    dr2("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    dr2("ERR_UNKNOWN_ENCODING", function(t) {
      return "Unknown encoding: " + t;
    }, TypeError);
    dr2("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    Oc.exports.codes = Cc;
  });
  J0 = k((YI, Fc) => {
    var G6 = un().codes.ERR_INVALID_OPT_VALUE;
    function Y6(t, e, r) {
      return t.highWaterMark != null ? t.highWaterMark : e ? t[r] : null;
    }
    function X6(t, e, r, o) {
      var f2 = Y6(e, o, r);
      if (f2 != null) {
        if (!(isFinite(f2) && Math.floor(f2) === f2) || f2 < 0) {
          var p = o ? r : "highWaterMark";
          throw new G6(p, f2);
        }
        return Math.floor(f2);
      }
      return t.objectMode ? 16 : 16 * 1024;
    }
    Fc.exports = { getHighWaterMark: X6 };
  });
  eh = k((XI, Uc) => {
    Uc.exports = J6;
    function J6(t, e) {
      if (Q0("noDeprecation"))
        return t;
      var r = false;
      function o() {
        if (!r) {
          if (Q0("throwDeprecation"))
            throw new Error(e);
          Q0("traceDeprecation") ? console.trace(e) : console.warn(e), r = true;
        }
        return t.apply(this, arguments);
      }
      return o;
    }
    function Q0(t) {
      try {
        if (!global.localStorage)
          return false;
      } catch {
        return false;
      }
      var e = global.localStorage[t];
      return e == null ? false : String(e).toLowerCase() === "true";
    }
  });
  ih = k((JI, Zc) => {
    Zc.exports = ht;
    function Hc(t) {
      var e = this;
      this.next = null, this.entry = null, this.finish = function() {
        EM(e, t);
      };
    }
    var ff;
    ht.WritableState = Qf;
    var Q6 = { deprecate: eh() }, Wc = $0(), vo = Ut().Buffer, eM = (typeof global < "u" ? global : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
    };
    function tM(t) {
      return vo.from(t);
    }
    function rM(t) {
      return vo.isBuffer(t) || t instanceof eM;
    }
    var rh = X0(), iM = J0(), nM = iM.getHighWaterMark, Ci = un().codes, fM = Ci.ERR_INVALID_ARG_TYPE, aM = Ci.ERR_METHOD_NOT_IMPLEMENTED, oM = Ci.ERR_MULTIPLE_CALLBACK, sM = Ci.ERR_STREAM_CANNOT_PIPE, hM = Ci.ERR_STREAM_DESTROYED, uM = Ci.ERR_STREAM_NULL_VALUES, lM = Ci.ERR_STREAM_WRITE_AFTER_END, dM = Ci.ERR_UNKNOWN_ENCODING, af = rh.errorOrDestroy;
    Ie()(ht, Wc);
    function cM() {
    }
    function Qf(t, e, r) {
      ff = ff || ln(), t = t || {}, typeof r != "boolean" && (r = e instanceof ff), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.writableObjectMode), this.highWaterMark = nM(this, t, "writableHighWaterMark", r), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
      var o = t.decodeStrings === false;
      this.decodeStrings = !o, this.defaultEncoding = t.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(f2) {
        wM(e, f2);
      }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = t.emitClose !== false, this.autoDestroy = !!t.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new Hc(this);
    }
    Qf.prototype.getBuffer = function() {
      for (var e = this.bufferedRequest, r = [];e; )
        r.push(e), e = e.next;
      return r;
    };
    (function() {
      try {
        Object.defineProperty(Qf.prototype, "buffer", { get: Q6.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
      } catch {
      }
    })();
    var po;
    typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (po = Function.prototype[Symbol.hasInstance], Object.defineProperty(ht, Symbol.hasInstance, { value: function(e) {
      return po.call(this, e) ? true : this !== ht ? false : e && e._writableState instanceof Qf;
    } })) : po = function(e) {
      return e instanceof this;
    };
    function ht(t) {
      ff = ff || ln();
      var e = this instanceof ff;
      if (!e && !po.call(ht, this))
        return new ht(t);
      this._writableState = new Qf(t, this, e), this.writable = true, t && (typeof t.write == "function" && (this._write = t.write), typeof t.writev == "function" && (this._writev = t.writev), typeof t.destroy == "function" && (this._destroy = t.destroy), typeof t.final == "function" && (this._final = t.final)), Wc.call(this);
    }
    ht.prototype.pipe = function() {
      af(this, new sM);
    };
    function pM(t, e) {
      var r = new lM;
      af(t, r), process.nextTick(e, r);
    }
    function vM(t, e, r, o) {
      var f2;
      return r === null ? f2 = new uM : typeof r != "string" && !e.objectMode && (f2 = new fM("chunk", ["string", "Buffer"], r)), f2 ? (af(t, f2), process.nextTick(o, f2), false) : true;
    }
    ht.prototype.write = function(t, e, r) {
      var o = this._writableState, f2 = false, p = !o.objectMode && rM(t);
      return p && !vo.isBuffer(t) && (t = tM(t)), typeof e == "function" && (r = e, e = null), p ? e = "buffer" : e || (e = o.defaultEncoding), typeof r != "function" && (r = cM), o.ending ? pM(this, r) : (p || vM(this, o, t, r)) && (o.pendingcb++, f2 = mM(this, o, p, t, e, r)), f2;
    };
    ht.prototype.cork = function() {
      this._writableState.corked++;
    };
    ht.prototype.uncork = function() {
      var t = this._writableState;
      t.corked && (t.corked--, !t.writing && !t.corked && !t.bufferProcessing && t.bufferedRequest && Kc(this, t));
    };
    ht.prototype.setDefaultEncoding = function(e) {
      if (typeof e == "string" && (e = e.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e + "").toLowerCase()) > -1))
        throw new dM(e);
      return this._writableState.defaultEncoding = e, this;
    };
    Object.defineProperty(ht.prototype, "writableBuffer", { enumerable: false, get: function() {
      return this._writableState && this._writableState.getBuffer();
    } });
    function bM(t, e, r) {
      return !t.objectMode && t.decodeStrings !== false && typeof e == "string" && (e = vo.from(e, r)), e;
    }
    Object.defineProperty(ht.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
      return this._writableState.highWaterMark;
    } });
    function mM(t, e, r, o, f2, p) {
      if (!r) {
        var m = bM(e, o, f2);
        o !== m && (r = true, f2 = "buffer", o = m);
      }
      var y = e.objectMode ? 1 : o.length;
      e.length += y;
      var M = e.length < e.highWaterMark;
      if (M || (e.needDrain = true), e.writing || e.corked) {
        var x = e.lastBufferedRequest;
        e.lastBufferedRequest = { chunk: o, encoding: f2, isBuf: r, callback: p, next: null }, x ? x.next = e.lastBufferedRequest : e.bufferedRequest = e.lastBufferedRequest, e.bufferedRequestCount += 1;
      } else
        th(t, e, false, y, o, f2, p);
      return M;
    }
    function th(t, e, r, o, f2, p, m) {
      e.writelen = o, e.writecb = m, e.writing = true, e.sync = true, e.destroyed ? e.onwrite(new hM("write")) : r ? t._writev(f2, e.onwrite) : t._write(f2, p, e.onwrite), e.sync = false;
    }
    function gM(t, e, r, o, f2) {
      --e.pendingcb, r ? (process.nextTick(f2, o), process.nextTick(Jf, t, e), t._writableState.errorEmitted = true, af(t, o)) : (f2(o), t._writableState.errorEmitted = true, af(t, o), Jf(t, e));
    }
    function yM(t) {
      t.writing = false, t.writecb = null, t.length -= t.writelen, t.writelen = 0;
    }
    function wM(t, e) {
      var r = t._writableState, o = r.sync, f2 = r.writecb;
      if (typeof f2 != "function")
        throw new oM;
      if (yM(r), e)
        gM(t, r, o, e, f2);
      else {
        var p = jc(r) || t.destroyed;
        !p && !r.corked && !r.bufferProcessing && r.bufferedRequest && Kc(t, r), o ? process.nextTick(zc, t, r, p, f2) : zc(t, r, p, f2);
      }
    }
    function zc(t, e, r, o) {
      r || MM(t, e), e.pendingcb--, o(), Jf(t, e);
    }
    function MM(t, e) {
      e.length === 0 && e.needDrain && (e.needDrain = false, t.emit("drain"));
    }
    function Kc(t, e) {
      e.bufferProcessing = true;
      var r = e.bufferedRequest;
      if (t._writev && r && r.next) {
        var o = e.bufferedRequestCount, f2 = new Array(o), p = e.corkedRequestsFree;
        p.entry = r;
        for (var m = 0, y = true;r; )
          f2[m] = r, r.isBuf || (y = false), r = r.next, m += 1;
        f2.allBuffers = y, th(t, e, true, e.length, f2, "", p.finish), e.pendingcb++, e.lastBufferedRequest = null, p.next ? (e.corkedRequestsFree = p.next, p.next = null) : e.corkedRequestsFree = new Hc(e), e.bufferedRequestCount = 0;
      } else {
        for (;r; ) {
          var { chunk: M, encoding: x, callback: S2 } = r, E = e.objectMode ? 1 : M.length;
          if (th(t, e, false, E, M, x, S2), r = r.next, e.bufferedRequestCount--, e.writing)
            break;
        }
        r === null && (e.lastBufferedRequest = null);
      }
      e.bufferedRequest = r, e.bufferProcessing = false;
    }
    ht.prototype._write = function(t, e, r) {
      r(new aM("_write()"));
    };
    ht.prototype._writev = null;
    ht.prototype.end = function(t, e, r) {
      var o = this._writableState;
      return typeof t == "function" ? (r = t, t = null, e = null) : typeof e == "function" && (r = e, e = null), t != null && this.write(t, e), o.corked && (o.corked = 1, this.uncork()), o.ending || SM(this, o, r), this;
    };
    Object.defineProperty(ht.prototype, "writableLength", { enumerable: false, get: function() {
      return this._writableState.length;
    } });
    function jc(t) {
      return t.ending && t.length === 0 && t.bufferedRequest === null && !t.finished && !t.writing;
    }
    function _M(t, e) {
      t._final(function(r) {
        e.pendingcb--, r && af(t, r), e.prefinished = true, t.emit("prefinish"), Jf(t, e);
      });
    }
    function xM(t, e) {
      !e.prefinished && !e.finalCalled && (typeof t._final == "function" && !e.destroyed ? (e.pendingcb++, e.finalCalled = true, process.nextTick(_M, t, e)) : (e.prefinished = true, t.emit("prefinish")));
    }
    function Jf(t, e) {
      var r = jc(e);
      if (r && (xM(t, e), e.pendingcb === 0 && (e.finished = true, t.emit("finish"), e.autoDestroy))) {
        var o = t._readableState;
        (!o || o.autoDestroy && o.endEmitted) && t.destroy();
      }
      return r;
    }
    function SM(t, e, r) {
      e.ending = true, Jf(t, e), r && (e.finished ? process.nextTick(r) : t.once("finish", r)), e.ended = true, t.writable = false;
    }
    function EM(t, e, r) {
      var o = t.entry;
      for (t.entry = null;o; ) {
        var f2 = o.callback;
        e.pendingcb--, f2(r), o = o.next;
      }
      e.corkedRequestsFree.next = t;
    }
    Object.defineProperty(ht.prototype, "destroyed", { enumerable: false, get: function() {
      return this._writableState === undefined ? false : this._writableState.destroyed;
    }, set: function(e) {
      !this._writableState || (this._writableState.destroyed = e);
    } });
    ht.prototype.destroy = rh.destroy;
    ht.prototype._undestroy = rh.undestroy;
    ht.prototype._destroy = function(t, e) {
      e(t);
    };
  });
  ln = k((QI, $c) => {
    var AM = Object.keys || function(t) {
      var e = [];
      for (var r in t)
        e.push(r);
      return e;
    };
    $c.exports = $r;
    var Vc = ah(), fh = ih();
    Ie()($r, Vc);
    for (nh = AM(fh.prototype), bo = 0;bo < nh.length; bo++)
      mo = nh[bo], $r.prototype[mo] || ($r.prototype[mo] = fh.prototype[mo]);
    var nh, mo, bo;
    function $r(t) {
      if (!(this instanceof $r))
        return new $r(t);
      Vc.call(this, t), fh.call(this, t), this.allowHalfOpen = true, t && (t.readable === false && (this.readable = false), t.writable === false && (this.writable = false), t.allowHalfOpen === false && (this.allowHalfOpen = false, this.once("end", RM)));
    }
    Object.defineProperty($r.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
      return this._writableState.highWaterMark;
    } });
    Object.defineProperty($r.prototype, "writableBuffer", { enumerable: false, get: function() {
      return this._writableState && this._writableState.getBuffer();
    } });
    Object.defineProperty($r.prototype, "writableLength", { enumerable: false, get: function() {
      return this._writableState.length;
    } });
    function RM() {
      this._writableState.ended || process.nextTick(BM, this);
    }
    function BM(t) {
      t.end();
    }
    Object.defineProperty($r.prototype, "destroyed", { enumerable: false, get: function() {
      return this._readableState === undefined || this._writableState === undefined ? false : this._readableState.destroyed && this._writableState.destroyed;
    }, set: function(e) {
      this._readableState === undefined || this._writableState === undefined || (this._readableState.destroyed = e, this._writableState.destroyed = e);
    } });
  });
  go = k((Yc) => {
    var sh = Te().Buffer, Gc = sh.isEncoding || function(t) {
      switch (t = "" + t, t && t.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function qM(t) {
      if (!t)
        return "utf8";
      for (var e;; )
        switch (t) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return t;
          default:
            if (e)
              return;
            t = ("" + t).toLowerCase(), e = true;
        }
    }
    function IM(t) {
      var e = qM(t);
      if (typeof e != "string" && (sh.isEncoding === Gc || !Gc(t)))
        throw new Error("Unknown encoding: " + t);
      return e || t;
    }
    Yc.StringDecoder = ea;
    function ea(t) {
      this.encoding = IM(t);
      var e;
      switch (this.encoding) {
        case "utf16le":
          this.text = DM, this.end = CM, e = 4;
          break;
        case "utf8":
          this.fillLast = LM, e = 4;
          break;
        case "base64":
          this.text = OM, this.end = FM, e = 3;
          break;
        default:
          this.write = UM, this.end = zM;
          return;
      }
      this.lastNeed = 0, this.lastTotal = 0, this.lastChar = sh.allocUnsafe(e);
    }
    ea.prototype.write = function(t) {
      if (t.length === 0)
        return "";
      var e, r;
      if (this.lastNeed) {
        if (e = this.fillLast(t), e === undefined)
          return "";
        r = this.lastNeed, this.lastNeed = 0;
      } else
        r = 0;
      return r < t.length ? e ? e + this.text(t, r) : this.text(t, r) : e || "";
    };
    ea.prototype.end = PM;
    ea.prototype.text = NM;
    ea.prototype.fillLast = function(t) {
      if (this.lastNeed <= t.length)
        return t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, t.length), this.lastNeed -= t.length;
    };
    function oh(t) {
      return t <= 127 ? 0 : t >> 5 === 6 ? 2 : t >> 4 === 14 ? 3 : t >> 3 === 30 ? 4 : t >> 6 === 2 ? -1 : -2;
    }
    function TM(t, e, r) {
      var o = e.length - 1;
      if (o < r)
        return 0;
      var f2 = oh(e[o]);
      return f2 >= 0 ? (f2 > 0 && (t.lastNeed = f2 - 1), f2) : --o < r || f2 === -2 ? 0 : (f2 = oh(e[o]), f2 >= 0 ? (f2 > 0 && (t.lastNeed = f2 - 2), f2) : --o < r || f2 === -2 ? 0 : (f2 = oh(e[o]), f2 >= 0 ? (f2 > 0 && (f2 === 2 ? f2 = 0 : t.lastNeed = f2 - 3), f2) : 0));
    }
    function kM(t, e, r) {
      if ((e[0] & 192) !== 128)
        return t.lastNeed = 0, "\uFFFD";
      if (t.lastNeed > 1 && e.length > 1) {
        if ((e[1] & 192) !== 128)
          return t.lastNeed = 1, "\uFFFD";
        if (t.lastNeed > 2 && e.length > 2 && (e[2] & 192) !== 128)
          return t.lastNeed = 2, "\uFFFD";
      }
    }
    function LM(t) {
      var e = this.lastTotal - this.lastNeed, r = kM(this, t, e);
      if (r !== undefined)
        return r;
      if (this.lastNeed <= t.length)
        return t.copy(this.lastChar, e, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      t.copy(this.lastChar, e, 0, t.length), this.lastNeed -= t.length;
    }
    function NM(t, e) {
      var r = TM(this, t, e);
      if (!this.lastNeed)
        return t.toString("utf8", e);
      this.lastTotal = r;
      var o = t.length - (r - this.lastNeed);
      return t.copy(this.lastChar, 0, o), t.toString("utf8", e, o);
    }
    function PM(t) {
      var e = t && t.length ? this.write(t) : "";
      return this.lastNeed ? e + "\uFFFD" : e;
    }
    function DM(t, e) {
      if ((t.length - e) % 2 === 0) {
        var r = t.toString("utf16le", e);
        if (r) {
          var o = r.charCodeAt(r.length - 1);
          if (o >= 55296 && o <= 56319)
            return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1], r.slice(0, -1);
        }
        return r;
      }
      return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = t[t.length - 1], t.toString("utf16le", e, t.length - 1);
    }
    function CM(t) {
      var e = t && t.length ? this.write(t) : "";
      if (this.lastNeed) {
        var r = this.lastTotal - this.lastNeed;
        return e + this.lastChar.toString("utf16le", 0, r);
      }
      return e;
    }
    function OM(t, e) {
      var r = (t.length - e) % 3;
      return r === 0 ? t.toString("base64", e) : (this.lastNeed = 3 - r, this.lastTotal = 3, r === 1 ? this.lastChar[0] = t[t.length - 1] : (this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1]), t.toString("base64", e, t.length - r));
    }
    function FM(t) {
      var e = t && t.length ? this.write(t) : "";
      return this.lastNeed ? e + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : e;
    }
    function UM(t) {
      return t.toString(this.encoding);
    }
    function zM(t) {
      return t && t.length ? this.write(t) : "";
    }
  });
  ta = {};
  io(ta, { StringDecoder: () => yo.StringDecoder, default: () => yo.StringDecoder });
  ra = k0(() => {
    yo = fn(go());
  });
  wo = k((tT, Qc) => {
    var Xc = un().codes.ERR_STREAM_PREMATURE_CLOSE;
    function HM(t) {
      var e = false;
      return function() {
        if (!e) {
          e = true;
          for (var r = arguments.length, o = new Array(r), f2 = 0;f2 < r; f2++)
            o[f2] = arguments[f2];
          t.apply(this, o);
        }
      };
    }
    function WM() {
    }
    function KM(t) {
      return t.setHeader && typeof t.abort == "function";
    }
    function Jc(t, e, r) {
      if (typeof e == "function")
        return Jc(t, null, e);
      e || (e = {}), r = HM(r || WM);
      var o = e.readable || e.readable !== false && t.readable, f2 = e.writable || e.writable !== false && t.writable, p = function() {
        t.writable || y();
      }, m = t._writableState && t._writableState.finished, y = function() {
        f2 = false, m = true, o || r.call(t);
      }, M = t._readableState && t._readableState.endEmitted, x = function() {
        o = false, M = true, f2 || r.call(t);
      }, S2 = function(T) {
        r.call(t, T);
      }, E = function() {
        var T;
        if (o && !M)
          return (!t._readableState || !t._readableState.ended) && (T = new Xc), r.call(t, T);
        if (f2 && !m)
          return (!t._writableState || !t._writableState.ended) && (T = new Xc), r.call(t, T);
      }, R = function() {
        t.req.on("finish", y);
      };
      return KM(t) ? (t.on("complete", y), t.on("abort", E), t.req ? R() : t.on("request", R)) : f2 && !t._writableState && (t.on("end", p), t.on("close", p)), t.on("end", x), t.on("finish", y), e.error !== false && t.on("error", S2), t.on("close", E), function() {
        t.removeListener("complete", y), t.removeListener("abort", E), t.removeListener("request", R), t.req && t.req.removeListener("finish", y), t.removeListener("end", p), t.removeListener("close", p), t.removeListener("finish", y), t.removeListener("end", x), t.removeListener("error", S2), t.removeListener("close", E);
      };
    }
    Qc.exports = Jc;
  });
  tp = k((rT, ep) => {
    var Mo;
    function Oi(t, e, r) {
      return e = jM(e), (e in t) ? Object.defineProperty(t, e, { value: r, enumerable: true, configurable: true, writable: true }) : t[e] = r, t;
    }
    function jM(t) {
      var e = ZM(t, "string");
      return typeof e == "symbol" ? e : String(e);
    }
    function ZM(t, e) {
      if (typeof t != "object" || t === null)
        return t;
      var r = t[Symbol.toPrimitive];
      if (r !== undefined) {
        var o = r.call(t, e || "default");
        if (typeof o != "object")
          return o;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (e === "string" ? String : Number)(t);
    }
    var VM = wo(), Fi = Symbol("lastResolve"), dn = Symbol("lastReject"), ia = Symbol("error"), _o = Symbol("ended"), cn = Symbol("lastPromise"), hh = Symbol("handlePromise"), pn = Symbol("stream");
    function Ui(t, e) {
      return { value: t, done: e };
    }
    function $M(t) {
      var e = t[Fi];
      if (e !== null) {
        var r = t[pn].read();
        r !== null && (t[cn] = null, t[Fi] = null, t[dn] = null, e(Ui(r, false)));
      }
    }
    function GM(t) {
      process.nextTick($M, t);
    }
    function YM(t, e) {
      return function(r, o) {
        t.then(function() {
          if (e[_o]) {
            r(Ui(undefined, true));
            return;
          }
          e[hh](r, o);
        }, o);
      };
    }
    var XM = Object.getPrototypeOf(function() {
    }), JM = Object.setPrototypeOf((Mo = { get stream() {
      return this[pn];
    }, next: function() {
      var e = this, r = this[ia];
      if (r !== null)
        return Promise.reject(r);
      if (this[_o])
        return Promise.resolve(Ui(undefined, true));
      if (this[pn].destroyed)
        return new Promise(function(m, y) {
          process.nextTick(function() {
            e[ia] ? y(e[ia]) : m(Ui(undefined, true));
          });
        });
      var o = this[cn], f2;
      if (o)
        f2 = new Promise(YM(o, this));
      else {
        var p = this[pn].read();
        if (p !== null)
          return Promise.resolve(Ui(p, false));
        f2 = new Promise(this[hh]);
      }
      return this[cn] = f2, f2;
    } }, Oi(Mo, Symbol.asyncIterator, function() {
      return this;
    }), Oi(Mo, "return", function() {
      var e = this;
      return new Promise(function(r, o) {
        e[pn].destroy(null, function(f2) {
          if (f2) {
            o(f2);
            return;
          }
          r(Ui(undefined, true));
        });
      });
    }), Mo), XM), QM = function(e) {
      var r, o = Object.create(JM, (r = {}, Oi(r, pn, { value: e, writable: true }), Oi(r, Fi, { value: null, writable: true }), Oi(r, dn, { value: null, writable: true }), Oi(r, ia, { value: null, writable: true }), Oi(r, _o, { value: e._readableState.endEmitted, writable: true }), Oi(r, hh, { value: function(p, m) {
        var y = o[pn].read();
        y ? (o[cn] = null, o[Fi] = null, o[dn] = null, p(Ui(y, false))) : (o[Fi] = p, o[dn] = m);
      }, writable: true }), r));
      return o[cn] = null, VM(e, function(f2) {
        if (f2 && f2.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var p = o[dn];
          p !== null && (o[cn] = null, o[Fi] = null, o[dn] = null, p(f2)), o[ia] = f2;
          return;
        }
        var m = o[Fi];
        m !== null && (o[cn] = null, o[Fi] = null, o[dn] = null, m(Ui(undefined, true))), o[_o] = true;
      }), e.on("readable", GM.bind(null, o)), o;
    };
    ep.exports = QM;
  });
  ip = k((iT, rp) => {
    rp.exports = function() {
      throw new Error("Readable.from is not available in the browser");
    };
  });
  ah = k((fT, cp) => {
    cp.exports = Ce;
    var of;
    Ce.ReadableState = op;
    var nT = Di().EventEmitter, ap = function(e, r) {
      return e.listeners(r).length;
    }, fa = $0(), xo = Ut().Buffer, e4 = (typeof global < "u" ? global : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
    };
    function t4(t) {
      return xo.from(t);
    }
    function r4(t) {
      return xo.isBuffer(t) || t instanceof e4;
    }
    var uh = Xf(), Ne;
    uh && uh.debuglog ? Ne = uh.debuglog("stream") : Ne = function() {
    };
    var i4 = Lc(), mh = X0(), n4 = J0(), f4 = n4.getHighWaterMark, So = un().codes, a4 = So.ERR_INVALID_ARG_TYPE, o4 = So.ERR_STREAM_PUSH_AFTER_EOF, s4 = So.ERR_METHOD_NOT_IMPLEMENTED, h4 = So.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, sf, lh, dh;
    Ie()(Ce, fa);
    var na = mh.errorOrDestroy, ch = ["error", "close", "destroy", "pause", "resume"];
    function u4(t, e, r) {
      if (typeof t.prependListener == "function")
        return t.prependListener(e, r);
      !t._events || !t._events[e] ? t.on(e, r) : Array.isArray(t._events[e]) ? t._events[e].unshift(r) : t._events[e] = [r, t._events[e]];
    }
    function op(t, e, r) {
      of = of || ln(), t = t || {}, typeof r != "boolean" && (r = e instanceof of), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.readableObjectMode), this.highWaterMark = f4(this, t, "readableHighWaterMark", r), this.buffer = new i4, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = t.emitClose !== false, this.autoDestroy = !!t.autoDestroy, this.destroyed = false, this.defaultEncoding = t.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, t.encoding && (sf || (sf = (ra(), ur(ta)).StringDecoder), this.decoder = new sf(t.encoding), this.encoding = t.encoding);
    }
    function Ce(t) {
      if (of = of || ln(), !(this instanceof Ce))
        return new Ce(t);
      var e = this instanceof of;
      this._readableState = new op(t, this, e), this.readable = true, t && (typeof t.read == "function" && (this._read = t.read), typeof t.destroy == "function" && (this._destroy = t.destroy)), fa.call(this);
    }
    Object.defineProperty(Ce.prototype, "destroyed", { enumerable: false, get: function() {
      return this._readableState === undefined ? false : this._readableState.destroyed;
    }, set: function(e) {
      !this._readableState || (this._readableState.destroyed = e);
    } });
    Ce.prototype.destroy = mh.destroy;
    Ce.prototype._undestroy = mh.undestroy;
    Ce.prototype._destroy = function(t, e) {
      e(t);
    };
    Ce.prototype.push = function(t, e) {
      var r = this._readableState, o;
      return r.objectMode ? o = true : typeof t == "string" && (e = e || r.defaultEncoding, e !== r.encoding && (t = xo.from(t, e), e = ""), o = true), sp(this, t, e, false, o);
    };
    Ce.prototype.unshift = function(t) {
      return sp(this, t, null, true, false);
    };
    function sp(t, e, r, o, f2) {
      Ne("readableAddChunk", e);
      var p = t._readableState;
      if (e === null)
        p.reading = false, c4(t, p);
      else {
        var m;
        if (f2 || (m = l4(p, e)), m)
          na(t, m);
        else if (p.objectMode || e && e.length > 0)
          if (typeof e != "string" && !p.objectMode && Object.getPrototypeOf(e) !== xo.prototype && (e = t4(e)), o)
            p.endEmitted ? na(t, new h4) : ph(t, p, e, true);
          else if (p.ended)
            na(t, new o4);
          else {
            if (p.destroyed)
              return false;
            p.reading = false, p.decoder && !r ? (e = p.decoder.write(e), p.objectMode || e.length !== 0 ? ph(t, p, e, false) : bh(t, p)) : ph(t, p, e, false);
          }
        else
          o || (p.reading = false, bh(t, p));
      }
      return !p.ended && (p.length < p.highWaterMark || p.length === 0);
    }
    function ph(t, e, r, o) {
      e.flowing && e.length === 0 && !e.sync ? (e.awaitDrain = 0, t.emit("data", r)) : (e.length += e.objectMode ? 1 : r.length, o ? e.buffer.unshift(r) : e.buffer.push(r), e.needReadable && Eo(t)), bh(t, e);
    }
    function l4(t, e) {
      var r;
      return !r4(e) && typeof e != "string" && e !== undefined && !t.objectMode && (r = new a4("chunk", ["string", "Buffer", "Uint8Array"], e)), r;
    }
    Ce.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Ce.prototype.setEncoding = function(t) {
      sf || (sf = (ra(), ur(ta)).StringDecoder);
      var e = new sf(t);
      this._readableState.decoder = e, this._readableState.encoding = this._readableState.decoder.encoding;
      for (var r = this._readableState.buffer.head, o = "";r !== null; )
        o += e.write(r.data), r = r.next;
      return this._readableState.buffer.clear(), o !== "" && this._readableState.buffer.push(o), this._readableState.length = o.length, this;
    };
    var np = 1073741824;
    function d4(t) {
      return t >= np ? t = np : (t--, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, t |= t >>> 16, t++), t;
    }
    function fp(t, e) {
      return t <= 0 || e.length === 0 && e.ended ? 0 : e.objectMode ? 1 : t !== t ? e.flowing && e.length ? e.buffer.head.data.length : e.length : (t > e.highWaterMark && (e.highWaterMark = d4(t)), t <= e.length ? t : e.ended ? e.length : (e.needReadable = true, 0));
    }
    Ce.prototype.read = function(t) {
      Ne("read", t), t = parseInt(t, 10);
      var e = this._readableState, r = t;
      if (t !== 0 && (e.emittedReadable = false), t === 0 && e.needReadable && ((e.highWaterMark !== 0 ? e.length >= e.highWaterMark : e.length > 0) || e.ended))
        return Ne("read: emitReadable", e.length, e.ended), e.length === 0 && e.ended ? vh(this) : Eo(this), null;
      if (t = fp(t, e), t === 0 && e.ended)
        return e.length === 0 && vh(this), null;
      var o = e.needReadable;
      Ne("need readable", o), (e.length === 0 || e.length - t < e.highWaterMark) && (o = true, Ne("length less than watermark", o)), e.ended || e.reading ? (o = false, Ne("reading or ended", o)) : o && (Ne("do read"), e.reading = true, e.sync = true, e.length === 0 && (e.needReadable = true), this._read(e.highWaterMark), e.sync = false, e.reading || (t = fp(r, e)));
      var f2;
      return t > 0 ? f2 = lp(t, e) : f2 = null, f2 === null ? (e.needReadable = e.length <= e.highWaterMark, t = 0) : (e.length -= t, e.awaitDrain = 0), e.length === 0 && (e.ended || (e.needReadable = true), r !== t && e.ended && vh(this)), f2 !== null && this.emit("data", f2), f2;
    };
    function c4(t, e) {
      if (Ne("onEofChunk"), !e.ended) {
        if (e.decoder) {
          var r = e.decoder.end();
          r && r.length && (e.buffer.push(r), e.length += e.objectMode ? 1 : r.length);
        }
        e.ended = true, e.sync ? Eo(t) : (e.needReadable = false, e.emittedReadable || (e.emittedReadable = true, hp(t)));
      }
    }
    function Eo(t) {
      var e = t._readableState;
      Ne("emitReadable", e.needReadable, e.emittedReadable), e.needReadable = false, e.emittedReadable || (Ne("emitReadable", e.flowing), e.emittedReadable = true, process.nextTick(hp, t));
    }
    function hp(t) {
      var e = t._readableState;
      Ne("emitReadable_", e.destroyed, e.length, e.ended), !e.destroyed && (e.length || e.ended) && (t.emit("readable"), e.emittedReadable = false), e.needReadable = !e.flowing && !e.ended && e.length <= e.highWaterMark, gh(t);
    }
    function bh(t, e) {
      e.readingMore || (e.readingMore = true, process.nextTick(p4, t, e));
    }
    function p4(t, e) {
      for (;!e.reading && !e.ended && (e.length < e.highWaterMark || e.flowing && e.length === 0); ) {
        var r = e.length;
        if (Ne("maybeReadMore read 0"), t.read(0), r === e.length)
          break;
      }
      e.readingMore = false;
    }
    Ce.prototype._read = function(t) {
      na(this, new s4("_read()"));
    };
    Ce.prototype.pipe = function(t, e) {
      var r = this, o = this._readableState;
      switch (o.pipesCount) {
        case 0:
          o.pipes = t;
          break;
        case 1:
          o.pipes = [o.pipes, t];
          break;
        default:
          o.pipes.push(t);
          break;
      }
      o.pipesCount += 1, Ne("pipe count=%d opts=%j", o.pipesCount, e);
      var f2 = (!e || e.end !== false) && t !== process.stdout && t !== process.stderr, p = f2 ? y : ye;
      o.endEmitted ? process.nextTick(p) : r.once("end", p), t.on("unpipe", m);
      function m(_e, P) {
        Ne("onunpipe"), _e === r && P && P.hasUnpiped === false && (P.hasUnpiped = true, S2());
      }
      function y() {
        Ne("onend"), t.end();
      }
      var M = v4(r);
      t.on("drain", M);
      var x = false;
      function S2() {
        Ne("cleanup"), t.removeListener("close", q), t.removeListener("finish", T), t.removeListener("drain", M), t.removeListener("error", R), t.removeListener("unpipe", m), r.removeListener("end", y), r.removeListener("end", ye), r.removeListener("data", E), x = true, o.awaitDrain && (!t._writableState || t._writableState.needDrain) && M();
      }
      r.on("data", E);
      function E(_e) {
        Ne("ondata");
        var P = t.write(_e);
        Ne("dest.write", P), P === false && ((o.pipesCount === 1 && o.pipes === t || o.pipesCount > 1 && dp(o.pipes, t) !== -1) && !x && (Ne("false write response, pause", o.awaitDrain), o.awaitDrain++), r.pause());
      }
      function R(_e) {
        Ne("onerror", _e), ye(), t.removeListener("error", R), ap(t, "error") === 0 && na(t, _e);
      }
      u4(t, "error", R);
      function q() {
        t.removeListener("finish", T), ye();
      }
      t.once("close", q);
      function T() {
        Ne("onfinish"), t.removeListener("close", q), ye();
      }
      t.once("finish", T);
      function ye() {
        Ne("unpipe"), r.unpipe(t);
      }
      return t.emit("pipe", r), o.flowing || (Ne("pipe resume"), r.resume()), t;
    };
    function v4(t) {
      return function() {
        var r = t._readableState;
        Ne("pipeOnDrain", r.awaitDrain), r.awaitDrain && r.awaitDrain--, r.awaitDrain === 0 && ap(t, "data") && (r.flowing = true, gh(t));
      };
    }
    Ce.prototype.unpipe = function(t) {
      var e = this._readableState, r = { hasUnpiped: false };
      if (e.pipesCount === 0)
        return this;
      if (e.pipesCount === 1)
        return t && t !== e.pipes ? this : (t || (t = e.pipes), e.pipes = null, e.pipesCount = 0, e.flowing = false, t && t.emit("unpipe", this, r), this);
      if (!t) {
        var { pipes: o, pipesCount: f2 } = e;
        e.pipes = null, e.pipesCount = 0, e.flowing = false;
        for (var p = 0;p < f2; p++)
          o[p].emit("unpipe", this, { hasUnpiped: false });
        return this;
      }
      var m = dp(e.pipes, t);
      return m === -1 ? this : (e.pipes.splice(m, 1), e.pipesCount -= 1, e.pipesCount === 1 && (e.pipes = e.pipes[0]), t.emit("unpipe", this, r), this);
    };
    Ce.prototype.on = function(t, e) {
      var r = fa.prototype.on.call(this, t, e), o = this._readableState;
      return t === "data" ? (o.readableListening = this.listenerCount("readable") > 0, o.flowing !== false && this.resume()) : t === "readable" && !o.endEmitted && !o.readableListening && (o.readableListening = o.needReadable = true, o.flowing = false, o.emittedReadable = false, Ne("on readable", o.length, o.reading), o.length ? Eo(this) : o.reading || process.nextTick(b4, this)), r;
    };
    Ce.prototype.addListener = Ce.prototype.on;
    Ce.prototype.removeListener = function(t, e) {
      var r = fa.prototype.removeListener.call(this, t, e);
      return t === "readable" && process.nextTick(up, this), r;
    };
    Ce.prototype.removeAllListeners = function(t) {
      var e = fa.prototype.removeAllListeners.apply(this, arguments);
      return (t === "readable" || t === undefined) && process.nextTick(up, this), e;
    };
    function up(t) {
      var e = t._readableState;
      e.readableListening = t.listenerCount("readable") > 0, e.resumeScheduled && !e.paused ? e.flowing = true : t.listenerCount("data") > 0 && t.resume();
    }
    function b4(t) {
      Ne("readable nexttick read 0"), t.read(0);
    }
    Ce.prototype.resume = function() {
      var t = this._readableState;
      return t.flowing || (Ne("resume"), t.flowing = !t.readableListening, m4(this, t)), t.paused = false, this;
    };
    function m4(t, e) {
      e.resumeScheduled || (e.resumeScheduled = true, process.nextTick(g4, t, e));
    }
    function g4(t, e) {
      Ne("resume", e.reading), e.reading || t.read(0), e.resumeScheduled = false, t.emit("resume"), gh(t), e.flowing && !e.reading && t.read(0);
    }
    Ce.prototype.pause = function() {
      return Ne("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (Ne("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState.paused = true, this;
    };
    function gh(t) {
      var e = t._readableState;
      for (Ne("flow", e.flowing);e.flowing && t.read() !== null; )
        ;
    }
    Ce.prototype.wrap = function(t) {
      var e = this, r = this._readableState, o = false;
      t.on("end", function() {
        if (Ne("wrapped end"), r.decoder && !r.ended) {
          var m = r.decoder.end();
          m && m.length && e.push(m);
        }
        e.push(null);
      }), t.on("data", function(m) {
        if (Ne("wrapped data"), r.decoder && (m = r.decoder.write(m)), !(r.objectMode && m == null) && !(!r.objectMode && (!m || !m.length))) {
          var y = e.push(m);
          y || (o = true, t.pause());
        }
      });
      for (var f2 in t)
        this[f2] === undefined && typeof t[f2] == "function" && (this[f2] = function(y) {
          return function() {
            return t[y].apply(t, arguments);
          };
        }(f2));
      for (var p = 0;p < ch.length; p++)
        t.on(ch[p], this.emit.bind(this, ch[p]));
      return this._read = function(m) {
        Ne("wrapped _read", m), o && (o = false, t.resume());
      }, this;
    };
    typeof Symbol == "function" && (Ce.prototype[Symbol.asyncIterator] = function() {
      return lh === undefined && (lh = tp()), lh(this);
    });
    Object.defineProperty(Ce.prototype, "readableHighWaterMark", { enumerable: false, get: function() {
      return this._readableState.highWaterMark;
    } });
    Object.defineProperty(Ce.prototype, "readableBuffer", { enumerable: false, get: function() {
      return this._readableState && this._readableState.buffer;
    } });
    Object.defineProperty(Ce.prototype, "readableFlowing", { enumerable: false, get: function() {
      return this._readableState.flowing;
    }, set: function(e) {
      this._readableState && (this._readableState.flowing = e);
    } });
    Ce._fromList = lp;
    Object.defineProperty(Ce.prototype, "readableLength", { enumerable: false, get: function() {
      return this._readableState.length;
    } });
    function lp(t, e) {
      if (e.length === 0)
        return null;
      var r;
      return e.objectMode ? r = e.buffer.shift() : !t || t >= e.length ? (e.decoder ? r = e.buffer.join("") : e.buffer.length === 1 ? r = e.buffer.first() : r = e.buffer.concat(e.length), e.buffer.clear()) : r = e.buffer.consume(t, e.decoder), r;
    }
    function vh(t) {
      var e = t._readableState;
      Ne("endReadable", e.endEmitted), e.endEmitted || (e.ended = true, process.nextTick(y4, e, t));
    }
    function y4(t, e) {
      if (Ne("endReadableNT", t.endEmitted, t.length), !t.endEmitted && t.length === 0 && (t.endEmitted = true, e.readable = false, e.emit("end"), t.autoDestroy)) {
        var r = e._writableState;
        (!r || r.autoDestroy && r.finished) && e.destroy();
      }
    }
    typeof Symbol == "function" && (Ce.from = function(t, e) {
      return dh === undefined && (dh = ip()), dh(Ce, t, e);
    });
    function dp(t, e) {
      for (var r = 0, o = t.length;r < o; r++)
        if (t[r] === e)
          return r;
      return -1;
    }
  });
  yh = k((aT, vp) => {
    vp.exports = vi;
    var Ao = un().codes, w4 = Ao.ERR_METHOD_NOT_IMPLEMENTED, M4 = Ao.ERR_MULTIPLE_CALLBACK, _4 = Ao.ERR_TRANSFORM_ALREADY_TRANSFORMING, x4 = Ao.ERR_TRANSFORM_WITH_LENGTH_0, Ro = ln();
    Ie()(vi, Ro);
    function S4(t, e) {
      var r = this._transformState;
      r.transforming = false;
      var o = r.writecb;
      if (o === null)
        return this.emit("error", new M4);
      r.writechunk = null, r.writecb = null, e != null && this.push(e), o(t);
      var f2 = this._readableState;
      f2.reading = false, (f2.needReadable || f2.length < f2.highWaterMark) && this._read(f2.highWaterMark);
    }
    function vi(t) {
      if (!(this instanceof vi))
        return new vi(t);
      Ro.call(this, t), this._transformState = { afterTransform: S4.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = true, this._readableState.sync = false, t && (typeof t.transform == "function" && (this._transform = t.transform), typeof t.flush == "function" && (this._flush = t.flush)), this.on("prefinish", E4);
    }
    function E4() {
      var t = this;
      typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(e, r) {
        pp(t, e, r);
      }) : pp(this, null, null);
    }
    vi.prototype.push = function(t, e) {
      return this._transformState.needTransform = false, Ro.prototype.push.call(this, t, e);
    };
    vi.prototype._transform = function(t, e, r) {
      r(new w4("_transform()"));
    };
    vi.prototype._write = function(t, e, r) {
      var o = this._transformState;
      if (o.writecb = r, o.writechunk = t, o.writeencoding = e, !o.transforming) {
        var f2 = this._readableState;
        (o.needTransform || f2.needReadable || f2.length < f2.highWaterMark) && this._read(f2.highWaterMark);
      }
    };
    vi.prototype._read = function(t) {
      var e = this._transformState;
      e.writechunk !== null && !e.transforming ? (e.transforming = true, this._transform(e.writechunk, e.writeencoding, e.afterTransform)) : e.needTransform = true;
    };
    vi.prototype._destroy = function(t, e) {
      Ro.prototype._destroy.call(this, t, function(r) {
        e(r);
      });
    };
    function pp(t, e, r) {
      if (e)
        return t.emit("error", e);
      if (r != null && t.push(r), t._writableState.length)
        throw new x4;
      if (t._transformState.transforming)
        throw new _4;
      return t.push(null);
    }
  });
  gp = k((oT, mp) => {
    mp.exports = aa;
    var bp = yh();
    Ie()(aa, bp);
    function aa(t) {
      if (!(this instanceof aa))
        return new aa(t);
      bp.call(this, t);
    }
    aa.prototype._transform = function(t, e, r) {
      r(null, t);
    };
  });
  xp = k((sT, _p) => {
    var wh;
    function A4(t) {
      var e = false;
      return function() {
        e || (e = true, t.apply(undefined, arguments));
      };
    }
    var Mp = un().codes, R4 = Mp.ERR_MISSING_ARGS, B4 = Mp.ERR_STREAM_DESTROYED;
    function yp(t) {
      if (t)
        throw t;
    }
    function q4(t) {
      return t.setHeader && typeof t.abort == "function";
    }
    function I4(t, e, r, o) {
      o = A4(o);
      var f2 = false;
      t.on("close", function() {
        f2 = true;
      }), wh === undefined && (wh = wo()), wh(t, { readable: e, writable: r }, function(m) {
        if (m)
          return o(m);
        f2 = true, o();
      });
      var p = false;
      return function(m) {
        if (!f2 && !p) {
          if (p = true, q4(t))
            return t.abort();
          if (typeof t.destroy == "function")
            return t.destroy();
          o(m || new B4("pipe"));
        }
      };
    }
    function wp(t) {
      t();
    }
    function T4(t, e) {
      return t.pipe(e);
    }
    function k4(t) {
      return !t.length || typeof t[t.length - 1] != "function" ? yp : t.pop();
    }
    function L4() {
      for (var t = arguments.length, e = new Array(t), r = 0;r < t; r++)
        e[r] = arguments[r];
      var o = k4(e);
      if (Array.isArray(e[0]) && (e = e[0]), e.length < 2)
        throw new R4("streams");
      var f2, p = e.map(function(m, y) {
        var M = y < e.length - 1, x = y > 0;
        return I4(m, M, x, function(S2) {
          f2 || (f2 = S2), S2 && p.forEach(wp), !M && (p.forEach(wp), o(f2));
        });
      });
      return e.reduce(T4);
    }
    _p.exports = L4;
  });
  Ep = k((cr, Sp) => {
    cr = Sp.exports = ah();
    cr.Stream = cr;
    cr.Readable = cr;
    cr.Writable = ih();
    cr.Duplex = ln();
    cr.Transform = yh();
    cr.PassThrough = gp();
    cr.finished = wo();
    cr.pipeline = xp();
  });
  Mh = k((hT, Rp) => {
    var Bo = Te().Buffer, Ap = Ep().Transform, N4 = Ie();
    function P4(t, e) {
      if (!Bo.isBuffer(t) && typeof t != "string")
        throw new TypeError(e + " must be a string or a buffer");
    }
    function zi(t) {
      Ap.call(this), this._block = Bo.allocUnsafe(t), this._blockSize = t, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = false;
    }
    N4(zi, Ap);
    zi.prototype._transform = function(t, e, r) {
      var o = null;
      try {
        this.update(t, e);
      } catch (f2) {
        o = f2;
      }
      r(o);
    };
    zi.prototype._flush = function(t) {
      var e = null;
      try {
        this.push(this.digest());
      } catch (r) {
        e = r;
      }
      t(e);
    };
    zi.prototype.update = function(t, e) {
      if (P4(t, "Data"), this._finalized)
        throw new Error("Digest already called");
      Bo.isBuffer(t) || (t = Bo.from(t, e));
      for (var r = this._block, o = 0;this._blockOffset + t.length - o >= this._blockSize; ) {
        for (var f2 = this._blockOffset;f2 < this._blockSize; )
          r[f2++] = t[o++];
        this._update(), this._blockOffset = 0;
      }
      for (;o < t.length; )
        r[this._blockOffset++] = t[o++];
      for (var p = 0, m = t.length * 8;m > 0; ++p)
        this._length[p] += m, m = this._length[p] / 4294967296 | 0, m > 0 && (this._length[p] -= 4294967296 * m);
      return this;
    };
    zi.prototype._update = function() {
      throw new Error("_update is not implemented");
    };
    zi.prototype.digest = function(t) {
      if (this._finalized)
        throw new Error("Digest already called");
      this._finalized = true;
      var e = this._digest();
      t !== undefined && (e = e.toString(t)), this._block.fill(0), this._blockOffset = 0;
      for (var r = 0;r < 4; ++r)
        this._length[r] = 0;
      return e;
    };
    zi.prototype._digest = function() {
      throw new Error("_digest is not implemented");
    };
    Rp.exports = zi;
  });
  To = k((uT, qp) => {
    var D4 = Ie(), Bp = Mh(), C4 = Te().Buffer, O4 = new Array(16);
    function qo() {
      Bp.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
    }
    D4(qo, Bp);
    qo.prototype._update = function() {
      for (var t = O4, e = 0;e < 16; ++e)
        t[e] = this._block.readInt32LE(e * 4);
      var r = this._a, o = this._b, f2 = this._c, p = this._d;
      r = jt(r, o, f2, p, t[0], 3614090360, 7), p = jt(p, r, o, f2, t[1], 3905402710, 12), f2 = jt(f2, p, r, o, t[2], 606105819, 17), o = jt(o, f2, p, r, t[3], 3250441966, 22), r = jt(r, o, f2, p, t[4], 4118548399, 7), p = jt(p, r, o, f2, t[5], 1200080426, 12), f2 = jt(f2, p, r, o, t[6], 2821735955, 17), o = jt(o, f2, p, r, t[7], 4249261313, 22), r = jt(r, o, f2, p, t[8], 1770035416, 7), p = jt(p, r, o, f2, t[9], 2336552879, 12), f2 = jt(f2, p, r, o, t[10], 4294925233, 17), o = jt(o, f2, p, r, t[11], 2304563134, 22), r = jt(r, o, f2, p, t[12], 1804603682, 7), p = jt(p, r, o, f2, t[13], 4254626195, 12), f2 = jt(f2, p, r, o, t[14], 2792965006, 17), o = jt(o, f2, p, r, t[15], 1236535329, 22), r = Zt(r, o, f2, p, t[1], 4129170786, 5), p = Zt(p, r, o, f2, t[6], 3225465664, 9), f2 = Zt(f2, p, r, o, t[11], 643717713, 14), o = Zt(o, f2, p, r, t[0], 3921069994, 20), r = Zt(r, o, f2, p, t[5], 3593408605, 5), p = Zt(p, r, o, f2, t[10], 38016083, 9), f2 = Zt(f2, p, r, o, t[15], 3634488961, 14), o = Zt(o, f2, p, r, t[4], 3889429448, 20), r = Zt(r, o, f2, p, t[9], 568446438, 5), p = Zt(p, r, o, f2, t[14], 3275163606, 9), f2 = Zt(f2, p, r, o, t[3], 4107603335, 14), o = Zt(o, f2, p, r, t[8], 1163531501, 20), r = Zt(r, o, f2, p, t[13], 2850285829, 5), p = Zt(p, r, o, f2, t[2], 4243563512, 9), f2 = Zt(f2, p, r, o, t[7], 1735328473, 14), o = Zt(o, f2, p, r, t[12], 2368359562, 20), r = Vt(r, o, f2, p, t[5], 4294588738, 4), p = Vt(p, r, o, f2, t[8], 2272392833, 11), f2 = Vt(f2, p, r, o, t[11], 1839030562, 16), o = Vt(o, f2, p, r, t[14], 4259657740, 23), r = Vt(r, o, f2, p, t[1], 2763975236, 4), p = Vt(p, r, o, f2, t[4], 1272893353, 11), f2 = Vt(f2, p, r, o, t[7], 4139469664, 16), o = Vt(o, f2, p, r, t[10], 3200236656, 23), r = Vt(r, o, f2, p, t[13], 681279174, 4), p = Vt(p, r, o, f2, t[0], 3936430074, 11), f2 = Vt(f2, p, r, o, t[3], 3572445317, 16), o = Vt(o, f2, p, r, t[6], 76029189, 23), r = Vt(r, o, f2, p, t[9], 3654602809, 4), p = Vt(p, r, o, f2, t[12], 3873151461, 11), f2 = Vt(f2, p, r, o, t[15], 530742520, 16), o = Vt(o, f2, p, r, t[2], 3299628645, 23), r = $t(r, o, f2, p, t[0], 4096336452, 6), p = $t(p, r, o, f2, t[7], 1126891415, 10), f2 = $t(f2, p, r, o, t[14], 2878612391, 15), o = $t(o, f2, p, r, t[5], 4237533241, 21), r = $t(r, o, f2, p, t[12], 1700485571, 6), p = $t(p, r, o, f2, t[3], 2399980690, 10), f2 = $t(f2, p, r, o, t[10], 4293915773, 15), o = $t(o, f2, p, r, t[1], 2240044497, 21), r = $t(r, o, f2, p, t[8], 1873313359, 6), p = $t(p, r, o, f2, t[15], 4264355552, 10), f2 = $t(f2, p, r, o, t[6], 2734768916, 15), o = $t(o, f2, p, r, t[13], 1309151649, 21), r = $t(r, o, f2, p, t[4], 4149444226, 6), p = $t(p, r, o, f2, t[11], 3174756917, 10), f2 = $t(f2, p, r, o, t[2], 718787259, 15), o = $t(o, f2, p, r, t[9], 3951481745, 21), this._a = this._a + r | 0, this._b = this._b + o | 0, this._c = this._c + f2 | 0, this._d = this._d + p | 0;
    };
    qo.prototype._digest = function() {
      this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
      var t = C4.allocUnsafe(16);
      return t.writeInt32LE(this._a, 0), t.writeInt32LE(this._b, 4), t.writeInt32LE(this._c, 8), t.writeInt32LE(this._d, 12), t;
    };
    function Io(t, e) {
      return t << e | t >>> 32 - e;
    }
    function jt(t, e, r, o, f2, p, m) {
      return Io(t + (e & r | ~e & o) + f2 + p | 0, m) + e | 0;
    }
    function Zt(t, e, r, o, f2, p, m) {
      return Io(t + (e & o | r & ~o) + f2 + p | 0, m) + e | 0;
    }
    function Vt(t, e, r, o, f2, p, m) {
      return Io(t + (e ^ r ^ o) + f2 + p | 0, m) + e | 0;
    }
    function $t(t, e, r, o, f2, p, m) {
      return Io(t + (r ^ (e | ~o)) + f2 + p | 0, m) + e | 0;
    }
    qp.exports = qo;
  });
  Lo = k((lT, Dp) => {
    var _h = Ut().Buffer, F4 = Ie(), Pp = Mh(), U4 = new Array(16), oa = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], sa = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], ha = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], ua = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11], la = [0, 1518500249, 1859775393, 2400959708, 2840853838], da = [1352829926, 1548603684, 1836072691, 2053994217, 0];
    function ko() {
      Pp.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
    }
    F4(ko, Pp);
    ko.prototype._update = function() {
      for (var t = U4, e = 0;e < 16; ++e)
        t[e] = this._block.readInt32LE(e * 4);
      for (var r = this._a | 0, o = this._b | 0, f2 = this._c | 0, p = this._d | 0, m = this._e | 0, y = this._a | 0, M = this._b | 0, x = this._c | 0, S2 = this._d | 0, E = this._e | 0, R = 0;R < 80; R += 1) {
        var q, T;
        R < 16 ? (q = Ip(r, o, f2, p, m, t[oa[R]], la[0], ha[R]), T = Np(y, M, x, S2, E, t[sa[R]], da[0], ua[R])) : R < 32 ? (q = Tp(r, o, f2, p, m, t[oa[R]], la[1], ha[R]), T = Lp(y, M, x, S2, E, t[sa[R]], da[1], ua[R])) : R < 48 ? (q = kp(r, o, f2, p, m, t[oa[R]], la[2], ha[R]), T = kp(y, M, x, S2, E, t[sa[R]], da[2], ua[R])) : R < 64 ? (q = Lp(r, o, f2, p, m, t[oa[R]], la[3], ha[R]), T = Tp(y, M, x, S2, E, t[sa[R]], da[3], ua[R])) : (q = Np(r, o, f2, p, m, t[oa[R]], la[4], ha[R]), T = Ip(y, M, x, S2, E, t[sa[R]], da[4], ua[R])), r = m, m = p, p = vn(f2, 10), f2 = o, o = q, y = E, E = S2, S2 = vn(x, 10), x = M, M = T;
      }
      var ye = this._b + f2 + S2 | 0;
      this._b = this._c + p + E | 0, this._c = this._d + m + y | 0, this._d = this._e + r + M | 0, this._e = this._a + o + x | 0, this._a = ye;
    };
    ko.prototype._digest = function() {
      this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
      var t = _h.alloc ? _h.alloc(20) : new _h(20);
      return t.writeInt32LE(this._a, 0), t.writeInt32LE(this._b, 4), t.writeInt32LE(this._c, 8), t.writeInt32LE(this._d, 12), t.writeInt32LE(this._e, 16), t;
    };
    function vn(t, e) {
      return t << e | t >>> 32 - e;
    }
    function Ip(t, e, r, o, f2, p, m, y) {
      return vn(t + (e ^ r ^ o) + p + m | 0, y) + f2 | 0;
    }
    function Tp(t, e, r, o, f2, p, m, y) {
      return vn(t + (e & r | ~e & o) + p + m | 0, y) + f2 | 0;
    }
    function kp(t, e, r, o, f2, p, m, y) {
      return vn(t + ((e | ~r) ^ o) + p + m | 0, y) + f2 | 0;
    }
    function Lp(t, e, r, o, f2, p, m, y) {
      return vn(t + (e & o | r & ~o) + p + m | 0, y) + f2 | 0;
    }
    function Np(t, e, r, o, f2, p, m, y) {
      return vn(t + (e ^ (r | ~o)) + p + m | 0, y) + f2 | 0;
    }
    Dp.exports = ko;
  });
  bn2 = k((dT, Op) => {
    var Cp = Te().Buffer;
    function No(t, e) {
      this._block = Cp.alloc(t), this._finalSize = e, this._blockSize = t, this._len = 0;
    }
    No.prototype.update = function(t, e) {
      typeof t == "string" && (e = e || "utf8", t = Cp.from(t, e));
      for (var r = this._block, o = this._blockSize, f2 = t.length, p = this._len, m = 0;m < f2; ) {
        for (var y = p % o, M = Math.min(f2 - m, o - y), x = 0;x < M; x++)
          r[y + x] = t[m + x];
        p += M, m += M, p % o === 0 && this._update(r);
      }
      return this._len += f2, this;
    };
    No.prototype.digest = function(t) {
      var e = this._len % this._blockSize;
      this._block[e] = 128, this._block.fill(0, e + 1), e >= this._finalSize && (this._update(this._block), this._block.fill(0));
      var r = this._len * 8;
      if (r <= 4294967295)
        this._block.writeUInt32BE(r, this._blockSize - 4);
      else {
        var o = (r & 4294967295) >>> 0, f2 = (r - o) / 4294967296;
        this._block.writeUInt32BE(f2, this._blockSize - 8), this._block.writeUInt32BE(o, this._blockSize - 4);
      }
      this._update(this._block);
      var p = this._hash();
      return t ? p.toString(t) : p;
    };
    No.prototype._update = function() {
      throw new Error("_update must be implemented by subclass");
    };
    Op.exports = No;
  });
  zp = k((cT, Up) => {
    var z4 = Ie(), Fp = bn2(), H4 = Te().Buffer, W4 = [1518500249, 1859775393, -1894007588, -899497514], K4 = new Array(80);
    function ca() {
      this.init(), this._w = K4, Fp.call(this, 64, 56);
    }
    z4(ca, Fp);
    ca.prototype.init = function() {
      return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
    };
    function j4(t) {
      return t << 5 | t >>> 27;
    }
    function Z4(t) {
      return t << 30 | t >>> 2;
    }
    function V4(t, e, r, o) {
      return t === 0 ? e & r | ~e & o : t === 2 ? e & r | e & o | r & o : e ^ r ^ o;
    }
    ca.prototype._update = function(t) {
      for (var e = this._w, r = this._a | 0, o = this._b | 0, f2 = this._c | 0, p = this._d | 0, m = this._e | 0, y = 0;y < 16; ++y)
        e[y] = t.readInt32BE(y * 4);
      for (;y < 80; ++y)
        e[y] = e[y - 3] ^ e[y - 8] ^ e[y - 14] ^ e[y - 16];
      for (var M = 0;M < 80; ++M) {
        var x = ~~(M / 20), S2 = j4(r) + V4(x, o, f2, p) + m + e[M] + W4[x] | 0;
        m = p, p = f2, f2 = Z4(o), o = r, r = S2;
      }
      this._a = r + this._a | 0, this._b = o + this._b | 0, this._c = f2 + this._c | 0, this._d = p + this._d | 0, this._e = m + this._e | 0;
    };
    ca.prototype._hash = function() {
      var t = H4.allocUnsafe(20);
      return t.writeInt32BE(this._a | 0, 0), t.writeInt32BE(this._b | 0, 4), t.writeInt32BE(this._c | 0, 8), t.writeInt32BE(this._d | 0, 12), t.writeInt32BE(this._e | 0, 16), t;
    };
    Up.exports = ca;
  });
  Kp = k((pT, Wp) => {
    var $4 = Ie(), Hp = bn2(), G4 = Te().Buffer, Y4 = [1518500249, 1859775393, -1894007588, -899497514], X4 = new Array(80);
    function pa() {
      this.init(), this._w = X4, Hp.call(this, 64, 56);
    }
    $4(pa, Hp);
    pa.prototype.init = function() {
      return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
    };
    function J4(t) {
      return t << 1 | t >>> 31;
    }
    function Q4(t) {
      return t << 5 | t >>> 27;
    }
    function e_(t) {
      return t << 30 | t >>> 2;
    }
    function t_(t, e, r, o) {
      return t === 0 ? e & r | ~e & o : t === 2 ? e & r | e & o | r & o : e ^ r ^ o;
    }
    pa.prototype._update = function(t) {
      for (var e = this._w, r = this._a | 0, o = this._b | 0, f2 = this._c | 0, p = this._d | 0, m = this._e | 0, y = 0;y < 16; ++y)
        e[y] = t.readInt32BE(y * 4);
      for (;y < 80; ++y)
        e[y] = J4(e[y - 3] ^ e[y - 8] ^ e[y - 14] ^ e[y - 16]);
      for (var M = 0;M < 80; ++M) {
        var x = ~~(M / 20), S2 = Q4(r) + t_(x, o, f2, p) + m + e[M] + Y4[x] | 0;
        m = p, p = f2, f2 = e_(o), o = r, r = S2;
      }
      this._a = r + this._a | 0, this._b = o + this._b | 0, this._c = f2 + this._c | 0, this._d = p + this._d | 0, this._e = m + this._e | 0;
    };
    pa.prototype._hash = function() {
      var t = G4.allocUnsafe(20);
      return t.writeInt32BE(this._a | 0, 0), t.writeInt32BE(this._b | 0, 4), t.writeInt32BE(this._c | 0, 8), t.writeInt32BE(this._d | 0, 12), t.writeInt32BE(this._e | 0, 16), t;
    };
    Wp.exports = pa;
  });
  xh = k((vT, Zp) => {
    var r_ = Ie(), jp = bn2(), i_ = Te().Buffer, n_ = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], f_ = new Array(64);
    function va() {
      this.init(), this._w = f_, jp.call(this, 64, 56);
    }
    r_(va, jp);
    va.prototype.init = function() {
      return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
    };
    function a_(t, e, r) {
      return r ^ t & (e ^ r);
    }
    function o_(t, e, r) {
      return t & e | r & (t | e);
    }
    function s_(t) {
      return (t >>> 2 | t << 30) ^ (t >>> 13 | t << 19) ^ (t >>> 22 | t << 10);
    }
    function h_(t) {
      return (t >>> 6 | t << 26) ^ (t >>> 11 | t << 21) ^ (t >>> 25 | t << 7);
    }
    function u_(t) {
      return (t >>> 7 | t << 25) ^ (t >>> 18 | t << 14) ^ t >>> 3;
    }
    function l_(t) {
      return (t >>> 17 | t << 15) ^ (t >>> 19 | t << 13) ^ t >>> 10;
    }
    va.prototype._update = function(t) {
      for (var e = this._w, r = this._a | 0, o = this._b | 0, f2 = this._c | 0, p = this._d | 0, m = this._e | 0, y = this._f | 0, M = this._g | 0, x = this._h | 0, S2 = 0;S2 < 16; ++S2)
        e[S2] = t.readInt32BE(S2 * 4);
      for (;S2 < 64; ++S2)
        e[S2] = l_(e[S2 - 2]) + e[S2 - 7] + u_(e[S2 - 15]) + e[S2 - 16] | 0;
      for (var E = 0;E < 64; ++E) {
        var R = x + h_(m) + a_(m, y, M) + n_[E] + e[E] | 0, q = s_(r) + o_(r, o, f2) | 0;
        x = M, M = y, y = m, m = p + R | 0, p = f2, f2 = o, o = r, r = R + q | 0;
      }
      this._a = r + this._a | 0, this._b = o + this._b | 0, this._c = f2 + this._c | 0, this._d = p + this._d | 0, this._e = m + this._e | 0, this._f = y + this._f | 0, this._g = M + this._g | 0, this._h = x + this._h | 0;
    };
    va.prototype._hash = function() {
      var t = i_.allocUnsafe(32);
      return t.writeInt32BE(this._a, 0), t.writeInt32BE(this._b, 4), t.writeInt32BE(this._c, 8), t.writeInt32BE(this._d, 12), t.writeInt32BE(this._e, 16), t.writeInt32BE(this._f, 20), t.writeInt32BE(this._g, 24), t.writeInt32BE(this._h, 28), t;
    };
    Zp.exports = va;
  });
  $p = k((bT, Vp) => {
    var d_ = Ie(), c_ = xh(), p_ = bn2(), v_ = Te().Buffer, b_ = new Array(64);
    function Po() {
      this.init(), this._w = b_, p_.call(this, 64, 56);
    }
    d_(Po, c_);
    Po.prototype.init = function() {
      return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
    };
    Po.prototype._hash = function() {
      var t = v_.allocUnsafe(28);
      return t.writeInt32BE(this._a, 0), t.writeInt32BE(this._b, 4), t.writeInt32BE(this._c, 8), t.writeInt32BE(this._d, 12), t.writeInt32BE(this._e, 16), t.writeInt32BE(this._f, 20), t.writeInt32BE(this._g, 24), t;
    };
    Vp.exports = Po;
  });
  Sh = k((mT, t1) => {
    var m_ = Ie(), e1 = bn2(), g_ = Te().Buffer, Gp = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591], y_ = new Array(160);
    function ba() {
      this.init(), this._w = y_, e1.call(this, 128, 112);
    }
    m_(ba, e1);
    ba.prototype.init = function() {
      return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
    };
    function Yp(t, e, r) {
      return r ^ t & (e ^ r);
    }
    function Xp(t, e, r) {
      return t & e | r & (t | e);
    }
    function Jp(t, e) {
      return (t >>> 28 | e << 4) ^ (e >>> 2 | t << 30) ^ (e >>> 7 | t << 25);
    }
    function Qp(t, e) {
      return (t >>> 14 | e << 18) ^ (t >>> 18 | e << 14) ^ (e >>> 9 | t << 23);
    }
    function w_(t, e) {
      return (t >>> 1 | e << 31) ^ (t >>> 8 | e << 24) ^ t >>> 7;
    }
    function M_(t, e) {
      return (t >>> 1 | e << 31) ^ (t >>> 8 | e << 24) ^ (t >>> 7 | e << 25);
    }
    function __(t, e) {
      return (t >>> 19 | e << 13) ^ (e >>> 29 | t << 3) ^ t >>> 6;
    }
    function x_(t, e) {
      return (t >>> 19 | e << 13) ^ (e >>> 29 | t << 3) ^ (t >>> 6 | e << 26);
    }
    function Dt(t, e) {
      return t >>> 0 < e >>> 0 ? 1 : 0;
    }
    ba.prototype._update = function(t) {
      for (var e = this._w, r = this._ah | 0, o = this._bh | 0, f2 = this._ch | 0, p = this._dh | 0, m = this._eh | 0, y = this._fh | 0, M = this._gh | 0, x = this._hh | 0, S2 = this._al | 0, E = this._bl | 0, R = this._cl | 0, q = this._dl | 0, T = this._el | 0, ye = this._fl | 0, _e = this._gl | 0, P = this._hl | 0, Me = 0;Me < 32; Me += 2)
        e[Me] = t.readInt32BE(Me * 4), e[Me + 1] = t.readInt32BE(Me * 4 + 4);
      for (;Me < 160; Me += 2) {
        var me = e[Me - 30], xe = e[Me - 15 * 2 + 1], Ae = w_(me, xe), Ee = M_(xe, me);
        me = e[Me - 2 * 2], xe = e[Me - 2 * 2 + 1];
        var Re = __(me, xe), D2 = x_(xe, me), Se = e[Me - 7 * 2], v2 = e[Me - 7 * 2 + 1], i = e[Me - 16 * 2], a = e[Me - 16 * 2 + 1], h = Ee + v2 | 0, s = Ae + Se + Dt(h, Ee) | 0;
        h = h + D2 | 0, s = s + Re + Dt(h, D2) | 0, h = h + a | 0, s = s + i + Dt(h, a) | 0, e[Me] = s, e[Me + 1] = h;
      }
      for (var u = 0;u < 160; u += 2) {
        s = e[u], h = e[u + 1];
        var c = Xp(r, o, f2), b2 = Xp(S2, E, R), l = Jp(r, S2), n = Jp(S2, r), d = Qp(m, T), w = Qp(T, m), g = Gp[u], _2 = Gp[u + 1], A = Yp(m, y, M), B = Yp(T, ye, _e), I = P + w | 0, we = x + d + Dt(I, P) | 0;
        I = I + B | 0, we = we + A + Dt(I, B) | 0, I = I + _2 | 0, we = we + g + Dt(I, _2) | 0, I = I + h | 0, we = we + s + Dt(I, h) | 0;
        var L = n + b2 | 0, N = l + c + Dt(L, n) | 0;
        x = M, P = _e, M = y, _e = ye, y = m, ye = T, T = q + I | 0, m = p + we + Dt(T, q) | 0, p = f2, q = R, f2 = o, R = E, o = r, E = S2, S2 = I + L | 0, r = we + N + Dt(S2, I) | 0;
      }
      this._al = this._al + S2 | 0, this._bl = this._bl + E | 0, this._cl = this._cl + R | 0, this._dl = this._dl + q | 0, this._el = this._el + T | 0, this._fl = this._fl + ye | 0, this._gl = this._gl + _e | 0, this._hl = this._hl + P | 0, this._ah = this._ah + r + Dt(this._al, S2) | 0, this._bh = this._bh + o + Dt(this._bl, E) | 0, this._ch = this._ch + f2 + Dt(this._cl, R) | 0, this._dh = this._dh + p + Dt(this._dl, q) | 0, this._eh = this._eh + m + Dt(this._el, T) | 0, this._fh = this._fh + y + Dt(this._fl, ye) | 0, this._gh = this._gh + M + Dt(this._gl, _e) | 0, this._hh = this._hh + x + Dt(this._hl, P) | 0;
    };
    ba.prototype._hash = function() {
      var t = g_.allocUnsafe(64);
      function e(r, o, f2) {
        t.writeInt32BE(r, f2), t.writeInt32BE(o, f2 + 4);
      }
      return e(this._ah, this._al, 0), e(this._bh, this._bl, 8), e(this._ch, this._cl, 16), e(this._dh, this._dl, 24), e(this._eh, this._el, 32), e(this._fh, this._fl, 40), e(this._gh, this._gl, 48), e(this._hh, this._hl, 56), t;
    };
    t1.exports = ba;
  });
  i1 = k((gT, r1) => {
    var S_ = Ie(), E_ = Sh(), A_ = bn2(), R_ = Te().Buffer, B_ = new Array(160);
    function Do() {
      this.init(), this._w = B_, A_.call(this, 128, 112);
    }
    S_(Do, E_);
    Do.prototype.init = function() {
      return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
    };
    Do.prototype._hash = function() {
      var t = R_.allocUnsafe(48);
      function e(r, o, f2) {
        t.writeInt32BE(r, f2), t.writeInt32BE(o, f2 + 4);
      }
      return e(this._ah, this._al, 0), e(this._bh, this._bl, 8), e(this._ch, this._cl, 16), e(this._dh, this._dl, 24), e(this._eh, this._el, 32), e(this._fh, this._fl, 40), t;
    };
    r1.exports = Do;
  });
  Co = k((bi, n1) => {
    var bi = n1.exports = function(e) {
      e = e.toLowerCase();
      var r = bi[e];
      if (!r)
        throw new Error(e + " is not supported (we accept pull requests)");
      return new r;
    };
    bi.sha = zp();
    bi.sha1 = Kp();
    bi.sha224 = $p();
    bi.sha256 = xh();
    bi.sha384 = i1();
    bi.sha512 = Sh();
  });
  Tt = k((yT, f1) => {
    f1.exports = { ArrayIsArray(t) {
      return Array.isArray(t);
    }, ArrayPrototypeIncludes(t, e) {
      return t.includes(e);
    }, ArrayPrototypeIndexOf(t, e) {
      return t.indexOf(e);
    }, ArrayPrototypeJoin(t, e) {
      return t.join(e);
    }, ArrayPrototypeMap(t, e) {
      return t.map(e);
    }, ArrayPrototypePop(t, e) {
      return t.pop(e);
    }, ArrayPrototypePush(t, e) {
      return t.push(e);
    }, ArrayPrototypeSlice(t, e, r) {
      return t.slice(e, r);
    }, Error, FunctionPrototypeCall(t, e, ...r) {
      return t.call(e, ...r);
    }, FunctionPrototypeSymbolHasInstance(t, e) {
      return Function.prototype[Symbol.hasInstance].call(t, e);
    }, MathFloor: Math.floor, Number, NumberIsInteger: Number.isInteger, NumberIsNaN: Number.isNaN, NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER, NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER, NumberParseInt: Number.parseInt, ObjectDefineProperties(t, e) {
      return Object.defineProperties(t, e);
    }, ObjectDefineProperty(t, e, r) {
      return Object.defineProperty(t, e, r);
    }, ObjectGetOwnPropertyDescriptor(t, e) {
      return Object.getOwnPropertyDescriptor(t, e);
    }, ObjectKeys(t) {
      return Object.keys(t);
    }, ObjectSetPrototypeOf(t, e) {
      return Object.setPrototypeOf(t, e);
    }, Promise, PromisePrototypeCatch(t, e) {
      return t.catch(e);
    }, PromisePrototypeThen(t, e, r) {
      return t.then(e, r);
    }, PromiseReject(t) {
      return Promise.reject(t);
    }, ReflectApply: Reflect.apply, RegExpPrototypeTest(t, e) {
      return t.test(e);
    }, SafeSet: Set, String, StringPrototypeSlice(t, e, r) {
      return t.slice(e, r);
    }, StringPrototypeToLowerCase(t) {
      return t.toLowerCase();
    }, StringPrototypeToUpperCase(t) {
      return t.toUpperCase();
    }, StringPrototypeTrim(t) {
      return t.trim();
    }, Symbol, SymbolFor: Symbol.for, SymbolAsyncIterator: Symbol.asyncIterator, SymbolHasInstance: Symbol.hasInstance, SymbolIterator: Symbol.iterator, TypedArrayPrototypeSet(t, e, r) {
      return t.set(e, r);
    }, Uint8Array };
  });
  Gr = k((wT, Ah) => {
    var q_ = Ut(), I_ = Object.getPrototypeOf(async function() {
    }).constructor, a1 = globalThis.Blob || q_.Blob, T_ = typeof a1 < "u" ? function(e) {
      return e instanceof a1;
    } : function(e) {
      return false;
    }, Eh = class extends Error {
      constructor(e) {
        if (!Array.isArray(e))
          throw new TypeError(`Expected input to be an Array, got ${typeof e}`);
        let r = "";
        for (let o = 0;o < e.length; o++)
          r += `    ${e[o].stack}
`;
        super(r), this.name = "AggregateError", this.errors = e;
      }
    };
    Ah.exports = { AggregateError: Eh, kEmptyObject: Object.freeze({}), once(t) {
      let e = false;
      return function(...r) {
        e || (e = true, t.apply(this, r));
      };
    }, createDeferredPromise: function() {
      let t, e;
      return { promise: new Promise((o, f2) => {
        t = o, e = f2;
      }), resolve: t, reject: e };
    }, promisify(t) {
      return new Promise((e, r) => {
        t((o, ...f2) => o ? r(o) : e(...f2));
      });
    }, debuglog() {
      return function() {
      };
    }, format(t, ...e) {
      return t.replace(/%([sdifj])/g, function(...[r, o]) {
        let f2 = e.shift();
        return o === "f" ? f2.toFixed(6) : o === "j" ? JSON.stringify(f2) : o === "s" && typeof f2 == "object" ? `${f2.constructor !== Object ? f2.constructor.name : ""} {}`.trim() : f2.toString();
      });
    }, inspect(t) {
      switch (typeof t) {
        case "string":
          if (t.includes("'"))
            if (t.includes('"')) {
              if (!t.includes("`") && !t.includes("${"))
                return `\`${t}\``;
            } else
              return `"${t}"`;
          return `'${t}'`;
        case "number":
          return isNaN(t) ? "NaN" : Object.is(t, -0) ? String(t) : t;
        case "bigint":
          return `${String(t)}n`;
        case "boolean":
        case "undefined":
          return String(t);
        case "object":
          return "{}";
      }
    }, types: { isAsyncFunction(t) {
      return t instanceof I_;
    }, isArrayBufferView(t) {
      return ArrayBuffer.isView(t);
    } }, isBlob: T_ };
    Ah.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
  });
  Fo = k((MT, Oo) => {
    var { AbortController: o1, AbortSignal: k_ } = typeof self < "u" ? self : typeof window < "u" ? window : undefined;
    Oo.exports = o1;
    Oo.exports.AbortSignal = k_;
    Oo.exports.default = o1;
  });
  Jt = k((_T, u1) => {
    var { format: L_, inspect: Uo, AggregateError: N_ } = Gr(), P_ = globalThis.AggregateError || N_, D_ = Symbol("kIsNodeError"), C_ = ["string", "function", "number", "object", "Function", "Object", "boolean", "bigint", "symbol"], O_ = /^([A-Z][a-z0-9]*)+$/, F_ = "__node_internal_", zo = {};
    function mn(t, e) {
      if (!t)
        throw new zo.ERR_INTERNAL_ASSERTION(e);
    }
    function s1(t) {
      let e = "", r = t.length, o = t[0] === "-" ? 1 : 0;
      for (;r >= o + 4; r -= 3)
        e = `_${t.slice(r - 3, r)}${e}`;
      return `${t.slice(0, r)}${e}`;
    }
    function U_(t, e, r) {
      if (typeof e == "function")
        return mn(e.length <= r.length, `Code: ${t}; The provided arguments length (${r.length}) does not match the required ones (${e.length}).`), e(...r);
      let o = (e.match(/%[dfijoOs]/g) || []).length;
      return mn(o === r.length, `Code: ${t}; The provided arguments length (${r.length}) does not match the required ones (${o}).`), r.length === 0 ? e : L_(e, ...r);
    }
    function zt(t, e, r) {
      r || (r = Error);

      class o extends r {
        constructor(...p) {
          super(U_(t, e, p));
        }
        toString() {
          return `${this.name} [${t}]: ${this.message}`;
        }
      }
      Object.defineProperties(o.prototype, { name: { value: r.name, writable: true, enumerable: false, configurable: true }, toString: { value() {
        return `${this.name} [${t}]: ${this.message}`;
      }, writable: true, enumerable: false, configurable: true } }), o.prototype.code = t, o.prototype[D_] = true, zo[t] = o;
    }
    function h1(t) {
      let e = F_ + t.name;
      return Object.defineProperty(t, "name", { value: e }), t;
    }
    function z_(t, e) {
      if (t && e && t !== e) {
        if (Array.isArray(e.errors))
          return e.errors.push(t), e;
        let r = new P_([e, t], e.message);
        return r.code = e.code, r;
      }
      return t || e;
    }
    var Rh = class extends Error {
      constructor(e = "The operation was aborted", r = undefined) {
        if (r !== undefined && typeof r != "object")
          throw new zo.ERR_INVALID_ARG_TYPE("options", "Object", r);
        super(e, r), this.code = "ABORT_ERR", this.name = "AbortError";
      }
    };
    zt("ERR_ASSERTION", "%s", Error);
    zt("ERR_INVALID_ARG_TYPE", (t, e, r) => {
      mn(typeof t == "string", "'name' must be a string"), Array.isArray(e) || (e = [e]);
      let o = "The ";
      t.endsWith(" argument") ? o += `${t} ` : o += `"${t}" ${t.includes(".") ? "property" : "argument"} `, o += "must be ";
      let f2 = [], p = [], m = [];
      for (let M of e)
        mn(typeof M == "string", "All expected entries have to be of type string"), C_.includes(M) ? f2.push(M.toLowerCase()) : O_.test(M) ? p.push(M) : (mn(M !== "object", 'The value "object" should be written as "Object"'), m.push(M));
      if (p.length > 0) {
        let M = f2.indexOf("object");
        M !== -1 && (f2.splice(f2, M, 1), p.push("Object"));
      }
      if (f2.length > 0) {
        switch (f2.length) {
          case 1:
            o += `of type ${f2[0]}`;
            break;
          case 2:
            o += `one of type ${f2[0]} or ${f2[1]}`;
            break;
          default: {
            let M = f2.pop();
            o += `one of type ${f2.join(", ")}, or ${M}`;
          }
        }
        (p.length > 0 || m.length > 0) && (o += " or ");
      }
      if (p.length > 0) {
        switch (p.length) {
          case 1:
            o += `an instance of ${p[0]}`;
            break;
          case 2:
            o += `an instance of ${p[0]} or ${p[1]}`;
            break;
          default: {
            let M = p.pop();
            o += `an instance of ${p.join(", ")}, or ${M}`;
          }
        }
        m.length > 0 && (o += " or ");
      }
      switch (m.length) {
        case 0:
          break;
        case 1:
          m[0].toLowerCase() !== m[0] && (o += "an "), o += `${m[0]}`;
          break;
        case 2:
          o += `one of ${m[0]} or ${m[1]}`;
          break;
        default: {
          let M = m.pop();
          o += `one of ${m.join(", ")}, or ${M}`;
        }
      }
      if (r == null)
        o += `. Received ${r}`;
      else if (typeof r == "function" && r.name)
        o += `. Received function ${r.name}`;
      else if (typeof r == "object") {
        var y;
        (y = r.constructor) !== null && y !== undefined && y.name ? o += `. Received an instance of ${r.constructor.name}` : o += `. Received ${Uo(r, { depth: -1 })}`;
      } else {
        let M = Uo(r, { colors: false });
        M.length > 25 && (M = `${M.slice(0, 25)}...`), o += `. Received type ${typeof r} (${M})`;
      }
      return o;
    }, TypeError);
    zt("ERR_INVALID_ARG_VALUE", (t, e, r = "is invalid") => {
      let o = Uo(e);
      return o.length > 128 && (o = o.slice(0, 128) + "..."), `The ${t.includes(".") ? "property" : "argument"} '${t}' ${r}. Received ${o}`;
    }, TypeError);
    zt("ERR_INVALID_RETURN_VALUE", (t, e, r) => {
      var o;
      let f2 = r != null && (o = r.constructor) !== null && o !== undefined && o.name ? `instance of ${r.constructor.name}` : `type ${typeof r}`;
      return `Expected ${t} to be returned from the "${e}" function but got ${f2}.`;
    }, TypeError);
    zt("ERR_MISSING_ARGS", (...t) => {
      mn(t.length > 0, "At least one arg needs to be specified");
      let e, r = t.length;
      switch (t = (Array.isArray(t) ? t : [t]).map((o) => `"${o}"`).join(" or "), r) {
        case 1:
          e += `The ${t[0]} argument`;
          break;
        case 2:
          e += `The ${t[0]} and ${t[1]} arguments`;
          break;
        default:
          {
            let o = t.pop();
            e += `The ${t.join(", ")}, and ${o} arguments`;
          }
          break;
      }
      return `${e} must be specified`;
    }, TypeError);
    zt("ERR_OUT_OF_RANGE", (t, e, r) => {
      mn(e, 'Missing "range" argument');
      let o;
      return Number.isInteger(r) && Math.abs(r) > 2 ** 32 ? o = s1(String(r)) : typeof r == "bigint" ? (o = String(r), (r > 2n ** 32n || r < -(2n ** 32n)) && (o = s1(o)), o += "n") : o = Uo(r), `The value of "${t}" is out of range. It must be ${e}. Received ${o}`;
    }, RangeError);
    zt("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
    zt("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
    zt("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
    zt("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
    zt("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
    zt("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    zt("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
    zt("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
    zt("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
    zt("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
    zt("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
    u1.exports = { AbortError: Rh, aggregateTwoErrors: h1(z_), hideStackFrames: h1, codes: zo };
  });
  ma = k((xT, y1) => {
    var { ArrayIsArray: qh, ArrayPrototypeIncludes: p1, ArrayPrototypeJoin: v1, ArrayPrototypeMap: H_, NumberIsInteger: Ih, NumberIsNaN: W_, NumberMAX_SAFE_INTEGER: K_, NumberMIN_SAFE_INTEGER: j_, NumberParseInt: Z_, ObjectPrototypeHasOwnProperty: V_, RegExpPrototypeExec: b1, String: $_, StringPrototypeToUpperCase: G_, StringPrototypeTrim: Y_ } = Tt(), { hideStackFrames: pr, codes: { ERR_SOCKET_BAD_PORT: X_, ERR_INVALID_ARG_TYPE: Qt, ERR_INVALID_ARG_VALUE: hf, ERR_OUT_OF_RANGE: gn, ERR_UNKNOWN_SIGNAL: l1 } } = Jt(), { normalizeEncoding: J_ } = Gr(), { isAsyncFunction: Q_, isArrayBufferView: e8 } = Gr().types, d1 = {};
    function t8(t) {
      return t === (t | 0);
    }
    function r8(t) {
      return t === t >>> 0;
    }
    var i8 = /^[0-7]+$/, n8 = "must be a 32-bit unsigned integer or an octal string";
    function f8(t, e, r) {
      if (typeof t > "u" && (t = r), typeof t == "string") {
        if (b1(i8, t) === null)
          throw new hf(e, t, n8);
        t = Z_(t, 8);
      }
      return m1(t, e), t;
    }
    var a8 = pr((t, e, r = j_, o = K_) => {
      if (typeof t != "number")
        throw new Qt(e, "number", t);
      if (!Ih(t))
        throw new gn(e, "an integer", t);
      if (t < r || t > o)
        throw new gn(e, `>= ${r} && <= ${o}`, t);
    }), o8 = pr((t, e, r = -2147483648, o = 2147483647) => {
      if (typeof t != "number")
        throw new Qt(e, "number", t);
      if (!Ih(t))
        throw new gn(e, "an integer", t);
      if (t < r || t > o)
        throw new gn(e, `>= ${r} && <= ${o}`, t);
    }), m1 = pr((t, e, r = false) => {
      if (typeof t != "number")
        throw new Qt(e, "number", t);
      if (!Ih(t))
        throw new gn(e, "an integer", t);
      let o = r ? 1 : 0, f2 = 4294967295;
      if (t < o || t > f2)
        throw new gn(e, `>= ${o} && <= ${f2}`, t);
    });
    function Th(t, e) {
      if (typeof t != "string")
        throw new Qt(e, "string", t);
    }
    function s8(t, e, r = undefined, o) {
      if (typeof t != "number")
        throw new Qt(e, "number", t);
      if (r != null && t < r || o != null && t > o || (r != null || o != null) && W_(t))
        throw new gn(e, `${r != null ? `>= ${r}` : ""}${r != null && o != null ? " && " : ""}${o != null ? `<= ${o}` : ""}`, t);
    }
    var h8 = pr((t, e, r) => {
      if (!p1(r, t)) {
        let o = v1(H_(r, (p) => typeof p == "string" ? `'${p}'` : $_(p)), ", "), f2 = "must be one of: " + o;
        throw new hf(e, t, f2);
      }
    });
    function g1(t, e) {
      if (typeof t != "boolean")
        throw new Qt(e, "boolean", t);
    }
    function Bh(t, e, r) {
      return t == null || !V_(t, e) ? r : t[e];
    }
    var u8 = pr((t, e, r = null) => {
      let o = Bh(r, "allowArray", false), f2 = Bh(r, "allowFunction", false);
      if (!Bh(r, "nullable", false) && t === null || !o && qh(t) || typeof t != "object" && (!f2 || typeof t != "function"))
        throw new Qt(e, "Object", t);
    }), l8 = pr((t, e) => {
      if (t != null && typeof t != "object" && typeof t != "function")
        throw new Qt(e, "a dictionary", t);
    }), kh = pr((t, e, r = 0) => {
      if (!qh(t))
        throw new Qt(e, "Array", t);
      if (t.length < r) {
        let o = `must be longer than ${r}`;
        throw new hf(e, t, o);
      }
    });
    function d8(t, e) {
      kh(t, e);
      for (let r = 0;r < t.length; r++)
        Th(t[r], `${e}[${r}]`);
    }
    function c8(t, e) {
      kh(t, e);
      for (let r = 0;r < t.length; r++)
        g1(t[r], `${e}[${r}]`);
    }
    function p8(t, e = "signal") {
      if (Th(t, e), d1[t] === undefined)
        throw d1[G_(t)] !== undefined ? new l1(t + " (signals must use all capital letters)") : new l1(t);
    }
    var v8 = pr((t, e = "buffer") => {
      if (!e8(t))
        throw new Qt(e, ["Buffer", "TypedArray", "DataView"], t);
    });
    function b8(t, e) {
      let r = J_(e), o = t.length;
      if (r === "hex" && o % 2 !== 0)
        throw new hf("encoding", e, `is invalid for data of length ${o}`);
    }
    function m8(t, e = "Port", r = true) {
      if (typeof t != "number" && typeof t != "string" || typeof t == "string" && Y_(t).length === 0 || +t !== +t >>> 0 || t > 65535 || t === 0 && !r)
        throw new X_(e, t, r);
      return t | 0;
    }
    var g8 = pr((t, e) => {
      if (t !== undefined && (t === null || typeof t != "object" || !("aborted" in t)))
        throw new Qt(e, "AbortSignal", t);
    }), y8 = pr((t, e) => {
      if (typeof t != "function")
        throw new Qt(e, "Function", t);
    }), w8 = pr((t, e) => {
      if (typeof t != "function" || Q_(t))
        throw new Qt(e, "Function", t);
    }), M8 = pr((t, e) => {
      if (t !== undefined)
        throw new Qt(e, "undefined", t);
    });
    function _8(t, e, r) {
      if (!p1(r, t))
        throw new Qt(e, `('${v1(r, "|")}')`, t);
    }
    var x8 = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
    function c1(t, e) {
      if (typeof t > "u" || !b1(x8, t))
        throw new hf(e, t, 'must be an array or string of format "</styles.css>; rel=preload; as=style"');
    }
    function S8(t) {
      if (typeof t == "string")
        return c1(t, "hints"), t;
      if (qh(t)) {
        let e = t.length, r = "";
        if (e === 0)
          return r;
        for (let o = 0;o < e; o++) {
          let f2 = t[o];
          c1(f2, "hints"), r += f2, o !== e - 1 && (r += ", ");
        }
        return r;
      }
      throw new hf("hints", t, 'must be an array or string of format "</styles.css>; rel=preload; as=style"');
    }
    y1.exports = { isInt32: t8, isUint32: r8, parseFileMode: f8, validateArray: kh, validateStringArray: d8, validateBooleanArray: c8, validateBoolean: g1, validateBuffer: v8, validateDictionary: l8, validateEncoding: b8, validateFunction: y8, validateInt32: o8, validateInteger: a8, validateNumber: s8, validateObject: u8, validateOneOf: h8, validatePlainFunction: w8, validatePort: m8, validateSignalName: p8, validateString: Th, validateUint32: m1, validateUndefined: M8, validateUnion: _8, validateAbortSignal: g8, validateLinkHeaderValue: S8 };
  });
  Ph = k((ST, x1) => {
    var dt = x1.exports = {}, Yr, Xr;
    function Lh() {
      throw new Error("setTimeout has not been defined");
    }
    function Nh() {
      throw new Error("clearTimeout has not been defined");
    }
    (function() {
      try {
        typeof setTimeout == "function" ? Yr = setTimeout : Yr = Lh;
      } catch {
        Yr = Lh;
      }
      try {
        typeof clearTimeout == "function" ? Xr = clearTimeout : Xr = Nh;
      } catch {
        Xr = Nh;
      }
    })();
    function w1(t) {
      if (Yr === setTimeout)
        return setTimeout(t, 0);
      if ((Yr === Lh || !Yr) && setTimeout)
        return Yr = setTimeout, setTimeout(t, 0);
      try {
        return Yr(t, 0);
      } catch {
        try {
          return Yr.call(null, t, 0);
        } catch {
          return Yr.call(this, t, 0);
        }
      }
    }
    function E8(t) {
      if (Xr === clearTimeout)
        return clearTimeout(t);
      if ((Xr === Nh || !Xr) && clearTimeout)
        return Xr = clearTimeout, clearTimeout(t);
      try {
        return Xr(t);
      } catch {
        try {
          return Xr.call(null, t);
        } catch {
          return Xr.call(this, t);
        }
      }
    }
    var mi = [], uf = false, yn, Ho = -1;
    function A8() {
      !uf || !yn || (uf = false, yn.length ? mi = yn.concat(mi) : Ho = -1, mi.length && M1());
    }
    function M1() {
      if (!uf) {
        var t = w1(A8);
        uf = true;
        for (var e = mi.length;e; ) {
          for (yn = mi, mi = [];++Ho < e; )
            yn && yn[Ho].run();
          Ho = -1, e = mi.length;
        }
        yn = null, uf = false, E8(t);
      }
    }
    dt.nextTick = function(t) {
      var e = new Array(arguments.length - 1);
      if (arguments.length > 1)
        for (var r = 1;r < arguments.length; r++)
          e[r - 1] = arguments[r];
      mi.push(new _1(t, e)), mi.length === 1 && !uf && w1(M1);
    };
    function _1(t, e) {
      this.fun = t, this.array = e;
    }
    _1.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    dt.title = "browser";
    dt.browser = true;
    dt.env = {};
    dt.argv = [];
    dt.version = "";
    dt.versions = {};
    function gi() {
    }
    dt.on = gi;
    dt.addListener = gi;
    dt.once = gi;
    dt.off = gi;
    dt.removeListener = gi;
    dt.removeAllListeners = gi;
    dt.emit = gi;
    dt.prependListener = gi;
    dt.prependOnceListener = gi;
    dt.listeners = function(t) {
      return [];
    };
    dt.binding = function(t) {
      throw new Error("process.binding is not supported");
    };
    dt.cwd = function() {
      return "/";
    };
    dt.chdir = function(t) {
      throw new Error("process.chdir is not supported");
    };
    dt.umask = function() {
      return 0;
    };
  });
  vr = {};
  io(vr, { default: () => R8 });
  Hi = k0(() => {
    ot(vr, fn(Ph()));
    R8 = fn(Ph());
  });
  Qr = k((AT, F1) => {
    var { Symbol: Wo, SymbolAsyncIterator: S1, SymbolIterator: E1, SymbolFor: A1 } = Tt(), R1 = Wo("kDestroyed"), B1 = Wo("kIsErrored"), Dh = Wo("kIsReadable"), q1 = Wo("kIsDisturbed"), B8 = A1("nodejs.webstream.isClosedPromise"), q8 = A1("nodejs.webstream.controllerErrorFunction");
    function Ko(t, e = false) {
      var r;
      return !!(t && typeof t.pipe == "function" && typeof t.on == "function" && (!e || typeof t.pause == "function" && typeof t.resume == "function") && (!t._writableState || ((r = t._readableState) === null || r === undefined ? undefined : r.readable) !== false) && (!t._writableState || t._readableState));
    }
    function jo(t) {
      var e;
      return !!(t && typeof t.write == "function" && typeof t.on == "function" && (!t._readableState || ((e = t._writableState) === null || e === undefined ? undefined : e.writable) !== false));
    }
    function I8(t) {
      return !!(t && typeof t.pipe == "function" && t._readableState && typeof t.on == "function" && typeof t.write == "function");
    }
    function Jr(t) {
      return t && (t._readableState || t._writableState || typeof t.write == "function" && typeof t.on == "function" || typeof t.pipe == "function" && typeof t.on == "function");
    }
    function I1(t) {
      return !!(t && !Jr(t) && typeof t.pipeThrough == "function" && typeof t.getReader == "function" && typeof t.cancel == "function");
    }
    function T1(t) {
      return !!(t && !Jr(t) && typeof t.getWriter == "function" && typeof t.abort == "function");
    }
    function k1(t) {
      return !!(t && !Jr(t) && typeof t.readable == "object" && typeof t.writable == "object");
    }
    function T8(t) {
      return I1(t) || T1(t) || k1(t);
    }
    function k8(t, e) {
      return t == null ? false : e === true ? typeof t[S1] == "function" : e === false ? typeof t[E1] == "function" : typeof t[S1] == "function" || typeof t[E1] == "function";
    }
    function Zo(t) {
      if (!Jr(t))
        return null;
      let { _writableState: e, _readableState: r } = t, o = e || r;
      return !!(t.destroyed || t[R1] || o != null && o.destroyed);
    }
    function L1(t) {
      if (!jo(t))
        return null;
      if (t.writableEnded === true)
        return true;
      let e = t._writableState;
      return e != null && e.errored ? false : typeof e?.ended != "boolean" ? null : e.ended;
    }
    function L8(t, e) {
      if (!jo(t))
        return null;
      if (t.writableFinished === true)
        return true;
      let r = t._writableState;
      return r != null && r.errored ? false : typeof r?.finished != "boolean" ? null : !!(r.finished || e === false && r.ended === true && r.length === 0);
    }
    function N8(t) {
      if (!Ko(t))
        return null;
      if (t.readableEnded === true)
        return true;
      let e = t._readableState;
      return !e || e.errored ? false : typeof e?.ended != "boolean" ? null : e.ended;
    }
    function N1(t, e) {
      if (!Ko(t))
        return null;
      let r = t._readableState;
      return r != null && r.errored ? false : typeof r?.endEmitted != "boolean" ? null : !!(r.endEmitted || e === false && r.ended === true && r.length === 0);
    }
    function P1(t) {
      return t && t[Dh] != null ? t[Dh] : typeof t?.readable != "boolean" ? null : Zo(t) ? false : Ko(t) && t.readable && !N1(t);
    }
    function D1(t) {
      return typeof t?.writable != "boolean" ? null : Zo(t) ? false : jo(t) && t.writable && !L1(t);
    }
    function P8(t, e) {
      return Jr(t) ? Zo(t) ? true : !(e?.readable !== false && P1(t) || e?.writable !== false && D1(t)) : null;
    }
    function D8(t) {
      var e, r;
      return Jr(t) ? t.writableErrored ? t.writableErrored : (e = (r = t._writableState) === null || r === undefined ? undefined : r.errored) !== null && e !== undefined ? e : null : null;
    }
    function C8(t) {
      var e, r;
      return Jr(t) ? t.readableErrored ? t.readableErrored : (e = (r = t._readableState) === null || r === undefined ? undefined : r.errored) !== null && e !== undefined ? e : null : null;
    }
    function O8(t) {
      if (!Jr(t))
        return null;
      if (typeof t.closed == "boolean")
        return t.closed;
      let { _writableState: e, _readableState: r } = t;
      return typeof e?.closed == "boolean" || typeof r?.closed == "boolean" ? e?.closed || r?.closed : typeof t._closed == "boolean" && C1(t) ? t._closed : null;
    }
    function C1(t) {
      return typeof t._closed == "boolean" && typeof t._defaultKeepAlive == "boolean" && typeof t._removedConnection == "boolean" && typeof t._removedContLen == "boolean";
    }
    function O1(t) {
      return typeof t._sent100 == "boolean" && C1(t);
    }
    function F8(t) {
      var e;
      return typeof t._consuming == "boolean" && typeof t._dumped == "boolean" && ((e = t.req) === null || e === undefined ? undefined : e.upgradeOrConnect) === undefined;
    }
    function U8(t) {
      if (!Jr(t))
        return null;
      let { _writableState: e, _readableState: r } = t, o = e || r;
      return !o && O1(t) || !!(o && o.autoDestroy && o.emitClose && o.closed === false);
    }
    function z8(t) {
      var e;
      return !!(t && ((e = t[q1]) !== null && e !== undefined ? e : t.readableDidRead || t.readableAborted));
    }
    function H8(t) {
      var e, r, o, f2, p, m, y, M, x, S2;
      return !!(t && ((e = (r = (o = (f2 = (p = (m = t[B1]) !== null && m !== undefined ? m : t.readableErrored) !== null && p !== undefined ? p : t.writableErrored) !== null && f2 !== undefined ? f2 : (y = t._readableState) === null || y === undefined ? undefined : y.errorEmitted) !== null && o !== undefined ? o : (M = t._writableState) === null || M === undefined ? undefined : M.errorEmitted) !== null && r !== undefined ? r : (x = t._readableState) === null || x === undefined ? undefined : x.errored) !== null && e !== undefined ? e : (S2 = t._writableState) === null || S2 === undefined ? undefined : S2.errored));
    }
    F1.exports = { kDestroyed: R1, isDisturbed: z8, kIsDisturbed: q1, isErrored: H8, kIsErrored: B1, isReadable: P1, kIsReadable: Dh, kIsClosedPromise: B8, kControllerErrorFunction: q8, isClosed: O8, isDestroyed: Zo, isDuplexNodeStream: I8, isFinished: P8, isIterable: k8, isReadableNodeStream: Ko, isReadableStream: I1, isReadableEnded: N8, isReadableFinished: N1, isReadableErrored: C8, isNodeStream: Jr, isWebStream: T8, isWritable: D1, isWritableNodeStream: jo, isWritableStream: T1, isWritableEnded: L1, isWritableFinished: L8, isWritableErrored: D8, isServerRequest: F8, isServerResponse: O1, willEmitClose: U8, isTransformStream: k1 };
  });
  yi = k((RT, zh) => {
    var Wi = (Hi(), ur(vr)), { AbortError: $1, codes: W8 } = Jt(), { ERR_INVALID_ARG_TYPE: K8, ERR_STREAM_PREMATURE_CLOSE: U1 } = W8, { kEmptyObject: Oh, once: Fh } = Gr(), { validateAbortSignal: j8, validateFunction: Z8, validateObject: V8, validateBoolean: $8 } = ma(), { Promise: G8, PromisePrototypeThen: Y8 } = Tt(), { isClosed: X8, isReadable: z1, isReadableNodeStream: Ch, isReadableStream: J8, isReadableFinished: H1, isReadableErrored: W1, isWritable: K1, isWritableNodeStream: j1, isWritableStream: Q8, isWritableFinished: Z1, isWritableErrored: V1, isNodeStream: e5, willEmitClose: t5, kIsClosedPromise: r5 } = Qr();
    function i5(t) {
      return t.setHeader && typeof t.abort == "function";
    }
    var Uh = () => {
    };
    function G1(t, e, r) {
      var o, f2;
      if (arguments.length === 2 ? (r = e, e = Oh) : e == null ? e = Oh : V8(e, "options"), Z8(r, "callback"), j8(e.signal, "options.signal"), r = Fh(r), J8(t) || Q8(t))
        return n5(t, e, r);
      if (!e5(t))
        throw new K8("stream", ["ReadableStream", "WritableStream", "Stream"], t);
      let p = (o = e.readable) !== null && o !== undefined ? o : Ch(t), m = (f2 = e.writable) !== null && f2 !== undefined ? f2 : j1(t), y = t._writableState, M = t._readableState, x = () => {
        t.writable || R();
      }, S2 = t5(t) && Ch(t) === p && j1(t) === m, E = Z1(t, false), R = () => {
        E = true, t.destroyed && (S2 = false), !(S2 && (!t.readable || p)) && (!p || q) && r.call(t);
      }, q = H1(t, false), T = () => {
        q = true, t.destroyed && (S2 = false), !(S2 && (!t.writable || m)) && (!m || E) && r.call(t);
      }, ye = (Ae) => {
        r.call(t, Ae);
      }, _e = X8(t), P = () => {
        _e = true;
        let Ae = V1(t) || W1(t);
        if (Ae && typeof Ae != "boolean")
          return r.call(t, Ae);
        if (p && !q && Ch(t, true) && !H1(t, false))
          return r.call(t, new U1);
        if (m && !E && !Z1(t, false))
          return r.call(t, new U1);
        r.call(t);
      }, Me = () => {
        _e = true;
        let Ae = V1(t) || W1(t);
        if (Ae && typeof Ae != "boolean")
          return r.call(t, Ae);
        r.call(t);
      }, me = () => {
        t.req.on("finish", R);
      };
      i5(t) ? (t.on("complete", R), S2 || t.on("abort", P), t.req ? me() : t.on("request", me)) : m && !y && (t.on("end", x), t.on("close", x)), !S2 && typeof t.aborted == "boolean" && t.on("aborted", P), t.on("end", T), t.on("finish", R), e.error !== false && t.on("error", ye), t.on("close", P), _e ? Wi.nextTick(P) : y != null && y.errorEmitted || M != null && M.errorEmitted ? S2 || Wi.nextTick(Me) : (!p && (!S2 || z1(t)) && (E || K1(t) === false) || !m && (!S2 || K1(t)) && (q || z1(t) === false) || M && t.req && t.aborted) && Wi.nextTick(Me);
      let xe = () => {
        r = Uh, t.removeListener("aborted", P), t.removeListener("complete", R), t.removeListener("abort", P), t.removeListener("request", me), t.req && t.req.removeListener("finish", R), t.removeListener("end", x), t.removeListener("close", x), t.removeListener("finish", R), t.removeListener("end", T), t.removeListener("error", ye), t.removeListener("close", P);
      };
      if (e.signal && !_e) {
        let Ae = () => {
          let Ee = r;
          xe(), Ee.call(t, new $1(undefined, { cause: e.signal.reason }));
        };
        if (e.signal.aborted)
          Wi.nextTick(Ae);
        else {
          let Ee = r;
          r = Fh((...Re) => {
            e.signal.removeEventListener("abort", Ae), Ee.apply(t, Re);
          }), e.signal.addEventListener("abort", Ae);
        }
      }
      return xe;
    }
    function n5(t, e, r) {
      let o = false, f2 = Uh;
      if (e.signal)
        if (f2 = () => {
          o = true, r.call(t, new $1(undefined, { cause: e.signal.reason }));
        }, e.signal.aborted)
          Wi.nextTick(f2);
        else {
          let m = r;
          r = Fh((...y) => {
            e.signal.removeEventListener("abort", f2), m.apply(t, y);
          }), e.signal.addEventListener("abort", f2);
        }
      let p = (...m) => {
        o || Wi.nextTick(() => r.apply(t, m));
      };
      return Y8(t[r5].promise, p, p), Uh;
    }
    function f5(t, e) {
      var r;
      let o = false;
      return e === null && (e = Oh), (r = e) !== null && r !== undefined && r.cleanup && ($8(e.cleanup, "cleanup"), o = e.cleanup), new G8((f2, p) => {
        let m = G1(t, e, (y) => {
          o && m(), y ? p(y) : f2();
        });
      });
    }
    zh.exports = G1;
    zh.exports.finished = f5;
  });
  wn = k((BT, iv) => {
    var ei = (Hi(), ur(vr)), { aggregateTwoErrors: a5, codes: { ERR_MULTIPLE_CALLBACK: o5 }, AbortError: s5 } = Jt(), { Symbol: J1 } = Tt(), { kDestroyed: h5, isDestroyed: u5, isFinished: l5, isServerRequest: d5 } = Qr(), Q1 = J1("kDestroy"), Hh = J1("kConstruct");
    function ev(t, e, r) {
      t && (t.stack, e && !e.errored && (e.errored = t), r && !r.errored && (r.errored = t));
    }
    function c5(t, e) {
      let r = this._readableState, o = this._writableState, f2 = o || r;
      return o != null && o.destroyed || r != null && r.destroyed ? (typeof e == "function" && e(), this) : (ev(t, o, r), o && (o.destroyed = true), r && (r.destroyed = true), f2.constructed ? Y1(this, t, e) : this.once(Q1, function(p) {
        Y1(this, a5(p, t), e);
      }), this);
    }
    function Y1(t, e, r) {
      let o = false;
      function f2(p) {
        if (o)
          return;
        o = true;
        let { _readableState: m, _writableState: y } = t;
        ev(p, y, m), y && (y.closed = true), m && (m.closed = true), typeof r == "function" && r(p), p ? ei.nextTick(p5, t, p) : ei.nextTick(tv, t);
      }
      try {
        t._destroy(e || null, f2);
      } catch (p) {
        f2(p);
      }
    }
    function p5(t, e) {
      Wh(t, e), tv(t);
    }
    function tv(t) {
      let { _readableState: e, _writableState: r } = t;
      r && (r.closeEmitted = true), e && (e.closeEmitted = true), (r != null && r.emitClose || e != null && e.emitClose) && t.emit("close");
    }
    function Wh(t, e) {
      let { _readableState: r, _writableState: o } = t;
      o != null && o.errorEmitted || r != null && r.errorEmitted || (o && (o.errorEmitted = true), r && (r.errorEmitted = true), t.emit("error", e));
    }
    function v5() {
      let t = this._readableState, e = this._writableState;
      t && (t.constructed = true, t.closed = false, t.closeEmitted = false, t.destroyed = false, t.errored = null, t.errorEmitted = false, t.reading = false, t.ended = t.readable === false, t.endEmitted = t.readable === false), e && (e.constructed = true, e.destroyed = false, e.closed = false, e.closeEmitted = false, e.errored = null, e.errorEmitted = false, e.finalCalled = false, e.prefinished = false, e.ended = e.writable === false, e.ending = e.writable === false, e.finished = e.writable === false);
    }
    function Kh(t, e, r) {
      let { _readableState: o, _writableState: f2 } = t;
      if (f2 != null && f2.destroyed || o != null && o.destroyed)
        return this;
      o != null && o.autoDestroy || f2 != null && f2.autoDestroy ? t.destroy(e) : e && (e.stack, f2 && !f2.errored && (f2.errored = e), o && !o.errored && (o.errored = e), r ? ei.nextTick(Wh, t, e) : Wh(t, e));
    }
    function b5(t, e) {
      if (typeof t._construct != "function")
        return;
      let { _readableState: r, _writableState: o } = t;
      r && (r.constructed = false), o && (o.constructed = false), t.once(Hh, e), !(t.listenerCount(Hh) > 1) && ei.nextTick(m5, t);
    }
    function m5(t) {
      let e = false;
      function r(o) {
        if (e) {
          Kh(t, o ?? new o5);
          return;
        }
        e = true;
        let { _readableState: f2, _writableState: p } = t, m = p || f2;
        f2 && (f2.constructed = true), p && (p.constructed = true), m.destroyed ? t.emit(Q1, o) : o ? Kh(t, o, true) : ei.nextTick(g5, t);
      }
      try {
        t._construct((o) => {
          ei.nextTick(r, o);
        });
      } catch (o) {
        ei.nextTick(r, o);
      }
    }
    function g5(t) {
      t.emit(Hh);
    }
    function X1(t) {
      return t?.setHeader && typeof t.abort == "function";
    }
    function rv(t) {
      t.emit("close");
    }
    function y5(t, e) {
      t.emit("error", e), ei.nextTick(rv, t);
    }
    function w5(t, e) {
      !t || u5(t) || (!e && !l5(t) && (e = new s5), d5(t) ? (t.socket = null, t.destroy(e)) : X1(t) ? t.abort() : X1(t.req) ? t.req.abort() : typeof t.destroy == "function" ? t.destroy(e) : typeof t.close == "function" ? t.close() : e ? ei.nextTick(y5, t, e) : ei.nextTick(rv, t), t.destroyed || (t[h5] = true));
    }
    iv.exports = { construct: b5, destroyer: w5, destroy: c5, undestroy: v5, errorOrDestroy: Kh };
  });
  Go = k((qT, fv) => {
    var { ArrayIsArray: M5, ObjectSetPrototypeOf: nv } = Tt(), { EventEmitter: Vo } = Di();
    function $o(t) {
      Vo.call(this, t);
    }
    nv($o.prototype, Vo.prototype);
    nv($o, Vo);
    $o.prototype.pipe = function(t, e) {
      let r = this;
      function o(S2) {
        t.writable && t.write(S2) === false && r.pause && r.pause();
      }
      r.on("data", o);
      function f2() {
        r.readable && r.resume && r.resume();
      }
      t.on("drain", f2), !t._isStdio && (!e || e.end !== false) && (r.on("end", m), r.on("close", y));
      let p = false;
      function m() {
        p || (p = true, t.end());
      }
      function y() {
        p || (p = true, typeof t.destroy == "function" && t.destroy());
      }
      function M(S2) {
        x(), Vo.listenerCount(this, "error") === 0 && this.emit("error", S2);
      }
      jh(r, "error", M), jh(t, "error", M);
      function x() {
        r.removeListener("data", o), t.removeListener("drain", f2), r.removeListener("end", m), r.removeListener("close", y), r.removeListener("error", M), t.removeListener("error", M), r.removeListener("end", x), r.removeListener("close", x), t.removeListener("close", x);
      }
      return r.on("end", x), r.on("close", x), t.on("close", x), t.emit("pipe", r), t;
    };
    function jh(t, e, r) {
      if (typeof t.prependListener == "function")
        return t.prependListener(e, r);
      !t._events || !t._events[e] ? t.on(e, r) : M5(t._events[e]) ? t._events[e].unshift(r) : t._events[e] = [r, t._events[e]];
    }
    fv.exports = { Stream: $o, prependListener: jh };
  });
  ga = k((IT, Yo) => {
    var { AbortError: av, codes: _5 } = Jt(), { isNodeStream: ov, isWebStream: x5, kControllerErrorFunction: S5 } = Qr(), E5 = yi(), { ERR_INVALID_ARG_TYPE: sv } = _5, A5 = (t, e) => {
      if (typeof t != "object" || !("aborted" in t))
        throw new sv(e, "AbortSignal", t);
    };
    Yo.exports.addAbortSignal = function(e, r) {
      if (A5(e, "signal"), !ov(r) && !x5(r))
        throw new sv("stream", ["ReadableStream", "WritableStream", "Stream"], r);
      return Yo.exports.addAbortSignalNoValidate(e, r);
    };
    Yo.exports.addAbortSignalNoValidate = function(t, e) {
      if (typeof t != "object" || !("aborted" in t))
        return e;
      let r = ov(e) ? () => {
        e.destroy(new av(undefined, { cause: t.reason }));
      } : () => {
        e[S5](new av(undefined, { cause: t.reason }));
      };
      return t.aborted ? r() : (t.addEventListener("abort", r), E5(e, () => t.removeEventListener("abort", r))), e;
    };
  });
  lv = k((kT, uv) => {
    var { StringPrototypeSlice: hv, SymbolIterator: R5, TypedArrayPrototypeSet: Xo, Uint8Array: B5 } = Tt(), { Buffer: Zh } = Ut(), { inspect: q5 } = Gr();
    uv.exports = class {
      constructor() {
        this.head = null, this.tail = null, this.length = 0;
      }
      push(e) {
        let r = { data: e, next: null };
        this.length > 0 ? this.tail.next = r : this.head = r, this.tail = r, ++this.length;
      }
      unshift(e) {
        let r = { data: e, next: this.head };
        this.length === 0 && (this.tail = r), this.head = r, ++this.length;
      }
      shift() {
        if (this.length === 0)
          return;
        let e = this.head.data;
        return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, e;
      }
      clear() {
        this.head = this.tail = null, this.length = 0;
      }
      join(e) {
        if (this.length === 0)
          return "";
        let r = this.head, o = "" + r.data;
        for (;(r = r.next) !== null; )
          o += e + r.data;
        return o;
      }
      concat(e) {
        if (this.length === 0)
          return Zh.alloc(0);
        let r = Zh.allocUnsafe(e >>> 0), o = this.head, f2 = 0;
        for (;o; )
          Xo(r, o.data, f2), f2 += o.data.length, o = o.next;
        return r;
      }
      consume(e, r) {
        let o = this.head.data;
        if (e < o.length) {
          let f2 = o.slice(0, e);
          return this.head.data = o.slice(e), f2;
        }
        return e === o.length ? this.shift() : r ? this._getString(e) : this._getBuffer(e);
      }
      first() {
        return this.head.data;
      }
      *[R5]() {
        for (let e = this.head;e; e = e.next)
          yield e.data;
      }
      _getString(e) {
        let r = "", o = this.head, f2 = 0;
        do {
          let p = o.data;
          if (e > p.length)
            r += p, e -= p.length;
          else {
            e === p.length ? (r += p, ++f2, o.next ? this.head = o.next : this.head = this.tail = null) : (r += hv(p, 0, e), this.head = o, o.data = hv(p, e));
            break;
          }
          ++f2;
        } while ((o = o.next) !== null);
        return this.length -= f2, r;
      }
      _getBuffer(e) {
        let r = Zh.allocUnsafe(e), o = e, f2 = this.head, p = 0;
        do {
          let m = f2.data;
          if (e > m.length)
            Xo(r, m, o - e), e -= m.length;
          else {
            e === m.length ? (Xo(r, m, o - e), ++p, f2.next ? this.head = f2.next : this.head = this.tail = null) : (Xo(r, new B5(m.buffer, m.byteOffset, e), o - e), this.head = f2, f2.data = m.slice(e));
            break;
          }
          ++p;
        } while ((f2 = f2.next) !== null);
        return this.length -= p, r;
      }
      [Symbol.for("nodejs.util.inspect.custom")](e, r) {
        return q5(this, { ...r, depth: 0, customInspect: false });
      }
    };
  });
  Jo = k((LT, cv) => {
    var { MathFloor: I5, NumberIsInteger: T5 } = Tt(), { ERR_INVALID_ARG_VALUE: k5 } = Jt().codes;
    function L5(t, e, r) {
      return t.highWaterMark != null ? t.highWaterMark : e ? t[r] : null;
    }
    function dv(t) {
      return t ? 16 : 16 * 1024;
    }
    function N5(t, e, r, o) {
      let f2 = L5(e, o, r);
      if (f2 != null) {
        if (!T5(f2) || f2 < 0) {
          let p = o ? `options.${r}` : "options.highWaterMark";
          throw new k5(p, f2);
        }
        return I5(f2);
      }
      return dv(t.objectMode);
    }
    cv.exports = { getHighWaterMark: N5, getDefaultHighWaterMark: dv };
  });
  Vh = k((NT, mv) => {
    var pv = (Hi(), ur(vr)), { PromisePrototypeThen: P5, SymbolAsyncIterator: vv, SymbolIterator: bv } = Tt(), { Buffer: D5 } = Ut(), { ERR_INVALID_ARG_TYPE: C5, ERR_STREAM_NULL_VALUES: O5 } = Jt().codes;
    function F5(t, e, r) {
      let o;
      if (typeof e == "string" || e instanceof D5)
        return new t({ objectMode: true, ...r, read() {
          this.push(e), this.push(null);
        } });
      let f2;
      if (e && e[vv])
        f2 = true, o = e[vv]();
      else if (e && e[bv])
        f2 = false, o = e[bv]();
      else
        throw new C5("iterable", ["Iterable"], e);
      let p = new t({ objectMode: true, highWaterMark: 1, ...r }), m = false;
      p._read = function() {
        m || (m = true, M());
      }, p._destroy = function(x, S2) {
        P5(y(x), () => pv.nextTick(S2, x), (E) => pv.nextTick(S2, E || x));
      };
      async function y(x) {
        let S2 = x != null, E = typeof o.throw == "function";
        if (S2 && E) {
          let { value: R, done: q } = await o.throw(x);
          if (await R, q)
            return;
        }
        if (typeof o.return == "function") {
          let { value: R } = await o.return();
          await R;
        }
      }
      async function M() {
        for (;; ) {
          try {
            let { value: x, done: S2 } = f2 ? await o.next() : o.next();
            if (S2)
              p.push(null);
            else {
              let E = x && typeof x.then == "function" ? await x : x;
              if (E === null)
                throw m = false, new O5;
              if (p.push(E))
                continue;
              m = false;
            }
          } catch (x) {
            p.destroy(x);
          }
          break;
        }
      }
      return p;
    }
    mv.exports = F5;
  });
  ya = k((PT, Iv) => {
    var Tr = (Hi(), ur(vr)), { ArrayPrototypeIndexOf: U5, NumberIsInteger: z5, NumberIsNaN: H5, NumberParseInt: W5, ObjectDefineProperties: wv, ObjectKeys: K5, ObjectSetPrototypeOf: Mv, Promise: j5, SafeSet: Z5, SymbolAsyncIterator: V5, Symbol: $5 } = Tt();
    Iv.exports = Le;
    Le.ReadableState = Qh;
    var { EventEmitter: G5 } = Di(), { Stream: Ki, prependListener: Y5 } = Go(), { Buffer: $h } = Ut(), { addAbortSignal: X5 } = ga(), J5 = yi(), De = Gr().debuglog("stream", (t) => {
      De = t;
    }), Q5 = lv(), df = wn(), { getHighWaterMark: ex, getDefaultHighWaterMark: tx } = Jo(), { aggregateTwoErrors: gv, codes: { ERR_INVALID_ARG_TYPE: rx, ERR_METHOD_NOT_IMPLEMENTED: ix, ERR_OUT_OF_RANGE: nx, ERR_STREAM_PUSH_AFTER_EOF: fx, ERR_STREAM_UNSHIFT_AFTER_END_EVENT: ax } } = Jt(), { validateObject: ox } = ma(), Mn = $5("kPaused"), { StringDecoder: _v } = go(), sx = Vh();
    Mv(Le.prototype, Ki.prototype);
    Mv(Le, Ki);
    var Gh = () => {
    }, { errorOrDestroy: lf } = df;
    function Qh(t, e, r) {
      typeof r != "boolean" && (r = e instanceof ti()), this.objectMode = !!(t && t.objectMode), r && (this.objectMode = this.objectMode || !!(t && t.readableObjectMode)), this.highWaterMark = t ? ex(this, t, "readableHighWaterMark", r) : tx(false), this.buffer = new Q5, this.length = 0, this.pipes = [], this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.constructed = true, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this[Mn] = null, this.errorEmitted = false, this.emitClose = !t || t.emitClose !== false, this.autoDestroy = !t || t.autoDestroy !== false, this.destroyed = false, this.errored = null, this.closed = false, this.closeEmitted = false, this.defaultEncoding = t && t.defaultEncoding || "utf8", this.awaitDrainWriters = null, this.multiAwaitDrain = false, this.readingMore = false, this.dataEmitted = false, this.decoder = null, this.encoding = null, t && t.encoding && (this.decoder = new _v(t.encoding), this.encoding = t.encoding);
    }
    function Le(t) {
      if (!(this instanceof Le))
        return new Le(t);
      let e = this instanceof ti();
      this._readableState = new Qh(t, this, e), t && (typeof t.read == "function" && (this._read = t.read), typeof t.destroy == "function" && (this._destroy = t.destroy), typeof t.construct == "function" && (this._construct = t.construct), t.signal && !e && X5(t.signal, this)), Ki.call(this, t), df.construct(this, () => {
        this._readableState.needReadable && Qo(this, this._readableState);
      });
    }
    Le.prototype.destroy = df.destroy;
    Le.prototype._undestroy = df.undestroy;
    Le.prototype._destroy = function(t, e) {
      e(t);
    };
    Le.prototype[G5.captureRejectionSymbol] = function(t) {
      this.destroy(t);
    };
    Le.prototype.push = function(t, e) {
      return xv(this, t, e, false);
    };
    Le.prototype.unshift = function(t, e) {
      return xv(this, t, e, true);
    };
    function xv(t, e, r, o) {
      De("readableAddChunk", e);
      let f2 = t._readableState, p;
      if (f2.objectMode || (typeof e == "string" ? (r = r || f2.defaultEncoding, f2.encoding !== r && (o && f2.encoding ? e = $h.from(e, r).toString(f2.encoding) : (e = $h.from(e, r), r = ""))) : e instanceof $h ? r = "" : Ki._isUint8Array(e) ? (e = Ki._uint8ArrayToBuffer(e), r = "") : e != null && (p = new rx("chunk", ["string", "Buffer", "Uint8Array"], e))), p)
        lf(t, p);
      else if (e === null)
        f2.reading = false, lx(t, f2);
      else if (f2.objectMode || e && e.length > 0)
        if (o)
          if (f2.endEmitted)
            lf(t, new ax);
          else {
            if (f2.destroyed || f2.errored)
              return false;
            Yh(t, f2, e, true);
          }
        else if (f2.ended)
          lf(t, new fx);
        else {
          if (f2.destroyed || f2.errored)
            return false;
          f2.reading = false, f2.decoder && !r ? (e = f2.decoder.write(e), f2.objectMode || e.length !== 0 ? Yh(t, f2, e, false) : Qo(t, f2)) : Yh(t, f2, e, false);
        }
      else
        o || (f2.reading = false, Qo(t, f2));
      return !f2.ended && (f2.length < f2.highWaterMark || f2.length === 0);
    }
    function Yh(t, e, r, o) {
      e.flowing && e.length === 0 && !e.sync && t.listenerCount("data") > 0 ? (e.multiAwaitDrain ? e.awaitDrainWriters.clear() : e.awaitDrainWriters = null, e.dataEmitted = true, t.emit("data", r)) : (e.length += e.objectMode ? 1 : r.length, o ? e.buffer.unshift(r) : e.buffer.push(r), e.needReadable && es(t)), Qo(t, e);
    }
    Le.prototype.isPaused = function() {
      let t = this._readableState;
      return t[Mn] === true || t.flowing === false;
    };
    Le.prototype.setEncoding = function(t) {
      let e = new _v(t);
      this._readableState.decoder = e, this._readableState.encoding = this._readableState.decoder.encoding;
      let r = this._readableState.buffer, o = "";
      for (let f2 of r)
        o += e.write(f2);
      return r.clear(), o !== "" && r.push(o), this._readableState.length = o.length, this;
    };
    var hx = 1073741824;
    function ux(t) {
      if (t > hx)
        throw new nx("size", "<= 1GiB", t);
      return t--, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, t |= t >>> 16, t++, t;
    }
    function yv(t, e) {
      return t <= 0 || e.length === 0 && e.ended ? 0 : e.objectMode ? 1 : H5(t) ? e.flowing && e.length ? e.buffer.first().length : e.length : t <= e.length ? t : e.ended ? e.length : 0;
    }
    Le.prototype.read = function(t) {
      De("read", t), t === undefined ? t = NaN : z5(t) || (t = W5(t, 10));
      let e = this._readableState, r = t;
      if (t > e.highWaterMark && (e.highWaterMark = ux(t)), t !== 0 && (e.emittedReadable = false), t === 0 && e.needReadable && ((e.highWaterMark !== 0 ? e.length >= e.highWaterMark : e.length > 0) || e.ended))
        return De("read: emitReadable", e.length, e.ended), e.length === 0 && e.ended ? Xh(this) : es(this), null;
      if (t = yv(t, e), t === 0 && e.ended)
        return e.length === 0 && Xh(this), null;
      let o = e.needReadable;
      if (De("need readable", o), (e.length === 0 || e.length - t < e.highWaterMark) && (o = true, De("length less than watermark", o)), e.ended || e.reading || e.destroyed || e.errored || !e.constructed)
        o = false, De("reading, ended or constructing", o);
      else if (o) {
        De("do read"), e.reading = true, e.sync = true, e.length === 0 && (e.needReadable = true);
        try {
          this._read(e.highWaterMark);
        } catch (p) {
          lf(this, p);
        }
        e.sync = false, e.reading || (t = yv(r, e));
      }
      let f2;
      return t > 0 ? f2 = Bv(t, e) : f2 = null, f2 === null ? (e.needReadable = e.length <= e.highWaterMark, t = 0) : (e.length -= t, e.multiAwaitDrain ? e.awaitDrainWriters.clear() : e.awaitDrainWriters = null), e.length === 0 && (e.ended || (e.needReadable = true), r !== t && e.ended && Xh(this)), f2 !== null && !e.errorEmitted && !e.closeEmitted && (e.dataEmitted = true, this.emit("data", f2)), f2;
    };
    function lx(t, e) {
      if (De("onEofChunk"), !e.ended) {
        if (e.decoder) {
          let r = e.decoder.end();
          r && r.length && (e.buffer.push(r), e.length += e.objectMode ? 1 : r.length);
        }
        e.ended = true, e.sync ? es(t) : (e.needReadable = false, e.emittedReadable = true, Sv(t));
      }
    }
    function es(t) {
      let e = t._readableState;
      De("emitReadable", e.needReadable, e.emittedReadable), e.needReadable = false, e.emittedReadable || (De("emitReadable", e.flowing), e.emittedReadable = true, Tr.nextTick(Sv, t));
    }
    function Sv(t) {
      let e = t._readableState;
      De("emitReadable_", e.destroyed, e.length, e.ended), !e.destroyed && !e.errored && (e.length || e.ended) && (t.emit("readable"), e.emittedReadable = false), e.needReadable = !e.flowing && !e.ended && e.length <= e.highWaterMark, Av(t);
    }
    function Qo(t, e) {
      !e.readingMore && e.constructed && (e.readingMore = true, Tr.nextTick(dx, t, e));
    }
    function dx(t, e) {
      for (;!e.reading && !e.ended && (e.length < e.highWaterMark || e.flowing && e.length === 0); ) {
        let r = e.length;
        if (De("maybeReadMore read 0"), t.read(0), r === e.length)
          break;
      }
      e.readingMore = false;
    }
    Le.prototype._read = function(t) {
      throw new ix("_read()");
    };
    Le.prototype.pipe = function(t, e) {
      let r = this, o = this._readableState;
      o.pipes.length === 1 && (o.multiAwaitDrain || (o.multiAwaitDrain = true, o.awaitDrainWriters = new Z5(o.awaitDrainWriters ? [o.awaitDrainWriters] : []))), o.pipes.push(t), De("pipe count=%d opts=%j", o.pipes.length, e);
      let p = (!e || e.end !== false) && t !== Tr.stdout && t !== Tr.stderr ? y : _e;
      o.endEmitted ? Tr.nextTick(p) : r.once("end", p), t.on("unpipe", m);
      function m(P, Me) {
        De("onunpipe"), P === r && Me && Me.hasUnpiped === false && (Me.hasUnpiped = true, S2());
      }
      function y() {
        De("onend"), t.end();
      }
      let M, x = false;
      function S2() {
        De("cleanup"), t.removeListener("close", T), t.removeListener("finish", ye), M && t.removeListener("drain", M), t.removeListener("error", q), t.removeListener("unpipe", m), r.removeListener("end", y), r.removeListener("end", _e), r.removeListener("data", R), x = true, M && o.awaitDrainWriters && (!t._writableState || t._writableState.needDrain) && M();
      }
      function E() {
        x || (o.pipes.length === 1 && o.pipes[0] === t ? (De("false write response, pause", 0), o.awaitDrainWriters = t, o.multiAwaitDrain = false) : o.pipes.length > 1 && o.pipes.includes(t) && (De("false write response, pause", o.awaitDrainWriters.size), o.awaitDrainWriters.add(t)), r.pause()), M || (M = cx(r, t), t.on("drain", M));
      }
      r.on("data", R);
      function R(P) {
        De("ondata");
        let Me = t.write(P);
        De("dest.write", Me), Me === false && E();
      }
      function q(P) {
        if (De("onerror", P), _e(), t.removeListener("error", q), t.listenerCount("error") === 0) {
          let Me = t._writableState || t._readableState;
          Me && !Me.errorEmitted ? lf(t, P) : t.emit("error", P);
        }
      }
      Y5(t, "error", q);
      function T() {
        t.removeListener("finish", ye), _e();
      }
      t.once("close", T);
      function ye() {
        De("onfinish"), t.removeListener("close", T), _e();
      }
      t.once("finish", ye);
      function _e() {
        De("unpipe"), r.unpipe(t);
      }
      return t.emit("pipe", r), t.writableNeedDrain === true ? o.flowing && E() : o.flowing || (De("pipe resume"), r.resume()), t;
    };
    function cx(t, e) {
      return function() {
        let o = t._readableState;
        o.awaitDrainWriters === e ? (De("pipeOnDrain", 1), o.awaitDrainWriters = null) : o.multiAwaitDrain && (De("pipeOnDrain", o.awaitDrainWriters.size), o.awaitDrainWriters.delete(e)), (!o.awaitDrainWriters || o.awaitDrainWriters.size === 0) && t.listenerCount("data") && t.resume();
      };
    }
    Le.prototype.unpipe = function(t) {
      let e = this._readableState, r = { hasUnpiped: false };
      if (e.pipes.length === 0)
        return this;
      if (!t) {
        let f2 = e.pipes;
        e.pipes = [], this.pause();
        for (let p = 0;p < f2.length; p++)
          f2[p].emit("unpipe", this, { hasUnpiped: false });
        return this;
      }
      let o = U5(e.pipes, t);
      return o === -1 ? this : (e.pipes.splice(o, 1), e.pipes.length === 0 && this.pause(), t.emit("unpipe", this, r), this);
    };
    Le.prototype.on = function(t, e) {
      let r = Ki.prototype.on.call(this, t, e), o = this._readableState;
      return t === "data" ? (o.readableListening = this.listenerCount("readable") > 0, o.flowing !== false && this.resume()) : t === "readable" && !o.endEmitted && !o.readableListening && (o.readableListening = o.needReadable = true, o.flowing = false, o.emittedReadable = false, De("on readable", o.length, o.reading), o.length ? es(this) : o.reading || Tr.nextTick(px, this)), r;
    };
    Le.prototype.addListener = Le.prototype.on;
    Le.prototype.removeListener = function(t, e) {
      let r = Ki.prototype.removeListener.call(this, t, e);
      return t === "readable" && Tr.nextTick(Ev, this), r;
    };
    Le.prototype.off = Le.prototype.removeListener;
    Le.prototype.removeAllListeners = function(t) {
      let e = Ki.prototype.removeAllListeners.apply(this, arguments);
      return (t === "readable" || t === undefined) && Tr.nextTick(Ev, this), e;
    };
    function Ev(t) {
      let e = t._readableState;
      e.readableListening = t.listenerCount("readable") > 0, e.resumeScheduled && e[Mn] === false ? e.flowing = true : t.listenerCount("data") > 0 ? t.resume() : e.readableListening || (e.flowing = null);
    }
    function px(t) {
      De("readable nexttick read 0"), t.read(0);
    }
    Le.prototype.resume = function() {
      let t = this._readableState;
      return t.flowing || (De("resume"), t.flowing = !t.readableListening, vx(this, t)), t[Mn] = false, this;
    };
    function vx(t, e) {
      e.resumeScheduled || (e.resumeScheduled = true, Tr.nextTick(bx, t, e));
    }
    function bx(t, e) {
      De("resume", e.reading), e.reading || t.read(0), e.resumeScheduled = false, t.emit("resume"), Av(t), e.flowing && !e.reading && t.read(0);
    }
    Le.prototype.pause = function() {
      return De("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (De("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState[Mn] = true, this;
    };
    function Av(t) {
      let e = t._readableState;
      for (De("flow", e.flowing);e.flowing && t.read() !== null; )
        ;
    }
    Le.prototype.wrap = function(t) {
      let e = false;
      t.on("data", (o) => {
        !this.push(o) && t.pause && (e = true, t.pause());
      }), t.on("end", () => {
        this.push(null);
      }), t.on("error", (o) => {
        lf(this, o);
      }), t.on("close", () => {
        this.destroy();
      }), t.on("destroy", () => {
        this.destroy();
      }), this._read = () => {
        e && t.resume && (e = false, t.resume());
      };
      let r = K5(t);
      for (let o = 1;o < r.length; o++) {
        let f2 = r[o];
        this[f2] === undefined && typeof t[f2] == "function" && (this[f2] = t[f2].bind(t));
      }
      return this;
    };
    Le.prototype[V5] = function() {
      return Rv(this);
    };
    Le.prototype.iterator = function(t) {
      return t !== undefined && ox(t, "options"), Rv(this, t);
    };
    function Rv(t, e) {
      typeof t.read != "function" && (t = Le.wrap(t, { objectMode: true }));
      let r = mx(t, e);
      return r.stream = t, r;
    }
    async function* mx(t, e) {
      let r = Gh;
      function o(m) {
        this === t ? (r(), r = Gh) : r = m;
      }
      t.on("readable", o);
      let f2, p = J5(t, { writable: false }, (m) => {
        f2 = m ? gv(f2, m) : null, r(), r = Gh;
      });
      try {
        for (;; ) {
          let m = t.destroyed ? null : t.read();
          if (m !== null)
            yield m;
          else {
            if (f2)
              throw f2;
            if (f2 === null)
              return;
            await new j5(o);
          }
        }
      } catch (m) {
        throw f2 = gv(f2, m), f2;
      } finally {
        (f2 || e?.destroyOnReturn !== false) && (f2 === undefined || t._readableState.autoDestroy) ? df.destroyer(t, null) : (t.off("readable", o), p());
      }
    }
    wv(Le.prototype, { readable: { __proto__: null, get() {
      let t = this._readableState;
      return !!t && t.readable !== false && !t.destroyed && !t.errorEmitted && !t.endEmitted;
    }, set(t) {
      this._readableState && (this._readableState.readable = !!t);
    } }, readableDidRead: { __proto__: null, enumerable: false, get: function() {
      return this._readableState.dataEmitted;
    } }, readableAborted: { __proto__: null, enumerable: false, get: function() {
      return !!(this._readableState.readable !== false && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
    } }, readableHighWaterMark: { __proto__: null, enumerable: false, get: function() {
      return this._readableState.highWaterMark;
    } }, readableBuffer: { __proto__: null, enumerable: false, get: function() {
      return this._readableState && this._readableState.buffer;
    } }, readableFlowing: { __proto__: null, enumerable: false, get: function() {
      return this._readableState.flowing;
    }, set: function(t) {
      this._readableState && (this._readableState.flowing = t);
    } }, readableLength: { __proto__: null, enumerable: false, get() {
      return this._readableState.length;
    } }, readableObjectMode: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.objectMode : false;
    } }, readableEncoding: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.encoding : null;
    } }, errored: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.errored : null;
    } }, closed: { __proto__: null, get() {
      return this._readableState ? this._readableState.closed : false;
    } }, destroyed: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.destroyed : false;
    }, set(t) {
      !this._readableState || (this._readableState.destroyed = t);
    } }, readableEnded: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.endEmitted : false;
    } } });
    wv(Qh.prototype, { pipesCount: { __proto__: null, get() {
      return this.pipes.length;
    } }, paused: { __proto__: null, get() {
      return this[Mn] !== false;
    }, set(t) {
      this[Mn] = !!t;
    } } });
    Le._fromList = Bv;
    function Bv(t, e) {
      if (e.length === 0)
        return null;
      let r;
      return e.objectMode ? r = e.buffer.shift() : !t || t >= e.length ? (e.decoder ? r = e.buffer.join("") : e.buffer.length === 1 ? r = e.buffer.first() : r = e.buffer.concat(e.length), e.buffer.clear()) : r = e.buffer.consume(t, e.decoder), r;
    }
    function Xh(t) {
      let e = t._readableState;
      De("endReadable", e.endEmitted), e.endEmitted || (e.ended = true, Tr.nextTick(gx, e, t));
    }
    function gx(t, e) {
      if (De("endReadableNT", t.endEmitted, t.length), !t.errored && !t.closeEmitted && !t.endEmitted && t.length === 0) {
        if (t.endEmitted = true, e.emit("end"), e.writable && e.allowHalfOpen === false)
          Tr.nextTick(yx, e);
        else if (t.autoDestroy) {
          let r = e._writableState;
          (!r || r.autoDestroy && (r.finished || r.writable === false)) && e.destroy();
        }
      }
    }
    function yx(t) {
      t.writable && !t.writableEnded && !t.destroyed && t.end();
    }
    Le.from = function(t, e) {
      return sx(Le, t, e);
    };
    var Jh;
    function qv() {
      return Jh === undefined && (Jh = {}), Jh;
    }
    Le.fromWeb = function(t, e) {
      return qv().newStreamReadableFromReadableStream(t, e);
    };
    Le.toWeb = function(t, e) {
      return qv().newReadableStreamFromStreamReadable(t, e);
    };
    Le.wrap = function(t, e) {
      var r, o;
      return new Le({ objectMode: (r = (o = t.readableObjectMode) !== null && o !== undefined ? o : t.objectMode) !== null && r !== undefined ? r : true, ...e, destroy(f2, p) {
        df.destroyer(t, f2), p(f2);
      } }).wrap(t);
    };
  });
  au = k((DT, Hv) => {
    var _n = (Hi(), ur(vr)), { ArrayPrototypeSlice: Lv, Error: wx, FunctionPrototypeSymbolHasInstance: Nv, ObjectDefineProperty: Pv, ObjectDefineProperties: Mx, ObjectSetPrototypeOf: Dv, StringPrototypeToLowerCase: _x, Symbol: xx, SymbolHasInstance: Sx } = Tt();
    Hv.exports = st;
    st.WritableState = _a;
    var { EventEmitter: Ex } = Di(), wa = Go().Stream, { Buffer: ts } = Ut(), ns = wn(), { addAbortSignal: Ax } = ga(), { getHighWaterMark: Rx, getDefaultHighWaterMark: Bx } = Jo(), { ERR_INVALID_ARG_TYPE: qx, ERR_METHOD_NOT_IMPLEMENTED: Ix, ERR_MULTIPLE_CALLBACK: Cv, ERR_STREAM_CANNOT_PIPE: Tx, ERR_STREAM_DESTROYED: Ma, ERR_STREAM_ALREADY_FINISHED: kx, ERR_STREAM_NULL_VALUES: Lx, ERR_STREAM_WRITE_AFTER_END: Nx, ERR_UNKNOWN_ENCODING: Ov } = Jt().codes, { errorOrDestroy: cf } = ns;
    Dv(st.prototype, wa.prototype);
    Dv(st, wa);
    function ru() {
    }
    var pf = xx("kOnFinished");
    function _a(t, e, r) {
      typeof r != "boolean" && (r = e instanceof ti()), this.objectMode = !!(t && t.objectMode), r && (this.objectMode = this.objectMode || !!(t && t.writableObjectMode)), this.highWaterMark = t ? Rx(this, t, "writableHighWaterMark", r) : Bx(false), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
      let o = !!(t && t.decodeStrings === false);
      this.decodeStrings = !o, this.defaultEncoding = t && t.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = Dx.bind(undefined, e), this.writecb = null, this.writelen = 0, this.afterWriteTickInfo = null, is(this), this.pendingcb = 0, this.constructed = true, this.prefinished = false, this.errorEmitted = false, this.emitClose = !t || t.emitClose !== false, this.autoDestroy = !t || t.autoDestroy !== false, this.errored = null, this.closed = false, this.closeEmitted = false, this[pf] = [];
    }
    function is(t) {
      t.buffered = [], t.bufferedIndex = 0, t.allBuffers = true, t.allNoop = true;
    }
    _a.prototype.getBuffer = function() {
      return Lv(this.buffered, this.bufferedIndex);
    };
    Pv(_a.prototype, "bufferedRequestCount", { __proto__: null, get() {
      return this.buffered.length - this.bufferedIndex;
    } });
    function st(t) {
      let e = this instanceof ti();
      if (!e && !Nv(st, this))
        return new st(t);
      this._writableState = new _a(t, this, e), t && (typeof t.write == "function" && (this._write = t.write), typeof t.writev == "function" && (this._writev = t.writev), typeof t.destroy == "function" && (this._destroy = t.destroy), typeof t.final == "function" && (this._final = t.final), typeof t.construct == "function" && (this._construct = t.construct), t.signal && Ax(t.signal, this)), wa.call(this, t), ns.construct(this, () => {
        let r = this._writableState;
        r.writing || nu(this, r), fu(this, r);
      });
    }
    Pv(st, Sx, { __proto__: null, value: function(t) {
      return Nv(this, t) ? true : this !== st ? false : t && t._writableState instanceof _a;
    } });
    st.prototype.pipe = function() {
      cf(this, new Tx);
    };
    function Fv(t, e, r, o) {
      let f2 = t._writableState;
      if (typeof r == "function")
        o = r, r = f2.defaultEncoding;
      else {
        if (!r)
          r = f2.defaultEncoding;
        else if (r !== "buffer" && !ts.isEncoding(r))
          throw new Ov(r);
        typeof o != "function" && (o = ru);
      }
      if (e === null)
        throw new Lx;
      if (!f2.objectMode)
        if (typeof e == "string")
          f2.decodeStrings !== false && (e = ts.from(e, r), r = "buffer");
        else if (e instanceof ts)
          r = "buffer";
        else if (wa._isUint8Array(e))
          e = wa._uint8ArrayToBuffer(e), r = "buffer";
        else
          throw new qx("chunk", ["string", "Buffer", "Uint8Array"], e);
      let p;
      return f2.ending ? p = new Nx : f2.destroyed && (p = new Ma("write")), p ? (_n.nextTick(o, p), cf(t, p, true), p) : (f2.pendingcb++, Px(t, f2, e, r, o));
    }
    st.prototype.write = function(t, e, r) {
      return Fv(this, t, e, r) === true;
    };
    st.prototype.cork = function() {
      this._writableState.corked++;
    };
    st.prototype.uncork = function() {
      let t = this._writableState;
      t.corked && (t.corked--, t.writing || nu(this, t));
    };
    st.prototype.setDefaultEncoding = function(e) {
      if (typeof e == "string" && (e = _x(e)), !ts.isEncoding(e))
        throw new Ov(e);
      return this._writableState.defaultEncoding = e, this;
    };
    function Px(t, e, r, o, f2) {
      let p = e.objectMode ? 1 : r.length;
      e.length += p;
      let m = e.length < e.highWaterMark;
      return m || (e.needDrain = true), e.writing || e.corked || e.errored || !e.constructed ? (e.buffered.push({ chunk: r, encoding: o, callback: f2 }), e.allBuffers && o !== "buffer" && (e.allBuffers = false), e.allNoop && f2 !== ru && (e.allNoop = false)) : (e.writelen = p, e.writecb = f2, e.writing = true, e.sync = true, t._write(r, o, e.onwrite), e.sync = false), m && !e.errored && !e.destroyed;
    }
    function Tv(t, e, r, o, f2, p, m) {
      e.writelen = o, e.writecb = m, e.writing = true, e.sync = true, e.destroyed ? e.onwrite(new Ma("write")) : r ? t._writev(f2, e.onwrite) : t._write(f2, p, e.onwrite), e.sync = false;
    }
    function kv(t, e, r, o) {
      --e.pendingcb, o(r), iu(e), cf(t, r);
    }
    function Dx(t, e) {
      let r = t._writableState, o = r.sync, f2 = r.writecb;
      if (typeof f2 != "function") {
        cf(t, new Cv);
        return;
      }
      r.writing = false, r.writecb = null, r.length -= r.writelen, r.writelen = 0, e ? (e.stack, r.errored || (r.errored = e), t._readableState && !t._readableState.errored && (t._readableState.errored = e), o ? _n.nextTick(kv, t, r, e, f2) : kv(t, r, e, f2)) : (r.buffered.length > r.bufferedIndex && nu(t, r), o ? r.afterWriteTickInfo !== null && r.afterWriteTickInfo.cb === f2 ? r.afterWriteTickInfo.count++ : (r.afterWriteTickInfo = { count: 1, cb: f2, stream: t, state: r }, _n.nextTick(Cx, r.afterWriteTickInfo)) : Uv(t, r, 1, f2));
    }
    function Cx({ stream: t, state: e, count: r, cb: o }) {
      return e.afterWriteTickInfo = null, Uv(t, e, r, o);
    }
    function Uv(t, e, r, o) {
      for (!e.ending && !t.destroyed && e.length === 0 && e.needDrain && (e.needDrain = false, t.emit("drain"));r-- > 0; )
        e.pendingcb--, o();
      e.destroyed && iu(e), fu(t, e);
    }
    function iu(t) {
      if (t.writing)
        return;
      for (let f2 = t.bufferedIndex;f2 < t.buffered.length; ++f2) {
        var e;
        let { chunk: p, callback: m } = t.buffered[f2], y = t.objectMode ? 1 : p.length;
        t.length -= y, m((e = t.errored) !== null && e !== undefined ? e : new Ma("write"));
      }
      let r = t[pf].splice(0);
      for (let f2 = 0;f2 < r.length; f2++) {
        var o;
        r[f2]((o = t.errored) !== null && o !== undefined ? o : new Ma("end"));
      }
      is(t);
    }
    function nu(t, e) {
      if (e.corked || e.bufferProcessing || e.destroyed || !e.constructed)
        return;
      let { buffered: r, bufferedIndex: o, objectMode: f2 } = e, p = r.length - o;
      if (!p)
        return;
      let m = o;
      if (e.bufferProcessing = true, p > 1 && t._writev) {
        e.pendingcb -= p - 1;
        let y = e.allNoop ? ru : (x) => {
          for (let S2 = m;S2 < r.length; ++S2)
            r[S2].callback(x);
        }, M = e.allNoop && m === 0 ? r : Lv(r, m);
        M.allBuffers = e.allBuffers, Tv(t, e, true, e.length, M, "", y), is(e);
      } else {
        do {
          let { chunk: y, encoding: M, callback: x } = r[m];
          r[m++] = null;
          let S2 = f2 ? 1 : y.length;
          Tv(t, e, false, S2, y, M, x);
        } while (m < r.length && !e.writing);
        m === r.length ? is(e) : m > 256 ? (r.splice(0, m), e.bufferedIndex = 0) : e.bufferedIndex = m;
      }
      e.bufferProcessing = false;
    }
    st.prototype._write = function(t, e, r) {
      if (this._writev)
        this._writev([{ chunk: t, encoding: e }], r);
      else
        throw new Ix("_write()");
    };
    st.prototype._writev = null;
    st.prototype.end = function(t, e, r) {
      let o = this._writableState;
      typeof t == "function" ? (r = t, t = null, e = null) : typeof e == "function" && (r = e, e = null);
      let f2;
      if (t != null) {
        let p = Fv(this, t, e);
        p instanceof wx && (f2 = p);
      }
      return o.corked && (o.corked = 1, this.uncork()), f2 || (!o.errored && !o.ending ? (o.ending = true, fu(this, o, true), o.ended = true) : o.finished ? f2 = new kx("end") : o.destroyed && (f2 = new Ma("end"))), typeof r == "function" && (f2 || o.finished ? _n.nextTick(r, f2) : o[pf].push(r)), this;
    };
    function rs(t) {
      return t.ending && !t.destroyed && t.constructed && t.length === 0 && !t.errored && t.buffered.length === 0 && !t.finished && !t.writing && !t.errorEmitted && !t.closeEmitted;
    }
    function Ox(t, e) {
      let r = false;
      function o(f2) {
        if (r) {
          cf(t, f2 ?? Cv());
          return;
        }
        if (r = true, e.pendingcb--, f2) {
          let p = e[pf].splice(0);
          for (let m = 0;m < p.length; m++)
            p[m](f2);
          cf(t, f2, e.sync);
        } else
          rs(e) && (e.prefinished = true, t.emit("prefinish"), e.pendingcb++, _n.nextTick(tu, t, e));
      }
      e.sync = true, e.pendingcb++;
      try {
        t._final(o);
      } catch (f2) {
        o(f2);
      }
      e.sync = false;
    }
    function Fx(t, e) {
      !e.prefinished && !e.finalCalled && (typeof t._final == "function" && !e.destroyed ? (e.finalCalled = true, Ox(t, e)) : (e.prefinished = true, t.emit("prefinish")));
    }
    function fu(t, e, r) {
      rs(e) && (Fx(t, e), e.pendingcb === 0 && (r ? (e.pendingcb++, _n.nextTick((o, f2) => {
        rs(f2) ? tu(o, f2) : f2.pendingcb--;
      }, t, e)) : rs(e) && (e.pendingcb++, tu(t, e))));
    }
    function tu(t, e) {
      e.pendingcb--, e.finished = true;
      let r = e[pf].splice(0);
      for (let o = 0;o < r.length; o++)
        r[o]();
      if (t.emit("finish"), e.autoDestroy) {
        let o = t._readableState;
        (!o || o.autoDestroy && (o.endEmitted || o.readable === false)) && t.destroy();
      }
    }
    Mx(st.prototype, { closed: { __proto__: null, get() {
      return this._writableState ? this._writableState.closed : false;
    } }, destroyed: { __proto__: null, get() {
      return this._writableState ? this._writableState.destroyed : false;
    }, set(t) {
      this._writableState && (this._writableState.destroyed = t);
    } }, writable: { __proto__: null, get() {
      let t = this._writableState;
      return !!t && t.writable !== false && !t.destroyed && !t.errored && !t.ending && !t.ended;
    }, set(t) {
      this._writableState && (this._writableState.writable = !!t);
    } }, writableFinished: { __proto__: null, get() {
      return this._writableState ? this._writableState.finished : false;
    } }, writableObjectMode: { __proto__: null, get() {
      return this._writableState ? this._writableState.objectMode : false;
    } }, writableBuffer: { __proto__: null, get() {
      return this._writableState && this._writableState.getBuffer();
    } }, writableEnded: { __proto__: null, get() {
      return this._writableState ? this._writableState.ending : false;
    } }, writableNeedDrain: { __proto__: null, get() {
      let t = this._writableState;
      return t ? !t.destroyed && !t.ending && t.needDrain : false;
    } }, writableHighWaterMark: { __proto__: null, get() {
      return this._writableState && this._writableState.highWaterMark;
    } }, writableCorked: { __proto__: null, get() {
      return this._writableState ? this._writableState.corked : 0;
    } }, writableLength: { __proto__: null, get() {
      return this._writableState && this._writableState.length;
    } }, errored: { __proto__: null, enumerable: false, get() {
      return this._writableState ? this._writableState.errored : null;
    } }, writableAborted: { __proto__: null, enumerable: false, get: function() {
      return !!(this._writableState.writable !== false && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
    } } });
    var Ux = ns.destroy;
    st.prototype.destroy = function(t, e) {
      let r = this._writableState;
      return !r.destroyed && (r.bufferedIndex < r.buffered.length || r[pf].length) && _n.nextTick(iu, r), Ux.call(this, t, e), this;
    };
    st.prototype._undestroy = ns.undestroy;
    st.prototype._destroy = function(t, e) {
      e(t);
    };
    st.prototype[Ex.captureRejectionSymbol] = function(t) {
      this.destroy(t);
    };
    var eu;
    function zv() {
      return eu === undefined && (eu = {}), eu;
    }
    st.fromWeb = function(t, e) {
      return zv().newStreamWritableFromWritableStream(t, e);
    };
    st.toWeb = function(t) {
      return zv().newWritableStreamFromStreamWritable(t);
    };
  });
  eb = k((CT, Qv) => {
    var ou = (Hi(), ur(vr)), zx = Ut(), { isReadable: Hx, isWritable: Wx, isIterable: Wv, isNodeStream: Kx, isReadableNodeStream: Kv, isWritableNodeStream: jv, isDuplexNodeStream: jx } = Qr(), Zv = yi(), { AbortError: Jv, codes: { ERR_INVALID_ARG_TYPE: Zx, ERR_INVALID_RETURN_VALUE: Vv } } = Jt(), { destroyer: vf } = wn(), Vx = ti(), $x = ya(), { createDeferredPromise: $v } = Gr(), Gv = Vh(), Yv = globalThis.Blob || zx.Blob, Gx = typeof Yv < "u" ? function(e) {
      return e instanceof Yv;
    } : function(e) {
      return false;
    }, Yx = globalThis.AbortController || Fo().AbortController, { FunctionPrototypeCall: Xv } = Tt(), xn = class extends Vx {
      constructor(e) {
        super(e), e?.readable === false && (this._readableState.readable = false, this._readableState.ended = true, this._readableState.endEmitted = true), e?.writable === false && (this._writableState.writable = false, this._writableState.ending = true, this._writableState.ended = true, this._writableState.finished = true);
      }
    };
    Qv.exports = function t(e, r) {
      if (jx(e))
        return e;
      if (Kv(e))
        return fs({ readable: e });
      if (jv(e))
        return fs({ writable: e });
      if (Kx(e))
        return fs({ writable: false, readable: false });
      if (typeof e == "function") {
        let { value: f2, write: p, final: m, destroy: y } = Xx(e);
        if (Wv(f2))
          return Gv(xn, f2, { objectMode: true, write: p, final: m, destroy: y });
        let M = f2?.then;
        if (typeof M == "function") {
          let x, S2 = Xv(M, f2, (E) => {
            if (E != null)
              throw new Vv("nully", "body", E);
          }, (E) => {
            vf(x, E);
          });
          return x = new xn({ objectMode: true, readable: false, write: p, final(E) {
            m(async () => {
              try {
                await S2, ou.nextTick(E, null);
              } catch (R) {
                ou.nextTick(E, R);
              }
            });
          }, destroy: y });
        }
        throw new Vv("Iterable, AsyncIterable or AsyncFunction", r, f2);
      }
      if (Gx(e))
        return t(e.arrayBuffer());
      if (Wv(e))
        return Gv(xn, e, { objectMode: true, writable: false });
      if (typeof e?.writable == "object" || typeof e?.readable == "object") {
        let f2 = e != null && e.readable ? Kv(e?.readable) ? e?.readable : t(e.readable) : undefined, p = e != null && e.writable ? jv(e?.writable) ? e?.writable : t(e.writable) : undefined;
        return fs({ readable: f2, writable: p });
      }
      let o = e?.then;
      if (typeof o == "function") {
        let f2;
        return Xv(o, e, (p) => {
          p != null && f2.push(p), f2.push(null);
        }, (p) => {
          vf(f2, p);
        }), f2 = new xn({ objectMode: true, writable: false, read() {
        } });
      }
      throw new Zx(r, ["Blob", "ReadableStream", "WritableStream", "Stream", "Iterable", "AsyncIterable", "Function", "{ readable, writable } pair", "Promise"], e);
    };
    function Xx(t) {
      let { promise: e, resolve: r } = $v(), o = new Yx, f2 = o.signal;
      return { value: t(async function* () {
        for (;; ) {
          let m = e;
          e = null;
          let { chunk: y, done: M, cb: x } = await m;
          if (ou.nextTick(x), M)
            return;
          if (f2.aborted)
            throw new Jv(undefined, { cause: f2.reason });
          ({ promise: e, resolve: r } = $v()), yield y;
        }
      }(), { signal: f2 }), write(m, y, M) {
        let x = r;
        r = null, x({ chunk: m, done: false, cb: M });
      }, final(m) {
        let y = r;
        r = null, y({ done: true, cb: m });
      }, destroy(m, y) {
        o.abort(), y(m);
      } };
    }
    function fs(t) {
      let e = t.readable && typeof t.readable.read != "function" ? $x.wrap(t.readable) : t.readable, r = t.writable, o = !!Hx(e), f2 = !!Wx(r), p, m, y, M, x;
      function S2(E) {
        let R = M;
        M = null, R ? R(E) : E && x.destroy(E);
      }
      return x = new xn({ readableObjectMode: !!(e != null && e.readableObjectMode), writableObjectMode: !!(r != null && r.writableObjectMode), readable: o, writable: f2 }), f2 && (Zv(r, (E) => {
        f2 = false, E && vf(e, E), S2(E);
      }), x._write = function(E, R, q) {
        r.write(E, R) ? q() : p = q;
      }, x._final = function(E) {
        r.end(), m = E;
      }, r.on("drain", function() {
        if (p) {
          let E = p;
          p = null, E();
        }
      }), r.on("finish", function() {
        if (m) {
          let E = m;
          m = null, E();
        }
      })), o && (Zv(e, (E) => {
        o = false, E && vf(e, E), S2(E);
      }), e.on("readable", function() {
        if (y) {
          let E = y;
          y = null, E();
        }
      }), e.on("end", function() {
        x.push(null);
      }), x._read = function() {
        for (;; ) {
          let E = e.read();
          if (E === null) {
            y = x._read;
            return;
          }
          if (!x.push(E))
            return;
        }
      }), x._destroy = function(E, R) {
        !E && M !== null && (E = new Jv), y = null, p = null, m = null, M === null ? R(E) : (M = R, vf(r, E), vf(e, E));
      }, x;
    }
  });
  ti = k((OT, ib) => {
    var { ObjectDefineProperties: Jx, ObjectGetOwnPropertyDescriptor: wi, ObjectKeys: Qx, ObjectSetPrototypeOf: tb } = Tt();
    ib.exports = kr;
    var uu = ya(), br = au();
    tb(kr.prototype, uu.prototype);
    tb(kr, uu);
    {
      let t = Qx(br.prototype);
      for (let e = 0;e < t.length; e++) {
        let r = t[e];
        kr.prototype[r] || (kr.prototype[r] = br.prototype[r]);
      }
    }
    function kr(t) {
      if (!(this instanceof kr))
        return new kr(t);
      uu.call(this, t), br.call(this, t), t ? (this.allowHalfOpen = t.allowHalfOpen !== false, t.readable === false && (this._readableState.readable = false, this._readableState.ended = true, this._readableState.endEmitted = true), t.writable === false && (this._writableState.writable = false, this._writableState.ending = true, this._writableState.ended = true, this._writableState.finished = true)) : this.allowHalfOpen = true;
    }
    Jx(kr.prototype, { writable: { __proto__: null, ...wi(br.prototype, "writable") }, writableHighWaterMark: { __proto__: null, ...wi(br.prototype, "writableHighWaterMark") }, writableObjectMode: { __proto__: null, ...wi(br.prototype, "writableObjectMode") }, writableBuffer: { __proto__: null, ...wi(br.prototype, "writableBuffer") }, writableLength: { __proto__: null, ...wi(br.prototype, "writableLength") }, writableFinished: { __proto__: null, ...wi(br.prototype, "writableFinished") }, writableCorked: { __proto__: null, ...wi(br.prototype, "writableCorked") }, writableEnded: { __proto__: null, ...wi(br.prototype, "writableEnded") }, writableNeedDrain: { __proto__: null, ...wi(br.prototype, "writableNeedDrain") }, destroyed: { __proto__: null, get() {
      return this._readableState === undefined || this._writableState === undefined ? false : this._readableState.destroyed && this._writableState.destroyed;
    }, set(t) {
      this._readableState && this._writableState && (this._readableState.destroyed = t, this._writableState.destroyed = t);
    } } });
    var su;
    function rb() {
      return su === undefined && (su = {}), su;
    }
    kr.fromWeb = function(t, e) {
      return rb().newStreamDuplexFromReadableWritablePair(t, e);
    };
    kr.toWeb = function(t) {
      return rb().newReadableWritablePairFromDuplex(t);
    };
    var hu;
    kr.from = function(t) {
      return hu || (hu = eb()), hu(t, "body");
    };
  });
  cu = k((FT, fb) => {
    var { ObjectSetPrototypeOf: nb, Symbol: e7 } = Tt();
    fb.exports = Mi;
    var { ERR_METHOD_NOT_IMPLEMENTED: t7 } = Jt().codes, du = ti(), { getHighWaterMark: r7 } = Jo();
    nb(Mi.prototype, du.prototype);
    nb(Mi, du);
    var xa = e7("kCallback");
    function Mi(t) {
      if (!(this instanceof Mi))
        return new Mi(t);
      let e = t ? r7(this, t, "readableHighWaterMark", true) : null;
      e === 0 && (t = { ...t, highWaterMark: null, readableHighWaterMark: e, writableHighWaterMark: t.writableHighWaterMark || 0 }), du.call(this, t), this._readableState.sync = false, this[xa] = null, t && (typeof t.transform == "function" && (this._transform = t.transform), typeof t.flush == "function" && (this._flush = t.flush)), this.on("prefinish", i7);
    }
    function lu(t) {
      typeof this._flush == "function" && !this.destroyed ? this._flush((e, r) => {
        if (e) {
          t ? t(e) : this.destroy(e);
          return;
        }
        r != null && this.push(r), this.push(null), t && t();
      }) : (this.push(null), t && t());
    }
    function i7() {
      this._final !== lu && lu.call(this);
    }
    Mi.prototype._final = lu;
    Mi.prototype._transform = function(t, e, r) {
      throw new t7("_transform()");
    };
    Mi.prototype._write = function(t, e, r) {
      let o = this._readableState, f2 = this._writableState, p = o.length;
      this._transform(t, e, (m, y) => {
        if (m) {
          r(m);
          return;
        }
        y != null && this.push(y), f2.ended || p === o.length || o.length < o.highWaterMark ? r() : this[xa] = r;
      });
    };
    Mi.prototype._read = function() {
      if (this[xa]) {
        let t = this[xa];
        this[xa] = null, t();
      }
    };
  });
  vu = k((UT, ob) => {
    var { ObjectSetPrototypeOf: ab } = Tt();
    ob.exports = bf;
    var pu = cu();
    ab(bf.prototype, pu.prototype);
    ab(bf, pu);
    function bf(t) {
      if (!(this instanceof bf))
        return new bf(t);
      pu.call(this, t);
    }
    bf.prototype._transform = function(t, e, r) {
      r(null, t);
    };
  });
  hs = k((zT, db) => {
    var Sa = (Hi(), ur(vr)), { ArrayIsArray: n7, Promise: f7, SymbolAsyncIterator: a7 } = Tt(), ss = yi(), { once: o7 } = Gr(), s7 = wn(), sb = ti(), { aggregateTwoErrors: h7, codes: { ERR_INVALID_ARG_TYPE: xu, ERR_INVALID_RETURN_VALUE: bu, ERR_MISSING_ARGS: u7, ERR_STREAM_DESTROYED: l7, ERR_STREAM_PREMATURE_CLOSE: d7 }, AbortError: c7 } = Jt(), { validateFunction: p7, validateAbortSignal: v7 } = ma(), { isIterable: Sn, isReadable: mu, isReadableNodeStream: os, isNodeStream: hb, isTransformStream: mf, isWebStream: b7, isReadableStream: gu, isReadableEnded: m7 } = Qr(), g7 = globalThis.AbortController || Fo().AbortController, yu, wu;
    function ub(t, e, r) {
      let o = false;
      t.on("close", () => {
        o = true;
      });
      let f2 = ss(t, { readable: e, writable: r }, (p) => {
        o = !p;
      });
      return { destroy: (p) => {
        o || (o = true, s7.destroyer(t, p || new l7("pipe")));
      }, cleanup: f2 };
    }
    function y7(t) {
      return p7(t[t.length - 1], "streams[stream.length - 1]"), t.pop();
    }
    function Mu(t) {
      if (Sn(t))
        return t;
      if (os(t))
        return w7(t);
      throw new xu("val", ["Readable", "Iterable", "AsyncIterable"], t);
    }
    async function* w7(t) {
      wu || (wu = ya()), yield* wu.prototype[a7].call(t);
    }
    async function as(t, e, r, { end: o }) {
      let f2, p = null, m = (x) => {
        if (x && (f2 = x), p) {
          let S2 = p;
          p = null, S2();
        }
      }, y = () => new f7((x, S2) => {
        f2 ? S2(f2) : p = () => {
          f2 ? S2(f2) : x();
        };
      });
      e.on("drain", m);
      let M = ss(e, { readable: false }, m);
      try {
        e.writableNeedDrain && await y();
        for await (let x of t)
          e.write(x) || await y();
        o && e.end(), await y(), r();
      } catch (x) {
        r(f2 !== x ? h7(f2, x) : x);
      } finally {
        M(), e.off("drain", m);
      }
    }
    async function _u(t, e, r, { end: o }) {
      mf(e) && (e = e.writable);
      let f2 = e.getWriter();
      try {
        for await (let p of t)
          await f2.ready, f2.write(p).catch(() => {
          });
        await f2.ready, o && await f2.close(), r();
      } catch (p) {
        try {
          await f2.abort(p), r(p);
        } catch (m) {
          r(m);
        }
      }
    }
    function M7(...t) {
      return lb(t, o7(y7(t)));
    }
    function lb(t, e, r) {
      if (t.length === 1 && n7(t[0]) && (t = t[0]), t.length < 2)
        throw new u7("streams");
      let o = new g7, f2 = o.signal, p = r?.signal, m = [];
      v7(p, "options.signal");
      function y() {
        q(new c7);
      }
      p?.addEventListener("abort", y);
      let M, x, S2 = [], E = 0;
      function R(Me) {
        q(Me, --E === 0);
      }
      function q(Me, me) {
        if (Me && (!M || M.code === "ERR_STREAM_PREMATURE_CLOSE") && (M = Me), !(!M && !me)) {
          for (;S2.length; )
            S2.shift()(M);
          p?.removeEventListener("abort", y), o.abort(), me && (M || m.forEach((xe) => xe()), Sa.nextTick(e, M, x));
        }
      }
      let T;
      for (let Me = 0;Me < t.length; Me++) {
        let me = t[Me], xe = Me < t.length - 1, Ae = Me > 0, Ee = xe || r?.end !== false, Re = Me === t.length - 1;
        if (hb(me)) {
          let D2 = function(Se) {
            Se && Se.name !== "AbortError" && Se.code !== "ERR_STREAM_PREMATURE_CLOSE" && R(Se);
          };
          var P = D2;
          if (Ee) {
            let { destroy: Se, cleanup: v2 } = ub(me, xe, Ae);
            S2.push(Se), mu(me) && Re && m.push(v2);
          }
          me.on("error", D2), mu(me) && Re && m.push(() => {
            me.removeListener("error", D2);
          });
        }
        if (Me === 0)
          if (typeof me == "function") {
            if (T = me({ signal: f2 }), !Sn(T))
              throw new bu("Iterable, AsyncIterable or Stream", "source", T);
          } else
            Sn(me) || os(me) || mf(me) ? T = me : T = sb.from(me);
        else if (typeof me == "function") {
          if (mf(T)) {
            var ye;
            T = Mu((ye = T) === null || ye === undefined ? undefined : ye.readable);
          } else
            T = Mu(T);
          if (T = me(T, { signal: f2 }), xe) {
            if (!Sn(T, true))
              throw new bu("AsyncIterable", `transform[${Me - 1}]`, T);
          } else {
            var _e;
            yu || (yu = vu());
            let D2 = new yu({ objectMode: true }), Se = (_e = T) === null || _e === undefined ? undefined : _e.then;
            if (typeof Se == "function")
              E++, Se.call(T, (a) => {
                x = a, a != null && D2.write(a), Ee && D2.end(), Sa.nextTick(R);
              }, (a) => {
                D2.destroy(a), Sa.nextTick(R, a);
              });
            else if (Sn(T, true))
              E++, as(T, D2, R, { end: Ee });
            else if (gu(T) || mf(T)) {
              let a = T.readable || T;
              E++, as(a, D2, R, { end: Ee });
            } else
              throw new bu("AsyncIterable or Promise", "destination", T);
            T = D2;
            let { destroy: v2, cleanup: i } = ub(T, false, true);
            S2.push(v2), Re && m.push(i);
          }
        } else if (hb(me)) {
          if (os(T)) {
            E += 2;
            let D2 = _7(T, me, R, { end: Ee });
            mu(me) && Re && m.push(D2);
          } else if (mf(T) || gu(T)) {
            let D2 = T.readable || T;
            E++, as(D2, me, R, { end: Ee });
          } else if (Sn(T))
            E++, as(T, me, R, { end: Ee });
          else
            throw new xu("val", ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"], T);
          T = me;
        } else if (b7(me)) {
          if (os(T))
            E++, _u(Mu(T), me, R, { end: Ee });
          else if (gu(T) || Sn(T))
            E++, _u(T, me, R, { end: Ee });
          else if (mf(T))
            E++, _u(T.readable, me, R, { end: Ee });
          else
            throw new xu("val", ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"], T);
          T = me;
        } else
          T = sb.from(me);
      }
      return (f2 != null && f2.aborted || p != null && p.aborted) && Sa.nextTick(y), T;
    }
    function _7(t, e, r, { end: o }) {
      let f2 = false;
      if (e.on("close", () => {
        f2 || r(new d7);
      }), t.pipe(e, { end: false }), o) {
        let m = function() {
          f2 = true, e.end();
        };
        var p = m;
        m7(t) ? Sa.nextTick(m) : t.once("end", m);
      } else
        r();
      return ss(t, { readable: true, writable: false }, (m) => {
        let y = t._readableState;
        m && m.code === "ERR_STREAM_PREMATURE_CLOSE" && y && y.ended && !y.errored && !y.errorEmitted ? t.once("end", r).once("error", r) : r(m);
      }), ss(e, { readable: false, writable: true }, r);
    }
    db.exports = { pipelineImpl: lb, pipeline: M7 };
  });
  Eu = k((HT, gb) => {
    var { pipeline: x7 } = hs(), us = ti(), { destroyer: S7 } = wn(), { isNodeStream: ls, isReadable: cb, isWritable: pb, isWebStream: Su, isTransformStream: En, isWritableStream: vb, isReadableStream: bb } = Qr(), { AbortError: E7, codes: { ERR_INVALID_ARG_VALUE: mb, ERR_MISSING_ARGS: A7 } } = Jt(), R7 = yi();
    gb.exports = function(...e) {
      if (e.length === 0)
        throw new A7("streams");
      if (e.length === 1)
        return us.from(e[0]);
      let r = [...e];
      if (typeof e[0] == "function" && (e[0] = us.from(e[0])), typeof e[e.length - 1] == "function") {
        let q = e.length - 1;
        e[q] = us.from(e[q]);
      }
      for (let q = 0;q < e.length; ++q)
        if (!(!ls(e[q]) && !Su(e[q]))) {
          if (q < e.length - 1 && !(cb(e[q]) || bb(e[q]) || En(e[q])))
            throw new mb(`streams[${q}]`, r[q], "must be readable");
          if (q > 0 && !(pb(e[q]) || vb(e[q]) || En(e[q])))
            throw new mb(`streams[${q}]`, r[q], "must be writable");
        }
      let o, f2, p, m, y;
      function M(q) {
        let T = m;
        m = null, T ? T(q) : q ? y.destroy(q) : !R && !E && y.destroy();
      }
      let x = e[0], S2 = x7(e, M), E = !!(pb(x) || vb(x) || En(x)), R = !!(cb(S2) || bb(S2) || En(S2));
      if (y = new us({ writableObjectMode: !!(x != null && x.writableObjectMode), readableObjectMode: !!(S2 != null && S2.writableObjectMode), writable: E, readable: R }), E) {
        if (ls(x))
          y._write = function(T, ye, _e) {
            x.write(T, ye) ? _e() : o = _e;
          }, y._final = function(T) {
            x.end(), f2 = T;
          }, x.on("drain", function() {
            if (o) {
              let T = o;
              o = null, T();
            }
          });
        else if (Su(x)) {
          let ye = (En(x) ? x.writable : x).getWriter();
          y._write = async function(_e, P, Me) {
            try {
              await ye.ready, ye.write(_e).catch(() => {
              }), Me();
            } catch (me) {
              Me(me);
            }
          }, y._final = async function(_e) {
            try {
              await ye.ready, ye.close().catch(() => {
              }), f2 = _e;
            } catch (P) {
              _e(P);
            }
          };
        }
        let q = En(S2) ? S2.readable : S2;
        R7(q, () => {
          if (f2) {
            let T = f2;
            f2 = null, T();
          }
        });
      }
      if (R) {
        if (ls(S2))
          S2.on("readable", function() {
            if (p) {
              let q = p;
              p = null, q();
            }
          }), S2.on("end", function() {
            y.push(null);
          }), y._read = function() {
            for (;; ) {
              let q = S2.read();
              if (q === null) {
                p = y._read;
                return;
              }
              if (!y.push(q))
                return;
            }
          };
        else if (Su(S2)) {
          let T = (En(S2) ? S2.readable : S2).getReader();
          y._read = async function() {
            for (;; )
              try {
                let { value: ye, done: _e } = await T.read();
                if (!y.push(ye))
                  return;
                if (_e) {
                  y.push(null);
                  return;
                }
              } catch {
                return;
              }
          };
        }
      }
      return y._destroy = function(q, T) {
        !q && m !== null && (q = new E7), p = null, o = null, f2 = null, m === null ? T(q) : (m = T, ls(S2) && S7(S2, q));
      }, y;
    };
  });
  Ab = k((WT, Bu) => {
    var _b = globalThis.AbortController || Fo().AbortController, { codes: { ERR_INVALID_ARG_VALUE: B7, ERR_INVALID_ARG_TYPE: Ea, ERR_MISSING_ARGS: q7, ERR_OUT_OF_RANGE: I7 }, AbortError: ri } = Jt(), { validateAbortSignal: An, validateInteger: T7, validateObject: Rn } = ma(), k7 = Tt().Symbol("kWeak"), { finished: L7 } = yi(), N7 = Eu(), { addAbortSignalNoValidate: P7 } = ga(), { isWritable: D7, isNodeStream: C7 } = Qr(), { ArrayPrototypePush: O7, MathFloor: F7, Number: U7, NumberIsNaN: z7, Promise: yb, PromiseReject: wb, PromisePrototypeThen: H7, Symbol: xb } = Tt(), ds = xb("kEmpty"), Mb = xb("kEof");
    function W7(t, e) {
      if (e != null && Rn(e, "options"), e?.signal != null && An(e.signal, "options.signal"), C7(t) && !D7(t))
        throw new B7("stream", t, "must be writable");
      let r = N7(this, t);
      return e != null && e.signal && P7(e.signal, r), r;
    }
    function cs(t, e) {
      if (typeof t != "function")
        throw new Ea("fn", ["Function", "AsyncFunction"], t);
      e != null && Rn(e, "options"), e?.signal != null && An(e.signal, "options.signal");
      let r = 1;
      return e?.concurrency != null && (r = F7(e.concurrency)), T7(r, "concurrency", 1), async function* () {
        var f2, p;
        let m = new _b, y = this, M = [], x = m.signal, S2 = { signal: x }, E = () => m.abort();
        e != null && (f2 = e.signal) !== null && f2 !== undefined && f2.aborted && E(), e == null || (p = e.signal) === null || p === undefined || p.addEventListener("abort", E);
        let R, q, T = false;
        function ye() {
          T = true;
        }
        async function _e() {
          try {
            for await (let me of y) {
              var P;
              if (T)
                return;
              if (x.aborted)
                throw new ri;
              try {
                me = t(me, S2);
              } catch (xe) {
                me = wb(xe);
              }
              me !== ds && (typeof ((P = me) === null || P === undefined ? undefined : P.catch) == "function" && me.catch(ye), M.push(me), R && (R(), R = null), !T && M.length && M.length >= r && await new yb((xe) => {
                q = xe;
              }));
            }
            M.push(Mb);
          } catch (me) {
            let xe = wb(me);
            H7(xe, undefined, ye), M.push(xe);
          } finally {
            var Me;
            T = true, R && (R(), R = null), e == null || (Me = e.signal) === null || Me === undefined || Me.removeEventListener("abort", E);
          }
        }
        _e();
        try {
          for (;; ) {
            for (;M.length > 0; ) {
              let P = await M[0];
              if (P === Mb)
                return;
              if (x.aborted)
                throw new ri;
              P !== ds && (yield P), M.shift(), q && (q(), q = null);
            }
            await new yb((P) => {
              R = P;
            });
          }
        } finally {
          m.abort(), T = true, q && (q(), q = null);
        }
      }.call(this);
    }
    function K7(t = undefined) {
      return t != null && Rn(t, "options"), t?.signal != null && An(t.signal, "options.signal"), async function* () {
        let r = 0;
        for await (let f2 of this) {
          var o;
          if (t != null && (o = t.signal) !== null && o !== undefined && o.aborted)
            throw new ri({ cause: t.signal.reason });
          yield [r++, f2];
        }
      }.call(this);
    }
    async function Sb(t, e = undefined) {
      for await (let r of Ru.call(this, t, e))
        return true;
      return false;
    }
    async function j7(t, e = undefined) {
      if (typeof t != "function")
        throw new Ea("fn", ["Function", "AsyncFunction"], t);
      return !await Sb.call(this, async (...r) => !await t(...r), e);
    }
    async function Z7(t, e) {
      for await (let r of Ru.call(this, t, e))
        return r;
    }
    async function V7(t, e) {
      if (typeof t != "function")
        throw new Ea("fn", ["Function", "AsyncFunction"], t);
      async function r(o, f2) {
        return await t(o, f2), ds;
      }
      for await (let o of cs.call(this, r, e))
        ;
    }
    function Ru(t, e) {
      if (typeof t != "function")
        throw new Ea("fn", ["Function", "AsyncFunction"], t);
      async function r(o, f2) {
        return await t(o, f2) ? o : ds;
      }
      return cs.call(this, r, e);
    }
    var Au = class extends q7 {
      constructor() {
        super("reduce"), this.message = "Reduce of an empty stream requires an initial value";
      }
    };
    async function $7(t, e, r) {
      var o;
      if (typeof t != "function")
        throw new Ea("reducer", ["Function", "AsyncFunction"], t);
      r != null && Rn(r, "options"), r?.signal != null && An(r.signal, "options.signal");
      let f2 = arguments.length > 1;
      if (r != null && (o = r.signal) !== null && o !== undefined && o.aborted) {
        let x = new ri(undefined, { cause: r.signal.reason });
        throw this.once("error", () => {
        }), await L7(this.destroy(x)), x;
      }
      let p = new _b, m = p.signal;
      if (r != null && r.signal) {
        let x = { once: true, [k7]: this };
        r.signal.addEventListener("abort", () => p.abort(), x);
      }
      let y = false;
      try {
        for await (let x of this) {
          var M;
          if (y = true, r != null && (M = r.signal) !== null && M !== undefined && M.aborted)
            throw new ri;
          f2 ? e = await t(e, x, { signal: m }) : (e = x, f2 = true);
        }
        if (!y && !f2)
          throw new Au;
      } finally {
        p.abort();
      }
      return e;
    }
    async function G7(t) {
      t != null && Rn(t, "options"), t?.signal != null && An(t.signal, "options.signal");
      let e = [];
      for await (let o of this) {
        var r;
        if (t != null && (r = t.signal) !== null && r !== undefined && r.aborted)
          throw new ri(undefined, { cause: t.signal.reason });
        O7(e, o);
      }
      return e;
    }
    function Y7(t, e) {
      let r = cs.call(this, t, e);
      return async function* () {
        for await (let f2 of r)
          yield* f2;
      }.call(this);
    }
    function Eb(t) {
      if (t = U7(t), z7(t))
        return 0;
      if (t < 0)
        throw new I7("number", ">= 0", t);
      return t;
    }
    function X7(t, e = undefined) {
      return e != null && Rn(e, "options"), e?.signal != null && An(e.signal, "options.signal"), t = Eb(t), async function* () {
        var o;
        if (e != null && (o = e.signal) !== null && o !== undefined && o.aborted)
          throw new ri;
        for await (let p of this) {
          var f2;
          if (e != null && (f2 = e.signal) !== null && f2 !== undefined && f2.aborted)
            throw new ri;
          t-- <= 0 && (yield p);
        }
      }.call(this);
    }
    function J7(t, e = undefined) {
      return e != null && Rn(e, "options"), e?.signal != null && An(e.signal, "options.signal"), t = Eb(t), async function* () {
        var o;
        if (e != null && (o = e.signal) !== null && o !== undefined && o.aborted)
          throw new ri;
        for await (let p of this) {
          var f2;
          if (e != null && (f2 = e.signal) !== null && f2 !== undefined && f2.aborted)
            throw new ri;
          if (t-- > 0)
            yield p;
          else
            return;
        }
      }.call(this);
    }
    Bu.exports.streamReturningOperators = { asIndexedPairs: K7, drop: X7, filter: Ru, flatMap: Y7, map: cs, take: J7, compose: W7 };
    Bu.exports.promiseReturningOperators = { every: j7, forEach: V7, reduce: $7, toArray: G7, some: Sb, find: Z7 };
  });
  qu = k((KT, Rb) => {
    var { ArrayPrototypePop: Q7, Promise: e9 } = Tt(), { isIterable: t9, isNodeStream: r9, isWebStream: i9 } = Qr(), { pipelineImpl: n9 } = hs(), { finished: f9 } = yi();
    Iu();
    function a9(...t) {
      return new e9((e, r) => {
        let o, f2, p = t[t.length - 1];
        if (p && typeof p == "object" && !r9(p) && !t9(p) && !i9(p)) {
          let m = Q7(t);
          o = m.signal, f2 = m.end;
        }
        n9(t, (m, y) => {
          m ? r(m) : e(y);
        }, { signal: o, end: f2 });
      });
    }
    Rb.exports = { finished: f9, pipeline: a9 };
  });
  Iu = k((jT, Db) => {
    var { Buffer: o9 } = Ut(), { ObjectDefineProperty: _i, ObjectKeys: Ib, ReflectApply: Tb } = Tt(), { promisify: { custom: kb } } = Gr(), { streamReturningOperators: Bb, promiseReturningOperators: qb } = Ab(), { codes: { ERR_ILLEGAL_CONSTRUCTOR: Lb } } = Jt(), s9 = Eu(), { pipeline: Nb } = hs(), { destroyer: h9 } = wn(), Pb = yi(), Tu = qu(), ku = Qr(), ct = Db.exports = Go().Stream;
    ct.isDisturbed = ku.isDisturbed;
    ct.isErrored = ku.isErrored;
    ct.isReadable = ku.isReadable;
    ct.Readable = ya();
    for (let t of Ib(Bb)) {
      let r = function(...o) {
        if (new.target)
          throw Lb();
        return ct.Readable.from(Tb(e, this, o));
      };
      l9 = r;
      let e = Bb[t];
      _i(r, "name", { __proto__: null, value: e.name }), _i(r, "length", { __proto__: null, value: e.length }), _i(ct.Readable.prototype, t, { __proto__: null, value: r, enumerable: false, configurable: true, writable: true });
    }
    var l9;
    for (let t of Ib(qb)) {
      let r = function(...f2) {
        if (new.target)
          throw Lb();
        return Tb(e, this, f2);
      };
      l9 = r;
      let e = qb[t];
      _i(r, "name", { __proto__: null, value: e.name }), _i(r, "length", { __proto__: null, value: e.length }), _i(ct.Readable.prototype, t, { __proto__: null, value: r, enumerable: false, configurable: true, writable: true });
    }
    var l9;
    ct.Writable = au();
    ct.Duplex = ti();
    ct.Transform = cu();
    ct.PassThrough = vu();
    ct.pipeline = Nb;
    var { addAbortSignal: u9 } = ga();
    ct.addAbortSignal = u9;
    ct.finished = Pb;
    ct.destroy = h9;
    ct.compose = s9;
    _i(ct, "promises", { __proto__: null, configurable: true, enumerable: true, get() {
      return Tu;
    } });
    _i(Nb, kb, { __proto__: null, enumerable: true, get() {
      return Tu.pipeline;
    } });
    _i(Pb, kb, { __proto__: null, enumerable: true, get() {
      return Tu.finished;
    } });
    ct.Stream = ct;
    ct._isUint8Array = function(e) {
      return e instanceof Uint8Array;
    };
    ct._uint8ArrayToBuffer = function(e) {
      return o9.from(e.buffer, e.byteOffset, e.byteLength);
    };
  });
  Lu = k((ZT, pt) => {
    var Lt = Iu(), d9 = qu(), c9 = Lt.Readable.destroy;
    pt.exports = Lt.Readable;
    pt.exports._uint8ArrayToBuffer = Lt._uint8ArrayToBuffer;
    pt.exports._isUint8Array = Lt._isUint8Array;
    pt.exports.isDisturbed = Lt.isDisturbed;
    pt.exports.isErrored = Lt.isErrored;
    pt.exports.isReadable = Lt.isReadable;
    pt.exports.Readable = Lt.Readable;
    pt.exports.Writable = Lt.Writable;
    pt.exports.Duplex = Lt.Duplex;
    pt.exports.Transform = Lt.Transform;
    pt.exports.PassThrough = Lt.PassThrough;
    pt.exports.addAbortSignal = Lt.addAbortSignal;
    pt.exports.finished = Lt.finished;
    pt.exports.destroy = Lt.destroy;
    pt.exports.destroy = c9;
    pt.exports.pipeline = Lt.pipeline;
    pt.exports.compose = Lt.compose;
    Object.defineProperty(Lt, "promises", { configurable: true, enumerable: true, get() {
      return d9;
    } });
    pt.exports.Stream = Lt.Stream;
    pt.exports.default = pt.exports;
  });
  gf = {};
  io(gf, { default: () => p9 });
  Cb = k0(() => {
    ot(gf, fn(Lu()));
    p9 = fn(Lu());
  });
  xi = k(($T, Ub) => {
    var Ob = Te().Buffer, Fb = (Cb(), ur(gf)).Transform, v9 = go().StringDecoder, b9 = Ie();
    function Lr(t) {
      Fb.call(this), this.hashMode = typeof t == "string", this.hashMode ? this[t] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
    }
    b9(Lr, Fb);
    Lr.prototype.update = function(t, e, r) {
      typeof t == "string" && (t = Ob.from(t, e));
      var o = this._update(t);
      return this.hashMode ? this : (r && (o = this._toString(o, r)), o);
    };
    Lr.prototype.setAutoPadding = function() {
    };
    Lr.prototype.getAuthTag = function() {
      throw new Error("trying to get auth tag in unsupported state");
    };
    Lr.prototype.setAuthTag = function() {
      throw new Error("trying to set auth tag in unsupported state");
    };
    Lr.prototype.setAAD = function() {
      throw new Error("trying to set aad in unsupported state");
    };
    Lr.prototype._transform = function(t, e, r) {
      var o;
      try {
        this.hashMode ? this._update(t) : this.push(this._update(t));
      } catch (f2) {
        o = f2;
      } finally {
        r(o);
      }
    };
    Lr.prototype._flush = function(t) {
      var e;
      try {
        this.push(this.__final());
      } catch (r) {
        e = r;
      }
      t(e);
    };
    Lr.prototype._finalOrDigest = function(t) {
      var e = this.__final() || Ob.alloc(0);
      return t && (e = this._toString(e, t, true)), e;
    };
    Lr.prototype._toString = function(t, e, r) {
      if (this._decoder || (this._decoder = new v9(e), this._encoding = e), this._encoding !== e)
        throw new Error("can't switch encodings");
      var o = this._decoder.write(t);
      return r && (o += this._decoder.end()), o;
    };
    Ub.exports = Lr;
  });
  yf = k((GT, Hb) => {
    var m9 = Ie(), g9 = To(), y9 = Lo(), w9 = Co(), zb = xi();
    function ps(t) {
      zb.call(this, "digest"), this._hash = t;
    }
    m9(ps, zb);
    ps.prototype._update = function(t) {
      this._hash.update(t);
    };
    ps.prototype._final = function() {
      return this._hash.digest();
    };
    Hb.exports = function(e) {
      return e = e.toLowerCase(), e === "md5" ? new g9 : e === "rmd160" || e === "ripemd160" ? new y9 : new ps(w9(e));
    };
  });
  jb = k((YT, Kb) => {
    var M9 = Ie(), Bn = Te().Buffer, Wb = xi(), _9 = Bn.alloc(128), wf = 64;
    function vs(t, e) {
      Wb.call(this, "digest"), typeof e == "string" && (e = Bn.from(e)), this._alg = t, this._key = e, e.length > wf ? e = t(e) : e.length < wf && (e = Bn.concat([e, _9], wf));
      for (var r = this._ipad = Bn.allocUnsafe(wf), o = this._opad = Bn.allocUnsafe(wf), f2 = 0;f2 < wf; f2++)
        r[f2] = e[f2] ^ 54, o[f2] = e[f2] ^ 92;
      this._hash = [r];
    }
    M9(vs, Wb);
    vs.prototype._update = function(t) {
      this._hash.push(t);
    };
    vs.prototype._final = function() {
      var t = this._alg(Bn.concat(this._hash));
      return this._alg(Bn.concat([this._opad, t]));
    };
    Kb.exports = vs;
  });
  Nu = k((XT, Zb) => {
    var x9 = To();
    Zb.exports = function(t) {
      return new x9().update(t).digest();
    };
  });
  Cu = k((JT, $b) => {
    var S9 = Ie(), E9 = jb(), Vb = xi(), Aa = Te().Buffer, A9 = Nu(), Pu = Lo(), Du = Co(), R9 = Aa.alloc(128);
    function Ra(t, e) {
      Vb.call(this, "digest"), typeof e == "string" && (e = Aa.from(e));
      var r = t === "sha512" || t === "sha384" ? 128 : 64;
      if (this._alg = t, this._key = e, e.length > r) {
        var o = t === "rmd160" ? new Pu : Du(t);
        e = o.update(e).digest();
      } else
        e.length < r && (e = Aa.concat([e, R9], r));
      for (var f2 = this._ipad = Aa.allocUnsafe(r), p = this._opad = Aa.allocUnsafe(r), m = 0;m < r; m++)
        f2[m] = e[m] ^ 54, p[m] = e[m] ^ 92;
      this._hash = t === "rmd160" ? new Pu : Du(t), this._hash.update(f2);
    }
    S9(Ra, Vb);
    Ra.prototype._update = function(t) {
      this._hash.update(t);
    };
    Ra.prototype._final = function() {
      var t = this._hash.digest(), e = this._alg === "rmd160" ? new Pu : Du(this._alg);
      return e.update(this._opad).update(t).digest();
    };
    $b.exports = function(e, r) {
      return e = e.toLowerCase(), e === "rmd160" || e === "ripemd160" ? new Ra("rmd160", r) : e === "md5" ? new E9(A9, r) : new Ra(e, r);
    };
  });
  Ou = k((QT, B9) => {
    B9.exports = { sha224WithRSAEncryption: { sign: "rsa", hash: "sha224", id: "302d300d06096086480165030402040500041c" }, "RSA-SHA224": { sign: "ecdsa/rsa", hash: "sha224", id: "302d300d06096086480165030402040500041c" }, sha256WithRSAEncryption: { sign: "rsa", hash: "sha256", id: "3031300d060960864801650304020105000420" }, "RSA-SHA256": { sign: "ecdsa/rsa", hash: "sha256", id: "3031300d060960864801650304020105000420" }, sha384WithRSAEncryption: { sign: "rsa", hash: "sha384", id: "3041300d060960864801650304020205000430" }, "RSA-SHA384": { sign: "ecdsa/rsa", hash: "sha384", id: "3041300d060960864801650304020205000430" }, sha512WithRSAEncryption: { sign: "rsa", hash: "sha512", id: "3051300d060960864801650304020305000440" }, "RSA-SHA512": { sign: "ecdsa/rsa", hash: "sha512", id: "3051300d060960864801650304020305000440" }, "RSA-SHA1": { sign: "rsa", hash: "sha1", id: "3021300906052b0e03021a05000414" }, "ecdsa-with-SHA1": { sign: "ecdsa", hash: "sha1", id: "" }, sha256: { sign: "ecdsa", hash: "sha256", id: "" }, sha224: { sign: "ecdsa", hash: "sha224", id: "" }, sha384: { sign: "ecdsa", hash: "sha384", id: "" }, sha512: { sign: "ecdsa", hash: "sha512", id: "" }, "DSA-SHA": { sign: "dsa", hash: "sha1", id: "" }, "DSA-SHA1": { sign: "dsa", hash: "sha1", id: "" }, DSA: { sign: "dsa", hash: "sha1", id: "" }, "DSA-WITH-SHA224": { sign: "dsa", hash: "sha224", id: "" }, "DSA-SHA224": { sign: "dsa", hash: "sha224", id: "" }, "DSA-WITH-SHA256": { sign: "dsa", hash: "sha256", id: "" }, "DSA-SHA256": { sign: "dsa", hash: "sha256", id: "" }, "DSA-WITH-SHA384": { sign: "dsa", hash: "sha384", id: "" }, "DSA-SHA384": { sign: "dsa", hash: "sha384", id: "" }, "DSA-WITH-SHA512": { sign: "dsa", hash: "sha512", id: "" }, "DSA-SHA512": { sign: "dsa", hash: "sha512", id: "" }, "DSA-RIPEMD160": { sign: "dsa", hash: "rmd160", id: "" }, ripemd160WithRSA: { sign: "rsa", hash: "rmd160", id: "3021300906052b2403020105000414" }, "RSA-RIPEMD160": { sign: "rsa", hash: "rmd160", id: "3021300906052b2403020105000414" }, md5WithRSAEncryption: { sign: "rsa", hash: "md5", id: "3020300c06082a864886f70d020505000410" }, "RSA-MD5": { sign: "rsa", hash: "md5", id: "3020300c06082a864886f70d020505000410" } };
  });
  Yb = k((ek, Gb) => {
    Gb.exports = Ou();
  });
  Fu = k((tk, Xb) => {
    var q9 = Math.pow(2, 30) - 1;
    Xb.exports = function(t, e) {
      if (typeof t != "number")
        throw new TypeError("Iterations not a number");
      if (t < 0)
        throw new TypeError("Bad iterations");
      if (typeof e != "number")
        throw new TypeError("Key length not a number");
      if (e < 0 || e > q9 || e !== e)
        throw new TypeError("Bad key length");
    };
  });
  Uu = k((rk, Qb) => {
    var bs;
    global.process && global.process.browser ? bs = "utf-8" : global.process && global.process.version ? (Jb = parseInt(process.version.split(".")[0].slice(1), 10), bs = Jb >= 6 ? "utf-8" : "binary") : bs = "utf-8";
    var Jb;
    Qb.exports = bs;
  });
  Hu = k((ik, em) => {
    var zu = Te().Buffer;
    em.exports = function(t, e, r) {
      if (zu.isBuffer(t))
        return t;
      if (typeof t == "string")
        return zu.from(t, e);
      if (ArrayBuffer.isView(t))
        return zu.from(t.buffer);
      throw new TypeError(r + " must be a string, a Buffer, a typed array or a DataView");
    };
  });
  Wu = k((nk, nm) => {
    var I9 = Nu(), T9 = Lo(), k9 = Co(), qn = Te().Buffer, L9 = Fu(), tm = Uu(), rm = Hu(), N9 = qn.alloc(128), ms = { md5: 16, sha1: 20, sha224: 28, sha256: 32, sha384: 48, sha512: 64, rmd160: 20, ripemd160: 20 };
    function im(t, e, r) {
      var o = P9(t), f2 = t === "sha512" || t === "sha384" ? 128 : 64;
      e.length > f2 ? e = o(e) : e.length < f2 && (e = qn.concat([e, N9], f2));
      for (var p = qn.allocUnsafe(f2 + ms[t]), m = qn.allocUnsafe(f2 + ms[t]), y = 0;y < f2; y++)
        p[y] = e[y] ^ 54, m[y] = e[y] ^ 92;
      var M = qn.allocUnsafe(f2 + r + 4);
      p.copy(M, 0, 0, f2), this.ipad1 = M, this.ipad2 = p, this.opad = m, this.alg = t, this.blocksize = f2, this.hash = o, this.size = ms[t];
    }
    im.prototype.run = function(t, e) {
      t.copy(e, this.blocksize);
      var r = this.hash(e);
      return r.copy(this.opad, this.blocksize), this.hash(this.opad);
    };
    function P9(t) {
      function e(o) {
        return k9(t).update(o).digest();
      }
      function r(o) {
        return new T9().update(o).digest();
      }
      return t === "rmd160" || t === "ripemd160" ? r : t === "md5" ? I9 : e;
    }
    function D9(t, e, r, o, f2) {
      L9(r, o), t = rm(t, tm, "Password"), e = rm(e, tm, "Salt"), f2 = f2 || "sha1";
      var p = new im(f2, t, e.length), m = qn.allocUnsafe(o), y = qn.allocUnsafe(e.length + 4);
      e.copy(y, 0, 0, e.length);
      for (var M = 0, x = ms[f2], S2 = Math.ceil(o / x), E = 1;E <= S2; E++) {
        y.writeUInt32BE(E, e.length);
        for (var R = p.run(y, p.ipad1), q = R, T = 1;T < r; T++) {
          q = p.run(q, p.ipad2);
          for (var ye = 0;ye < x; ye++)
            R[ye] ^= q[ye];
        }
        R.copy(m, M), M += x;
      }
      return m;
    }
    nm.exports = D9;
  });
  lm = k((fk, um) => {
    var sm = Te().Buffer, C9 = Fu(), fm = Uu(), am = Wu(), om = Hu(), gs, Ba = global.crypto && global.crypto.subtle, O9 = { sha: "SHA-1", "sha-1": "SHA-1", sha1: "SHA-1", sha256: "SHA-256", "sha-256": "SHA-256", sha384: "SHA-384", "sha-384": "SHA-384", "sha-512": "SHA-512", sha512: "SHA-512" }, Ku = [];
    function F9(t) {
      if (global.process && !global.process.browser || !Ba || !Ba.importKey || !Ba.deriveBits)
        return Promise.resolve(false);
      if (Ku[t] !== undefined)
        return Ku[t];
      gs = gs || sm.alloc(8);
      var e = hm(gs, gs, 10, 128, t).then(function() {
        return true;
      }).catch(function() {
        return false;
      });
      return Ku[t] = e, e;
    }
    var In;
    function ju() {
      return In || (global.process && global.process.nextTick ? In = global.process.nextTick : global.queueMicrotask ? In = global.queueMicrotask : global.setImmediate ? In = global.setImmediate : In = global.setTimeout, In);
    }
    function hm(t, e, r, o, f2) {
      return Ba.importKey("raw", t, { name: "PBKDF2" }, false, ["deriveBits"]).then(function(p) {
        return Ba.deriveBits({ name: "PBKDF2", salt: e, iterations: r, hash: { name: f2 } }, p, o << 3);
      }).then(function(p) {
        return sm.from(p);
      });
    }
    function U9(t, e) {
      t.then(function(r) {
        ju()(function() {
          e(null, r);
        });
      }, function(r) {
        ju()(function() {
          e(r);
        });
      });
    }
    um.exports = function(t, e, r, o, f2, p) {
      typeof f2 == "function" && (p = f2, f2 = undefined), f2 = f2 || "sha1";
      var m = O9[f2.toLowerCase()];
      if (!m || typeof global.Promise != "function") {
        ju()(function() {
          var y;
          try {
            y = am(t, e, r, o, f2);
          } catch (M) {
            return p(M);
          }
          p(null, y);
        });
        return;
      }
      if (C9(r, o), t = om(t, fm, "Password"), e = om(e, fm, "Salt"), typeof p != "function")
        throw new Error("No callback provided to pbkdf2");
      U9(F9(m).then(function(y) {
        return y ? hm(t, e, r, o, m) : am(t, e, r, o, f2);
      }), p);
    };
  });
  Vu = k((Zu) => {
    Zu.pbkdf2 = lm();
    Zu.pbkdf2Sync = Wu();
  });
  $u = k((mr2) => {
    mr2.readUInt32BE = function(e, r) {
      var o = e[0 + r] << 24 | e[1 + r] << 16 | e[2 + r] << 8 | e[3 + r];
      return o >>> 0;
    };
    mr2.writeUInt32BE = function(e, r, o) {
      e[0 + o] = r >>> 24, e[1 + o] = r >>> 16 & 255, e[2 + o] = r >>> 8 & 255, e[3 + o] = r & 255;
    };
    mr2.ip = function(e, r, o, f2) {
      for (var p = 0, m = 0, y = 6;y >= 0; y -= 2) {
        for (var M = 0;M <= 24; M += 8)
          p <<= 1, p |= r >>> M + y & 1;
        for (var M = 0;M <= 24; M += 8)
          p <<= 1, p |= e >>> M + y & 1;
      }
      for (var y = 6;y >= 0; y -= 2) {
        for (var M = 1;M <= 25; M += 8)
          m <<= 1, m |= r >>> M + y & 1;
        for (var M = 1;M <= 25; M += 8)
          m <<= 1, m |= e >>> M + y & 1;
      }
      o[f2 + 0] = p >>> 0, o[f2 + 1] = m >>> 0;
    };
    mr2.rip = function(e, r, o, f2) {
      for (var p = 0, m = 0, y = 0;y < 4; y++)
        for (var M = 24;M >= 0; M -= 8)
          p <<= 1, p |= r >>> M + y & 1, p <<= 1, p |= e >>> M + y & 1;
      for (var y = 4;y < 8; y++)
        for (var M = 24;M >= 0; M -= 8)
          m <<= 1, m |= r >>> M + y & 1, m <<= 1, m |= e >>> M + y & 1;
      o[f2 + 0] = p >>> 0, o[f2 + 1] = m >>> 0;
    };
    mr2.pc1 = function(e, r, o, f2) {
      for (var p = 0, m = 0, y = 7;y >= 5; y--) {
        for (var M = 0;M <= 24; M += 8)
          p <<= 1, p |= r >> M + y & 1;
        for (var M = 0;M <= 24; M += 8)
          p <<= 1, p |= e >> M + y & 1;
      }
      for (var M = 0;M <= 24; M += 8)
        p <<= 1, p |= r >> M + y & 1;
      for (var y = 1;y <= 3; y++) {
        for (var M = 0;M <= 24; M += 8)
          m <<= 1, m |= r >> M + y & 1;
        for (var M = 0;M <= 24; M += 8)
          m <<= 1, m |= e >> M + y & 1;
      }
      for (var M = 0;M <= 24; M += 8)
        m <<= 1, m |= e >> M + y & 1;
      o[f2 + 0] = p >>> 0, o[f2 + 1] = m >>> 0;
    };
    mr2.r28shl = function(e, r) {
      return e << r & 268435455 | e >>> 28 - r;
    };
    var ys = [14, 11, 17, 4, 27, 23, 25, 0, 13, 22, 7, 18, 5, 9, 16, 24, 2, 20, 12, 21, 1, 8, 15, 26, 15, 4, 25, 19, 9, 1, 26, 16, 5, 11, 23, 8, 12, 7, 17, 0, 22, 3, 10, 14, 6, 20, 27, 24];
    mr2.pc2 = function(e, r, o, f2) {
      for (var p = 0, m = 0, y = ys.length >>> 1, M = 0;M < y; M++)
        p <<= 1, p |= e >>> ys[M] & 1;
      for (var M = y;M < ys.length; M++)
        m <<= 1, m |= r >>> ys[M] & 1;
      o[f2 + 0] = p >>> 0, o[f2 + 1] = m >>> 0;
    };
    mr2.expand = function(e, r, o) {
      var f2 = 0, p = 0;
      f2 = (e & 1) << 5 | e >>> 27;
      for (var m = 23;m >= 15; m -= 4)
        f2 <<= 6, f2 |= e >>> m & 63;
      for (var m = 11;m >= 3; m -= 4)
        p |= e >>> m & 63, p <<= 6;
      p |= (e & 31) << 1 | e >>> 31, r[o + 0] = f2 >>> 0, r[o + 1] = p >>> 0;
    };
    var dm = [14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1, 3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8, 4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7, 15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13, 15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14, 9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5, 0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2, 5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9, 10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10, 1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1, 13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7, 11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12, 7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3, 1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9, 10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8, 15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14, 2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1, 8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6, 4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13, 15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3, 12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5, 0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8, 9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10, 7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13, 4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10, 3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6, 1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7, 10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12, 13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4, 10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2, 7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13, 0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11];
    mr2.substitute = function(e, r) {
      for (var o = 0, f2 = 0;f2 < 4; f2++) {
        var p = e >>> 18 - f2 * 6 & 63, m = dm[f2 * 64 + p];
        o <<= 4, o |= m;
      }
      for (var f2 = 0;f2 < 4; f2++) {
        var p = r >>> 18 - f2 * 6 & 63, m = dm[4 * 64 + f2 * 64 + p];
        o <<= 4, o |= m;
      }
      return o >>> 0;
    };
    var cm = [16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22, 30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7];
    mr2.permute = function(e) {
      for (var r = 0, o = 0;o < cm.length; o++)
        r <<= 1, r |= e >>> cm[o] & 1;
      return r >>> 0;
    };
    mr2.padSplit = function(e, r, o) {
      for (var f2 = e.toString(2);f2.length < r; )
        f2 = "0" + f2;
      for (var p = [], m = 0;m < r; m += o)
        p.push(f2.slice(m, m + o));
      return p.join(" ");
    };
  });
  ar = k((sk, vm) => {
    vm.exports = pm;
    function pm(t, e) {
      if (!t)
        throw new Error(e || "Assertion failed");
    }
    pm.equal = function(e, r, o) {
      if (e != r)
        throw new Error(o || "Assertion failed: " + e + " != " + r);
    };
  });
  ws = k((hk, bm) => {
    var z9 = ar();
    function gr2(t) {
      this.options = t, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0, this.padding = t.padding !== false;
    }
    bm.exports = gr2;
    gr2.prototype._init = function() {
    };
    gr2.prototype.update = function(e) {
      return e.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(e) : this._updateEncrypt(e);
    };
    gr2.prototype._buffer = function(e, r) {
      for (var o = Math.min(this.buffer.length - this.bufferOff, e.length - r), f2 = 0;f2 < o; f2++)
        this.buffer[this.bufferOff + f2] = e[r + f2];
      return this.bufferOff += o, o;
    };
    gr2.prototype._flushBuffer = function(e, r) {
      return this._update(this.buffer, 0, e, r), this.bufferOff = 0, this.blockSize;
    };
    gr2.prototype._updateEncrypt = function(e) {
      var r = 0, o = 0, f2 = (this.bufferOff + e.length) / this.blockSize | 0, p = new Array(f2 * this.blockSize);
      this.bufferOff !== 0 && (r += this._buffer(e, r), this.bufferOff === this.buffer.length && (o += this._flushBuffer(p, o)));
      for (var m = e.length - (e.length - r) % this.blockSize;r < m; r += this.blockSize)
        this._update(e, r, p, o), o += this.blockSize;
      for (;r < e.length; r++, this.bufferOff++)
        this.buffer[this.bufferOff] = e[r];
      return p;
    };
    gr2.prototype._updateDecrypt = function(e) {
      for (var r = 0, o = 0, f2 = Math.ceil((this.bufferOff + e.length) / this.blockSize) - 1, p = new Array(f2 * this.blockSize);f2 > 0; f2--)
        r += this._buffer(e, r), o += this._flushBuffer(p, o);
      return r += this._buffer(e, r), p;
    };
    gr2.prototype.final = function(e) {
      var r;
      e && (r = this.update(e));
      var o;
      return this.type === "encrypt" ? o = this._finalEncrypt() : o = this._finalDecrypt(), r ? r.concat(o) : o;
    };
    gr2.prototype._pad = function(e, r) {
      if (r === 0)
        return false;
      for (;r < e.length; )
        e[r++] = 0;
      return true;
    };
    gr2.prototype._finalEncrypt = function() {
      if (!this._pad(this.buffer, this.bufferOff))
        return [];
      var e = new Array(this.blockSize);
      return this._update(this.buffer, 0, e, 0), e;
    };
    gr2.prototype._unpad = function(e) {
      return e;
    };
    gr2.prototype._finalDecrypt = function() {
      z9.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
      var e = new Array(this.blockSize);
      return this._flushBuffer(e, 0), this._unpad(e);
    };
  });
  Gu = k((uk, ym) => {
    var mm = ar(), H9 = Ie(), Nt = $u(), gm = ws();
    function W9() {
      this.tmp = new Array(2), this.keys = null;
    }
    function ii(t) {
      gm.call(this, t);
      var e = new W9;
      this._desState = e, this.deriveKeys(e, t.key);
    }
    H9(ii, gm);
    ym.exports = ii;
    ii.create = function(e) {
      return new ii(e);
    };
    var K9 = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1];
    ii.prototype.deriveKeys = function(e, r) {
      e.keys = new Array(16 * 2), mm.equal(r.length, this.blockSize, "Invalid key length");
      var o = Nt.readUInt32BE(r, 0), f2 = Nt.readUInt32BE(r, 4);
      Nt.pc1(o, f2, e.tmp, 0), o = e.tmp[0], f2 = e.tmp[1];
      for (var p = 0;p < e.keys.length; p += 2) {
        var m = K9[p >>> 1];
        o = Nt.r28shl(o, m), f2 = Nt.r28shl(f2, m), Nt.pc2(o, f2, e.keys, p);
      }
    };
    ii.prototype._update = function(e, r, o, f2) {
      var p = this._desState, m = Nt.readUInt32BE(e, r), y = Nt.readUInt32BE(e, r + 4);
      Nt.ip(m, y, p.tmp, 0), m = p.tmp[0], y = p.tmp[1], this.type === "encrypt" ? this._encrypt(p, m, y, p.tmp, 0) : this._decrypt(p, m, y, p.tmp, 0), m = p.tmp[0], y = p.tmp[1], Nt.writeUInt32BE(o, m, f2), Nt.writeUInt32BE(o, y, f2 + 4);
    };
    ii.prototype._pad = function(e, r) {
      if (this.padding === false)
        return false;
      for (var o = e.length - r, f2 = r;f2 < e.length; f2++)
        e[f2] = o;
      return true;
    };
    ii.prototype._unpad = function(e) {
      if (this.padding === false)
        return e;
      for (var r = e[e.length - 1], o = e.length - r;o < e.length; o++)
        mm.equal(e[o], r);
      return e.slice(0, e.length - r);
    };
    ii.prototype._encrypt = function(e, r, o, f2, p) {
      for (var m = r, y = o, M = 0;M < e.keys.length; M += 2) {
        var x = e.keys[M], S2 = e.keys[M + 1];
        Nt.expand(y, e.tmp, 0), x ^= e.tmp[0], S2 ^= e.tmp[1];
        var E = Nt.substitute(x, S2), R = Nt.permute(E), q = y;
        y = (m ^ R) >>> 0, m = q;
      }
      Nt.rip(y, m, f2, p);
    };
    ii.prototype._decrypt = function(e, r, o, f2, p) {
      for (var m = o, y = r, M = e.keys.length - 2;M >= 0; M -= 2) {
        var x = e.keys[M], S2 = e.keys[M + 1];
        Nt.expand(m, e.tmp, 0), x ^= e.tmp[0], S2 ^= e.tmp[1];
        var E = Nt.substitute(x, S2), R = Nt.permute(E), q = m;
        m = (y ^ R) >>> 0, y = q;
      }
      Nt.rip(m, y, f2, p);
    };
  });
  Mm = k((wm) => {
    var j9 = ar(), Z9 = Ie(), Ms = {};
    function V9(t) {
      j9.equal(t.length, 8, "Invalid IV length"), this.iv = new Array(8);
      for (var e = 0;e < this.iv.length; e++)
        this.iv[e] = t[e];
    }
    function $9(t) {
      function e(p) {
        t.call(this, p), this._cbcInit();
      }
      Z9(e, t);
      for (var r = Object.keys(Ms), o = 0;o < r.length; o++) {
        var f2 = r[o];
        e.prototype[f2] = Ms[f2];
      }
      return e.create = function(m) {
        return new e(m);
      }, e;
    }
    wm.instantiate = $9;
    Ms._cbcInit = function() {
      var e = new V9(this.options.iv);
      this._cbcState = e;
    };
    Ms._update = function(e, r, o, f2) {
      var p = this._cbcState, m = this.constructor.super_.prototype, y = p.iv;
      if (this.type === "encrypt") {
        for (var M = 0;M < this.blockSize; M++)
          y[M] ^= e[r + M];
        m._update.call(this, y, 0, o, f2);
        for (var M = 0;M < this.blockSize; M++)
          y[M] = o[f2 + M];
      } else {
        m._update.call(this, e, r, o, f2);
        for (var M = 0;M < this.blockSize; M++)
          o[f2 + M] ^= y[M];
        for (var M = 0;M < this.blockSize; M++)
          y[M] = e[r + M];
      }
    };
  });
  Sm = k((dk, xm) => {
    var G9 = ar(), Y9 = Ie(), _m = ws(), ji = Gu();
    function X9(t, e) {
      G9.equal(e.length, 24, "Invalid key length");
      var r = e.slice(0, 8), o = e.slice(8, 16), f2 = e.slice(16, 24);
      t === "encrypt" ? this.ciphers = [ji.create({ type: "encrypt", key: r }), ji.create({ type: "decrypt", key: o }), ji.create({ type: "encrypt", key: f2 })] : this.ciphers = [ji.create({ type: "decrypt", key: f2 }), ji.create({ type: "encrypt", key: o }), ji.create({ type: "decrypt", key: r })];
    }
    function Tn(t) {
      _m.call(this, t);
      var e = new X9(this.type, this.options.key);
      this._edeState = e;
    }
    Y9(Tn, _m);
    xm.exports = Tn;
    Tn.create = function(e) {
      return new Tn(e);
    };
    Tn.prototype._update = function(e, r, o, f2) {
      var p = this._edeState;
      p.ciphers[0]._update(e, r, o, f2), p.ciphers[1]._update(o, f2, o, f2), p.ciphers[2]._update(o, f2, o, f2);
    };
    Tn.prototype._pad = ji.prototype._pad;
    Tn.prototype._unpad = ji.prototype._unpad;
  });
  Em = k((Mf) => {
    Mf.utils = $u();
    Mf.Cipher = ws();
    Mf.DES = Gu();
    Mf.CBC = Mm();
    Mf.EDE = Sm();
  });
  Bm = k((pk, Rm) => {
    var Am = xi(), Si = Em(), J9 = Ie(), kn = Te().Buffer, qa = { "des-ede3-cbc": Si.CBC.instantiate(Si.EDE), "des-ede3": Si.EDE, "des-ede-cbc": Si.CBC.instantiate(Si.EDE), "des-ede": Si.EDE, "des-cbc": Si.CBC.instantiate(Si.DES), "des-ecb": Si.DES };
    qa.des = qa["des-cbc"];
    qa.des3 = qa["des-ede3-cbc"];
    Rm.exports = _s;
    J9(_s, Am);
    function _s(t) {
      Am.call(this);
      var e = t.mode.toLowerCase(), r = qa[e], o;
      t.decrypt ? o = "decrypt" : o = "encrypt";
      var f2 = t.key;
      kn.isBuffer(f2) || (f2 = kn.from(f2)), (e === "des-ede" || e === "des-ede-cbc") && (f2 = kn.concat([f2, f2.slice(0, 8)]));
      var p = t.iv;
      kn.isBuffer(p) || (p = kn.from(p)), this._des = r.create({ key: f2, iv: p, type: o });
    }
    _s.prototype._update = function(t) {
      return kn.from(this._des.update(t));
    };
    _s.prototype._final = function() {
      return kn.from(this._des.final());
    };
  });
  qm = k((Yu) => {
    Yu.encrypt = function(t, e) {
      return t._cipher.encryptBlock(e);
    };
    Yu.decrypt = function(t, e) {
      return t._cipher.decryptBlock(e);
    };
  });
  _f = k((bk, Im) => {
    Im.exports = function(e, r) {
      for (var o = Math.min(e.length, r.length), f2 = new Buffer(o), p = 0;p < o; ++p)
        f2[p] = e[p] ^ r[p];
      return f2;
    };
  });
  km = k((Xu) => {
    var Tm = _f();
    Xu.encrypt = function(t, e) {
      var r = Tm(e, t._prev);
      return t._prev = t._cipher.encryptBlock(r), t._prev;
    };
    Xu.decrypt = function(t, e) {
      var r = t._prev;
      t._prev = e;
      var o = t._cipher.decryptBlock(e);
      return Tm(o, r);
    };
  });
  Pm = k((Nm) => {
    var Ia = Te().Buffer, Q9 = _f();
    function Lm(t, e, r) {
      var o = e.length, f2 = Q9(e, t._cache);
      return t._cache = t._cache.slice(o), t._prev = Ia.concat([t._prev, r ? e : f2]), f2;
    }
    Nm.encrypt = function(t, e, r) {
      for (var o = Ia.allocUnsafe(0), f2;e.length; )
        if (t._cache.length === 0 && (t._cache = t._cipher.encryptBlock(t._prev), t._prev = Ia.allocUnsafe(0)), t._cache.length <= e.length)
          f2 = t._cache.length, o = Ia.concat([o, Lm(t, e.slice(0, f2), r)]), e = e.slice(f2);
        else {
          o = Ia.concat([o, Lm(t, e, r)]);
          break;
        }
      return o;
    };
  });
  Cm = k((Dm) => {
    var Ju = Te().Buffer;
    function eS(t, e, r) {
      var o = t._cipher.encryptBlock(t._prev), f2 = o[0] ^ e;
      return t._prev = Ju.concat([t._prev.slice(1), Ju.from([r ? e : f2])]), f2;
    }
    Dm.encrypt = function(t, e, r) {
      for (var o = e.length, f2 = Ju.allocUnsafe(o), p = -1;++p < o; )
        f2[p] = eS(t, e[p], r);
      return f2;
    };
  });
  Fm = k((Om) => {
    var xs = Te().Buffer;
    function tS(t, e, r) {
      for (var o, f2 = -1, p = 8, m = 0, y, M;++f2 < p; )
        o = t._cipher.encryptBlock(t._prev), y = e & 1 << 7 - f2 ? 128 : 0, M = o[0] ^ y, m += (M & 128) >> f2 % 8, t._prev = rS(t._prev, r ? y : M);
      return m;
    }
    function rS(t, e) {
      var r = t.length, o = -1, f2 = xs.allocUnsafe(t.length);
      for (t = xs.concat([t, xs.from([e])]);++o < r; )
        f2[o] = t[o] << 1 | t[o + 1] >> 7;
      return f2;
    }
    Om.encrypt = function(t, e, r) {
      for (var o = e.length, f2 = xs.allocUnsafe(o), p = -1;++p < o; )
        f2[p] = tS(t, e[p], r);
      return f2;
    };
  });
  zm = k((Um) => {
    var iS = _f();
    function nS(t) {
      return t._prev = t._cipher.encryptBlock(t._prev), t._prev;
    }
    Um.encrypt = function(t, e) {
      for (;t._cache.length < e.length; )
        t._cache = Buffer.concat([t._cache, nS(t)]);
      var r = t._cache.slice(0, e.length);
      return t._cache = t._cache.slice(e.length), iS(e, r);
    };
  });
  Qu = k((_k, Hm) => {
    function fS(t) {
      for (var e = t.length, r;e--; )
        if (r = t.readUInt8(e), r === 255)
          t.writeUInt8(0, e);
        else {
          r++, t.writeUInt8(r, e);
          break;
        }
    }
    Hm.exports = fS;
  });
  tl = k((Km) => {
    var aS = _f(), Wm = Te().Buffer, oS = Qu();
    function sS(t) {
      var e = t._cipher.encryptBlockRaw(t._prev);
      return oS(t._prev), e;
    }
    var el = 16;
    Km.encrypt = function(t, e) {
      var r = Math.ceil(e.length / el), o = t._cache.length;
      t._cache = Wm.concat([t._cache, Wm.allocUnsafe(r * el)]);
      for (var f2 = 0;f2 < r; f2++) {
        var p = sS(t), m = o + f2 * el;
        t._cache.writeUInt32BE(p[0], m + 0), t._cache.writeUInt32BE(p[1], m + 4), t._cache.writeUInt32BE(p[2], m + 8), t._cache.writeUInt32BE(p[3], m + 12);
      }
      var y = t._cache.slice(0, e.length);
      return t._cache = t._cache.slice(e.length), aS(e, y);
    };
  });
  rl = k((Sk, hS) => {
    hS.exports = { "aes-128-ecb": { cipher: "AES", key: 128, iv: 0, mode: "ECB", type: "block" }, "aes-192-ecb": { cipher: "AES", key: 192, iv: 0, mode: "ECB", type: "block" }, "aes-256-ecb": { cipher: "AES", key: 256, iv: 0, mode: "ECB", type: "block" }, "aes-128-cbc": { cipher: "AES", key: 128, iv: 16, mode: "CBC", type: "block" }, "aes-192-cbc": { cipher: "AES", key: 192, iv: 16, mode: "CBC", type: "block" }, "aes-256-cbc": { cipher: "AES", key: 256, iv: 16, mode: "CBC", type: "block" }, aes128: { cipher: "AES", key: 128, iv: 16, mode: "CBC", type: "block" }, aes192: { cipher: "AES", key: 192, iv: 16, mode: "CBC", type: "block" }, aes256: { cipher: "AES", key: 256, iv: 16, mode: "CBC", type: "block" }, "aes-128-cfb": { cipher: "AES", key: 128, iv: 16, mode: "CFB", type: "stream" }, "aes-192-cfb": { cipher: "AES", key: 192, iv: 16, mode: "CFB", type: "stream" }, "aes-256-cfb": { cipher: "AES", key: 256, iv: 16, mode: "CFB", type: "stream" }, "aes-128-cfb8": { cipher: "AES", key: 128, iv: 16, mode: "CFB8", type: "stream" }, "aes-192-cfb8": { cipher: "AES", key: 192, iv: 16, mode: "CFB8", type: "stream" }, "aes-256-cfb8": { cipher: "AES", key: 256, iv: 16, mode: "CFB8", type: "stream" }, "aes-128-cfb1": { cipher: "AES", key: 128, iv: 16, mode: "CFB1", type: "stream" }, "aes-192-cfb1": { cipher: "AES", key: 192, iv: 16, mode: "CFB1", type: "stream" }, "aes-256-cfb1": { cipher: "AES", key: 256, iv: 16, mode: "CFB1", type: "stream" }, "aes-128-ofb": { cipher: "AES", key: 128, iv: 16, mode: "OFB", type: "stream" }, "aes-192-ofb": { cipher: "AES", key: 192, iv: 16, mode: "OFB", type: "stream" }, "aes-256-ofb": { cipher: "AES", key: 256, iv: 16, mode: "OFB", type: "stream" }, "aes-128-ctr": { cipher: "AES", key: 128, iv: 16, mode: "CTR", type: "stream" }, "aes-192-ctr": { cipher: "AES", key: 192, iv: 16, mode: "CTR", type: "stream" }, "aes-256-ctr": { cipher: "AES", key: 256, iv: 16, mode: "CTR", type: "stream" }, "aes-128-gcm": { cipher: "AES", key: 128, iv: 12, mode: "GCM", type: "auth" }, "aes-192-gcm": { cipher: "AES", key: 192, iv: 12, mode: "GCM", type: "auth" }, "aes-256-gcm": { cipher: "AES", key: 256, iv: 12, mode: "GCM", type: "auth" } };
  });
  Es = k((Ek, jm) => {
    var uS = { ECB: qm(), CBC: km(), CFB: Pm(), CFB8: Cm(), CFB1: Fm(), OFB: zm(), CTR: tl(), GCM: tl() }, Ss = rl();
    for (il in Ss)
      Ss[il].module = uS[Ss[il].mode];
    var il;
    jm.exports = Ss;
  });
  Ta = k((Ak, Vm) => {
    var As = Te().Buffer;
    function fl(t) {
      As.isBuffer(t) || (t = As.from(t));
      for (var e = t.length / 4 | 0, r = new Array(e), o = 0;o < e; o++)
        r[o] = t.readUInt32BE(o * 4);
      return r;
    }
    function nl(t) {
      for (var e = 0;e < t.length; t++)
        t[e] = 0;
    }
    function Zm(t, e, r, o, f2) {
      for (var p = r[0], m = r[1], y = r[2], M = r[3], x = t[0] ^ e[0], S2 = t[1] ^ e[1], E = t[2] ^ e[2], R = t[3] ^ e[3], q, T, ye, _e, P = 4, Me = 1;Me < f2; Me++)
        q = p[x >>> 24] ^ m[S2 >>> 16 & 255] ^ y[E >>> 8 & 255] ^ M[R & 255] ^ e[P++], T = p[S2 >>> 24] ^ m[E >>> 16 & 255] ^ y[R >>> 8 & 255] ^ M[x & 255] ^ e[P++], ye = p[E >>> 24] ^ m[R >>> 16 & 255] ^ y[x >>> 8 & 255] ^ M[S2 & 255] ^ e[P++], _e = p[R >>> 24] ^ m[x >>> 16 & 255] ^ y[S2 >>> 8 & 255] ^ M[E & 255] ^ e[P++], x = q, S2 = T, E = ye, R = _e;
      return q = (o[x >>> 24] << 24 | o[S2 >>> 16 & 255] << 16 | o[E >>> 8 & 255] << 8 | o[R & 255]) ^ e[P++], T = (o[S2 >>> 24] << 24 | o[E >>> 16 & 255] << 16 | o[R >>> 8 & 255] << 8 | o[x & 255]) ^ e[P++], ye = (o[E >>> 24] << 24 | o[R >>> 16 & 255] << 16 | o[x >>> 8 & 255] << 8 | o[S2 & 255]) ^ e[P++], _e = (o[R >>> 24] << 24 | o[x >>> 16 & 255] << 16 | o[S2 >>> 8 & 255] << 8 | o[E & 255]) ^ e[P++], q = q >>> 0, T = T >>> 0, ye = ye >>> 0, _e = _e >>> 0, [q, T, ye, _e];
    }
    var lS = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], kt = function() {
      for (var t = new Array(256), e = 0;e < 256; e++)
        e < 128 ? t[e] = e << 1 : t[e] = e << 1 ^ 283;
      for (var r = [], o = [], f2 = [[], [], [], []], p = [[], [], [], []], m = 0, y = 0, M = 0;M < 256; ++M) {
        var x = y ^ y << 1 ^ y << 2 ^ y << 3 ^ y << 4;
        x = x >>> 8 ^ x & 255 ^ 99, r[m] = x, o[x] = m;
        var S2 = t[m], E = t[S2], R = t[E], q = t[x] * 257 ^ x * 16843008;
        f2[0][m] = q << 24 | q >>> 8, f2[1][m] = q << 16 | q >>> 16, f2[2][m] = q << 8 | q >>> 24, f2[3][m] = q, q = R * 16843009 ^ E * 65537 ^ S2 * 257 ^ m * 16843008, p[0][x] = q << 24 | q >>> 8, p[1][x] = q << 16 | q >>> 16, p[2][x] = q << 8 | q >>> 24, p[3][x] = q, m === 0 ? m = y = 1 : (m = S2 ^ t[t[t[R ^ S2]]], y ^= t[t[y]]);
      }
      return { SBOX: r, INV_SBOX: o, SUB_MIX: f2, INV_SUB_MIX: p };
    }();
    function yr(t) {
      this._key = fl(t), this._reset();
    }
    yr.blockSize = 4 * 4;
    yr.keySize = 256 / 8;
    yr.prototype.blockSize = yr.blockSize;
    yr.prototype.keySize = yr.keySize;
    yr.prototype._reset = function() {
      for (var t = this._key, e = t.length, r = e + 6, o = (r + 1) * 4, f2 = [], p = 0;p < e; p++)
        f2[p] = t[p];
      for (p = e;p < o; p++) {
        var m = f2[p - 1];
        p % e === 0 ? (m = m << 8 | m >>> 24, m = kt.SBOX[m >>> 24] << 24 | kt.SBOX[m >>> 16 & 255] << 16 | kt.SBOX[m >>> 8 & 255] << 8 | kt.SBOX[m & 255], m ^= lS[p / e | 0] << 24) : e > 6 && p % e === 4 && (m = kt.SBOX[m >>> 24] << 24 | kt.SBOX[m >>> 16 & 255] << 16 | kt.SBOX[m >>> 8 & 255] << 8 | kt.SBOX[m & 255]), f2[p] = f2[p - e] ^ m;
      }
      for (var y = [], M = 0;M < o; M++) {
        var x = o - M, S2 = f2[x - (M % 4 ? 0 : 4)];
        M < 4 || x <= 4 ? y[M] = S2 : y[M] = kt.INV_SUB_MIX[0][kt.SBOX[S2 >>> 24]] ^ kt.INV_SUB_MIX[1][kt.SBOX[S2 >>> 16 & 255]] ^ kt.INV_SUB_MIX[2][kt.SBOX[S2 >>> 8 & 255]] ^ kt.INV_SUB_MIX[3][kt.SBOX[S2 & 255]];
      }
      this._nRounds = r, this._keySchedule = f2, this._invKeySchedule = y;
    };
    yr.prototype.encryptBlockRaw = function(t) {
      return t = fl(t), Zm(t, this._keySchedule, kt.SUB_MIX, kt.SBOX, this._nRounds);
    };
    yr.prototype.encryptBlock = function(t) {
      var e = this.encryptBlockRaw(t), r = As.allocUnsafe(16);
      return r.writeUInt32BE(e[0], 0), r.writeUInt32BE(e[1], 4), r.writeUInt32BE(e[2], 8), r.writeUInt32BE(e[3], 12), r;
    };
    yr.prototype.decryptBlock = function(t) {
      t = fl(t);
      var e = t[1];
      t[1] = t[3], t[3] = e;
      var r = Zm(t, this._invKeySchedule, kt.INV_SUB_MIX, kt.INV_SBOX, this._nRounds), o = As.allocUnsafe(16);
      return o.writeUInt32BE(r[0], 0), o.writeUInt32BE(r[3], 4), o.writeUInt32BE(r[2], 8), o.writeUInt32BE(r[1], 12), o;
    };
    yr.prototype.scrub = function() {
      nl(this._keySchedule), nl(this._invKeySchedule), nl(this._key);
    };
    Vm.exports.AES = yr;
  });
  Ym = k((Rk, Gm) => {
    var xf = Te().Buffer, dS = xf.alloc(16, 0);
    function cS(t) {
      return [t.readUInt32BE(0), t.readUInt32BE(4), t.readUInt32BE(8), t.readUInt32BE(12)];
    }
    function $m(t) {
      var e = xf.allocUnsafe(16);
      return e.writeUInt32BE(t[0] >>> 0, 0), e.writeUInt32BE(t[1] >>> 0, 4), e.writeUInt32BE(t[2] >>> 0, 8), e.writeUInt32BE(t[3] >>> 0, 12), e;
    }
    function ka(t) {
      this.h = t, this.state = xf.alloc(16, 0), this.cache = xf.allocUnsafe(0);
    }
    ka.prototype.ghash = function(t) {
      for (var e = -1;++e < t.length; )
        this.state[e] ^= t[e];
      this._multiply();
    };
    ka.prototype._multiply = function() {
      for (var t = cS(this.h), e = [0, 0, 0, 0], r, o, f2, p = -1;++p < 128; ) {
        for (o = (this.state[~~(p / 8)] & 1 << 7 - p % 8) !== 0, o && (e[0] ^= t[0], e[1] ^= t[1], e[2] ^= t[2], e[3] ^= t[3]), f2 = (t[3] & 1) !== 0, r = 3;r > 0; r--)
          t[r] = t[r] >>> 1 | (t[r - 1] & 1) << 31;
        t[0] = t[0] >>> 1, f2 && (t[0] = t[0] ^ 225 << 24);
      }
      this.state = $m(e);
    };
    ka.prototype.update = function(t) {
      this.cache = xf.concat([this.cache, t]);
      for (var e;this.cache.length >= 16; )
        e = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(e);
    };
    ka.prototype.final = function(t, e) {
      return this.cache.length && this.ghash(xf.concat([this.cache, dS], 16)), this.ghash($m([0, t, 0, e])), this.state;
    };
    Gm.exports = ka;
  });
  al = k((Bk, Qm) => {
    var pS = Ta(), rr = Te().Buffer, Xm = xi(), vS = Ie(), Jm = Ym(), bS = _f(), mS = Qu();
    function gS(t, e) {
      var r = 0;
      t.length !== e.length && r++;
      for (var o = Math.min(t.length, e.length), f2 = 0;f2 < o; ++f2)
        r += t[f2] ^ e[f2];
      return r;
    }
    function yS(t, e, r) {
      if (e.length === 12)
        return t._finID = rr.concat([e, rr.from([0, 0, 0, 1])]), rr.concat([e, rr.from([0, 0, 0, 2])]);
      var o = new Jm(r), f2 = e.length, p = f2 % 16;
      o.update(e), p && (p = 16 - p, o.update(rr.alloc(p, 0))), o.update(rr.alloc(8, 0));
      var m = f2 * 8, y = rr.alloc(8);
      y.writeUIntBE(m, 0, 8), o.update(y), t._finID = o.state;
      var M = rr.from(t._finID);
      return mS(M), M;
    }
    function Ln(t, e, r, o) {
      Xm.call(this);
      var f2 = rr.alloc(4, 0);
      this._cipher = new pS.AES(e);
      var p = this._cipher.encryptBlock(f2);
      this._ghash = new Jm(p), r = yS(this, r, p), this._prev = rr.from(r), this._cache = rr.allocUnsafe(0), this._secCache = rr.allocUnsafe(0), this._decrypt = o, this._alen = 0, this._len = 0, this._mode = t, this._authTag = null, this._called = false;
    }
    vS(Ln, Xm);
    Ln.prototype._update = function(t) {
      if (!this._called && this._alen) {
        var e = 16 - this._alen % 16;
        e < 16 && (e = rr.alloc(e, 0), this._ghash.update(e));
      }
      this._called = true;
      var r = this._mode.encrypt(this, t);
      return this._decrypt ? this._ghash.update(t) : this._ghash.update(r), this._len += t.length, r;
    };
    Ln.prototype._final = function() {
      if (this._decrypt && !this._authTag)
        throw new Error("Unsupported state or unable to authenticate data");
      var t = bS(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
      if (this._decrypt && gS(t, this._authTag))
        throw new Error("Unsupported state or unable to authenticate data");
      this._authTag = t, this._cipher.scrub();
    };
    Ln.prototype.getAuthTag = function() {
      if (this._decrypt || !rr.isBuffer(this._authTag))
        throw new Error("Attempting to get auth tag in unsupported state");
      return this._authTag;
    };
    Ln.prototype.setAuthTag = function(e) {
      if (!this._decrypt)
        throw new Error("Attempting to set auth tag in unsupported state");
      this._authTag = e;
    };
    Ln.prototype.setAAD = function(e) {
      if (this._called)
        throw new Error("Attempting to set AAD in unsupported state");
      this._ghash.update(e), this._alen += e.length;
    };
    Qm.exports = Ln;
  });
  sl = k((qk, tg) => {
    var wS = Ta(), ol = Te().Buffer, eg = xi(), MS = Ie();
    function Rs(t, e, r, o) {
      eg.call(this), this._cipher = new wS.AES(e), this._prev = ol.from(r), this._cache = ol.allocUnsafe(0), this._secCache = ol.allocUnsafe(0), this._decrypt = o, this._mode = t;
    }
    MS(Rs, eg);
    Rs.prototype._update = function(t) {
      return this._mode.encrypt(this, t, this._decrypt);
    };
    Rs.prototype._final = function() {
      this._cipher.scrub();
    };
    tg.exports = Rs;
  });
  La = k((Ik, rg) => {
    var Nn = Te().Buffer, _S = To();
    function xS(t, e, r, o) {
      if (Nn.isBuffer(t) || (t = Nn.from(t, "binary")), e && (Nn.isBuffer(e) || (e = Nn.from(e, "binary")), e.length !== 8))
        throw new RangeError("salt should be Buffer with 8 byte length");
      for (var f2 = r / 8, p = Nn.alloc(f2), m = Nn.alloc(o || 0), y = Nn.alloc(0);f2 > 0 || o > 0; ) {
        var M = new _S;
        M.update(y), M.update(t), e && M.update(e), y = M.digest();
        var x = 0;
        if (f2 > 0) {
          var S2 = p.length - f2;
          x = Math.min(f2, y.length), y.copy(p, S2, 0, x), f2 -= x;
        }
        if (x < y.length && o > 0) {
          var E = m.length - o, R = Math.min(o, y.length - x);
          y.copy(m, E, x, x + R), o -= R;
        }
      }
      return y.fill(0), { key: p, iv: m };
    }
    rg.exports = xS;
  });
  ag = k((hl) => {
    var ig = Es(), SS = al(), Ei = Te().Buffer, ES = sl(), ng = xi(), AS = Ta(), RS = La(), BS = Ie();
    function Na(t, e, r) {
      ng.call(this), this._cache = new Bs, this._cipher = new AS.AES(e), this._prev = Ei.from(r), this._mode = t, this._autopadding = true;
    }
    BS(Na, ng);
    Na.prototype._update = function(t) {
      this._cache.add(t);
      for (var e, r, o = [];e = this._cache.get(); )
        r = this._mode.encrypt(this, e), o.push(r);
      return Ei.concat(o);
    };
    var qS = Ei.alloc(16, 16);
    Na.prototype._final = function() {
      var t = this._cache.flush();
      if (this._autopadding)
        return t = this._mode.encrypt(this, t), this._cipher.scrub(), t;
      if (!t.equals(qS))
        throw this._cipher.scrub(), new Error("data not multiple of block length");
    };
    Na.prototype.setAutoPadding = function(t) {
      return this._autopadding = !!t, this;
    };
    function Bs() {
      this.cache = Ei.allocUnsafe(0);
    }
    Bs.prototype.add = function(t) {
      this.cache = Ei.concat([this.cache, t]);
    };
    Bs.prototype.get = function() {
      if (this.cache.length > 15) {
        var t = this.cache.slice(0, 16);
        return this.cache = this.cache.slice(16), t;
      }
      return null;
    };
    Bs.prototype.flush = function() {
      for (var t = 16 - this.cache.length, e = Ei.allocUnsafe(t), r = -1;++r < t; )
        e.writeUInt8(t, r);
      return Ei.concat([this.cache, e]);
    };
    function fg(t, e, r) {
      var o = ig[t.toLowerCase()];
      if (!o)
        throw new TypeError("invalid suite type");
      if (typeof e == "string" && (e = Ei.from(e)), e.length !== o.key / 8)
        throw new TypeError("invalid key length " + e.length);
      if (typeof r == "string" && (r = Ei.from(r)), o.mode !== "GCM" && r.length !== o.iv)
        throw new TypeError("invalid iv length " + r.length);
      return o.type === "stream" ? new ES(o.module, e, r) : o.type === "auth" ? new SS(o.module, e, r) : new Na(o.module, e, r);
    }
    function IS(t, e) {
      var r = ig[t.toLowerCase()];
      if (!r)
        throw new TypeError("invalid suite type");
      var o = RS(e, false, r.key, r.iv);
      return fg(t, o.key, o.iv);
    }
    hl.createCipheriv = fg;
    hl.createCipher = IS;
  });
  ug = k((ul) => {
    var TS = al(), Sf = Te().Buffer, og = Es(), kS = sl(), sg = xi(), LS = Ta(), NS = La(), PS = Ie();
    function Pa(t, e, r) {
      sg.call(this), this._cache = new qs, this._last = undefined, this._cipher = new LS.AES(e), this._prev = Sf.from(r), this._mode = t, this._autopadding = true;
    }
    PS(Pa, sg);
    Pa.prototype._update = function(t) {
      this._cache.add(t);
      for (var e, r, o = [];e = this._cache.get(this._autopadding); )
        r = this._mode.decrypt(this, e), o.push(r);
      return Sf.concat(o);
    };
    Pa.prototype._final = function() {
      var t = this._cache.flush();
      if (this._autopadding)
        return DS(this._mode.decrypt(this, t));
      if (t)
        throw new Error("data not multiple of block length");
    };
    Pa.prototype.setAutoPadding = function(t) {
      return this._autopadding = !!t, this;
    };
    function qs() {
      this.cache = Sf.allocUnsafe(0);
    }
    qs.prototype.add = function(t) {
      this.cache = Sf.concat([this.cache, t]);
    };
    qs.prototype.get = function(t) {
      var e;
      if (t) {
        if (this.cache.length > 16)
          return e = this.cache.slice(0, 16), this.cache = this.cache.slice(16), e;
      } else if (this.cache.length >= 16)
        return e = this.cache.slice(0, 16), this.cache = this.cache.slice(16), e;
      return null;
    };
    qs.prototype.flush = function() {
      if (this.cache.length)
        return this.cache;
    };
    function DS(t) {
      var e = t[15];
      if (e < 1 || e > 16)
        throw new Error("unable to decrypt data");
      for (var r = -1;++r < e; )
        if (t[r + (16 - e)] !== e)
          throw new Error("unable to decrypt data");
      if (e !== 16)
        return t.slice(0, 16 - e);
    }
    function hg(t, e, r) {
      var o = og[t.toLowerCase()];
      if (!o)
        throw new TypeError("invalid suite type");
      if (typeof r == "string" && (r = Sf.from(r)), o.mode !== "GCM" && r.length !== o.iv)
        throw new TypeError("invalid iv length " + r.length);
      if (typeof e == "string" && (e = Sf.from(e)), e.length !== o.key / 8)
        throw new TypeError("invalid key length " + e.length);
      return o.type === "stream" ? new kS(o.module, e, r, true) : o.type === "auth" ? new TS(o.module, e, r, true) : new Pa(o.module, e, r);
    }
    function CS(t, e) {
      var r = og[t.toLowerCase()];
      if (!r)
        throw new TypeError("invalid suite type");
      var o = NS(e, false, r.key, r.iv);
      return hg(t, o.key, o.iv);
    }
    ul.createDecipher = CS;
    ul.createDecipheriv = hg;
  });
  Is = k((Nr) => {
    var lg = ag(), dg = ug(), OS = rl();
    function FS() {
      return Object.keys(OS);
    }
    Nr.createCipher = Nr.Cipher = lg.createCipher;
    Nr.createCipheriv = Nr.Cipheriv = lg.createCipheriv;
    Nr.createDecipher = Nr.Decipher = dg.createDecipher;
    Nr.createDecipheriv = Nr.Decipheriv = dg.createDecipheriv;
    Nr.listCiphers = Nr.getCiphers = FS;
  });
  cg = k((Ai) => {
    Ai["des-ecb"] = { key: 8, iv: 0 };
    Ai["des-cbc"] = Ai.des = { key: 8, iv: 8 };
    Ai["des-ede3-cbc"] = Ai.des3 = { key: 24, iv: 8 };
    Ai["des-ede3"] = { key: 24, iv: 0 };
    Ai["des-ede-cbc"] = { key: 16, iv: 8 };
    Ai["des-ede"] = { key: 16, iv: 0 };
  });
  gg = k((Pr) => {
    var pg = Bm(), ll = Is(), Zi = Es(), Ri = cg(), vg = La();
    function US(t, e) {
      t = t.toLowerCase();
      var r, o;
      if (Zi[t])
        r = Zi[t].key, o = Zi[t].iv;
      else if (Ri[t])
        r = Ri[t].key * 8, o = Ri[t].iv;
      else
        throw new TypeError("invalid suite type");
      var f2 = vg(e, false, r, o);
      return bg(t, f2.key, f2.iv);
    }
    function zS(t, e) {
      t = t.toLowerCase();
      var r, o;
      if (Zi[t])
        r = Zi[t].key, o = Zi[t].iv;
      else if (Ri[t])
        r = Ri[t].key * 8, o = Ri[t].iv;
      else
        throw new TypeError("invalid suite type");
      var f2 = vg(e, false, r, o);
      return mg(t, f2.key, f2.iv);
    }
    function bg(t, e, r) {
      if (t = t.toLowerCase(), Zi[t])
        return ll.createCipheriv(t, e, r);
      if (Ri[t])
        return new pg({ key: e, iv: r, mode: t });
      throw new TypeError("invalid suite type");
    }
    function mg(t, e, r) {
      if (t = t.toLowerCase(), Zi[t])
        return ll.createDecipheriv(t, e, r);
      if (Ri[t])
        return new pg({ key: e, iv: r, mode: t, decrypt: true });
      throw new TypeError("invalid suite type");
    }
    function HS() {
      return Object.keys(Ri).concat(ll.getCiphers());
    }
    Pr.createCipher = Pr.Cipher = US;
    Pr.createCipheriv = Pr.Cipheriv = bg;
    Pr.createDecipher = Pr.Decipher = zS;
    Pr.createDecipheriv = Pr.Decipheriv = mg;
    Pr.listCiphers = Pr.getCiphers = HS;
  });
  Vi = k(() => {
  });
  cl = k((yg, dl) => {
    (function(t, e) {
      function r(v2, i) {
        if (!v2)
          throw new Error(i || "Assertion failed");
      }
      function o(v2, i) {
        v2.super_ = i;
        var a = function() {
        };
        a.prototype = i.prototype, v2.prototype = new a, v2.prototype.constructor = v2;
      }
      function f2(v2, i, a) {
        if (f2.isBN(v2))
          return v2;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, v2 !== null && ((i === "le" || i === "be") && (a = i, i = 10), this._init(v2 || 0, i || 10, a || "be"));
      }
      typeof t == "object" ? t.exports = f2 : e.BN = f2, f2.BN = f2, f2.wordSize = 26;
      var p;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? p = window.Buffer : p = Vi().Buffer;
      } catch {
      }
      f2.isBN = function(i) {
        return i instanceof f2 ? true : i !== null && typeof i == "object" && i.constructor.wordSize === f2.wordSize && Array.isArray(i.words);
      }, f2.max = function(i, a) {
        return i.cmp(a) > 0 ? i : a;
      }, f2.min = function(i, a) {
        return i.cmp(a) < 0 ? i : a;
      }, f2.prototype._init = function(i, a, h) {
        if (typeof i == "number")
          return this._initNumber(i, a, h);
        if (typeof i == "object")
          return this._initArray(i, a, h);
        a === "hex" && (a = 16), r(a === (a | 0) && a >= 2 && a <= 36), i = i.toString().replace(/\s+/g, "");
        var s = 0;
        i[0] === "-" && (s++, this.negative = 1), s < i.length && (a === 16 ? this._parseHex(i, s, h) : (this._parseBase(i, a, s), h === "le" && this._initArray(this.toArray(), a, h)));
      }, f2.prototype._initNumber = function(i, a, h) {
        i < 0 && (this.negative = 1, i = -i), i < 67108864 ? (this.words = [i & 67108863], this.length = 1) : i < 4503599627370496 ? (this.words = [i & 67108863, i / 67108864 & 67108863], this.length = 2) : (r(i < 9007199254740992), this.words = [i & 67108863, i / 67108864 & 67108863, 1], this.length = 3), h === "le" && this._initArray(this.toArray(), a, h);
      }, f2.prototype._initArray = function(i, a, h) {
        if (r(typeof i.length == "number"), i.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(i.length / 3), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u, c, b2 = 0;
        if (h === "be")
          for (s = i.length - 1, u = 0;s >= 0; s -= 3)
            c = i[s] | i[s - 1] << 8 | i[s - 2] << 16, this.words[u] |= c << b2 & 67108863, this.words[u + 1] = c >>> 26 - b2 & 67108863, b2 += 24, b2 >= 26 && (b2 -= 26, u++);
        else if (h === "le")
          for (s = 0, u = 0;s < i.length; s += 3)
            c = i[s] | i[s + 1] << 8 | i[s + 2] << 16, this.words[u] |= c << b2 & 67108863, this.words[u + 1] = c >>> 26 - b2 & 67108863, b2 += 24, b2 >= 26 && (b2 -= 26, u++);
        return this.strip();
      };
      function m(v2, i) {
        var a = v2.charCodeAt(i);
        return a >= 65 && a <= 70 ? a - 55 : a >= 97 && a <= 102 ? a - 87 : a - 48 & 15;
      }
      function y(v2, i, a) {
        var h = m(v2, a);
        return a - 1 >= i && (h |= m(v2, a - 1) << 4), h;
      }
      f2.prototype._parseHex = function(i, a, h) {
        this.length = Math.ceil((i.length - a) / 6), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u = 0, c = 0, b2;
        if (h === "be")
          for (s = i.length - 1;s >= a; s -= 2)
            b2 = y(i, a, s) << u, this.words[c] |= b2 & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b2 >>> 26) : u += 8;
        else {
          var l = i.length - a;
          for (s = l % 2 === 0 ? a + 1 : a;s < i.length; s += 2)
            b2 = y(i, a, s) << u, this.words[c] |= b2 & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b2 >>> 26) : u += 8;
        }
        this.strip();
      };
      function M(v2, i, a, h) {
        for (var s = 0, u = Math.min(v2.length, a), c = i;c < u; c++) {
          var b2 = v2.charCodeAt(c) - 48;
          s *= h, b2 >= 49 ? s += b2 - 49 + 10 : b2 >= 17 ? s += b2 - 17 + 10 : s += b2;
        }
        return s;
      }
      f2.prototype._parseBase = function(i, a, h) {
        this.words = [0], this.length = 1;
        for (var s = 0, u = 1;u <= 67108863; u *= a)
          s++;
        s--, u = u / a | 0;
        for (var c = i.length - h, b2 = c % s, l = Math.min(c, c - b2) + h, n = 0, d = h;d < l; d += s)
          n = M(i, d, d + s, a), this.imuln(u), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        if (b2 !== 0) {
          var w = 1;
          for (n = M(i, d, i.length, a), d = 0;d < b2; d++)
            w *= a;
          this.imuln(w), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        }
        this.strip();
      }, f2.prototype.copy = function(i) {
        i.words = new Array(this.length);
        for (var a = 0;a < this.length; a++)
          i.words[a] = this.words[a];
        i.length = this.length, i.negative = this.negative, i.red = this.red;
      }, f2.prototype.clone = function() {
        var i = new f2(null);
        return this.copy(i), i;
      }, f2.prototype._expand = function(i) {
        for (;this.length < i; )
          this.words[this.length++] = 0;
        return this;
      }, f2.prototype.strip = function() {
        for (;this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, f2.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, f2.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var x = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], S2 = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], E = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      f2.prototype.toString = function(i, a) {
        i = i || 10, a = a | 0 || 1;
        var h;
        if (i === 16 || i === "hex") {
          h = "";
          for (var s = 0, u = 0, c = 0;c < this.length; c++) {
            var b2 = this.words[c], l = ((b2 << s | u) & 16777215).toString(16);
            u = b2 >>> 24 - s & 16777215, u !== 0 || c !== this.length - 1 ? h = x[6 - l.length] + l + h : h = l + h, s += 2, s >= 26 && (s -= 26, c--);
          }
          for (u !== 0 && (h = u.toString(16) + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        if (i === (i | 0) && i >= 2 && i <= 36) {
          var n = S2[i], d = E[i];
          h = "";
          var w = this.clone();
          for (w.negative = 0;!w.isZero(); ) {
            var g = w.modn(d).toString(i);
            w = w.idivn(d), w.isZero() ? h = g + h : h = x[n - g.length] + g + h;
          }
          for (this.isZero() && (h = "0" + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        r(false, "Base should be between 2 and 36");
      }, f2.prototype.toNumber = function() {
        var i = this.words[0];
        return this.length === 2 ? i += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? i += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -i : i;
      }, f2.prototype.toJSON = function() {
        return this.toString(16);
      }, f2.prototype.toBuffer = function(i, a) {
        return r(typeof p < "u"), this.toArrayLike(p, i, a);
      }, f2.prototype.toArray = function(i, a) {
        return this.toArrayLike(Array, i, a);
      }, f2.prototype.toArrayLike = function(i, a, h) {
        var s = this.byteLength(), u = h || Math.max(1, s);
        r(s <= u, "byte array longer than desired length"), r(u > 0, "Requested array length <= 0"), this.strip();
        var c = a === "le", b2 = new i(u), l, n, d = this.clone();
        if (c) {
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b2[n] = l;
          for (;n < u; n++)
            b2[n] = 0;
        } else {
          for (n = 0;n < u - s; n++)
            b2[n] = 0;
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b2[u - n - 1] = l;
        }
        return b2;
      }, Math.clz32 ? f2.prototype._countBits = function(i) {
        return 32 - Math.clz32(i);
      } : f2.prototype._countBits = function(i) {
        var a = i, h = 0;
        return a >= 4096 && (h += 13, a >>>= 13), a >= 64 && (h += 7, a >>>= 7), a >= 8 && (h += 4, a >>>= 4), a >= 2 && (h += 2, a >>>= 2), h + a;
      }, f2.prototype._zeroBits = function(i) {
        if (i === 0)
          return 26;
        var a = i, h = 0;
        return (a & 8191) === 0 && (h += 13, a >>>= 13), (a & 127) === 0 && (h += 7, a >>>= 7), (a & 15) === 0 && (h += 4, a >>>= 4), (a & 3) === 0 && (h += 2, a >>>= 2), (a & 1) === 0 && h++, h;
      }, f2.prototype.bitLength = function() {
        var i = this.words[this.length - 1], a = this._countBits(i);
        return (this.length - 1) * 26 + a;
      };
      function R(v2) {
        for (var i = new Array(v2.bitLength()), a = 0;a < i.length; a++) {
          var h = a / 26 | 0, s = a % 26;
          i[a] = (v2.words[h] & 1 << s) >>> s;
        }
        return i;
      }
      f2.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var i = 0, a = 0;a < this.length; a++) {
          var h = this._zeroBits(this.words[a]);
          if (i += h, h !== 26)
            break;
        }
        return i;
      }, f2.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, f2.prototype.toTwos = function(i) {
        return this.negative !== 0 ? this.abs().inotn(i).iaddn(1) : this.clone();
      }, f2.prototype.fromTwos = function(i) {
        return this.testn(i - 1) ? this.notn(i).iaddn(1).ineg() : this.clone();
      }, f2.prototype.isNeg = function() {
        return this.negative !== 0;
      }, f2.prototype.neg = function() {
        return this.clone().ineg();
      }, f2.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, f2.prototype.iuor = function(i) {
        for (;this.length < i.length; )
          this.words[this.length++] = 0;
        for (var a = 0;a < i.length; a++)
          this.words[a] = this.words[a] | i.words[a];
        return this.strip();
      }, f2.prototype.ior = function(i) {
        return r((this.negative | i.negative) === 0), this.iuor(i);
      }, f2.prototype.or = function(i) {
        return this.length > i.length ? this.clone().ior(i) : i.clone().ior(this);
      }, f2.prototype.uor = function(i) {
        return this.length > i.length ? this.clone().iuor(i) : i.clone().iuor(this);
      }, f2.prototype.iuand = function(i) {
        var a;
        this.length > i.length ? a = i : a = this;
        for (var h = 0;h < a.length; h++)
          this.words[h] = this.words[h] & i.words[h];
        return this.length = a.length, this.strip();
      }, f2.prototype.iand = function(i) {
        return r((this.negative | i.negative) === 0), this.iuand(i);
      }, f2.prototype.and = function(i) {
        return this.length > i.length ? this.clone().iand(i) : i.clone().iand(this);
      }, f2.prototype.uand = function(i) {
        return this.length > i.length ? this.clone().iuand(i) : i.clone().iuand(this);
      }, f2.prototype.iuxor = function(i) {
        var a, h;
        this.length > i.length ? (a = this, h = i) : (a = i, h = this);
        for (var s = 0;s < h.length; s++)
          this.words[s] = a.words[s] ^ h.words[s];
        if (this !== a)
          for (;s < a.length; s++)
            this.words[s] = a.words[s];
        return this.length = a.length, this.strip();
      }, f2.prototype.ixor = function(i) {
        return r((this.negative | i.negative) === 0), this.iuxor(i);
      }, f2.prototype.xor = function(i) {
        return this.length > i.length ? this.clone().ixor(i) : i.clone().ixor(this);
      }, f2.prototype.uxor = function(i) {
        return this.length > i.length ? this.clone().iuxor(i) : i.clone().iuxor(this);
      }, f2.prototype.inotn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = Math.ceil(i / 26) | 0, h = i % 26;
        this._expand(a), h > 0 && a--;
        for (var s = 0;s < a; s++)
          this.words[s] = ~this.words[s] & 67108863;
        return h > 0 && (this.words[s] = ~this.words[s] & 67108863 >> 26 - h), this.strip();
      }, f2.prototype.notn = function(i) {
        return this.clone().inotn(i);
      }, f2.prototype.setn = function(i, a) {
        r(typeof i == "number" && i >= 0);
        var h = i / 26 | 0, s = i % 26;
        return this._expand(h + 1), a ? this.words[h] = this.words[h] | 1 << s : this.words[h] = this.words[h] & ~(1 << s), this.strip();
      }, f2.prototype.iadd = function(i) {
        var a;
        if (this.negative !== 0 && i.negative === 0)
          return this.negative = 0, a = this.isub(i), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && i.negative !== 0)
          return i.negative = 0, a = this.isub(i), i.negative = 1, a._normSign();
        var h, s;
        this.length > i.length ? (h = this, s = i) : (h = i, s = this);
        for (var u = 0, c = 0;c < s.length; c++)
          a = (h.words[c] | 0) + (s.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        for (;u !== 0 && c < h.length; c++)
          a = (h.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        if (this.length = h.length, u !== 0)
          this.words[this.length] = u, this.length++;
        else if (h !== this)
          for (;c < h.length; c++)
            this.words[c] = h.words[c];
        return this;
      }, f2.prototype.add = function(i) {
        var a;
        return i.negative !== 0 && this.negative === 0 ? (i.negative = 0, a = this.sub(i), i.negative ^= 1, a) : i.negative === 0 && this.negative !== 0 ? (this.negative = 0, a = i.sub(this), this.negative = 1, a) : this.length > i.length ? this.clone().iadd(i) : i.clone().iadd(this);
      }, f2.prototype.isub = function(i) {
        if (i.negative !== 0) {
          i.negative = 0;
          var a = this.iadd(i);
          return i.negative = 1, a._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(i), this.negative = 1, this._normSign();
        var h = this.cmp(i);
        if (h === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var s, u;
        h > 0 ? (s = this, u = i) : (s = i, u = this);
        for (var c = 0, b2 = 0;b2 < u.length; b2++)
          a = (s.words[b2] | 0) - (u.words[b2] | 0) + c, c = a >> 26, this.words[b2] = a & 67108863;
        for (;c !== 0 && b2 < s.length; b2++)
          a = (s.words[b2] | 0) + c, c = a >> 26, this.words[b2] = a & 67108863;
        if (c === 0 && b2 < s.length && s !== this)
          for (;b2 < s.length; b2++)
            this.words[b2] = s.words[b2];
        return this.length = Math.max(this.length, b2), s !== this && (this.negative = 1), this.strip();
      }, f2.prototype.sub = function(i) {
        return this.clone().isub(i);
      };
      function q(v2, i, a) {
        a.negative = i.negative ^ v2.negative;
        var h = v2.length + i.length | 0;
        a.length = h, h = h - 1 | 0;
        var s = v2.words[0] | 0, u = i.words[0] | 0, c = s * u, b2 = c & 67108863, l = c / 67108864 | 0;
        a.words[0] = b2;
        for (var n = 1;n < h; n++) {
          for (var d = l >>> 26, w = l & 67108863, g = Math.min(n, i.length - 1), _2 = Math.max(0, n - v2.length + 1);_2 <= g; _2++) {
            var A = n - _2 | 0;
            s = v2.words[A] | 0, u = i.words[_2] | 0, c = s * u + w, d += c / 67108864 | 0, w = c & 67108863;
          }
          a.words[n] = w | 0, l = d | 0;
        }
        return l !== 0 ? a.words[n] = l | 0 : a.length--, a.strip();
      }
      var T = function(i, a, h) {
        var s = i.words, u = a.words, c = h.words, b2 = 0, l, n, d, w = s[0] | 0, g = w & 8191, _2 = w >>> 13, A = s[1] | 0, B = A & 8191, I = A >>> 13, we = s[2] | 0, L = we & 8191, N = we >>> 13, nt = s[3] | 0, C = nt & 8191, O = nt >>> 13, vt = s[4] | 0, F = vt & 8191, U = vt >>> 13, bt = s[5] | 0, z2 = bt & 8191, H = bt >>> 13, mt = s[6] | 0, W = mt & 8191, K = mt >>> 13, gt = s[7] | 0, j = gt & 8191, Z = gt >>> 13, yt = s[8] | 0, V = yt & 8191, $2 = yt >>> 13, wt = s[9] | 0, G = wt & 8191, Y = wt >>> 13, Mt = u[0] | 0, X = Mt & 8191, J2 = Mt >>> 13, _t = u[1] | 0, Q2 = _t & 8191, ee = _t >>> 13, xt = u[2] | 0, te = xt & 8191, re = xt >>> 13, St = u[3] | 0, ie = St & 8191, ne = St >>> 13, Et = u[4] | 0, fe = Et & 8191, ae = Et >>> 13, At = u[5] | 0, oe = At & 8191, se = At >>> 13, Rt = u[6] | 0, he = Rt & 8191, ue = Rt >>> 13, Bt = u[7] | 0, le = Bt & 8191, de = Bt >>> 13, qt = u[8] | 0, ce = qt & 8191, pe = qt >>> 13, It = u[9] | 0, ve = It & 8191, be = It >>> 13;
        h.negative = i.negative ^ a.negative, h.length = 19, l = Math.imul(g, X), n = Math.imul(g, J2), n = n + Math.imul(_2, X) | 0, d = Math.imul(_2, J2);
        var ft = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, l = Math.imul(B, X), n = Math.imul(B, J2), n = n + Math.imul(I, X) | 0, d = Math.imul(I, J2), l = l + Math.imul(g, Q2) | 0, n = n + Math.imul(g, ee) | 0, n = n + Math.imul(_2, Q2) | 0, d = d + Math.imul(_2, ee) | 0;
        var Be = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, l = Math.imul(L, X), n = Math.imul(L, J2), n = n + Math.imul(N, X) | 0, d = Math.imul(N, J2), l = l + Math.imul(B, Q2) | 0, n = n + Math.imul(B, ee) | 0, n = n + Math.imul(I, Q2) | 0, d = d + Math.imul(I, ee) | 0, l = l + Math.imul(g, te) | 0, n = n + Math.imul(g, re) | 0, n = n + Math.imul(_2, te) | 0, d = d + Math.imul(_2, re) | 0;
        var qe = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (qe >>> 26) | 0, qe &= 67108863, l = Math.imul(C, X), n = Math.imul(C, J2), n = n + Math.imul(O, X) | 0, d = Math.imul(O, J2), l = l + Math.imul(L, Q2) | 0, n = n + Math.imul(L, ee) | 0, n = n + Math.imul(N, Q2) | 0, d = d + Math.imul(N, ee) | 0, l = l + Math.imul(B, te) | 0, n = n + Math.imul(B, re) | 0, n = n + Math.imul(I, te) | 0, d = d + Math.imul(I, re) | 0, l = l + Math.imul(g, ie) | 0, n = n + Math.imul(g, ne) | 0, n = n + Math.imul(_2, ie) | 0, d = d + Math.imul(_2, ne) | 0;
        var ze = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, l = Math.imul(F, X), n = Math.imul(F, J2), n = n + Math.imul(U, X) | 0, d = Math.imul(U, J2), l = l + Math.imul(C, Q2) | 0, n = n + Math.imul(C, ee) | 0, n = n + Math.imul(O, Q2) | 0, d = d + Math.imul(O, ee) | 0, l = l + Math.imul(L, te) | 0, n = n + Math.imul(L, re) | 0, n = n + Math.imul(N, te) | 0, d = d + Math.imul(N, re) | 0, l = l + Math.imul(B, ie) | 0, n = n + Math.imul(B, ne) | 0, n = n + Math.imul(I, ie) | 0, d = d + Math.imul(I, ne) | 0, l = l + Math.imul(g, fe) | 0, n = n + Math.imul(g, ae) | 0, n = n + Math.imul(_2, fe) | 0, d = d + Math.imul(_2, ae) | 0;
        var He = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, l = Math.imul(z2, X), n = Math.imul(z2, J2), n = n + Math.imul(H, X) | 0, d = Math.imul(H, J2), l = l + Math.imul(F, Q2) | 0, n = n + Math.imul(F, ee) | 0, n = n + Math.imul(U, Q2) | 0, d = d + Math.imul(U, ee) | 0, l = l + Math.imul(C, te) | 0, n = n + Math.imul(C, re) | 0, n = n + Math.imul(O, te) | 0, d = d + Math.imul(O, re) | 0, l = l + Math.imul(L, ie) | 0, n = n + Math.imul(L, ne) | 0, n = n + Math.imul(N, ie) | 0, d = d + Math.imul(N, ne) | 0, l = l + Math.imul(B, fe) | 0, n = n + Math.imul(B, ae) | 0, n = n + Math.imul(I, fe) | 0, d = d + Math.imul(I, ae) | 0, l = l + Math.imul(g, oe) | 0, n = n + Math.imul(g, se) | 0, n = n + Math.imul(_2, oe) | 0, d = d + Math.imul(_2, se) | 0;
        var We = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (We >>> 26) | 0, We &= 67108863, l = Math.imul(W, X), n = Math.imul(W, J2), n = n + Math.imul(K, X) | 0, d = Math.imul(K, J2), l = l + Math.imul(z2, Q2) | 0, n = n + Math.imul(z2, ee) | 0, n = n + Math.imul(H, Q2) | 0, d = d + Math.imul(H, ee) | 0, l = l + Math.imul(F, te) | 0, n = n + Math.imul(F, re) | 0, n = n + Math.imul(U, te) | 0, d = d + Math.imul(U, re) | 0, l = l + Math.imul(C, ie) | 0, n = n + Math.imul(C, ne) | 0, n = n + Math.imul(O, ie) | 0, d = d + Math.imul(O, ne) | 0, l = l + Math.imul(L, fe) | 0, n = n + Math.imul(L, ae) | 0, n = n + Math.imul(N, fe) | 0, d = d + Math.imul(N, ae) | 0, l = l + Math.imul(B, oe) | 0, n = n + Math.imul(B, se) | 0, n = n + Math.imul(I, oe) | 0, d = d + Math.imul(I, se) | 0, l = l + Math.imul(g, he) | 0, n = n + Math.imul(g, ue) | 0, n = n + Math.imul(_2, he) | 0, d = d + Math.imul(_2, ue) | 0;
        var Ke = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, l = Math.imul(j, X), n = Math.imul(j, J2), n = n + Math.imul(Z, X) | 0, d = Math.imul(Z, J2), l = l + Math.imul(W, Q2) | 0, n = n + Math.imul(W, ee) | 0, n = n + Math.imul(K, Q2) | 0, d = d + Math.imul(K, ee) | 0, l = l + Math.imul(z2, te) | 0, n = n + Math.imul(z2, re) | 0, n = n + Math.imul(H, te) | 0, d = d + Math.imul(H, re) | 0, l = l + Math.imul(F, ie) | 0, n = n + Math.imul(F, ne) | 0, n = n + Math.imul(U, ie) | 0, d = d + Math.imul(U, ne) | 0, l = l + Math.imul(C, fe) | 0, n = n + Math.imul(C, ae) | 0, n = n + Math.imul(O, fe) | 0, d = d + Math.imul(O, ae) | 0, l = l + Math.imul(L, oe) | 0, n = n + Math.imul(L, se) | 0, n = n + Math.imul(N, oe) | 0, d = d + Math.imul(N, se) | 0, l = l + Math.imul(B, he) | 0, n = n + Math.imul(B, ue) | 0, n = n + Math.imul(I, he) | 0, d = d + Math.imul(I, ue) | 0, l = l + Math.imul(g, le) | 0, n = n + Math.imul(g, de) | 0, n = n + Math.imul(_2, le) | 0, d = d + Math.imul(_2, de) | 0;
        var je = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, l = Math.imul(V, X), n = Math.imul(V, J2), n = n + Math.imul($2, X) | 0, d = Math.imul($2, J2), l = l + Math.imul(j, Q2) | 0, n = n + Math.imul(j, ee) | 0, n = n + Math.imul(Z, Q2) | 0, d = d + Math.imul(Z, ee) | 0, l = l + Math.imul(W, te) | 0, n = n + Math.imul(W, re) | 0, n = n + Math.imul(K, te) | 0, d = d + Math.imul(K, re) | 0, l = l + Math.imul(z2, ie) | 0, n = n + Math.imul(z2, ne) | 0, n = n + Math.imul(H, ie) | 0, d = d + Math.imul(H, ne) | 0, l = l + Math.imul(F, fe) | 0, n = n + Math.imul(F, ae) | 0, n = n + Math.imul(U, fe) | 0, d = d + Math.imul(U, ae) | 0, l = l + Math.imul(C, oe) | 0, n = n + Math.imul(C, se) | 0, n = n + Math.imul(O, oe) | 0, d = d + Math.imul(O, se) | 0, l = l + Math.imul(L, he) | 0, n = n + Math.imul(L, ue) | 0, n = n + Math.imul(N, he) | 0, d = d + Math.imul(N, ue) | 0, l = l + Math.imul(B, le) | 0, n = n + Math.imul(B, de) | 0, n = n + Math.imul(I, le) | 0, d = d + Math.imul(I, de) | 0, l = l + Math.imul(g, ce) | 0, n = n + Math.imul(g, pe) | 0, n = n + Math.imul(_2, ce) | 0, d = d + Math.imul(_2, pe) | 0;
        var Ze = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, l = Math.imul(G, X), n = Math.imul(G, J2), n = n + Math.imul(Y, X) | 0, d = Math.imul(Y, J2), l = l + Math.imul(V, Q2) | 0, n = n + Math.imul(V, ee) | 0, n = n + Math.imul($2, Q2) | 0, d = d + Math.imul($2, ee) | 0, l = l + Math.imul(j, te) | 0, n = n + Math.imul(j, re) | 0, n = n + Math.imul(Z, te) | 0, d = d + Math.imul(Z, re) | 0, l = l + Math.imul(W, ie) | 0, n = n + Math.imul(W, ne) | 0, n = n + Math.imul(K, ie) | 0, d = d + Math.imul(K, ne) | 0, l = l + Math.imul(z2, fe) | 0, n = n + Math.imul(z2, ae) | 0, n = n + Math.imul(H, fe) | 0, d = d + Math.imul(H, ae) | 0, l = l + Math.imul(F, oe) | 0, n = n + Math.imul(F, se) | 0, n = n + Math.imul(U, oe) | 0, d = d + Math.imul(U, se) | 0, l = l + Math.imul(C, he) | 0, n = n + Math.imul(C, ue) | 0, n = n + Math.imul(O, he) | 0, d = d + Math.imul(O, ue) | 0, l = l + Math.imul(L, le) | 0, n = n + Math.imul(L, de) | 0, n = n + Math.imul(N, le) | 0, d = d + Math.imul(N, de) | 0, l = l + Math.imul(B, ce) | 0, n = n + Math.imul(B, pe) | 0, n = n + Math.imul(I, ce) | 0, d = d + Math.imul(I, pe) | 0, l = l + Math.imul(g, ve) | 0, n = n + Math.imul(g, be) | 0, n = n + Math.imul(_2, ve) | 0, d = d + Math.imul(_2, be) | 0;
        var Ve = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, l = Math.imul(G, Q2), n = Math.imul(G, ee), n = n + Math.imul(Y, Q2) | 0, d = Math.imul(Y, ee), l = l + Math.imul(V, te) | 0, n = n + Math.imul(V, re) | 0, n = n + Math.imul($2, te) | 0, d = d + Math.imul($2, re) | 0, l = l + Math.imul(j, ie) | 0, n = n + Math.imul(j, ne) | 0, n = n + Math.imul(Z, ie) | 0, d = d + Math.imul(Z, ne) | 0, l = l + Math.imul(W, fe) | 0, n = n + Math.imul(W, ae) | 0, n = n + Math.imul(K, fe) | 0, d = d + Math.imul(K, ae) | 0, l = l + Math.imul(z2, oe) | 0, n = n + Math.imul(z2, se) | 0, n = n + Math.imul(H, oe) | 0, d = d + Math.imul(H, se) | 0, l = l + Math.imul(F, he) | 0, n = n + Math.imul(F, ue) | 0, n = n + Math.imul(U, he) | 0, d = d + Math.imul(U, ue) | 0, l = l + Math.imul(C, le) | 0, n = n + Math.imul(C, de) | 0, n = n + Math.imul(O, le) | 0, d = d + Math.imul(O, de) | 0, l = l + Math.imul(L, ce) | 0, n = n + Math.imul(L, pe) | 0, n = n + Math.imul(N, ce) | 0, d = d + Math.imul(N, pe) | 0, l = l + Math.imul(B, ve) | 0, n = n + Math.imul(B, be) | 0, n = n + Math.imul(I, ve) | 0, d = d + Math.imul(I, be) | 0;
        var $e = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + ($e >>> 26) | 0, $e &= 67108863, l = Math.imul(G, te), n = Math.imul(G, re), n = n + Math.imul(Y, te) | 0, d = Math.imul(Y, re), l = l + Math.imul(V, ie) | 0, n = n + Math.imul(V, ne) | 0, n = n + Math.imul($2, ie) | 0, d = d + Math.imul($2, ne) | 0, l = l + Math.imul(j, fe) | 0, n = n + Math.imul(j, ae) | 0, n = n + Math.imul(Z, fe) | 0, d = d + Math.imul(Z, ae) | 0, l = l + Math.imul(W, oe) | 0, n = n + Math.imul(W, se) | 0, n = n + Math.imul(K, oe) | 0, d = d + Math.imul(K, se) | 0, l = l + Math.imul(z2, he) | 0, n = n + Math.imul(z2, ue) | 0, n = n + Math.imul(H, he) | 0, d = d + Math.imul(H, ue) | 0, l = l + Math.imul(F, le) | 0, n = n + Math.imul(F, de) | 0, n = n + Math.imul(U, le) | 0, d = d + Math.imul(U, de) | 0, l = l + Math.imul(C, ce) | 0, n = n + Math.imul(C, pe) | 0, n = n + Math.imul(O, ce) | 0, d = d + Math.imul(O, pe) | 0, l = l + Math.imul(L, ve) | 0, n = n + Math.imul(L, be) | 0, n = n + Math.imul(N, ve) | 0, d = d + Math.imul(N, be) | 0;
        var Ge = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, l = Math.imul(G, ie), n = Math.imul(G, ne), n = n + Math.imul(Y, ie) | 0, d = Math.imul(Y, ne), l = l + Math.imul(V, fe) | 0, n = n + Math.imul(V, ae) | 0, n = n + Math.imul($2, fe) | 0, d = d + Math.imul($2, ae) | 0, l = l + Math.imul(j, oe) | 0, n = n + Math.imul(j, se) | 0, n = n + Math.imul(Z, oe) | 0, d = d + Math.imul(Z, se) | 0, l = l + Math.imul(W, he) | 0, n = n + Math.imul(W, ue) | 0, n = n + Math.imul(K, he) | 0, d = d + Math.imul(K, ue) | 0, l = l + Math.imul(z2, le) | 0, n = n + Math.imul(z2, de) | 0, n = n + Math.imul(H, le) | 0, d = d + Math.imul(H, de) | 0, l = l + Math.imul(F, ce) | 0, n = n + Math.imul(F, pe) | 0, n = n + Math.imul(U, ce) | 0, d = d + Math.imul(U, pe) | 0, l = l + Math.imul(C, ve) | 0, n = n + Math.imul(C, be) | 0, n = n + Math.imul(O, ve) | 0, d = d + Math.imul(O, be) | 0;
        var Ye = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, l = Math.imul(G, fe), n = Math.imul(G, ae), n = n + Math.imul(Y, fe) | 0, d = Math.imul(Y, ae), l = l + Math.imul(V, oe) | 0, n = n + Math.imul(V, se) | 0, n = n + Math.imul($2, oe) | 0, d = d + Math.imul($2, se) | 0, l = l + Math.imul(j, he) | 0, n = n + Math.imul(j, ue) | 0, n = n + Math.imul(Z, he) | 0, d = d + Math.imul(Z, ue) | 0, l = l + Math.imul(W, le) | 0, n = n + Math.imul(W, de) | 0, n = n + Math.imul(K, le) | 0, d = d + Math.imul(K, de) | 0, l = l + Math.imul(z2, ce) | 0, n = n + Math.imul(z2, pe) | 0, n = n + Math.imul(H, ce) | 0, d = d + Math.imul(H, pe) | 0, l = l + Math.imul(F, ve) | 0, n = n + Math.imul(F, be) | 0, n = n + Math.imul(U, ve) | 0, d = d + Math.imul(U, be) | 0;
        var Xe = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, l = Math.imul(G, oe), n = Math.imul(G, se), n = n + Math.imul(Y, oe) | 0, d = Math.imul(Y, se), l = l + Math.imul(V, he) | 0, n = n + Math.imul(V, ue) | 0, n = n + Math.imul($2, he) | 0, d = d + Math.imul($2, ue) | 0, l = l + Math.imul(j, le) | 0, n = n + Math.imul(j, de) | 0, n = n + Math.imul(Z, le) | 0, d = d + Math.imul(Z, de) | 0, l = l + Math.imul(W, ce) | 0, n = n + Math.imul(W, pe) | 0, n = n + Math.imul(K, ce) | 0, d = d + Math.imul(K, pe) | 0, l = l + Math.imul(z2, ve) | 0, n = n + Math.imul(z2, be) | 0, n = n + Math.imul(H, ve) | 0, d = d + Math.imul(H, be) | 0;
        var Je = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, l = Math.imul(G, he), n = Math.imul(G, ue), n = n + Math.imul(Y, he) | 0, d = Math.imul(Y, ue), l = l + Math.imul(V, le) | 0, n = n + Math.imul(V, de) | 0, n = n + Math.imul($2, le) | 0, d = d + Math.imul($2, de) | 0, l = l + Math.imul(j, ce) | 0, n = n + Math.imul(j, pe) | 0, n = n + Math.imul(Z, ce) | 0, d = d + Math.imul(Z, pe) | 0, l = l + Math.imul(W, ve) | 0, n = n + Math.imul(W, be) | 0, n = n + Math.imul(K, ve) | 0, d = d + Math.imul(K, be) | 0;
        var Qe = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, l = Math.imul(G, le), n = Math.imul(G, de), n = n + Math.imul(Y, le) | 0, d = Math.imul(Y, de), l = l + Math.imul(V, ce) | 0, n = n + Math.imul(V, pe) | 0, n = n + Math.imul($2, ce) | 0, d = d + Math.imul($2, pe) | 0, l = l + Math.imul(j, ve) | 0, n = n + Math.imul(j, be) | 0, n = n + Math.imul(Z, ve) | 0, d = d + Math.imul(Z, be) | 0;
        var et = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, l = Math.imul(G, ce), n = Math.imul(G, pe), n = n + Math.imul(Y, ce) | 0, d = Math.imul(Y, pe), l = l + Math.imul(V, ve) | 0, n = n + Math.imul(V, be) | 0, n = n + Math.imul($2, ve) | 0, d = d + Math.imul($2, be) | 0;
        var tt = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, l = Math.imul(G, ve), n = Math.imul(G, be), n = n + Math.imul(Y, ve) | 0, d = Math.imul(Y, be);
        var rt = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        return b2 = (d + (n >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, c[0] = ft, c[1] = Be, c[2] = qe, c[3] = ze, c[4] = He, c[5] = We, c[6] = Ke, c[7] = je, c[8] = Ze, c[9] = Ve, c[10] = $e, c[11] = Ge, c[12] = Ye, c[13] = Xe, c[14] = Je, c[15] = Qe, c[16] = et, c[17] = tt, c[18] = rt, b2 !== 0 && (c[19] = b2, h.length++), h;
      };
      Math.imul || (T = q);
      function ye(v2, i, a) {
        a.negative = i.negative ^ v2.negative, a.length = v2.length + i.length;
        for (var h = 0, s = 0, u = 0;u < a.length - 1; u++) {
          var c = s;
          s = 0;
          for (var b2 = h & 67108863, l = Math.min(u, i.length - 1), n = Math.max(0, u - v2.length + 1);n <= l; n++) {
            var d = u - n, w = v2.words[d] | 0, g = i.words[n] | 0, _2 = w * g, A = _2 & 67108863;
            c = c + (_2 / 67108864 | 0) | 0, A = A + b2 | 0, b2 = A & 67108863, c = c + (A >>> 26) | 0, s += c >>> 26, c &= 67108863;
          }
          a.words[u] = b2, h = c, c = s;
        }
        return h !== 0 ? a.words[u] = h : a.length--, a.strip();
      }
      function _e(v2, i, a) {
        var h = new P;
        return h.mulp(v2, i, a);
      }
      f2.prototype.mulTo = function(i, a) {
        var h, s = this.length + i.length;
        return this.length === 10 && i.length === 10 ? h = T(this, i, a) : s < 63 ? h = q(this, i, a) : s < 1024 ? h = ye(this, i, a) : h = _e(this, i, a), h;
      };
      function P(v2, i) {
        this.x = v2, this.y = i;
      }
      P.prototype.makeRBT = function(i) {
        for (var a = new Array(i), h = f2.prototype._countBits(i) - 1, s = 0;s < i; s++)
          a[s] = this.revBin(s, h, i);
        return a;
      }, P.prototype.revBin = function(i, a, h) {
        if (i === 0 || i === h - 1)
          return i;
        for (var s = 0, u = 0;u < a; u++)
          s |= (i & 1) << a - u - 1, i >>= 1;
        return s;
      }, P.prototype.permute = function(i, a, h, s, u, c) {
        for (var b2 = 0;b2 < c; b2++)
          s[b2] = a[i[b2]], u[b2] = h[i[b2]];
      }, P.prototype.transform = function(i, a, h, s, u, c) {
        this.permute(c, i, a, h, s, u);
        for (var b2 = 1;b2 < u; b2 <<= 1)
          for (var l = b2 << 1, n = Math.cos(2 * Math.PI / l), d = Math.sin(2 * Math.PI / l), w = 0;w < u; w += l)
            for (var g = n, _2 = d, A = 0;A < b2; A++) {
              var B = h[w + A], I = s[w + A], we = h[w + A + b2], L = s[w + A + b2], N = g * we - _2 * L;
              L = g * L + _2 * we, we = N, h[w + A] = B + we, s[w + A] = I + L, h[w + A + b2] = B - we, s[w + A + b2] = I - L, A !== l && (N = n * g - d * _2, _2 = n * _2 + d * g, g = N);
            }
      }, P.prototype.guessLen13b = function(i, a) {
        var h = Math.max(a, i) | 1, s = h & 1, u = 0;
        for (h = h / 2 | 0;h; h = h >>> 1)
          u++;
        return 1 << u + 1 + s;
      }, P.prototype.conjugate = function(i, a, h) {
        if (!(h <= 1))
          for (var s = 0;s < h / 2; s++) {
            var u = i[s];
            i[s] = i[h - s - 1], i[h - s - 1] = u, u = a[s], a[s] = -a[h - s - 1], a[h - s - 1] = -u;
          }
      }, P.prototype.normalize13b = function(i, a) {
        for (var h = 0, s = 0;s < a / 2; s++) {
          var u = Math.round(i[2 * s + 1] / a) * 8192 + Math.round(i[2 * s] / a) + h;
          i[s] = u & 67108863, u < 67108864 ? h = 0 : h = u / 67108864 | 0;
        }
        return i;
      }, P.prototype.convert13b = function(i, a, h, s) {
        for (var u = 0, c = 0;c < a; c++)
          u = u + (i[c] | 0), h[2 * c] = u & 8191, u = u >>> 13, h[2 * c + 1] = u & 8191, u = u >>> 13;
        for (c = 2 * a;c < s; ++c)
          h[c] = 0;
        r(u === 0), r((u & -8192) === 0);
      }, P.prototype.stub = function(i) {
        for (var a = new Array(i), h = 0;h < i; h++)
          a[h] = 0;
        return a;
      }, P.prototype.mulp = function(i, a, h) {
        var s = 2 * this.guessLen13b(i.length, a.length), u = this.makeRBT(s), c = this.stub(s), b2 = new Array(s), l = new Array(s), n = new Array(s), d = new Array(s), w = new Array(s), g = new Array(s), _2 = h.words;
        _2.length = s, this.convert13b(i.words, i.length, b2, s), this.convert13b(a.words, a.length, d, s), this.transform(b2, c, l, n, s, u), this.transform(d, c, w, g, s, u);
        for (var A = 0;A < s; A++) {
          var B = l[A] * w[A] - n[A] * g[A];
          n[A] = l[A] * g[A] + n[A] * w[A], l[A] = B;
        }
        return this.conjugate(l, n, s), this.transform(l, n, _2, c, s, u), this.conjugate(_2, c, s), this.normalize13b(_2, s), h.negative = i.negative ^ a.negative, h.length = i.length + a.length, h.strip();
      }, f2.prototype.mul = function(i) {
        var a = new f2(null);
        return a.words = new Array(this.length + i.length), this.mulTo(i, a);
      }, f2.prototype.mulf = function(i) {
        var a = new f2(null);
        return a.words = new Array(this.length + i.length), _e(this, i, a);
      }, f2.prototype.imul = function(i) {
        return this.clone().mulTo(i, this);
      }, f2.prototype.imuln = function(i) {
        r(typeof i == "number"), r(i < 67108864);
        for (var a = 0, h = 0;h < this.length; h++) {
          var s = (this.words[h] | 0) * i, u = (s & 67108863) + (a & 67108863);
          a >>= 26, a += s / 67108864 | 0, a += u >>> 26, this.words[h] = u & 67108863;
        }
        return a !== 0 && (this.words[h] = a, this.length++), this;
      }, f2.prototype.muln = function(i) {
        return this.clone().imuln(i);
      }, f2.prototype.sqr = function() {
        return this.mul(this);
      }, f2.prototype.isqr = function() {
        return this.imul(this.clone());
      }, f2.prototype.pow = function(i) {
        var a = R(i);
        if (a.length === 0)
          return new f2(1);
        for (var h = this, s = 0;s < a.length && a[s] === 0; s++, h = h.sqr())
          ;
        if (++s < a.length)
          for (var u = h.sqr();s < a.length; s++, u = u.sqr())
            a[s] !== 0 && (h = h.mul(u));
        return h;
      }, f2.prototype.iushln = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 67108863 >>> 26 - a << 26 - a, u;
        if (a !== 0) {
          var c = 0;
          for (u = 0;u < this.length; u++) {
            var b2 = this.words[u] & s, l = (this.words[u] | 0) - b2 << a;
            this.words[u] = l | c, c = b2 >>> 26 - a;
          }
          c && (this.words[u] = c, this.length++);
        }
        if (h !== 0) {
          for (u = this.length - 1;u >= 0; u--)
            this.words[u + h] = this.words[u];
          for (u = 0;u < h; u++)
            this.words[u] = 0;
          this.length += h;
        }
        return this.strip();
      }, f2.prototype.ishln = function(i) {
        return r(this.negative === 0), this.iushln(i);
      }, f2.prototype.iushrn = function(i, a, h) {
        r(typeof i == "number" && i >= 0);
        var s;
        a ? s = (a - a % 26) / 26 : s = 0;
        var u = i % 26, c = Math.min((i - u) / 26, this.length), b2 = 67108863 ^ 67108863 >>> u << u, l = h;
        if (s -= c, s = Math.max(0, s), l) {
          for (var n = 0;n < c; n++)
            l.words[n] = this.words[n];
          l.length = c;
        }
        if (c !== 0)
          if (this.length > c)
            for (this.length -= c, n = 0;n < this.length; n++)
              this.words[n] = this.words[n + c];
          else
            this.words[0] = 0, this.length = 1;
        var d = 0;
        for (n = this.length - 1;n >= 0 && (d !== 0 || n >= s); n--) {
          var w = this.words[n] | 0;
          this.words[n] = d << 26 - u | w >>> u, d = w & b2;
        }
        return l && d !== 0 && (l.words[l.length++] = d), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, f2.prototype.ishrn = function(i, a, h) {
        return r(this.negative === 0), this.iushrn(i, a, h);
      }, f2.prototype.shln = function(i) {
        return this.clone().ishln(i);
      }, f2.prototype.ushln = function(i) {
        return this.clone().iushln(i);
      }, f2.prototype.shrn = function(i) {
        return this.clone().ishrn(i);
      }, f2.prototype.ushrn = function(i) {
        return this.clone().iushrn(i);
      }, f2.prototype.testn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return false;
        var u = this.words[h];
        return !!(u & s);
      }, f2.prototype.imaskn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= h)
          return this;
        if (a !== 0 && h++, this.length = Math.min(h, this.length), a !== 0) {
          var s = 67108863 ^ 67108863 >>> a << a;
          this.words[this.length - 1] &= s;
        }
        return this.strip();
      }, f2.prototype.maskn = function(i) {
        return this.clone().imaskn(i);
      }, f2.prototype.iaddn = function(i) {
        return r(typeof i == "number"), r(i < 67108864), i < 0 ? this.isubn(-i) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < i ? (this.words[0] = i - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(i), this.negative = 1, this) : this._iaddn(i);
      }, f2.prototype._iaddn = function(i) {
        this.words[0] += i;
        for (var a = 0;a < this.length && this.words[a] >= 67108864; a++)
          this.words[a] -= 67108864, a === this.length - 1 ? this.words[a + 1] = 1 : this.words[a + 1]++;
        return this.length = Math.max(this.length, a + 1), this;
      }, f2.prototype.isubn = function(i) {
        if (r(typeof i == "number"), r(i < 67108864), i < 0)
          return this.iaddn(-i);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(i), this.negative = 1, this;
        if (this.words[0] -= i, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var a = 0;a < this.length && this.words[a] < 0; a++)
            this.words[a] += 67108864, this.words[a + 1] -= 1;
        return this.strip();
      }, f2.prototype.addn = function(i) {
        return this.clone().iaddn(i);
      }, f2.prototype.subn = function(i) {
        return this.clone().isubn(i);
      }, f2.prototype.iabs = function() {
        return this.negative = 0, this;
      }, f2.prototype.abs = function() {
        return this.clone().iabs();
      }, f2.prototype._ishlnsubmul = function(i, a, h) {
        var s = i.length + h, u;
        this._expand(s);
        var c, b2 = 0;
        for (u = 0;u < i.length; u++) {
          c = (this.words[u + h] | 0) + b2;
          var l = (i.words[u] | 0) * a;
          c -= l & 67108863, b2 = (c >> 26) - (l / 67108864 | 0), this.words[u + h] = c & 67108863;
        }
        for (;u < this.length - h; u++)
          c = (this.words[u + h] | 0) + b2, b2 = c >> 26, this.words[u + h] = c & 67108863;
        if (b2 === 0)
          return this.strip();
        for (r(b2 === -1), b2 = 0, u = 0;u < this.length; u++)
          c = -(this.words[u] | 0) + b2, b2 = c >> 26, this.words[u] = c & 67108863;
        return this.negative = 1, this.strip();
      }, f2.prototype._wordDiv = function(i, a) {
        var h = this.length - i.length, s = this.clone(), u = i, c = u.words[u.length - 1] | 0, b2 = this._countBits(c);
        h = 26 - b2, h !== 0 && (u = u.ushln(h), s.iushln(h), c = u.words[u.length - 1] | 0);
        var l = s.length - u.length, n;
        if (a !== "mod") {
          n = new f2(null), n.length = l + 1, n.words = new Array(n.length);
          for (var d = 0;d < n.length; d++)
            n.words[d] = 0;
        }
        var w = s.clone()._ishlnsubmul(u, 1, l);
        w.negative === 0 && (s = w, n && (n.words[l] = 1));
        for (var g = l - 1;g >= 0; g--) {
          var _2 = (s.words[u.length + g] | 0) * 67108864 + (s.words[u.length + g - 1] | 0);
          for (_2 = Math.min(_2 / c | 0, 67108863), s._ishlnsubmul(u, _2, g);s.negative !== 0; )
            _2--, s.negative = 0, s._ishlnsubmul(u, 1, g), s.isZero() || (s.negative ^= 1);
          n && (n.words[g] = _2);
        }
        return n && n.strip(), s.strip(), a !== "div" && h !== 0 && s.iushrn(h), { div: n || null, mod: s };
      }, f2.prototype.divmod = function(i, a, h) {
        if (r(!i.isZero()), this.isZero())
          return { div: new f2(0), mod: new f2(0) };
        var s, u, c;
        return this.negative !== 0 && i.negative === 0 ? (c = this.neg().divmod(i, a), a !== "mod" && (s = c.div.neg()), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.iadd(i)), { div: s, mod: u }) : this.negative === 0 && i.negative !== 0 ? (c = this.divmod(i.neg(), a), a !== "mod" && (s = c.div.neg()), { div: s, mod: c.mod }) : (this.negative & i.negative) !== 0 ? (c = this.neg().divmod(i.neg(), a), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.isub(i)), { div: c.div, mod: u }) : i.length > this.length || this.cmp(i) < 0 ? { div: new f2(0), mod: this } : i.length === 1 ? a === "div" ? { div: this.divn(i.words[0]), mod: null } : a === "mod" ? { div: null, mod: new f2(this.modn(i.words[0])) } : { div: this.divn(i.words[0]), mod: new f2(this.modn(i.words[0])) } : this._wordDiv(i, a);
      }, f2.prototype.div = function(i) {
        return this.divmod(i, "div", false).div;
      }, f2.prototype.mod = function(i) {
        return this.divmod(i, "mod", false).mod;
      }, f2.prototype.umod = function(i) {
        return this.divmod(i, "mod", true).mod;
      }, f2.prototype.divRound = function(i) {
        var a = this.divmod(i);
        if (a.mod.isZero())
          return a.div;
        var h = a.div.negative !== 0 ? a.mod.isub(i) : a.mod, s = i.ushrn(1), u = i.andln(1), c = h.cmp(s);
        return c < 0 || u === 1 && c === 0 ? a.div : a.div.negative !== 0 ? a.div.isubn(1) : a.div.iaddn(1);
      }, f2.prototype.modn = function(i) {
        r(i <= 67108863);
        for (var a = (1 << 26) % i, h = 0, s = this.length - 1;s >= 0; s--)
          h = (a * h + (this.words[s] | 0)) % i;
        return h;
      }, f2.prototype.idivn = function(i) {
        r(i <= 67108863);
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = (this.words[h] | 0) + a * 67108864;
          this.words[h] = s / i | 0, a = s % i;
        }
        return this.strip();
      }, f2.prototype.divn = function(i) {
        return this.clone().idivn(i);
      }, f2.prototype.egcd = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f2(1), u = new f2(0), c = new f2(0), b2 = new f2(1), l = 0;a.isEven() && h.isEven(); )
          a.iushrn(1), h.iushrn(1), ++l;
        for (var n = h.clone(), d = a.clone();!a.isZero(); ) {
          for (var w = 0, g = 1;(a.words[0] & g) === 0 && w < 26; ++w, g <<= 1)
            ;
          if (w > 0)
            for (a.iushrn(w);w-- > 0; )
              (s.isOdd() || u.isOdd()) && (s.iadd(n), u.isub(d)), s.iushrn(1), u.iushrn(1);
          for (var _2 = 0, A = 1;(h.words[0] & A) === 0 && _2 < 26; ++_2, A <<= 1)
            ;
          if (_2 > 0)
            for (h.iushrn(_2);_2-- > 0; )
              (c.isOdd() || b2.isOdd()) && (c.iadd(n), b2.isub(d)), c.iushrn(1), b2.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(c), u.isub(b2)) : (h.isub(a), c.isub(s), b2.isub(u));
        }
        return { a: c, b: b2, gcd: h.iushln(l) };
      }, f2.prototype._invmp = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f2(1), u = new f2(0), c = h.clone();a.cmpn(1) > 0 && h.cmpn(1) > 0; ) {
          for (var b2 = 0, l = 1;(a.words[0] & l) === 0 && b2 < 26; ++b2, l <<= 1)
            ;
          if (b2 > 0)
            for (a.iushrn(b2);b2-- > 0; )
              s.isOdd() && s.iadd(c), s.iushrn(1);
          for (var n = 0, d = 1;(h.words[0] & d) === 0 && n < 26; ++n, d <<= 1)
            ;
          if (n > 0)
            for (h.iushrn(n);n-- > 0; )
              u.isOdd() && u.iadd(c), u.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(u)) : (h.isub(a), u.isub(s));
        }
        var w;
        return a.cmpn(1) === 0 ? w = s : w = u, w.cmpn(0) < 0 && w.iadd(i), w;
      }, f2.prototype.gcd = function(i) {
        if (this.isZero())
          return i.abs();
        if (i.isZero())
          return this.abs();
        var a = this.clone(), h = i.clone();
        a.negative = 0, h.negative = 0;
        for (var s = 0;a.isEven() && h.isEven(); s++)
          a.iushrn(1), h.iushrn(1);
        do {
          for (;a.isEven(); )
            a.iushrn(1);
          for (;h.isEven(); )
            h.iushrn(1);
          var u = a.cmp(h);
          if (u < 0) {
            var c = a;
            a = h, h = c;
          } else if (u === 0 || h.cmpn(1) === 0)
            break;
          a.isub(h);
        } while (true);
        return h.iushln(s);
      }, f2.prototype.invm = function(i) {
        return this.egcd(i).a.umod(i);
      }, f2.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, f2.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, f2.prototype.andln = function(i) {
        return this.words[0] & i;
      }, f2.prototype.bincn = function(i) {
        r(typeof i == "number");
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return this._expand(h + 1), this.words[h] |= s, this;
        for (var u = s, c = h;u !== 0 && c < this.length; c++) {
          var b2 = this.words[c] | 0;
          b2 += u, u = b2 >>> 26, b2 &= 67108863, this.words[c] = b2;
        }
        return u !== 0 && (this.words[c] = u, this.length++), this;
      }, f2.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, f2.prototype.cmpn = function(i) {
        var a = i < 0;
        if (this.negative !== 0 && !a)
          return -1;
        if (this.negative === 0 && a)
          return 1;
        this.strip();
        var h;
        if (this.length > 1)
          h = 1;
        else {
          a && (i = -i), r(i <= 67108863, "Number is too big");
          var s = this.words[0] | 0;
          h = s === i ? 0 : s < i ? -1 : 1;
        }
        return this.negative !== 0 ? -h | 0 : h;
      }, f2.prototype.cmp = function(i) {
        if (this.negative !== 0 && i.negative === 0)
          return -1;
        if (this.negative === 0 && i.negative !== 0)
          return 1;
        var a = this.ucmp(i);
        return this.negative !== 0 ? -a | 0 : a;
      }, f2.prototype.ucmp = function(i) {
        if (this.length > i.length)
          return 1;
        if (this.length < i.length)
          return -1;
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = this.words[h] | 0, u = i.words[h] | 0;
          if (s !== u) {
            s < u ? a = -1 : s > u && (a = 1);
            break;
          }
        }
        return a;
      }, f2.prototype.gtn = function(i) {
        return this.cmpn(i) === 1;
      }, f2.prototype.gt = function(i) {
        return this.cmp(i) === 1;
      }, f2.prototype.gten = function(i) {
        return this.cmpn(i) >= 0;
      }, f2.prototype.gte = function(i) {
        return this.cmp(i) >= 0;
      }, f2.prototype.ltn = function(i) {
        return this.cmpn(i) === -1;
      }, f2.prototype.lt = function(i) {
        return this.cmp(i) === -1;
      }, f2.prototype.lten = function(i) {
        return this.cmpn(i) <= 0;
      }, f2.prototype.lte = function(i) {
        return this.cmp(i) <= 0;
      }, f2.prototype.eqn = function(i) {
        return this.cmpn(i) === 0;
      }, f2.prototype.eq = function(i) {
        return this.cmp(i) === 0;
      }, f2.red = function(i) {
        return new D2(i);
      }, f2.prototype.toRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), i.convertTo(this)._forceRed(i);
      }, f2.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, f2.prototype._forceRed = function(i) {
        return this.red = i, this;
      }, f2.prototype.forceRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(i);
      }, f2.prototype.redAdd = function(i) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, i);
      }, f2.prototype.redIAdd = function(i) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, i);
      }, f2.prototype.redSub = function(i) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, i);
      }, f2.prototype.redISub = function(i) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, i);
      }, f2.prototype.redShl = function(i) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, i);
      }, f2.prototype.redMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.mul(this, i);
      }, f2.prototype.redIMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.imul(this, i);
      }, f2.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, f2.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, f2.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, f2.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, f2.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, f2.prototype.redPow = function(i) {
        return r(this.red && !i.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, i);
      };
      var Me = { k256: null, p224: null, p192: null, p25519: null };
      function me(v2, i) {
        this.name = v2, this.p = new f2(i, 16), this.n = this.p.bitLength(), this.k = new f2(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      me.prototype._tmp = function() {
        var i = new f2(null);
        return i.words = new Array(Math.ceil(this.n / 13)), i;
      }, me.prototype.ireduce = function(i) {
        var a = i, h;
        do
          this.split(a, this.tmp), a = this.imulK(a), a = a.iadd(this.tmp), h = a.bitLength();
        while (h > this.n);
        var s = h < this.n ? -1 : a.ucmp(this.p);
        return s === 0 ? (a.words[0] = 0, a.length = 1) : s > 0 ? a.isub(this.p) : a.strip !== undefined ? a.strip() : a._strip(), a;
      }, me.prototype.split = function(i, a) {
        i.iushrn(this.n, 0, a);
      }, me.prototype.imulK = function(i) {
        return i.imul(this.k);
      };
      function xe() {
        me.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      o(xe, me), xe.prototype.split = function(i, a) {
        for (var h = 4194303, s = Math.min(i.length, 9), u = 0;u < s; u++)
          a.words[u] = i.words[u];
        if (a.length = s, i.length <= 9) {
          i.words[0] = 0, i.length = 1;
          return;
        }
        var c = i.words[9];
        for (a.words[a.length++] = c & h, u = 10;u < i.length; u++) {
          var b2 = i.words[u] | 0;
          i.words[u - 10] = (b2 & h) << 4 | c >>> 22, c = b2;
        }
        c >>>= 22, i.words[u - 10] = c, c === 0 && i.length > 10 ? i.length -= 10 : i.length -= 9;
      }, xe.prototype.imulK = function(i) {
        i.words[i.length] = 0, i.words[i.length + 1] = 0, i.length += 2;
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = i.words[h] | 0;
          a += s * 977, i.words[h] = a & 67108863, a = s * 64 + (a / 67108864 | 0);
        }
        return i.words[i.length - 1] === 0 && (i.length--, i.words[i.length - 1] === 0 && i.length--), i;
      };
      function Ae() {
        me.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      o(Ae, me);
      function Ee() {
        me.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      o(Ee, me);
      function Re() {
        me.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      o(Re, me), Re.prototype.imulK = function(i) {
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = (i.words[h] | 0) * 19 + a, u = s & 67108863;
          s >>>= 26, i.words[h] = u, a = s;
        }
        return a !== 0 && (i.words[i.length++] = a), i;
      }, f2._prime = function(i) {
        if (Me[i])
          return Me[i];
        var a;
        if (i === "k256")
          a = new xe;
        else if (i === "p224")
          a = new Ae;
        else if (i === "p192")
          a = new Ee;
        else if (i === "p25519")
          a = new Re;
        else
          throw new Error("Unknown prime " + i);
        return Me[i] = a, a;
      };
      function D2(v2) {
        if (typeof v2 == "string") {
          var i = f2._prime(v2);
          this.m = i.p, this.prime = i;
        } else
          r(v2.gtn(1), "modulus must be greater than 1"), this.m = v2, this.prime = null;
      }
      D2.prototype._verify1 = function(i) {
        r(i.negative === 0, "red works only with positives"), r(i.red, "red works only with red numbers");
      }, D2.prototype._verify2 = function(i, a) {
        r((i.negative | a.negative) === 0, "red works only with positives"), r(i.red && i.red === a.red, "red works only with red numbers");
      }, D2.prototype.imod = function(i) {
        return this.prime ? this.prime.ireduce(i)._forceRed(this) : i.umod(this.m)._forceRed(this);
      }, D2.prototype.neg = function(i) {
        return i.isZero() ? i.clone() : this.m.sub(i)._forceRed(this);
      }, D2.prototype.add = function(i, a) {
        this._verify2(i, a);
        var h = i.add(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h._forceRed(this);
      }, D2.prototype.iadd = function(i, a) {
        this._verify2(i, a);
        var h = i.iadd(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h;
      }, D2.prototype.sub = function(i, a) {
        this._verify2(i, a);
        var h = i.sub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h._forceRed(this);
      }, D2.prototype.isub = function(i, a) {
        this._verify2(i, a);
        var h = i.isub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h;
      }, D2.prototype.shl = function(i, a) {
        return this._verify1(i), this.imod(i.ushln(a));
      }, D2.prototype.imul = function(i, a) {
        return this._verify2(i, a), this.imod(i.imul(a));
      }, D2.prototype.mul = function(i, a) {
        return this._verify2(i, a), this.imod(i.mul(a));
      }, D2.prototype.isqr = function(i) {
        return this.imul(i, i.clone());
      }, D2.prototype.sqr = function(i) {
        return this.mul(i, i);
      }, D2.prototype.sqrt = function(i) {
        if (i.isZero())
          return i.clone();
        var a = this.m.andln(3);
        if (r(a % 2 === 1), a === 3) {
          var h = this.m.add(new f2(1)).iushrn(2);
          return this.pow(i, h);
        }
        for (var s = this.m.subn(1), u = 0;!s.isZero() && s.andln(1) === 0; )
          u++, s.iushrn(1);
        r(!s.isZero());
        var c = new f2(1).toRed(this), b2 = c.redNeg(), l = this.m.subn(1).iushrn(1), n = this.m.bitLength();
        for (n = new f2(2 * n * n).toRed(this);this.pow(n, l).cmp(b2) !== 0; )
          n.redIAdd(b2);
        for (var d = this.pow(n, s), w = this.pow(i, s.addn(1).iushrn(1)), g = this.pow(i, s), _2 = u;g.cmp(c) !== 0; ) {
          for (var A = g, B = 0;A.cmp(c) !== 0; B++)
            A = A.redSqr();
          r(B < _2);
          var I = this.pow(d, new f2(1).iushln(_2 - B - 1));
          w = w.redMul(I), d = I.redSqr(), g = g.redMul(d), _2 = B;
        }
        return w;
      }, D2.prototype.invm = function(i) {
        var a = i._invmp(this.m);
        return a.negative !== 0 ? (a.negative = 0, this.imod(a).redNeg()) : this.imod(a);
      }, D2.prototype.pow = function(i, a) {
        if (a.isZero())
          return new f2(1).toRed(this);
        if (a.cmpn(1) === 0)
          return i.clone();
        var h = 4, s = new Array(1 << h);
        s[0] = new f2(1).toRed(this), s[1] = i;
        for (var u = 2;u < s.length; u++)
          s[u] = this.mul(s[u - 1], i);
        var c = s[0], b2 = 0, l = 0, n = a.bitLength() % 26;
        for (n === 0 && (n = 26), u = a.length - 1;u >= 0; u--) {
          for (var d = a.words[u], w = n - 1;w >= 0; w--) {
            var g = d >> w & 1;
            if (c !== s[0] && (c = this.sqr(c)), g === 0 && b2 === 0) {
              l = 0;
              continue;
            }
            b2 <<= 1, b2 |= g, l++, !(l !== h && (u !== 0 || w !== 0)) && (c = this.mul(c, s[b2]), l = 0, b2 = 0);
          }
          n = 26;
        }
        return c;
      }, D2.prototype.convertTo = function(i) {
        var a = i.umod(this.m);
        return a === i ? a.clone() : a;
      }, D2.prototype.convertFrom = function(i) {
        var a = i.clone();
        return a.red = null, a;
      }, f2.mont = function(i) {
        return new Se(i);
      };
      function Se(v2) {
        D2.call(this, v2), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f2(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o(Se, D2), Se.prototype.convertTo = function(i) {
        return this.imod(i.ushln(this.shift));
      }, Se.prototype.convertFrom = function(i) {
        var a = this.imod(i.mul(this.rinv));
        return a.red = null, a;
      }, Se.prototype.imul = function(i, a) {
        if (i.isZero() || a.isZero())
          return i.words[0] = 0, i.length = 1, i;
        var h = i.imul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se.prototype.mul = function(i, a) {
        if (i.isZero() || a.isZero())
          return new f2(0)._forceRed(this);
        var h = i.mul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se.prototype.invm = function(i) {
        var a = this.imod(i._invmp(this.m).mul(this.r2));
        return a._forceRed(this);
      };
    })(typeof dl > "u" || dl, yg);
  });
  Mg = k((wg, pl) => {
    (function(t, e) {
      function r(v2, i) {
        if (!v2)
          throw new Error(i || "Assertion failed");
      }
      function o(v2, i) {
        v2.super_ = i;
        var a = function() {
        };
        a.prototype = i.prototype, v2.prototype = new a, v2.prototype.constructor = v2;
      }
      function f2(v2, i, a) {
        if (f2.isBN(v2))
          return v2;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, v2 !== null && ((i === "le" || i === "be") && (a = i, i = 10), this._init(v2 || 0, i || 10, a || "be"));
      }
      typeof t == "object" ? t.exports = f2 : e.BN = f2, f2.BN = f2, f2.wordSize = 26;
      var p;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? p = window.Buffer : p = Vi().Buffer;
      } catch {
      }
      f2.isBN = function(i) {
        return i instanceof f2 ? true : i !== null && typeof i == "object" && i.constructor.wordSize === f2.wordSize && Array.isArray(i.words);
      }, f2.max = function(i, a) {
        return i.cmp(a) > 0 ? i : a;
      }, f2.min = function(i, a) {
        return i.cmp(a) < 0 ? i : a;
      }, f2.prototype._init = function(i, a, h) {
        if (typeof i == "number")
          return this._initNumber(i, a, h);
        if (typeof i == "object")
          return this._initArray(i, a, h);
        a === "hex" && (a = 16), r(a === (a | 0) && a >= 2 && a <= 36), i = i.toString().replace(/\s+/g, "");
        var s = 0;
        i[0] === "-" && (s++, this.negative = 1), s < i.length && (a === 16 ? this._parseHex(i, s, h) : (this._parseBase(i, a, s), h === "le" && this._initArray(this.toArray(), a, h)));
      }, f2.prototype._initNumber = function(i, a, h) {
        i < 0 && (this.negative = 1, i = -i), i < 67108864 ? (this.words = [i & 67108863], this.length = 1) : i < 4503599627370496 ? (this.words = [i & 67108863, i / 67108864 & 67108863], this.length = 2) : (r(i < 9007199254740992), this.words = [i & 67108863, i / 67108864 & 67108863, 1], this.length = 3), h === "le" && this._initArray(this.toArray(), a, h);
      }, f2.prototype._initArray = function(i, a, h) {
        if (r(typeof i.length == "number"), i.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(i.length / 3), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u, c, b2 = 0;
        if (h === "be")
          for (s = i.length - 1, u = 0;s >= 0; s -= 3)
            c = i[s] | i[s - 1] << 8 | i[s - 2] << 16, this.words[u] |= c << b2 & 67108863, this.words[u + 1] = c >>> 26 - b2 & 67108863, b2 += 24, b2 >= 26 && (b2 -= 26, u++);
        else if (h === "le")
          for (s = 0, u = 0;s < i.length; s += 3)
            c = i[s] | i[s + 1] << 8 | i[s + 2] << 16, this.words[u] |= c << b2 & 67108863, this.words[u + 1] = c >>> 26 - b2 & 67108863, b2 += 24, b2 >= 26 && (b2 -= 26, u++);
        return this.strip();
      };
      function m(v2, i) {
        var a = v2.charCodeAt(i);
        return a >= 65 && a <= 70 ? a - 55 : a >= 97 && a <= 102 ? a - 87 : a - 48 & 15;
      }
      function y(v2, i, a) {
        var h = m(v2, a);
        return a - 1 >= i && (h |= m(v2, a - 1) << 4), h;
      }
      f2.prototype._parseHex = function(i, a, h) {
        this.length = Math.ceil((i.length - a) / 6), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u = 0, c = 0, b2;
        if (h === "be")
          for (s = i.length - 1;s >= a; s -= 2)
            b2 = y(i, a, s) << u, this.words[c] |= b2 & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b2 >>> 26) : u += 8;
        else {
          var l = i.length - a;
          for (s = l % 2 === 0 ? a + 1 : a;s < i.length; s += 2)
            b2 = y(i, a, s) << u, this.words[c] |= b2 & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b2 >>> 26) : u += 8;
        }
        this.strip();
      };
      function M(v2, i, a, h) {
        for (var s = 0, u = Math.min(v2.length, a), c = i;c < u; c++) {
          var b2 = v2.charCodeAt(c) - 48;
          s *= h, b2 >= 49 ? s += b2 - 49 + 10 : b2 >= 17 ? s += b2 - 17 + 10 : s += b2;
        }
        return s;
      }
      f2.prototype._parseBase = function(i, a, h) {
        this.words = [0], this.length = 1;
        for (var s = 0, u = 1;u <= 67108863; u *= a)
          s++;
        s--, u = u / a | 0;
        for (var c = i.length - h, b2 = c % s, l = Math.min(c, c - b2) + h, n = 0, d = h;d < l; d += s)
          n = M(i, d, d + s, a), this.imuln(u), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        if (b2 !== 0) {
          var w = 1;
          for (n = M(i, d, i.length, a), d = 0;d < b2; d++)
            w *= a;
          this.imuln(w), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        }
        this.strip();
      }, f2.prototype.copy = function(i) {
        i.words = new Array(this.length);
        for (var a = 0;a < this.length; a++)
          i.words[a] = this.words[a];
        i.length = this.length, i.negative = this.negative, i.red = this.red;
      }, f2.prototype.clone = function() {
        var i = new f2(null);
        return this.copy(i), i;
      }, f2.prototype._expand = function(i) {
        for (;this.length < i; )
          this.words[this.length++] = 0;
        return this;
      }, f2.prototype.strip = function() {
        for (;this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, f2.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, f2.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var x = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], S2 = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], E = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      f2.prototype.toString = function(i, a) {
        i = i || 10, a = a | 0 || 1;
        var h;
        if (i === 16 || i === "hex") {
          h = "";
          for (var s = 0, u = 0, c = 0;c < this.length; c++) {
            var b2 = this.words[c], l = ((b2 << s | u) & 16777215).toString(16);
            u = b2 >>> 24 - s & 16777215, u !== 0 || c !== this.length - 1 ? h = x[6 - l.length] + l + h : h = l + h, s += 2, s >= 26 && (s -= 26, c--);
          }
          for (u !== 0 && (h = u.toString(16) + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        if (i === (i | 0) && i >= 2 && i <= 36) {
          var n = S2[i], d = E[i];
          h = "";
          var w = this.clone();
          for (w.negative = 0;!w.isZero(); ) {
            var g = w.modn(d).toString(i);
            w = w.idivn(d), w.isZero() ? h = g + h : h = x[n - g.length] + g + h;
          }
          for (this.isZero() && (h = "0" + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        r(false, "Base should be between 2 and 36");
      }, f2.prototype.toNumber = function() {
        var i = this.words[0];
        return this.length === 2 ? i += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? i += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -i : i;
      }, f2.prototype.toJSON = function() {
        return this.toString(16);
      }, f2.prototype.toBuffer = function(i, a) {
        return r(typeof p < "u"), this.toArrayLike(p, i, a);
      }, f2.prototype.toArray = function(i, a) {
        return this.toArrayLike(Array, i, a);
      }, f2.prototype.toArrayLike = function(i, a, h) {
        var s = this.byteLength(), u = h || Math.max(1, s);
        r(s <= u, "byte array longer than desired length"), r(u > 0, "Requested array length <= 0"), this.strip();
        var c = a === "le", b2 = new i(u), l, n, d = this.clone();
        if (c) {
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b2[n] = l;
          for (;n < u; n++)
            b2[n] = 0;
        } else {
          for (n = 0;n < u - s; n++)
            b2[n] = 0;
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b2[u - n - 1] = l;
        }
        return b2;
      }, Math.clz32 ? f2.prototype._countBits = function(i) {
        return 32 - Math.clz32(i);
      } : f2.prototype._countBits = function(i) {
        var a = i, h = 0;
        return a >= 4096 && (h += 13, a >>>= 13), a >= 64 && (h += 7, a >>>= 7), a >= 8 && (h += 4, a >>>= 4), a >= 2 && (h += 2, a >>>= 2), h + a;
      }, f2.prototype._zeroBits = function(i) {
        if (i === 0)
          return 26;
        var a = i, h = 0;
        return (a & 8191) === 0 && (h += 13, a >>>= 13), (a & 127) === 0 && (h += 7, a >>>= 7), (a & 15) === 0 && (h += 4, a >>>= 4), (a & 3) === 0 && (h += 2, a >>>= 2), (a & 1) === 0 && h++, h;
      }, f2.prototype.bitLength = function() {
        var i = this.words[this.length - 1], a = this._countBits(i);
        return (this.length - 1) * 26 + a;
      };
      function R(v2) {
        for (var i = new Array(v2.bitLength()), a = 0;a < i.length; a++) {
          var h = a / 26 | 0, s = a % 26;
          i[a] = (v2.words[h] & 1 << s) >>> s;
        }
        return i;
      }
      f2.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var i = 0, a = 0;a < this.length; a++) {
          var h = this._zeroBits(this.words[a]);
          if (i += h, h !== 26)
            break;
        }
        return i;
      }, f2.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, f2.prototype.toTwos = function(i) {
        return this.negative !== 0 ? this.abs().inotn(i).iaddn(1) : this.clone();
      }, f2.prototype.fromTwos = function(i) {
        return this.testn(i - 1) ? this.notn(i).iaddn(1).ineg() : this.clone();
      }, f2.prototype.isNeg = function() {
        return this.negative !== 0;
      }, f2.prototype.neg = function() {
        return this.clone().ineg();
      }, f2.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, f2.prototype.iuor = function(i) {
        for (;this.length < i.length; )
          this.words[this.length++] = 0;
        for (var a = 0;a < i.length; a++)
          this.words[a] = this.words[a] | i.words[a];
        return this.strip();
      }, f2.prototype.ior = function(i) {
        return r((this.negative | i.negative) === 0), this.iuor(i);
      }, f2.prototype.or = function(i) {
        return this.length > i.length ? this.clone().ior(i) : i.clone().ior(this);
      }, f2.prototype.uor = function(i) {
        return this.length > i.length ? this.clone().iuor(i) : i.clone().iuor(this);
      }, f2.prototype.iuand = function(i) {
        var a;
        this.length > i.length ? a = i : a = this;
        for (var h = 0;h < a.length; h++)
          this.words[h] = this.words[h] & i.words[h];
        return this.length = a.length, this.strip();
      }, f2.prototype.iand = function(i) {
        return r((this.negative | i.negative) === 0), this.iuand(i);
      }, f2.prototype.and = function(i) {
        return this.length > i.length ? this.clone().iand(i) : i.clone().iand(this);
      }, f2.prototype.uand = function(i) {
        return this.length > i.length ? this.clone().iuand(i) : i.clone().iuand(this);
      }, f2.prototype.iuxor = function(i) {
        var a, h;
        this.length > i.length ? (a = this, h = i) : (a = i, h = this);
        for (var s = 0;s < h.length; s++)
          this.words[s] = a.words[s] ^ h.words[s];
        if (this !== a)
          for (;s < a.length; s++)
            this.words[s] = a.words[s];
        return this.length = a.length, this.strip();
      }, f2.prototype.ixor = function(i) {
        return r((this.negative | i.negative) === 0), this.iuxor(i);
      }, f2.prototype.xor = function(i) {
        return this.length > i.length ? this.clone().ixor(i) : i.clone().ixor(this);
      }, f2.prototype.uxor = function(i) {
        return this.length > i.length ? this.clone().iuxor(i) : i.clone().iuxor(this);
      }, f2.prototype.inotn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = Math.ceil(i / 26) | 0, h = i % 26;
        this._expand(a), h > 0 && a--;
        for (var s = 0;s < a; s++)
          this.words[s] = ~this.words[s] & 67108863;
        return h > 0 && (this.words[s] = ~this.words[s] & 67108863 >> 26 - h), this.strip();
      }, f2.prototype.notn = function(i) {
        return this.clone().inotn(i);
      }, f2.prototype.setn = function(i, a) {
        r(typeof i == "number" && i >= 0);
        var h = i / 26 | 0, s = i % 26;
        return this._expand(h + 1), a ? this.words[h] = this.words[h] | 1 << s : this.words[h] = this.words[h] & ~(1 << s), this.strip();
      }, f2.prototype.iadd = function(i) {
        var a;
        if (this.negative !== 0 && i.negative === 0)
          return this.negative = 0, a = this.isub(i), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && i.negative !== 0)
          return i.negative = 0, a = this.isub(i), i.negative = 1, a._normSign();
        var h, s;
        this.length > i.length ? (h = this, s = i) : (h = i, s = this);
        for (var u = 0, c = 0;c < s.length; c++)
          a = (h.words[c] | 0) + (s.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        for (;u !== 0 && c < h.length; c++)
          a = (h.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        if (this.length = h.length, u !== 0)
          this.words[this.length] = u, this.length++;
        else if (h !== this)
          for (;c < h.length; c++)
            this.words[c] = h.words[c];
        return this;
      }, f2.prototype.add = function(i) {
        var a;
        return i.negative !== 0 && this.negative === 0 ? (i.negative = 0, a = this.sub(i), i.negative ^= 1, a) : i.negative === 0 && this.negative !== 0 ? (this.negative = 0, a = i.sub(this), this.negative = 1, a) : this.length > i.length ? this.clone().iadd(i) : i.clone().iadd(this);
      }, f2.prototype.isub = function(i) {
        if (i.negative !== 0) {
          i.negative = 0;
          var a = this.iadd(i);
          return i.negative = 1, a._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(i), this.negative = 1, this._normSign();
        var h = this.cmp(i);
        if (h === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var s, u;
        h > 0 ? (s = this, u = i) : (s = i, u = this);
        for (var c = 0, b2 = 0;b2 < u.length; b2++)
          a = (s.words[b2] | 0) - (u.words[b2] | 0) + c, c = a >> 26, this.words[b2] = a & 67108863;
        for (;c !== 0 && b2 < s.length; b2++)
          a = (s.words[b2] | 0) + c, c = a >> 26, this.words[b2] = a & 67108863;
        if (c === 0 && b2 < s.length && s !== this)
          for (;b2 < s.length; b2++)
            this.words[b2] = s.words[b2];
        return this.length = Math.max(this.length, b2), s !== this && (this.negative = 1), this.strip();
      }, f2.prototype.sub = function(i) {
        return this.clone().isub(i);
      };
      function q(v2, i, a) {
        a.negative = i.negative ^ v2.negative;
        var h = v2.length + i.length | 0;
        a.length = h, h = h - 1 | 0;
        var s = v2.words[0] | 0, u = i.words[0] | 0, c = s * u, b2 = c & 67108863, l = c / 67108864 | 0;
        a.words[0] = b2;
        for (var n = 1;n < h; n++) {
          for (var d = l >>> 26, w = l & 67108863, g = Math.min(n, i.length - 1), _2 = Math.max(0, n - v2.length + 1);_2 <= g; _2++) {
            var A = n - _2 | 0;
            s = v2.words[A] | 0, u = i.words[_2] | 0, c = s * u + w, d += c / 67108864 | 0, w = c & 67108863;
          }
          a.words[n] = w | 0, l = d | 0;
        }
        return l !== 0 ? a.words[n] = l | 0 : a.length--, a.strip();
      }
      var T = function(i, a, h) {
        var s = i.words, u = a.words, c = h.words, b2 = 0, l, n, d, w = s[0] | 0, g = w & 8191, _2 = w >>> 13, A = s[1] | 0, B = A & 8191, I = A >>> 13, we = s[2] | 0, L = we & 8191, N = we >>> 13, nt = s[3] | 0, C = nt & 8191, O = nt >>> 13, vt = s[4] | 0, F = vt & 8191, U = vt >>> 13, bt = s[5] | 0, z2 = bt & 8191, H = bt >>> 13, mt = s[6] | 0, W = mt & 8191, K = mt >>> 13, gt = s[7] | 0, j = gt & 8191, Z = gt >>> 13, yt = s[8] | 0, V = yt & 8191, $2 = yt >>> 13, wt = s[9] | 0, G = wt & 8191, Y = wt >>> 13, Mt = u[0] | 0, X = Mt & 8191, J2 = Mt >>> 13, _t = u[1] | 0, Q2 = _t & 8191, ee = _t >>> 13, xt = u[2] | 0, te = xt & 8191, re = xt >>> 13, St = u[3] | 0, ie = St & 8191, ne = St >>> 13, Et = u[4] | 0, fe = Et & 8191, ae = Et >>> 13, At = u[5] | 0, oe = At & 8191, se = At >>> 13, Rt = u[6] | 0, he = Rt & 8191, ue = Rt >>> 13, Bt = u[7] | 0, le = Bt & 8191, de = Bt >>> 13, qt = u[8] | 0, ce = qt & 8191, pe = qt >>> 13, It = u[9] | 0, ve = It & 8191, be = It >>> 13;
        h.negative = i.negative ^ a.negative, h.length = 19, l = Math.imul(g, X), n = Math.imul(g, J2), n = n + Math.imul(_2, X) | 0, d = Math.imul(_2, J2);
        var ft = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, l = Math.imul(B, X), n = Math.imul(B, J2), n = n + Math.imul(I, X) | 0, d = Math.imul(I, J2), l = l + Math.imul(g, Q2) | 0, n = n + Math.imul(g, ee) | 0, n = n + Math.imul(_2, Q2) | 0, d = d + Math.imul(_2, ee) | 0;
        var Be = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, l = Math.imul(L, X), n = Math.imul(L, J2), n = n + Math.imul(N, X) | 0, d = Math.imul(N, J2), l = l + Math.imul(B, Q2) | 0, n = n + Math.imul(B, ee) | 0, n = n + Math.imul(I, Q2) | 0, d = d + Math.imul(I, ee) | 0, l = l + Math.imul(g, te) | 0, n = n + Math.imul(g, re) | 0, n = n + Math.imul(_2, te) | 0, d = d + Math.imul(_2, re) | 0;
        var qe = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (qe >>> 26) | 0, qe &= 67108863, l = Math.imul(C, X), n = Math.imul(C, J2), n = n + Math.imul(O, X) | 0, d = Math.imul(O, J2), l = l + Math.imul(L, Q2) | 0, n = n + Math.imul(L, ee) | 0, n = n + Math.imul(N, Q2) | 0, d = d + Math.imul(N, ee) | 0, l = l + Math.imul(B, te) | 0, n = n + Math.imul(B, re) | 0, n = n + Math.imul(I, te) | 0, d = d + Math.imul(I, re) | 0, l = l + Math.imul(g, ie) | 0, n = n + Math.imul(g, ne) | 0, n = n + Math.imul(_2, ie) | 0, d = d + Math.imul(_2, ne) | 0;
        var ze = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, l = Math.imul(F, X), n = Math.imul(F, J2), n = n + Math.imul(U, X) | 0, d = Math.imul(U, J2), l = l + Math.imul(C, Q2) | 0, n = n + Math.imul(C, ee) | 0, n = n + Math.imul(O, Q2) | 0, d = d + Math.imul(O, ee) | 0, l = l + Math.imul(L, te) | 0, n = n + Math.imul(L, re) | 0, n = n + Math.imul(N, te) | 0, d = d + Math.imul(N, re) | 0, l = l + Math.imul(B, ie) | 0, n = n + Math.imul(B, ne) | 0, n = n + Math.imul(I, ie) | 0, d = d + Math.imul(I, ne) | 0, l = l + Math.imul(g, fe) | 0, n = n + Math.imul(g, ae) | 0, n = n + Math.imul(_2, fe) | 0, d = d + Math.imul(_2, ae) | 0;
        var He = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, l = Math.imul(z2, X), n = Math.imul(z2, J2), n = n + Math.imul(H, X) | 0, d = Math.imul(H, J2), l = l + Math.imul(F, Q2) | 0, n = n + Math.imul(F, ee) | 0, n = n + Math.imul(U, Q2) | 0, d = d + Math.imul(U, ee) | 0, l = l + Math.imul(C, te) | 0, n = n + Math.imul(C, re) | 0, n = n + Math.imul(O, te) | 0, d = d + Math.imul(O, re) | 0, l = l + Math.imul(L, ie) | 0, n = n + Math.imul(L, ne) | 0, n = n + Math.imul(N, ie) | 0, d = d + Math.imul(N, ne) | 0, l = l + Math.imul(B, fe) | 0, n = n + Math.imul(B, ae) | 0, n = n + Math.imul(I, fe) | 0, d = d + Math.imul(I, ae) | 0, l = l + Math.imul(g, oe) | 0, n = n + Math.imul(g, se) | 0, n = n + Math.imul(_2, oe) | 0, d = d + Math.imul(_2, se) | 0;
        var We = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (We >>> 26) | 0, We &= 67108863, l = Math.imul(W, X), n = Math.imul(W, J2), n = n + Math.imul(K, X) | 0, d = Math.imul(K, J2), l = l + Math.imul(z2, Q2) | 0, n = n + Math.imul(z2, ee) | 0, n = n + Math.imul(H, Q2) | 0, d = d + Math.imul(H, ee) | 0, l = l + Math.imul(F, te) | 0, n = n + Math.imul(F, re) | 0, n = n + Math.imul(U, te) | 0, d = d + Math.imul(U, re) | 0, l = l + Math.imul(C, ie) | 0, n = n + Math.imul(C, ne) | 0, n = n + Math.imul(O, ie) | 0, d = d + Math.imul(O, ne) | 0, l = l + Math.imul(L, fe) | 0, n = n + Math.imul(L, ae) | 0, n = n + Math.imul(N, fe) | 0, d = d + Math.imul(N, ae) | 0, l = l + Math.imul(B, oe) | 0, n = n + Math.imul(B, se) | 0, n = n + Math.imul(I, oe) | 0, d = d + Math.imul(I, se) | 0, l = l + Math.imul(g, he) | 0, n = n + Math.imul(g, ue) | 0, n = n + Math.imul(_2, he) | 0, d = d + Math.imul(_2, ue) | 0;
        var Ke = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, l = Math.imul(j, X), n = Math.imul(j, J2), n = n + Math.imul(Z, X) | 0, d = Math.imul(Z, J2), l = l + Math.imul(W, Q2) | 0, n = n + Math.imul(W, ee) | 0, n = n + Math.imul(K, Q2) | 0, d = d + Math.imul(K, ee) | 0, l = l + Math.imul(z2, te) | 0, n = n + Math.imul(z2, re) | 0, n = n + Math.imul(H, te) | 0, d = d + Math.imul(H, re) | 0, l = l + Math.imul(F, ie) | 0, n = n + Math.imul(F, ne) | 0, n = n + Math.imul(U, ie) | 0, d = d + Math.imul(U, ne) | 0, l = l + Math.imul(C, fe) | 0, n = n + Math.imul(C, ae) | 0, n = n + Math.imul(O, fe) | 0, d = d + Math.imul(O, ae) | 0, l = l + Math.imul(L, oe) | 0, n = n + Math.imul(L, se) | 0, n = n + Math.imul(N, oe) | 0, d = d + Math.imul(N, se) | 0, l = l + Math.imul(B, he) | 0, n = n + Math.imul(B, ue) | 0, n = n + Math.imul(I, he) | 0, d = d + Math.imul(I, ue) | 0, l = l + Math.imul(g, le) | 0, n = n + Math.imul(g, de) | 0, n = n + Math.imul(_2, le) | 0, d = d + Math.imul(_2, de) | 0;
        var je = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, l = Math.imul(V, X), n = Math.imul(V, J2), n = n + Math.imul($2, X) | 0, d = Math.imul($2, J2), l = l + Math.imul(j, Q2) | 0, n = n + Math.imul(j, ee) | 0, n = n + Math.imul(Z, Q2) | 0, d = d + Math.imul(Z, ee) | 0, l = l + Math.imul(W, te) | 0, n = n + Math.imul(W, re) | 0, n = n + Math.imul(K, te) | 0, d = d + Math.imul(K, re) | 0, l = l + Math.imul(z2, ie) | 0, n = n + Math.imul(z2, ne) | 0, n = n + Math.imul(H, ie) | 0, d = d + Math.imul(H, ne) | 0, l = l + Math.imul(F, fe) | 0, n = n + Math.imul(F, ae) | 0, n = n + Math.imul(U, fe) | 0, d = d + Math.imul(U, ae) | 0, l = l + Math.imul(C, oe) | 0, n = n + Math.imul(C, se) | 0, n = n + Math.imul(O, oe) | 0, d = d + Math.imul(O, se) | 0, l = l + Math.imul(L, he) | 0, n = n + Math.imul(L, ue) | 0, n = n + Math.imul(N, he) | 0, d = d + Math.imul(N, ue) | 0, l = l + Math.imul(B, le) | 0, n = n + Math.imul(B, de) | 0, n = n + Math.imul(I, le) | 0, d = d + Math.imul(I, de) | 0, l = l + Math.imul(g, ce) | 0, n = n + Math.imul(g, pe) | 0, n = n + Math.imul(_2, ce) | 0, d = d + Math.imul(_2, pe) | 0;
        var Ze = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, l = Math.imul(G, X), n = Math.imul(G, J2), n = n + Math.imul(Y, X) | 0, d = Math.imul(Y, J2), l = l + Math.imul(V, Q2) | 0, n = n + Math.imul(V, ee) | 0, n = n + Math.imul($2, Q2) | 0, d = d + Math.imul($2, ee) | 0, l = l + Math.imul(j, te) | 0, n = n + Math.imul(j, re) | 0, n = n + Math.imul(Z, te) | 0, d = d + Math.imul(Z, re) | 0, l = l + Math.imul(W, ie) | 0, n = n + Math.imul(W, ne) | 0, n = n + Math.imul(K, ie) | 0, d = d + Math.imul(K, ne) | 0, l = l + Math.imul(z2, fe) | 0, n = n + Math.imul(z2, ae) | 0, n = n + Math.imul(H, fe) | 0, d = d + Math.imul(H, ae) | 0, l = l + Math.imul(F, oe) | 0, n = n + Math.imul(F, se) | 0, n = n + Math.imul(U, oe) | 0, d = d + Math.imul(U, se) | 0, l = l + Math.imul(C, he) | 0, n = n + Math.imul(C, ue) | 0, n = n + Math.imul(O, he) | 0, d = d + Math.imul(O, ue) | 0, l = l + Math.imul(L, le) | 0, n = n + Math.imul(L, de) | 0, n = n + Math.imul(N, le) | 0, d = d + Math.imul(N, de) | 0, l = l + Math.imul(B, ce) | 0, n = n + Math.imul(B, pe) | 0, n = n + Math.imul(I, ce) | 0, d = d + Math.imul(I, pe) | 0, l = l + Math.imul(g, ve) | 0, n = n + Math.imul(g, be) | 0, n = n + Math.imul(_2, ve) | 0, d = d + Math.imul(_2, be) | 0;
        var Ve = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, l = Math.imul(G, Q2), n = Math.imul(G, ee), n = n + Math.imul(Y, Q2) | 0, d = Math.imul(Y, ee), l = l + Math.imul(V, te) | 0, n = n + Math.imul(V, re) | 0, n = n + Math.imul($2, te) | 0, d = d + Math.imul($2, re) | 0, l = l + Math.imul(j, ie) | 0, n = n + Math.imul(j, ne) | 0, n = n + Math.imul(Z, ie) | 0, d = d + Math.imul(Z, ne) | 0, l = l + Math.imul(W, fe) | 0, n = n + Math.imul(W, ae) | 0, n = n + Math.imul(K, fe) | 0, d = d + Math.imul(K, ae) | 0, l = l + Math.imul(z2, oe) | 0, n = n + Math.imul(z2, se) | 0, n = n + Math.imul(H, oe) | 0, d = d + Math.imul(H, se) | 0, l = l + Math.imul(F, he) | 0, n = n + Math.imul(F, ue) | 0, n = n + Math.imul(U, he) | 0, d = d + Math.imul(U, ue) | 0, l = l + Math.imul(C, le) | 0, n = n + Math.imul(C, de) | 0, n = n + Math.imul(O, le) | 0, d = d + Math.imul(O, de) | 0, l = l + Math.imul(L, ce) | 0, n = n + Math.imul(L, pe) | 0, n = n + Math.imul(N, ce) | 0, d = d + Math.imul(N, pe) | 0, l = l + Math.imul(B, ve) | 0, n = n + Math.imul(B, be) | 0, n = n + Math.imul(I, ve) | 0, d = d + Math.imul(I, be) | 0;
        var $e = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + ($e >>> 26) | 0, $e &= 67108863, l = Math.imul(G, te), n = Math.imul(G, re), n = n + Math.imul(Y, te) | 0, d = Math.imul(Y, re), l = l + Math.imul(V, ie) | 0, n = n + Math.imul(V, ne) | 0, n = n + Math.imul($2, ie) | 0, d = d + Math.imul($2, ne) | 0, l = l + Math.imul(j, fe) | 0, n = n + Math.imul(j, ae) | 0, n = n + Math.imul(Z, fe) | 0, d = d + Math.imul(Z, ae) | 0, l = l + Math.imul(W, oe) | 0, n = n + Math.imul(W, se) | 0, n = n + Math.imul(K, oe) | 0, d = d + Math.imul(K, se) | 0, l = l + Math.imul(z2, he) | 0, n = n + Math.imul(z2, ue) | 0, n = n + Math.imul(H, he) | 0, d = d + Math.imul(H, ue) | 0, l = l + Math.imul(F, le) | 0, n = n + Math.imul(F, de) | 0, n = n + Math.imul(U, le) | 0, d = d + Math.imul(U, de) | 0, l = l + Math.imul(C, ce) | 0, n = n + Math.imul(C, pe) | 0, n = n + Math.imul(O, ce) | 0, d = d + Math.imul(O, pe) | 0, l = l + Math.imul(L, ve) | 0, n = n + Math.imul(L, be) | 0, n = n + Math.imul(N, ve) | 0, d = d + Math.imul(N, be) | 0;
        var Ge = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, l = Math.imul(G, ie), n = Math.imul(G, ne), n = n + Math.imul(Y, ie) | 0, d = Math.imul(Y, ne), l = l + Math.imul(V, fe) | 0, n = n + Math.imul(V, ae) | 0, n = n + Math.imul($2, fe) | 0, d = d + Math.imul($2, ae) | 0, l = l + Math.imul(j, oe) | 0, n = n + Math.imul(j, se) | 0, n = n + Math.imul(Z, oe) | 0, d = d + Math.imul(Z, se) | 0, l = l + Math.imul(W, he) | 0, n = n + Math.imul(W, ue) | 0, n = n + Math.imul(K, he) | 0, d = d + Math.imul(K, ue) | 0, l = l + Math.imul(z2, le) | 0, n = n + Math.imul(z2, de) | 0, n = n + Math.imul(H, le) | 0, d = d + Math.imul(H, de) | 0, l = l + Math.imul(F, ce) | 0, n = n + Math.imul(F, pe) | 0, n = n + Math.imul(U, ce) | 0, d = d + Math.imul(U, pe) | 0, l = l + Math.imul(C, ve) | 0, n = n + Math.imul(C, be) | 0, n = n + Math.imul(O, ve) | 0, d = d + Math.imul(O, be) | 0;
        var Ye = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, l = Math.imul(G, fe), n = Math.imul(G, ae), n = n + Math.imul(Y, fe) | 0, d = Math.imul(Y, ae), l = l + Math.imul(V, oe) | 0, n = n + Math.imul(V, se) | 0, n = n + Math.imul($2, oe) | 0, d = d + Math.imul($2, se) | 0, l = l + Math.imul(j, he) | 0, n = n + Math.imul(j, ue) | 0, n = n + Math.imul(Z, he) | 0, d = d + Math.imul(Z, ue) | 0, l = l + Math.imul(W, le) | 0, n = n + Math.imul(W, de) | 0, n = n + Math.imul(K, le) | 0, d = d + Math.imul(K, de) | 0, l = l + Math.imul(z2, ce) | 0, n = n + Math.imul(z2, pe) | 0, n = n + Math.imul(H, ce) | 0, d = d + Math.imul(H, pe) | 0, l = l + Math.imul(F, ve) | 0, n = n + Math.imul(F, be) | 0, n = n + Math.imul(U, ve) | 0, d = d + Math.imul(U, be) | 0;
        var Xe = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, l = Math.imul(G, oe), n = Math.imul(G, se), n = n + Math.imul(Y, oe) | 0, d = Math.imul(Y, se), l = l + Math.imul(V, he) | 0, n = n + Math.imul(V, ue) | 0, n = n + Math.imul($2, he) | 0, d = d + Math.imul($2, ue) | 0, l = l + Math.imul(j, le) | 0, n = n + Math.imul(j, de) | 0, n = n + Math.imul(Z, le) | 0, d = d + Math.imul(Z, de) | 0, l = l + Math.imul(W, ce) | 0, n = n + Math.imul(W, pe) | 0, n = n + Math.imul(K, ce) | 0, d = d + Math.imul(K, pe) | 0, l = l + Math.imul(z2, ve) | 0, n = n + Math.imul(z2, be) | 0, n = n + Math.imul(H, ve) | 0, d = d + Math.imul(H, be) | 0;
        var Je = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, l = Math.imul(G, he), n = Math.imul(G, ue), n = n + Math.imul(Y, he) | 0, d = Math.imul(Y, ue), l = l + Math.imul(V, le) | 0, n = n + Math.imul(V, de) | 0, n = n + Math.imul($2, le) | 0, d = d + Math.imul($2, de) | 0, l = l + Math.imul(j, ce) | 0, n = n + Math.imul(j, pe) | 0, n = n + Math.imul(Z, ce) | 0, d = d + Math.imul(Z, pe) | 0, l = l + Math.imul(W, ve) | 0, n = n + Math.imul(W, be) | 0, n = n + Math.imul(K, ve) | 0, d = d + Math.imul(K, be) | 0;
        var Qe = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, l = Math.imul(G, le), n = Math.imul(G, de), n = n + Math.imul(Y, le) | 0, d = Math.imul(Y, de), l = l + Math.imul(V, ce) | 0, n = n + Math.imul(V, pe) | 0, n = n + Math.imul($2, ce) | 0, d = d + Math.imul($2, pe) | 0, l = l + Math.imul(j, ve) | 0, n = n + Math.imul(j, be) | 0, n = n + Math.imul(Z, ve) | 0, d = d + Math.imul(Z, be) | 0;
        var et = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, l = Math.imul(G, ce), n = Math.imul(G, pe), n = n + Math.imul(Y, ce) | 0, d = Math.imul(Y, pe), l = l + Math.imul(V, ve) | 0, n = n + Math.imul(V, be) | 0, n = n + Math.imul($2, ve) | 0, d = d + Math.imul($2, be) | 0;
        var tt = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, l = Math.imul(G, ve), n = Math.imul(G, be), n = n + Math.imul(Y, ve) | 0, d = Math.imul(Y, be);
        var rt = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        return b2 = (d + (n >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, c[0] = ft, c[1] = Be, c[2] = qe, c[3] = ze, c[4] = He, c[5] = We, c[6] = Ke, c[7] = je, c[8] = Ze, c[9] = Ve, c[10] = $e, c[11] = Ge, c[12] = Ye, c[13] = Xe, c[14] = Je, c[15] = Qe, c[16] = et, c[17] = tt, c[18] = rt, b2 !== 0 && (c[19] = b2, h.length++), h;
      };
      Math.imul || (T = q);
      function ye(v2, i, a) {
        a.negative = i.negative ^ v2.negative, a.length = v2.length + i.length;
        for (var h = 0, s = 0, u = 0;u < a.length - 1; u++) {
          var c = s;
          s = 0;
          for (var b2 = h & 67108863, l = Math.min(u, i.length - 1), n = Math.max(0, u - v2.length + 1);n <= l; n++) {
            var d = u - n, w = v2.words[d] | 0, g = i.words[n] | 0, _2 = w * g, A = _2 & 67108863;
            c = c + (_2 / 67108864 | 0) | 0, A = A + b2 | 0, b2 = A & 67108863, c = c + (A >>> 26) | 0, s += c >>> 26, c &= 67108863;
          }
          a.words[u] = b2, h = c, c = s;
        }
        return h !== 0 ? a.words[u] = h : a.length--, a.strip();
      }
      function _e(v2, i, a) {
        var h = new P;
        return h.mulp(v2, i, a);
      }
      f2.prototype.mulTo = function(i, a) {
        var h, s = this.length + i.length;
        return this.length === 10 && i.length === 10 ? h = T(this, i, a) : s < 63 ? h = q(this, i, a) : s < 1024 ? h = ye(this, i, a) : h = _e(this, i, a), h;
      };
      function P(v2, i) {
        this.x = v2, this.y = i;
      }
      P.prototype.makeRBT = function(i) {
        for (var a = new Array(i), h = f2.prototype._countBits(i) - 1, s = 0;s < i; s++)
          a[s] = this.revBin(s, h, i);
        return a;
      }, P.prototype.revBin = function(i, a, h) {
        if (i === 0 || i === h - 1)
          return i;
        for (var s = 0, u = 0;u < a; u++)
          s |= (i & 1) << a - u - 1, i >>= 1;
        return s;
      }, P.prototype.permute = function(i, a, h, s, u, c) {
        for (var b2 = 0;b2 < c; b2++)
          s[b2] = a[i[b2]], u[b2] = h[i[b2]];
      }, P.prototype.transform = function(i, a, h, s, u, c) {
        this.permute(c, i, a, h, s, u);
        for (var b2 = 1;b2 < u; b2 <<= 1)
          for (var l = b2 << 1, n = Math.cos(2 * Math.PI / l), d = Math.sin(2 * Math.PI / l), w = 0;w < u; w += l)
            for (var g = n, _2 = d, A = 0;A < b2; A++) {
              var B = h[w + A], I = s[w + A], we = h[w + A + b2], L = s[w + A + b2], N = g * we - _2 * L;
              L = g * L + _2 * we, we = N, h[w + A] = B + we, s[w + A] = I + L, h[w + A + b2] = B - we, s[w + A + b2] = I - L, A !== l && (N = n * g - d * _2, _2 = n * _2 + d * g, g = N);
            }
      }, P.prototype.guessLen13b = function(i, a) {
        var h = Math.max(a, i) | 1, s = h & 1, u = 0;
        for (h = h / 2 | 0;h; h = h >>> 1)
          u++;
        return 1 << u + 1 + s;
      }, P.prototype.conjugate = function(i, a, h) {
        if (!(h <= 1))
          for (var s = 0;s < h / 2; s++) {
            var u = i[s];
            i[s] = i[h - s - 1], i[h - s - 1] = u, u = a[s], a[s] = -a[h - s - 1], a[h - s - 1] = -u;
          }
      }, P.prototype.normalize13b = function(i, a) {
        for (var h = 0, s = 0;s < a / 2; s++) {
          var u = Math.round(i[2 * s + 1] / a) * 8192 + Math.round(i[2 * s] / a) + h;
          i[s] = u & 67108863, u < 67108864 ? h = 0 : h = u / 67108864 | 0;
        }
        return i;
      }, P.prototype.convert13b = function(i, a, h, s) {
        for (var u = 0, c = 0;c < a; c++)
          u = u + (i[c] | 0), h[2 * c] = u & 8191, u = u >>> 13, h[2 * c + 1] = u & 8191, u = u >>> 13;
        for (c = 2 * a;c < s; ++c)
          h[c] = 0;
        r(u === 0), r((u & -8192) === 0);
      }, P.prototype.stub = function(i) {
        for (var a = new Array(i), h = 0;h < i; h++)
          a[h] = 0;
        return a;
      }, P.prototype.mulp = function(i, a, h) {
        var s = 2 * this.guessLen13b(i.length, a.length), u = this.makeRBT(s), c = this.stub(s), b2 = new Array(s), l = new Array(s), n = new Array(s), d = new Array(s), w = new Array(s), g = new Array(s), _2 = h.words;
        _2.length = s, this.convert13b(i.words, i.length, b2, s), this.convert13b(a.words, a.length, d, s), this.transform(b2, c, l, n, s, u), this.transform(d, c, w, g, s, u);
        for (var A = 0;A < s; A++) {
          var B = l[A] * w[A] - n[A] * g[A];
          n[A] = l[A] * g[A] + n[A] * w[A], l[A] = B;
        }
        return this.conjugate(l, n, s), this.transform(l, n, _2, c, s, u), this.conjugate(_2, c, s), this.normalize13b(_2, s), h.negative = i.negative ^ a.negative, h.length = i.length + a.length, h.strip();
      }, f2.prototype.mul = function(i) {
        var a = new f2(null);
        return a.words = new Array(this.length + i.length), this.mulTo(i, a);
      }, f2.prototype.mulf = function(i) {
        var a = new f2(null);
        return a.words = new Array(this.length + i.length), _e(this, i, a);
      }, f2.prototype.imul = function(i) {
        return this.clone().mulTo(i, this);
      }, f2.prototype.imuln = function(i) {
        r(typeof i == "number"), r(i < 67108864);
        for (var a = 0, h = 0;h < this.length; h++) {
          var s = (this.words[h] | 0) * i, u = (s & 67108863) + (a & 67108863);
          a >>= 26, a += s / 67108864 | 0, a += u >>> 26, this.words[h] = u & 67108863;
        }
        return a !== 0 && (this.words[h] = a, this.length++), this;
      }, f2.prototype.muln = function(i) {
        return this.clone().imuln(i);
      }, f2.prototype.sqr = function() {
        return this.mul(this);
      }, f2.prototype.isqr = function() {
        return this.imul(this.clone());
      }, f2.prototype.pow = function(i) {
        var a = R(i);
        if (a.length === 0)
          return new f2(1);
        for (var h = this, s = 0;s < a.length && a[s] === 0; s++, h = h.sqr())
          ;
        if (++s < a.length)
          for (var u = h.sqr();s < a.length; s++, u = u.sqr())
            a[s] !== 0 && (h = h.mul(u));
        return h;
      }, f2.prototype.iushln = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 67108863 >>> 26 - a << 26 - a, u;
        if (a !== 0) {
          var c = 0;
          for (u = 0;u < this.length; u++) {
            var b2 = this.words[u] & s, l = (this.words[u] | 0) - b2 << a;
            this.words[u] = l | c, c = b2 >>> 26 - a;
          }
          c && (this.words[u] = c, this.length++);
        }
        if (h !== 0) {
          for (u = this.length - 1;u >= 0; u--)
            this.words[u + h] = this.words[u];
          for (u = 0;u < h; u++)
            this.words[u] = 0;
          this.length += h;
        }
        return this.strip();
      }, f2.prototype.ishln = function(i) {
        return r(this.negative === 0), this.iushln(i);
      }, f2.prototype.iushrn = function(i, a, h) {
        r(typeof i == "number" && i >= 0);
        var s;
        a ? s = (a - a % 26) / 26 : s = 0;
        var u = i % 26, c = Math.min((i - u) / 26, this.length), b2 = 67108863 ^ 67108863 >>> u << u, l = h;
        if (s -= c, s = Math.max(0, s), l) {
          for (var n = 0;n < c; n++)
            l.words[n] = this.words[n];
          l.length = c;
        }
        if (c !== 0)
          if (this.length > c)
            for (this.length -= c, n = 0;n < this.length; n++)
              this.words[n] = this.words[n + c];
          else
            this.words[0] = 0, this.length = 1;
        var d = 0;
        for (n = this.length - 1;n >= 0 && (d !== 0 || n >= s); n--) {
          var w = this.words[n] | 0;
          this.words[n] = d << 26 - u | w >>> u, d = w & b2;
        }
        return l && d !== 0 && (l.words[l.length++] = d), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, f2.prototype.ishrn = function(i, a, h) {
        return r(this.negative === 0), this.iushrn(i, a, h);
      }, f2.prototype.shln = function(i) {
        return this.clone().ishln(i);
      }, f2.prototype.ushln = function(i) {
        return this.clone().iushln(i);
      }, f2.prototype.shrn = function(i) {
        return this.clone().ishrn(i);
      }, f2.prototype.ushrn = function(i) {
        return this.clone().iushrn(i);
      }, f2.prototype.testn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return false;
        var u = this.words[h];
        return !!(u & s);
      }, f2.prototype.imaskn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= h)
          return this;
        if (a !== 0 && h++, this.length = Math.min(h, this.length), a !== 0) {
          var s = 67108863 ^ 67108863 >>> a << a;
          this.words[this.length - 1] &= s;
        }
        return this.strip();
      }, f2.prototype.maskn = function(i) {
        return this.clone().imaskn(i);
      }, f2.prototype.iaddn = function(i) {
        return r(typeof i == "number"), r(i < 67108864), i < 0 ? this.isubn(-i) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < i ? (this.words[0] = i - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(i), this.negative = 1, this) : this._iaddn(i);
      }, f2.prototype._iaddn = function(i) {
        this.words[0] += i;
        for (var a = 0;a < this.length && this.words[a] >= 67108864; a++)
          this.words[a] -= 67108864, a === this.length - 1 ? this.words[a + 1] = 1 : this.words[a + 1]++;
        return this.length = Math.max(this.length, a + 1), this;
      }, f2.prototype.isubn = function(i) {
        if (r(typeof i == "number"), r(i < 67108864), i < 0)
          return this.iaddn(-i);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(i), this.negative = 1, this;
        if (this.words[0] -= i, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var a = 0;a < this.length && this.words[a] < 0; a++)
            this.words[a] += 67108864, this.words[a + 1] -= 1;
        return this.strip();
      }, f2.prototype.addn = function(i) {
        return this.clone().iaddn(i);
      }, f2.prototype.subn = function(i) {
        return this.clone().isubn(i);
      }, f2.prototype.iabs = function() {
        return this.negative = 0, this;
      }, f2.prototype.abs = function() {
        return this.clone().iabs();
      }, f2.prototype._ishlnsubmul = function(i, a, h) {
        var s = i.length + h, u;
        this._expand(s);
        var c, b2 = 0;
        for (u = 0;u < i.length; u++) {
          c = (this.words[u + h] | 0) + b2;
          var l = (i.words[u] | 0) * a;
          c -= l & 67108863, b2 = (c >> 26) - (l / 67108864 | 0), this.words[u + h] = c & 67108863;
        }
        for (;u < this.length - h; u++)
          c = (this.words[u + h] | 0) + b2, b2 = c >> 26, this.words[u + h] = c & 67108863;
        if (b2 === 0)
          return this.strip();
        for (r(b2 === -1), b2 = 0, u = 0;u < this.length; u++)
          c = -(this.words[u] | 0) + b2, b2 = c >> 26, this.words[u] = c & 67108863;
        return this.negative = 1, this.strip();
      }, f2.prototype._wordDiv = function(i, a) {
        var h = this.length - i.length, s = this.clone(), u = i, c = u.words[u.length - 1] | 0, b2 = this._countBits(c);
        h = 26 - b2, h !== 0 && (u = u.ushln(h), s.iushln(h), c = u.words[u.length - 1] | 0);
        var l = s.length - u.length, n;
        if (a !== "mod") {
          n = new f2(null), n.length = l + 1, n.words = new Array(n.length);
          for (var d = 0;d < n.length; d++)
            n.words[d] = 0;
        }
        var w = s.clone()._ishlnsubmul(u, 1, l);
        w.negative === 0 && (s = w, n && (n.words[l] = 1));
        for (var g = l - 1;g >= 0; g--) {
          var _2 = (s.words[u.length + g] | 0) * 67108864 + (s.words[u.length + g - 1] | 0);
          for (_2 = Math.min(_2 / c | 0, 67108863), s._ishlnsubmul(u, _2, g);s.negative !== 0; )
            _2--, s.negative = 0, s._ishlnsubmul(u, 1, g), s.isZero() || (s.negative ^= 1);
          n && (n.words[g] = _2);
        }
        return n && n.strip(), s.strip(), a !== "div" && h !== 0 && s.iushrn(h), { div: n || null, mod: s };
      }, f2.prototype.divmod = function(i, a, h) {
        if (r(!i.isZero()), this.isZero())
          return { div: new f2(0), mod: new f2(0) };
        var s, u, c;
        return this.negative !== 0 && i.negative === 0 ? (c = this.neg().divmod(i, a), a !== "mod" && (s = c.div.neg()), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.iadd(i)), { div: s, mod: u }) : this.negative === 0 && i.negative !== 0 ? (c = this.divmod(i.neg(), a), a !== "mod" && (s = c.div.neg()), { div: s, mod: c.mod }) : (this.negative & i.negative) !== 0 ? (c = this.neg().divmod(i.neg(), a), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.isub(i)), { div: c.div, mod: u }) : i.length > this.length || this.cmp(i) < 0 ? { div: new f2(0), mod: this } : i.length === 1 ? a === "div" ? { div: this.divn(i.words[0]), mod: null } : a === "mod" ? { div: null, mod: new f2(this.modn(i.words[0])) } : { div: this.divn(i.words[0]), mod: new f2(this.modn(i.words[0])) } : this._wordDiv(i, a);
      }, f2.prototype.div = function(i) {
        return this.divmod(i, "div", false).div;
      }, f2.prototype.mod = function(i) {
        return this.divmod(i, "mod", false).mod;
      }, f2.prototype.umod = function(i) {
        return this.divmod(i, "mod", true).mod;
      }, f2.prototype.divRound = function(i) {
        var a = this.divmod(i);
        if (a.mod.isZero())
          return a.div;
        var h = a.div.negative !== 0 ? a.mod.isub(i) : a.mod, s = i.ushrn(1), u = i.andln(1), c = h.cmp(s);
        return c < 0 || u === 1 && c === 0 ? a.div : a.div.negative !== 0 ? a.div.isubn(1) : a.div.iaddn(1);
      }, f2.prototype.modn = function(i) {
        r(i <= 67108863);
        for (var a = (1 << 26) % i, h = 0, s = this.length - 1;s >= 0; s--)
          h = (a * h + (this.words[s] | 0)) % i;
        return h;
      }, f2.prototype.idivn = function(i) {
        r(i <= 67108863);
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = (this.words[h] | 0) + a * 67108864;
          this.words[h] = s / i | 0, a = s % i;
        }
        return this.strip();
      }, f2.prototype.divn = function(i) {
        return this.clone().idivn(i);
      }, f2.prototype.egcd = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f2(1), u = new f2(0), c = new f2(0), b2 = new f2(1), l = 0;a.isEven() && h.isEven(); )
          a.iushrn(1), h.iushrn(1), ++l;
        for (var n = h.clone(), d = a.clone();!a.isZero(); ) {
          for (var w = 0, g = 1;(a.words[0] & g) === 0 && w < 26; ++w, g <<= 1)
            ;
          if (w > 0)
            for (a.iushrn(w);w-- > 0; )
              (s.isOdd() || u.isOdd()) && (s.iadd(n), u.isub(d)), s.iushrn(1), u.iushrn(1);
          for (var _2 = 0, A = 1;(h.words[0] & A) === 0 && _2 < 26; ++_2, A <<= 1)
            ;
          if (_2 > 0)
            for (h.iushrn(_2);_2-- > 0; )
              (c.isOdd() || b2.isOdd()) && (c.iadd(n), b2.isub(d)), c.iushrn(1), b2.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(c), u.isub(b2)) : (h.isub(a), c.isub(s), b2.isub(u));
        }
        return { a: c, b: b2, gcd: h.iushln(l) };
      }, f2.prototype._invmp = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f2(1), u = new f2(0), c = h.clone();a.cmpn(1) > 0 && h.cmpn(1) > 0; ) {
          for (var b2 = 0, l = 1;(a.words[0] & l) === 0 && b2 < 26; ++b2, l <<= 1)
            ;
          if (b2 > 0)
            for (a.iushrn(b2);b2-- > 0; )
              s.isOdd() && s.iadd(c), s.iushrn(1);
          for (var n = 0, d = 1;(h.words[0] & d) === 0 && n < 26; ++n, d <<= 1)
            ;
          if (n > 0)
            for (h.iushrn(n);n-- > 0; )
              u.isOdd() && u.iadd(c), u.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(u)) : (h.isub(a), u.isub(s));
        }
        var w;
        return a.cmpn(1) === 0 ? w = s : w = u, w.cmpn(0) < 0 && w.iadd(i), w;
      }, f2.prototype.gcd = function(i) {
        if (this.isZero())
          return i.abs();
        if (i.isZero())
          return this.abs();
        var a = this.clone(), h = i.clone();
        a.negative = 0, h.negative = 0;
        for (var s = 0;a.isEven() && h.isEven(); s++)
          a.iushrn(1), h.iushrn(1);
        do {
          for (;a.isEven(); )
            a.iushrn(1);
          for (;h.isEven(); )
            h.iushrn(1);
          var u = a.cmp(h);
          if (u < 0) {
            var c = a;
            a = h, h = c;
          } else if (u === 0 || h.cmpn(1) === 0)
            break;
          a.isub(h);
        } while (true);
        return h.iushln(s);
      }, f2.prototype.invm = function(i) {
        return this.egcd(i).a.umod(i);
      }, f2.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, f2.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, f2.prototype.andln = function(i) {
        return this.words[0] & i;
      }, f2.prototype.bincn = function(i) {
        r(typeof i == "number");
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return this._expand(h + 1), this.words[h] |= s, this;
        for (var u = s, c = h;u !== 0 && c < this.length; c++) {
          var b2 = this.words[c] | 0;
          b2 += u, u = b2 >>> 26, b2 &= 67108863, this.words[c] = b2;
        }
        return u !== 0 && (this.words[c] = u, this.length++), this;
      }, f2.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, f2.prototype.cmpn = function(i) {
        var a = i < 0;
        if (this.negative !== 0 && !a)
          return -1;
        if (this.negative === 0 && a)
          return 1;
        this.strip();
        var h;
        if (this.length > 1)
          h = 1;
        else {
          a && (i = -i), r(i <= 67108863, "Number is too big");
          var s = this.words[0] | 0;
          h = s === i ? 0 : s < i ? -1 : 1;
        }
        return this.negative !== 0 ? -h | 0 : h;
      }, f2.prototype.cmp = function(i) {
        if (this.negative !== 0 && i.negative === 0)
          return -1;
        if (this.negative === 0 && i.negative !== 0)
          return 1;
        var a = this.ucmp(i);
        return this.negative !== 0 ? -a | 0 : a;
      }, f2.prototype.ucmp = function(i) {
        if (this.length > i.length)
          return 1;
        if (this.length < i.length)
          return -1;
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = this.words[h] | 0, u = i.words[h] | 0;
          if (s !== u) {
            s < u ? a = -1 : s > u && (a = 1);
            break;
          }
        }
        return a;
      }, f2.prototype.gtn = function(i) {
        return this.cmpn(i) === 1;
      }, f2.prototype.gt = function(i) {
        return this.cmp(i) === 1;
      }, f2.prototype.gten = function(i) {
        return this.cmpn(i) >= 0;
      }, f2.prototype.gte = function(i) {
        return this.cmp(i) >= 0;
      }, f2.prototype.ltn = function(i) {
        return this.cmpn(i) === -1;
      }, f2.prototype.lt = function(i) {
        return this.cmp(i) === -1;
      }, f2.prototype.lten = function(i) {
        return this.cmpn(i) <= 0;
      }, f2.prototype.lte = function(i) {
        return this.cmp(i) <= 0;
      }, f2.prototype.eqn = function(i) {
        return this.cmpn(i) === 0;
      }, f2.prototype.eq = function(i) {
        return this.cmp(i) === 0;
      }, f2.red = function(i) {
        return new D2(i);
      }, f2.prototype.toRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), i.convertTo(this)._forceRed(i);
      }, f2.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, f2.prototype._forceRed = function(i) {
        return this.red = i, this;
      }, f2.prototype.forceRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(i);
      }, f2.prototype.redAdd = function(i) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, i);
      }, f2.prototype.redIAdd = function(i) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, i);
      }, f2.prototype.redSub = function(i) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, i);
      }, f2.prototype.redISub = function(i) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, i);
      }, f2.prototype.redShl = function(i) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, i);
      }, f2.prototype.redMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.mul(this, i);
      }, f2.prototype.redIMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.imul(this, i);
      }, f2.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, f2.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, f2.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, f2.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, f2.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, f2.prototype.redPow = function(i) {
        return r(this.red && !i.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, i);
      };
      var Me = { k256: null, p224: null, p192: null, p25519: null };
      function me(v2, i) {
        this.name = v2, this.p = new f2(i, 16), this.n = this.p.bitLength(), this.k = new f2(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      me.prototype._tmp = function() {
        var i = new f2(null);
        return i.words = new Array(Math.ceil(this.n / 13)), i;
      }, me.prototype.ireduce = function(i) {
        var a = i, h;
        do
          this.split(a, this.tmp), a = this.imulK(a), a = a.iadd(this.tmp), h = a.bitLength();
        while (h > this.n);
        var s = h < this.n ? -1 : a.ucmp(this.p);
        return s === 0 ? (a.words[0] = 0, a.length = 1) : s > 0 ? a.isub(this.p) : a.strip !== undefined ? a.strip() : a._strip(), a;
      }, me.prototype.split = function(i, a) {
        i.iushrn(this.n, 0, a);
      }, me.prototype.imulK = function(i) {
        return i.imul(this.k);
      };
      function xe() {
        me.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      o(xe, me), xe.prototype.split = function(i, a) {
        for (var h = 4194303, s = Math.min(i.length, 9), u = 0;u < s; u++)
          a.words[u] = i.words[u];
        if (a.length = s, i.length <= 9) {
          i.words[0] = 0, i.length = 1;
          return;
        }
        var c = i.words[9];
        for (a.words[a.length++] = c & h, u = 10;u < i.length; u++) {
          var b2 = i.words[u] | 0;
          i.words[u - 10] = (b2 & h) << 4 | c >>> 22, c = b2;
        }
        c >>>= 22, i.words[u - 10] = c, c === 0 && i.length > 10 ? i.length -= 10 : i.length -= 9;
      }, xe.prototype.imulK = function(i) {
        i.words[i.length] = 0, i.words[i.length + 1] = 0, i.length += 2;
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = i.words[h] | 0;
          a += s * 977, i.words[h] = a & 67108863, a = s * 64 + (a / 67108864 | 0);
        }
        return i.words[i.length - 1] === 0 && (i.length--, i.words[i.length - 1] === 0 && i.length--), i;
      };
      function Ae() {
        me.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      o(Ae, me);
      function Ee() {
        me.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      o(Ee, me);
      function Re() {
        me.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      o(Re, me), Re.prototype.imulK = function(i) {
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = (i.words[h] | 0) * 19 + a, u = s & 67108863;
          s >>>= 26, i.words[h] = u, a = s;
        }
        return a !== 0 && (i.words[i.length++] = a), i;
      }, f2._prime = function(i) {
        if (Me[i])
          return Me[i];
        var a;
        if (i === "k256")
          a = new xe;
        else if (i === "p224")
          a = new Ae;
        else if (i === "p192")
          a = new Ee;
        else if (i === "p25519")
          a = new Re;
        else
          throw new Error("Unknown prime " + i);
        return Me[i] = a, a;
      };
      function D2(v2) {
        if (typeof v2 == "string") {
          var i = f2._prime(v2);
          this.m = i.p, this.prime = i;
        } else
          r(v2.gtn(1), "modulus must be greater than 1"), this.m = v2, this.prime = null;
      }
      D2.prototype._verify1 = function(i) {
        r(i.negative === 0, "red works only with positives"), r(i.red, "red works only with red numbers");
      }, D2.prototype._verify2 = function(i, a) {
        r((i.negative | a.negative) === 0, "red works only with positives"), r(i.red && i.red === a.red, "red works only with red numbers");
      }, D2.prototype.imod = function(i) {
        return this.prime ? this.prime.ireduce(i)._forceRed(this) : i.umod(this.m)._forceRed(this);
      }, D2.prototype.neg = function(i) {
        return i.isZero() ? i.clone() : this.m.sub(i)._forceRed(this);
      }, D2.prototype.add = function(i, a) {
        this._verify2(i, a);
        var h = i.add(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h._forceRed(this);
      }, D2.prototype.iadd = function(i, a) {
        this._verify2(i, a);
        var h = i.iadd(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h;
      }, D2.prototype.sub = function(i, a) {
        this._verify2(i, a);
        var h = i.sub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h._forceRed(this);
      }, D2.prototype.isub = function(i, a) {
        this._verify2(i, a);
        var h = i.isub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h;
      }, D2.prototype.shl = function(i, a) {
        return this._verify1(i), this.imod(i.ushln(a));
      }, D2.prototype.imul = function(i, a) {
        return this._verify2(i, a), this.imod(i.imul(a));
      }, D2.prototype.mul = function(i, a) {
        return this._verify2(i, a), this.imod(i.mul(a));
      }, D2.prototype.isqr = function(i) {
        return this.imul(i, i.clone());
      }, D2.prototype.sqr = function(i) {
        return this.mul(i, i);
      }, D2.prototype.sqrt = function(i) {
        if (i.isZero())
          return i.clone();
        var a = this.m.andln(3);
        if (r(a % 2 === 1), a === 3) {
          var h = this.m.add(new f2(1)).iushrn(2);
          return this.pow(i, h);
        }
        for (var s = this.m.subn(1), u = 0;!s.isZero() && s.andln(1) === 0; )
          u++, s.iushrn(1);
        r(!s.isZero());
        var c = new f2(1).toRed(this), b2 = c.redNeg(), l = this.m.subn(1).iushrn(1), n = this.m.bitLength();
        for (n = new f2(2 * n * n).toRed(this);this.pow(n, l).cmp(b2) !== 0; )
          n.redIAdd(b2);
        for (var d = this.pow(n, s), w = this.pow(i, s.addn(1).iushrn(1)), g = this.pow(i, s), _2 = u;g.cmp(c) !== 0; ) {
          for (var A = g, B = 0;A.cmp(c) !== 0; B++)
            A = A.redSqr();
          r(B < _2);
          var I = this.pow(d, new f2(1).iushln(_2 - B - 1));
          w = w.redMul(I), d = I.redSqr(), g = g.redMul(d), _2 = B;
        }
        return w;
      }, D2.prototype.invm = function(i) {
        var a = i._invmp(this.m);
        return a.negative !== 0 ? (a.negative = 0, this.imod(a).redNeg()) : this.imod(a);
      }, D2.prototype.pow = function(i, a) {
        if (a.isZero())
          return new f2(1).toRed(this);
        if (a.cmpn(1) === 0)
          return i.clone();
        var h = 4, s = new Array(1 << h);
        s[0] = new f2(1).toRed(this), s[1] = i;
        for (var u = 2;u < s.length; u++)
          s[u] = this.mul(s[u - 1], i);
        var c = s[0], b2 = 0, l = 0, n = a.bitLength() % 26;
        for (n === 0 && (n = 26), u = a.length - 1;u >= 0; u--) {
          for (var d = a.words[u], w = n - 1;w >= 0; w--) {
            var g = d >> w & 1;
            if (c !== s[0] && (c = this.sqr(c)), g === 0 && b2 === 0) {
              l = 0;
              continue;
            }
            b2 <<= 1, b2 |= g, l++, !(l !== h && (u !== 0 || w !== 0)) && (c = this.mul(c, s[b2]), l = 0, b2 = 0);
          }
          n = 26;
        }
        return c;
      }, D2.prototype.convertTo = function(i) {
        var a = i.umod(this.m);
        return a === i ? a.clone() : a;
      }, D2.prototype.convertFrom = function(i) {
        var a = i.clone();
        return a.red = null, a;
      }, f2.mont = function(i) {
        return new Se(i);
      };
      function Se(v2) {
        D2.call(this, v2), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f2(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o(Se, D2), Se.prototype.convertTo = function(i) {
        return this.imod(i.ushln(this.shift));
      }, Se.prototype.convertFrom = function(i) {
        var a = this.imod(i.mul(this.rinv));
        return a.red = null, a;
      }, Se.prototype.imul = function(i, a) {
        if (i.isZero() || a.isZero())
          return i.words[0] = 0, i.length = 1, i;
        var h = i.imul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se.prototype.mul = function(i, a) {
        if (i.isZero() || a.isZero())
          return new f2(0)._forceRed(this);
        var h = i.mul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se.prototype.invm = function(i) {
        var a = this.imod(i._invmp(this.m).mul(this.r2));
        return a._forceRed(this);
      };
    })(typeof pl > "u" || pl, wg);
  });
  _g = k(() => {
  });
  Ts = k((Uk, ml) => {
    var vl;
    ml.exports = function(e) {
      return vl || (vl = new $i(null)), vl.generate(e);
    };
    function $i(t) {
      this.rand = t;
    }
    ml.exports.Rand = $i;
    $i.prototype.generate = function(e) {
      return this._rand(e);
    };
    $i.prototype._rand = function(e) {
      if (this.rand.getBytes)
        return this.rand.getBytes(e);
      for (var r = new Uint8Array(e), o = 0;o < r.length; o++)
        r[o] = this.rand.getByte();
      return r;
    };
    if (typeof self == "object")
      self.crypto && self.crypto.getRandomValues ? $i.prototype._rand = function(e) {
        var r = new Uint8Array(e);
        return self.crypto.getRandomValues(r), r;
      } : self.msCrypto && self.msCrypto.getRandomValues ? $i.prototype._rand = function(e) {
        var r = new Uint8Array(e);
        return self.msCrypto.getRandomValues(r), r;
      } : typeof window == "object" && ($i.prototype._rand = function() {
        throw new Error("Not implemented yet");
      });
    else
      try {
        if (bl = _g(), typeof bl.randomBytes != "function")
          throw new Error("Not supported");
        $i.prototype._rand = function(e) {
          return bl.randomBytes(e);
        };
      } catch {
      }
    var bl;
  });
  gl = k((zk, xg) => {
    var Pn = Mg(), WS = Ts();
    function Dn(t) {
      this.rand = t || new WS.Rand;
    }
    xg.exports = Dn;
    Dn.create = function(e) {
      return new Dn(e);
    };
    Dn.prototype._randbelow = function(e) {
      var r = e.bitLength(), o = Math.ceil(r / 8);
      do
        var f2 = new Pn(this.rand.generate(o));
      while (f2.cmp(e) >= 0);
      return f2;
    };
    Dn.prototype._randrange = function(e, r) {
      var o = r.sub(e);
      return e.add(this._randbelow(o));
    };
    Dn.prototype.test = function(e, r, o) {
      var f2 = e.bitLength(), p = Pn.mont(e), m = new Pn(1).toRed(p);
      r || (r = Math.max(1, f2 / 48 | 0));
      for (var y = e.subn(1), M = 0;!y.testn(M); M++)
        ;
      for (var x = e.shrn(M), S2 = y.toRed(p), E = true;r > 0; r--) {
        var R = this._randrange(new Pn(2), y);
        o && o(R);
        var q = R.toRed(p).redPow(x);
        if (!(q.cmp(m) === 0 || q.cmp(S2) === 0)) {
          for (var T = 1;T < M; T++) {
            if (q = q.redSqr(), q.cmp(m) === 0)
              return false;
            if (q.cmp(S2) === 0)
              break;
          }
          if (T === M)
            return false;
        }
      }
      return E;
    };
    Dn.prototype.getDivisor = function(e, r) {
      var o = e.bitLength(), f2 = Pn.mont(e), p = new Pn(1).toRed(f2);
      r || (r = Math.max(1, o / 48 | 0));
      for (var m = e.subn(1), y = 0;!m.testn(y); y++)
        ;
      for (var M = e.shrn(y), x = m.toRed(f2);r > 0; r--) {
        var S2 = this._randrange(new Pn(2), m), E = e.gcd(S2);
        if (E.cmpn(1) !== 0)
          return E;
        var R = S2.toRed(f2).redPow(M);
        if (!(R.cmp(p) === 0 || R.cmp(x) === 0)) {
          for (var q = 1;q < y; q++) {
            if (R = R.redSqr(), R.cmp(p) === 0)
              return R.fromRed().subn(1).gcd(e);
            if (R.cmp(x) === 0)
              break;
          }
          if (q === y)
            return R = R.redSqr(), R.fromRed().subn(1).gcd(e);
        }
      }
      return false;
    };
  });
  Sl = k((Zk, Ag) => {
    var KS = hn();
    Ag.exports = xl;
    xl.simpleSieve = Ml;
    xl.fermatTest = _l;
    var Ht = cl(), jS = new Ht(24), ZS = gl(), Sg = new ZS, VS = new Ht(1), wl = new Ht(2), $S = new Ht(5), Hk = new Ht(16), Wk = new Ht(8), GS = new Ht(10), YS = new Ht(3), Kk = new Ht(7), XS = new Ht(11), Eg = new Ht(4), jk = new Ht(12), yl = null;
    function JS() {
      if (yl !== null)
        return yl;
      var t = 1048576, e = [];
      e[0] = 2;
      for (var r = 1, o = 3;o < t; o += 2) {
        for (var f2 = Math.ceil(Math.sqrt(o)), p = 0;p < r && e[p] <= f2 && o % e[p] !== 0; p++)
          ;
        r !== p && e[p] <= f2 || (e[r++] = o);
      }
      return yl = e, e;
    }
    function Ml(t) {
      for (var e = JS(), r = 0;r < e.length; r++)
        if (t.modn(e[r]) === 0)
          return t.cmpn(e[r]) === 0;
      return true;
    }
    function _l(t) {
      var e = Ht.mont(t);
      return wl.toRed(e).redPow(t.subn(1)).fromRed().cmpn(1) === 0;
    }
    function xl(t, e) {
      if (t < 16)
        return e === 2 || e === 5 ? new Ht([140, 123]) : new Ht([140, 39]);
      e = new Ht(e);
      for (var r, o;; ) {
        for (r = new Ht(KS(Math.ceil(t / 8)));r.bitLength() > t; )
          r.ishrn(1);
        if (r.isEven() && r.iadd(VS), r.testn(1) || r.iadd(wl), e.cmp(wl)) {
          if (!e.cmp($S))
            for (;r.mod(GS).cmp(YS); )
              r.iadd(Eg);
        } else
          for (;r.mod(jS).cmp(XS); )
            r.iadd(Eg);
        if (o = r.shrn(1), Ml(o) && Ml(r) && _l(o) && _l(r) && Sg.test(o) && Sg.test(r))
          return r;
      }
    }
  });
  Rg = k((Vk, QS) => {
    QS.exports = { modp1: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff" }, modp2: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff" }, modp5: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff" }, modp14: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff" }, modp15: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff" }, modp16: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff" }, modp17: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff" }, modp18: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff" } };
  });
  Tg = k(($k, Ig) => {
    var wr = cl(), eE = gl(), Bg = new eE, tE = new wr(24), rE = new wr(11), iE = new wr(10), nE = new wr(3), fE = new wr(7), qg = Sl(), aE = hn();
    Ig.exports = Bi;
    function oE(t, e) {
      return e = e || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e)), this._pub = new wr(t), this;
    }
    function sE(t, e) {
      return e = e || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e)), this._priv = new wr(t), this;
    }
    var ks = {};
    function hE(t, e) {
      var r = e.toString("hex"), o = [r, t.toString(16)].join("_");
      if (o in ks)
        return ks[o];
      var f2 = 0;
      if (t.isEven() || !qg.simpleSieve || !qg.fermatTest(t) || !Bg.test(t))
        return f2 += 1, r === "02" || r === "05" ? f2 += 8 : f2 += 4, ks[o] = f2, f2;
      Bg.test(t.shrn(1)) || (f2 += 2);
      var p;
      switch (r) {
        case "02":
          t.mod(tE).cmp(rE) && (f2 += 8);
          break;
        case "05":
          p = t.mod(iE), p.cmp(nE) && p.cmp(fE) && (f2 += 8);
          break;
        default:
          f2 += 4;
      }
      return ks[o] = f2, f2;
    }
    function Bi(t, e, r) {
      this.setGenerator(e), this.__prime = new wr(t), this._prime = wr.mont(this.__prime), this._primeLen = t.length, this._pub = undefined, this._priv = undefined, this._primeCode = undefined, r ? (this.setPublicKey = oE, this.setPrivateKey = sE) : this._primeCode = 8;
    }
    Object.defineProperty(Bi.prototype, "verifyError", { enumerable: true, get: function() {
      return typeof this._primeCode != "number" && (this._primeCode = hE(this.__prime, this.__gen)), this._primeCode;
    } });
    Bi.prototype.generateKeys = function() {
      return this._priv || (this._priv = new wr(aE(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
    };
    Bi.prototype.computeSecret = function(t) {
      t = new wr(t), t = t.toRed(this._prime);
      var e = t.redPow(this._priv).fromRed(), r = new Buffer(e.toArray()), o = this.getPrime();
      if (r.length < o.length) {
        var f2 = new Buffer(o.length - r.length);
        f2.fill(0), r = Buffer.concat([f2, r]);
      }
      return r;
    };
    Bi.prototype.getPublicKey = function(e) {
      return Ls(this._pub, e);
    };
    Bi.prototype.getPrivateKey = function(e) {
      return Ls(this._priv, e);
    };
    Bi.prototype.getPrime = function(t) {
      return Ls(this.__prime, t);
    };
    Bi.prototype.getGenerator = function(t) {
      return Ls(this._gen, t);
    };
    Bi.prototype.setGenerator = function(t, e) {
      return e = e || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e)), this.__gen = t, this._gen = new wr(t), this;
    };
    function Ls(t, e) {
      var r = new Buffer(t.toArray());
      return e ? r.toString(e) : r;
    }
  });
  Ng = k((Ef) => {
    var uE = Sl(), kg = Rg(), El = Tg();
    function lE(t) {
      var e = new Buffer(kg[t].prime, "hex"), r = new Buffer(kg[t].gen, "hex");
      return new El(e, r);
    }
    var dE = { binary: true, hex: true, base64: true };
    function Lg(t, e, r, o) {
      return Buffer.isBuffer(e) || dE[e] === undefined ? Lg(t, "binary", e, r) : (e = e || "binary", o = o || "binary", r = r || new Buffer([2]), Buffer.isBuffer(r) || (r = new Buffer(r, o)), typeof t == "number" ? new El(uE(t, r), r, true) : (Buffer.isBuffer(t) || (t = new Buffer(t, e)), new El(t, r, true)));
    }
    Ef.DiffieHellmanGroup = Ef.createDiffieHellmanGroup = Ef.getDiffieHellman = lE;
    Ef.createDiffieHellman = Ef.DiffieHellman = Lg;
  });
  Al = k((Yk, Pg) => {
    Pg.exports = Di().EventEmitter;
  });
  zg = k((Xk, Ug) => {
    function Dg(t, e) {
      var r = Object.keys(t);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(t);
        e && (o = o.filter(function(f2) {
          return Object.getOwnPropertyDescriptor(t, f2).enumerable;
        })), r.push.apply(r, o);
      }
      return r;
    }
    function Cg(t) {
      for (var e = 1;e < arguments.length; e++) {
        var r = arguments[e] != null ? arguments[e] : {};
        e % 2 ? Dg(Object(r), true).forEach(function(o) {
          cE(t, o, r[o]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : Dg(Object(r)).forEach(function(o) {
          Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(r, o));
        });
      }
      return t;
    }
    function cE(t, e, r) {
      return e = Fg(e), (e in t) ? Object.defineProperty(t, e, { value: r, enumerable: true, configurable: true, writable: true }) : t[e] = r, t;
    }
    function pE(t, e) {
      if (!(t instanceof e))
        throw new TypeError("Cannot call a class as a function");
    }
    function Og(t, e) {
      for (var r = 0;r < e.length; r++) {
        var o = e[r];
        o.enumerable = o.enumerable || false, o.configurable = true, ("value" in o) && (o.writable = true), Object.defineProperty(t, Fg(o.key), o);
      }
    }
    function vE(t, e, r) {
      return e && Og(t.prototype, e), r && Og(t, r), Object.defineProperty(t, "prototype", { writable: false }), t;
    }
    function Fg(t) {
      var e = bE(t, "string");
      return typeof e == "symbol" ? e : String(e);
    }
    function bE(t, e) {
      if (typeof t != "object" || t === null)
        return t;
      var r = t[Symbol.toPrimitive];
      if (r !== undefined) {
        var o = r.call(t, e || "default");
        if (typeof o != "object")
          return o;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (e === "string" ? String : Number)(t);
    }
    var mE = Ut(), Ns = mE.Buffer, gE = Xf(), Rl = gE.inspect, yE = Rl && Rl.custom || "inspect";
    function wE(t, e, r) {
      Ns.prototype.copy.call(t, e, r);
    }
    Ug.exports = function() {
      function t() {
        pE(this, t), this.head = null, this.tail = null, this.length = 0;
      }
      return vE(t, [{ key: "push", value: function(r) {
        var o = { data: r, next: null };
        this.length > 0 ? this.tail.next = o : this.head = o, this.tail = o, ++this.length;
      } }, { key: "unshift", value: function(r) {
        var o = { data: r, next: this.head };
        this.length === 0 && (this.tail = o), this.head = o, ++this.length;
      } }, { key: "shift", value: function() {
        if (this.length !== 0) {
          var r = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, r;
        }
      } }, { key: "clear", value: function() {
        this.head = this.tail = null, this.length = 0;
      } }, { key: "join", value: function(r) {
        if (this.length === 0)
          return "";
        for (var o = this.head, f2 = "" + o.data;o = o.next; )
          f2 += r + o.data;
        return f2;
      } }, { key: "concat", value: function(r) {
        if (this.length === 0)
          return Ns.alloc(0);
        for (var o = Ns.allocUnsafe(r >>> 0), f2 = this.head, p = 0;f2; )
          wE(f2.data, o, p), p += f2.data.length, f2 = f2.next;
        return o;
      } }, { key: "consume", value: function(r, o) {
        var f2;
        return r < this.head.data.length ? (f2 = this.head.data.slice(0, r), this.head.data = this.head.data.slice(r)) : r === this.head.data.length ? f2 = this.shift() : f2 = o ? this._getString(r) : this._getBuffer(r), f2;
      } }, { key: "first", value: function() {
        return this.head.data;
      } }, { key: "_getString", value: function(r) {
        var o = this.head, f2 = 1, p = o.data;
        for (r -= p.length;o = o.next; ) {
          var m = o.data, y = r > m.length ? m.length : r;
          if (y === m.length ? p += m : p += m.slice(0, r), r -= y, r === 0) {
            y === m.length ? (++f2, o.next ? this.head = o.next : this.head = this.tail = null) : (this.head = o, o.data = m.slice(y));
            break;
          }
          ++f2;
        }
        return this.length -= f2, p;
      } }, { key: "_getBuffer", value: function(r) {
        var o = Ns.allocUnsafe(r), f2 = this.head, p = 1;
        for (f2.data.copy(o), r -= f2.data.length;f2 = f2.next; ) {
          var m = f2.data, y = r > m.length ? m.length : r;
          if (m.copy(o, o.length - r, 0, y), r -= y, r === 0) {
            y === m.length ? (++p, f2.next ? this.head = f2.next : this.head = this.tail = null) : (this.head = f2, f2.data = m.slice(y));
            break;
          }
          ++p;
        }
        return this.length -= p, o;
      } }, { key: yE, value: function(r, o) {
        return Rl(this, Cg(Cg({}, o), {}, { depth: 0, customInspect: false }));
      } }]), t;
    }();
  });
  ql = k((Jk, Wg) => {
    function ME(t, e) {
      var r = this, o = this._readableState && this._readableState.destroyed, f2 = this._writableState && this._writableState.destroyed;
      return o || f2 ? (e ? e(t) : t && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = true, process.nextTick(Bl, this, t)) : process.nextTick(Bl, this, t)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(t || null, function(p) {
        !e && p ? r._writableState ? r._writableState.errorEmitted ? process.nextTick(Ps, r) : (r._writableState.errorEmitted = true, process.nextTick(Hg, r, p)) : process.nextTick(Hg, r, p) : e ? (process.nextTick(Ps, r), e(p)) : process.nextTick(Ps, r);
      }), this);
    }
    function Hg(t, e) {
      Bl(t, e), Ps(t);
    }
    function Ps(t) {
      t._writableState && !t._writableState.emitClose || t._readableState && !t._readableState.emitClose || t.emit("close");
    }
    function _E() {
      this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
    }
    function Bl(t, e) {
      t.emit("error", e);
    }
    function xE(t, e) {
      var { _readableState: r, _writableState: o } = t;
      r && r.autoDestroy || o && o.autoDestroy ? t.destroy(e) : t.emit("error", e);
    }
    Wg.exports = { destroy: ME, undestroy: _E, errorOrDestroy: xE };
  });
  Cn = k((Qk, Zg) => {
    function SE(t, e) {
      t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;
    }
    var jg = {};
    function Mr(t, e, r) {
      r || (r = Error);
      function o(p, m, y) {
        return typeof e == "string" ? e : e(p, m, y);
      }
      var f2 = function(p) {
        SE(m, p);
        function m(y, M, x) {
          return p.call(this, o(y, M, x)) || this;
        }
        return m;
      }(r);
      f2.prototype.name = r.name, f2.prototype.code = t, jg[t] = f2;
    }
    function Kg(t, e) {
      if (Array.isArray(t)) {
        var r = t.length;
        return t = t.map(function(o) {
          return String(o);
        }), r > 2 ? "one of ".concat(e, " ").concat(t.slice(0, r - 1).join(", "), ", or ") + t[r - 1] : r === 2 ? "one of ".concat(e, " ").concat(t[0], " or ").concat(t[1]) : "of ".concat(e, " ").concat(t[0]);
      } else
        return "of ".concat(e, " ").concat(String(t));
    }
    function EE(t, e, r) {
      return t.substr(!r || r < 0 ? 0 : +r, e.length) === e;
    }
    function AE(t, e, r) {
      return (r === undefined || r > t.length) && (r = t.length), t.substring(r - e.length, r) === e;
    }
    function RE(t, e, r) {
      return typeof r != "number" && (r = 0), r + e.length > t.length ? false : t.indexOf(e, r) !== -1;
    }
    Mr("ERR_INVALID_OPT_VALUE", function(t, e) {
      return 'The value "' + e + '" is invalid for option "' + t + '"';
    }, TypeError);
    Mr("ERR_INVALID_ARG_TYPE", function(t, e, r) {
      var o;
      typeof e == "string" && EE(e, "not ") ? (o = "must not be", e = e.replace(/^not /, "")) : o = "must be";
      var f2;
      if (AE(t, " argument"))
        f2 = "The ".concat(t, " ").concat(o, " ").concat(Kg(e, "type"));
      else {
        var p = RE(t, ".") ? "property" : "argument";
        f2 = 'The "'.concat(t, '" ').concat(p, " ").concat(o, " ").concat(Kg(e, "type"));
      }
      return f2 += ". Received type ".concat(typeof r), f2;
    }, TypeError);
    Mr("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    Mr("ERR_METHOD_NOT_IMPLEMENTED", function(t) {
      return "The " + t + " method is not implemented";
    });
    Mr("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    Mr("ERR_STREAM_DESTROYED", function(t) {
      return "Cannot call " + t + " after a stream was destroyed";
    });
    Mr("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    Mr("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    Mr("ERR_STREAM_WRITE_AFTER_END", "write after end");
    Mr("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    Mr("ERR_UNKNOWN_ENCODING", function(t) {
      return "Unknown encoding: " + t;
    }, TypeError);
    Mr("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    Zg.exports.codes = jg;
  });
  Il = k((eL, Vg) => {
    var BE = Cn().codes.ERR_INVALID_OPT_VALUE;
    function qE(t, e, r) {
      return t.highWaterMark != null ? t.highWaterMark : e ? t[r] : null;
    }
    function IE(t, e, r, o) {
      var f2 = qE(e, o, r);
      if (f2 != null) {
        if (!(isFinite(f2) && Math.floor(f2) === f2) || f2 < 0) {
          var p = o ? r : "highWaterMark";
          throw new BE(p, f2);
        }
        return Math.floor(f2);
      }
      return t.objectMode ? 16 : 16 * 1024;
    }
    Vg.exports = { getHighWaterMark: IE };
  });
  Ll = k((tL, Qg) => {
    Qg.exports = ut;
    function Gg(t) {
      var e = this;
      this.next = null, this.entry = null, this.finish = function() {
        iA(e, t);
      };
    }
    var Af;
    ut.WritableState = Ca;
    var TE = { deprecate: eh() }, Yg = Al(), Cs = Ut().Buffer, kE = (typeof global < "u" ? global : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
    };
    function LE(t) {
      return Cs.from(t);
    }
    function NE(t) {
      return Cs.isBuffer(t) || t instanceof kE;
    }
    var kl = ql(), PE = Il(), DE = PE.getHighWaterMark, Gi = Cn().codes, CE = Gi.ERR_INVALID_ARG_TYPE, OE = Gi.ERR_METHOD_NOT_IMPLEMENTED, FE = Gi.ERR_MULTIPLE_CALLBACK, UE = Gi.ERR_STREAM_CANNOT_PIPE, zE = Gi.ERR_STREAM_DESTROYED, HE = Gi.ERR_STREAM_NULL_VALUES, WE = Gi.ERR_STREAM_WRITE_AFTER_END, KE = Gi.ERR_UNKNOWN_ENCODING, Rf = kl.errorOrDestroy;
    Ie()(ut, Yg);
    function jE() {
    }
    function Ca(t, e, r) {
      Af = Af || On(), t = t || {}, typeof r != "boolean" && (r = e instanceof Af), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.writableObjectMode), this.highWaterMark = DE(this, t, "writableHighWaterMark", r), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
      var o = t.decodeStrings === false;
      this.decodeStrings = !o, this.defaultEncoding = t.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(f2) {
        JE(e, f2);
      }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = t.emitClose !== false, this.autoDestroy = !!t.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new Gg(this);
    }
    Ca.prototype.getBuffer = function() {
      for (var e = this.bufferedRequest, r = [];e; )
        r.push(e), e = e.next;
      return r;
    };
    (function() {
      try {
        Object.defineProperty(Ca.prototype, "buffer", { get: TE.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
      } catch {
      }
    })();
    var Ds;
    typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (Ds = Function.prototype[Symbol.hasInstance], Object.defineProperty(ut, Symbol.hasInstance, { value: function(e) {
      return Ds.call(this, e) ? true : this !== ut ? false : e && e._writableState instanceof Ca;
    } })) : Ds = function(e) {
      return e instanceof this;
    };
    function ut(t) {
      Af = Af || On();
      var e = this instanceof Af;
      if (!e && !Ds.call(ut, this))
        return new ut(t);
      this._writableState = new Ca(t, this, e), this.writable = true, t && (typeof t.write == "function" && (this._write = t.write), typeof t.writev == "function" && (this._writev = t.writev), typeof t.destroy == "function" && (this._destroy = t.destroy), typeof t.final == "function" && (this._final = t.final)), Yg.call(this);
    }
    ut.prototype.pipe = function() {
      Rf(this, new UE);
    };
    function ZE(t, e) {
      var r = new WE;
      Rf(t, r), process.nextTick(e, r);
    }
    function VE(t, e, r, o) {
      var f2;
      return r === null ? f2 = new HE : typeof r != "string" && !e.objectMode && (f2 = new CE("chunk", ["string", "Buffer"], r)), f2 ? (Rf(t, f2), process.nextTick(o, f2), false) : true;
    }
    ut.prototype.write = function(t, e, r) {
      var o = this._writableState, f2 = false, p = !o.objectMode && NE(t);
      return p && !Cs.isBuffer(t) && (t = LE(t)), typeof e == "function" && (r = e, e = null), p ? e = "buffer" : e || (e = o.defaultEncoding), typeof r != "function" && (r = jE), o.ending ? ZE(this, r) : (p || VE(this, o, t, r)) && (o.pendingcb++, f2 = GE(this, o, p, t, e, r)), f2;
    };
    ut.prototype.cork = function() {
      this._writableState.corked++;
    };
    ut.prototype.uncork = function() {
      var t = this._writableState;
      t.corked && (t.corked--, !t.writing && !t.corked && !t.bufferProcessing && t.bufferedRequest && Xg(this, t));
    };
    ut.prototype.setDefaultEncoding = function(e) {
      if (typeof e == "string" && (e = e.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e + "").toLowerCase()) > -1))
        throw new KE(e);
      return this._writableState.defaultEncoding = e, this;
    };
    Object.defineProperty(ut.prototype, "writableBuffer", { enumerable: false, get: function() {
      return this._writableState && this._writableState.getBuffer();
    } });
    function $E(t, e, r) {
      return !t.objectMode && t.decodeStrings !== false && typeof e == "string" && (e = Cs.from(e, r)), e;
    }
    Object.defineProperty(ut.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
      return this._writableState.highWaterMark;
    } });
    function GE(t, e, r, o, f2, p) {
      if (!r) {
        var m = $E(e, o, f2);
        o !== m && (r = true, f2 = "buffer", o = m);
      }
      var y = e.objectMode ? 1 : o.length;
      e.length += y;
      var M = e.length < e.highWaterMark;
      if (M || (e.needDrain = true), e.writing || e.corked) {
        var x = e.lastBufferedRequest;
        e.lastBufferedRequest = { chunk: o, encoding: f2, isBuf: r, callback: p, next: null }, x ? x.next = e.lastBufferedRequest : e.bufferedRequest = e.lastBufferedRequest, e.bufferedRequestCount += 1;
      } else
        Tl(t, e, false, y, o, f2, p);
      return M;
    }
    function Tl(t, e, r, o, f2, p, m) {
      e.writelen = o, e.writecb = m, e.writing = true, e.sync = true, e.destroyed ? e.onwrite(new zE("write")) : r ? t._writev(f2, e.onwrite) : t._write(f2, p, e.onwrite), e.sync = false;
    }
    function YE(t, e, r, o, f2) {
      --e.pendingcb, r ? (process.nextTick(f2, o), process.nextTick(Da, t, e), t._writableState.errorEmitted = true, Rf(t, o)) : (f2(o), t._writableState.errorEmitted = true, Rf(t, o), Da(t, e));
    }
    function XE(t) {
      t.writing = false, t.writecb = null, t.length -= t.writelen, t.writelen = 0;
    }
    function JE(t, e) {
      var r = t._writableState, o = r.sync, f2 = r.writecb;
      if (typeof f2 != "function")
        throw new FE;
      if (XE(r), e)
        YE(t, r, o, e, f2);
      else {
        var p = Jg(r) || t.destroyed;
        !p && !r.corked && !r.bufferProcessing && r.bufferedRequest && Xg(t, r), o ? process.nextTick($g, t, r, p, f2) : $g(t, r, p, f2);
      }
    }
    function $g(t, e, r, o) {
      r || QE(t, e), e.pendingcb--, o(), Da(t, e);
    }
    function QE(t, e) {
      e.length === 0 && e.needDrain && (e.needDrain = false, t.emit("drain"));
    }
    function Xg(t, e) {
      e.bufferProcessing = true;
      var r = e.bufferedRequest;
      if (t._writev && r && r.next) {
        var o = e.bufferedRequestCount, f2 = new Array(o), p = e.corkedRequestsFree;
        p.entry = r;
        for (var m = 0, y = true;r; )
          f2[m] = r, r.isBuf || (y = false), r = r.next, m += 1;
        f2.allBuffers = y, Tl(t, e, true, e.length, f2, "", p.finish), e.pendingcb++, e.lastBufferedRequest = null, p.next ? (e.corkedRequestsFree = p.next, p.next = null) : e.corkedRequestsFree = new Gg(e), e.bufferedRequestCount = 0;
      } else {
        for (;r; ) {
          var { chunk: M, encoding: x, callback: S2 } = r, E = e.objectMode ? 1 : M.length;
          if (Tl(t, e, false, E, M, x, S2), r = r.next, e.bufferedRequestCount--, e.writing)
            break;
        }
        r === null && (e.lastBufferedRequest = null);
      }
      e.bufferedRequest = r, e.bufferProcessing = false;
    }
    ut.prototype._write = function(t, e, r) {
      r(new OE("_write()"));
    };
    ut.prototype._writev = null;
    ut.prototype.end = function(t, e, r) {
      var o = this._writableState;
      return typeof t == "function" ? (r = t, t = null, e = null) : typeof e == "function" && (r = e, e = null), t != null && this.write(t, e), o.corked && (o.corked = 1, this.uncork()), o.ending || rA(this, o, r), this;
    };
    Object.defineProperty(ut.prototype, "writableLength", { enumerable: false, get: function() {
      return this._writableState.length;
    } });
    function Jg(t) {
      return t.ending && t.length === 0 && t.bufferedRequest === null && !t.finished && !t.writing;
    }
    function eA(t, e) {
      t._final(function(r) {
        e.pendingcb--, r && Rf(t, r), e.prefinished = true, t.emit("prefinish"), Da(t, e);
      });
    }
    function tA(t, e) {
      !e.prefinished && !e.finalCalled && (typeof t._final == "function" && !e.destroyed ? (e.pendingcb++, e.finalCalled = true, process.nextTick(eA, t, e)) : (e.prefinished = true, t.emit("prefinish")));
    }
    function Da(t, e) {
      var r = Jg(e);
      if (r && (tA(t, e), e.pendingcb === 0 && (e.finished = true, t.emit("finish"), e.autoDestroy))) {
        var o = t._readableState;
        (!o || o.autoDestroy && o.endEmitted) && t.destroy();
      }
      return r;
    }
    function rA(t, e, r) {
      e.ending = true, Da(t, e), r && (e.finished ? process.nextTick(r) : t.once("finish", r)), e.ended = true, t.writable = false;
    }
    function iA(t, e, r) {
      var o = t.entry;
      for (t.entry = null;o; ) {
        var f2 = o.callback;
        e.pendingcb--, f2(r), o = o.next;
      }
      e.corkedRequestsFree.next = t;
    }
    Object.defineProperty(ut.prototype, "destroyed", { enumerable: false, get: function() {
      return this._writableState === undefined ? false : this._writableState.destroyed;
    }, set: function(e) {
      !this._writableState || (this._writableState.destroyed = e);
    } });
    ut.prototype.destroy = kl.destroy;
    ut.prototype._undestroy = kl.undestroy;
    ut.prototype._destroy = function(t, e) {
      e(t);
    };
  });
  On = k((rL, t2) => {
    var nA = Object.keys || function(t) {
      var e = [];
      for (var r in t)
        e.push(r);
      return e;
    };
    t2.exports = ni;
    var e2 = Dl(), Pl = Ll();
    Ie()(ni, e2);
    for (Nl = nA(Pl.prototype), Os = 0;Os < Nl.length; Os++)
      Fs = Nl[Os], ni.prototype[Fs] || (ni.prototype[Fs] = Pl.prototype[Fs]);
    var Nl, Fs, Os;
    function ni(t) {
      if (!(this instanceof ni))
        return new ni(t);
      e2.call(this, t), Pl.call(this, t), this.allowHalfOpen = true, t && (t.readable === false && (this.readable = false), t.writable === false && (this.writable = false), t.allowHalfOpen === false && (this.allowHalfOpen = false, this.once("end", fA)));
    }
    Object.defineProperty(ni.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
      return this._writableState.highWaterMark;
    } });
    Object.defineProperty(ni.prototype, "writableBuffer", { enumerable: false, get: function() {
      return this._writableState && this._writableState.getBuffer();
    } });
    Object.defineProperty(ni.prototype, "writableLength", { enumerable: false, get: function() {
      return this._writableState.length;
    } });
    function fA() {
      this._writableState.ended || process.nextTick(aA, this);
    }
    function aA(t) {
      t.end();
    }
    Object.defineProperty(ni.prototype, "destroyed", { enumerable: false, get: function() {
      return this._readableState === undefined || this._writableState === undefined ? false : this._readableState.destroyed && this._writableState.destroyed;
    }, set: function(e) {
      this._readableState === undefined || this._writableState === undefined || (this._readableState.destroyed = e, this._writableState.destroyed = e);
    } });
  });
  Us = k((iL, n2) => {
    var r2 = Cn().codes.ERR_STREAM_PREMATURE_CLOSE;
    function oA(t) {
      var e = false;
      return function() {
        if (!e) {
          e = true;
          for (var r = arguments.length, o = new Array(r), f2 = 0;f2 < r; f2++)
            o[f2] = arguments[f2];
          t.apply(this, o);
        }
      };
    }
    function sA() {
    }
    function hA(t) {
      return t.setHeader && typeof t.abort == "function";
    }
    function i2(t, e, r) {
      if (typeof e == "function")
        return i2(t, null, e);
      e || (e = {}), r = oA(r || sA);
      var o = e.readable || e.readable !== false && t.readable, f2 = e.writable || e.writable !== false && t.writable, p = function() {
        t.writable || y();
      }, m = t._writableState && t._writableState.finished, y = function() {
        f2 = false, m = true, o || r.call(t);
      }, M = t._readableState && t._readableState.endEmitted, x = function() {
        o = false, M = true, f2 || r.call(t);
      }, S2 = function(T) {
        r.call(t, T);
      }, E = function() {
        var T;
        if (o && !M)
          return (!t._readableState || !t._readableState.ended) && (T = new r2), r.call(t, T);
        if (f2 && !m)
          return (!t._writableState || !t._writableState.ended) && (T = new r2), r.call(t, T);
      }, R = function() {
        t.req.on("finish", y);
      };
      return hA(t) ? (t.on("complete", y), t.on("abort", E), t.req ? R() : t.on("request", R)) : f2 && !t._writableState && (t.on("end", p), t.on("close", p)), t.on("end", x), t.on("finish", y), e.error !== false && t.on("error", S2), t.on("close", E), function() {
        t.removeListener("complete", y), t.removeListener("abort", E), t.removeListener("request", R), t.req && t.req.removeListener("finish", y), t.removeListener("end", p), t.removeListener("close", p), t.removeListener("finish", y), t.removeListener("end", x), t.removeListener("error", S2), t.removeListener("close", E);
      };
    }
    n2.exports = i2;
  });
  a2 = k((nL, f2) => {
    var zs;
    function Yi(t, e, r) {
      return e = uA(e), (e in t) ? Object.defineProperty(t, e, { value: r, enumerable: true, configurable: true, writable: true }) : t[e] = r, t;
    }
    function uA(t) {
      var e = lA(t, "string");
      return typeof e == "symbol" ? e : String(e);
    }
    function lA(t, e) {
      if (typeof t != "object" || t === null)
        return t;
      var r = t[Symbol.toPrimitive];
      if (r !== undefined) {
        var o = r.call(t, e || "default");
        if (typeof o != "object")
          return o;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (e === "string" ? String : Number)(t);
    }
    var dA = Us(), Xi = Symbol("lastResolve"), Fn = Symbol("lastReject"), Oa = Symbol("error"), Hs = Symbol("ended"), Un = Symbol("lastPromise"), Cl = Symbol("handlePromise"), zn = Symbol("stream");
    function Ji(t, e) {
      return { value: t, done: e };
    }
    function cA(t) {
      var e = t[Xi];
      if (e !== null) {
        var r = t[zn].read();
        r !== null && (t[Un] = null, t[Xi] = null, t[Fn] = null, e(Ji(r, false)));
      }
    }
    function pA(t) {
      process.nextTick(cA, t);
    }
    function vA(t, e) {
      return function(r, o) {
        t.then(function() {
          if (e[Hs]) {
            r(Ji(undefined, true));
            return;
          }
          e[Cl](r, o);
        }, o);
      };
    }
    var bA = Object.getPrototypeOf(function() {
    }), mA = Object.setPrototypeOf((zs = { get stream() {
      return this[zn];
    }, next: function() {
      var e = this, r = this[Oa];
      if (r !== null)
        return Promise.reject(r);
      if (this[Hs])
        return Promise.resolve(Ji(undefined, true));
      if (this[zn].destroyed)
        return new Promise(function(m, y) {
          process.nextTick(function() {
            e[Oa] ? y(e[Oa]) : m(Ji(undefined, true));
          });
        });
      var o = this[Un], f3;
      if (o)
        f3 = new Promise(vA(o, this));
      else {
        var p = this[zn].read();
        if (p !== null)
          return Promise.resolve(Ji(p, false));
        f3 = new Promise(this[Cl]);
      }
      return this[Un] = f3, f3;
    } }, Yi(zs, Symbol.asyncIterator, function() {
      return this;
    }), Yi(zs, "return", function() {
      var e = this;
      return new Promise(function(r, o) {
        e[zn].destroy(null, function(f3) {
          if (f3) {
            o(f3);
            return;
          }
          r(Ji(undefined, true));
        });
      });
    }), zs), bA), gA = function(e) {
      var r, o = Object.create(mA, (r = {}, Yi(r, zn, { value: e, writable: true }), Yi(r, Xi, { value: null, writable: true }), Yi(r, Fn, { value: null, writable: true }), Yi(r, Oa, { value: null, writable: true }), Yi(r, Hs, { value: e._readableState.endEmitted, writable: true }), Yi(r, Cl, { value: function(p, m) {
        var y = o[zn].read();
        y ? (o[Un] = null, o[Xi] = null, o[Fn] = null, p(Ji(y, false))) : (o[Xi] = p, o[Fn] = m);
      }, writable: true }), r));
      return o[Un] = null, dA(e, function(f3) {
        if (f3 && f3.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var p = o[Fn];
          p !== null && (o[Un] = null, o[Xi] = null, o[Fn] = null, p(f3)), o[Oa] = f3;
          return;
        }
        var m = o[Xi];
        m !== null && (o[Un] = null, o[Xi] = null, o[Fn] = null, m(Ji(undefined, true))), o[Hs] = true;
      }), e.on("readable", pA.bind(null, o)), o;
    };
    f2.exports = gA;
  });
  s2 = k((fL, o2) => {
    o2.exports = function() {
      throw new Error("Readable.from is not available in the browser");
    };
  });
  Dl = k((oL, g2) => {
    g2.exports = Oe;
    var Bf;
    Oe.ReadableState = d2;
    var aL = Di().EventEmitter, l2 = function(e, r) {
      return e.listeners(r).length;
    }, Ua = Al(), Ws = Ut().Buffer, yA = (typeof global < "u" ? global : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
    };
    function wA(t) {
      return Ws.from(t);
    }
    function MA(t) {
      return Ws.isBuffer(t) || t instanceof yA;
    }
    var Ol = Xf(), Pe;
    Ol && Ol.debuglog ? Pe = Ol.debuglog("stream") : Pe = function() {
    };
    var _A = zg(), jl = ql(), xA = Il(), SA = xA.getHighWaterMark, Ks = Cn().codes, EA = Ks.ERR_INVALID_ARG_TYPE, AA = Ks.ERR_STREAM_PUSH_AFTER_EOF, RA = Ks.ERR_METHOD_NOT_IMPLEMENTED, BA = Ks.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, qf, Fl, Ul;
    Ie()(Oe, Ua);
    var Fa = jl.errorOrDestroy, zl = ["error", "close", "destroy", "pause", "resume"];
    function qA(t, e, r) {
      if (typeof t.prependListener == "function")
        return t.prependListener(e, r);
      !t._events || !t._events[e] ? t.on(e, r) : Array.isArray(t._events[e]) ? t._events[e].unshift(r) : t._events[e] = [r, t._events[e]];
    }
    function d2(t, e, r) {
      Bf = Bf || On(), t = t || {}, typeof r != "boolean" && (r = e instanceof Bf), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.readableObjectMode), this.highWaterMark = SA(this, t, "readableHighWaterMark", r), this.buffer = new _A, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = t.emitClose !== false, this.autoDestroy = !!t.autoDestroy, this.destroyed = false, this.defaultEncoding = t.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, t.encoding && (qf || (qf = (ra(), ur(ta)).StringDecoder), this.decoder = new qf(t.encoding), this.encoding = t.encoding);
    }
    function Oe(t) {
      if (Bf = Bf || On(), !(this instanceof Oe))
        return new Oe(t);
      var e = this instanceof Bf;
      this._readableState = new d2(t, this, e), this.readable = true, t && (typeof t.read == "function" && (this._read = t.read), typeof t.destroy == "function" && (this._destroy = t.destroy)), Ua.call(this);
    }
    Object.defineProperty(Oe.prototype, "destroyed", { enumerable: false, get: function() {
      return this._readableState === undefined ? false : this._readableState.destroyed;
    }, set: function(e) {
      !this._readableState || (this._readableState.destroyed = e);
    } });
    Oe.prototype.destroy = jl.destroy;
    Oe.prototype._undestroy = jl.undestroy;
    Oe.prototype._destroy = function(t, e) {
      e(t);
    };
    Oe.prototype.push = function(t, e) {
      var r = this._readableState, o;
      return r.objectMode ? o = true : typeof t == "string" && (e = e || r.defaultEncoding, e !== r.encoding && (t = Ws.from(t, e), e = ""), o = true), c2(this, t, e, false, o);
    };
    Oe.prototype.unshift = function(t) {
      return c2(this, t, null, true, false);
    };
    function c2(t, e, r, o, f2) {
      Pe("readableAddChunk", e);
      var p = t._readableState;
      if (e === null)
        p.reading = false, kA(t, p);
      else {
        var m;
        if (f2 || (m = IA(p, e)), m)
          Fa(t, m);
        else if (p.objectMode || e && e.length > 0)
          if (typeof e != "string" && !p.objectMode && Object.getPrototypeOf(e) !== Ws.prototype && (e = wA(e)), o)
            p.endEmitted ? Fa(t, new BA) : Hl(t, p, e, true);
          else if (p.ended)
            Fa(t, new AA);
          else {
            if (p.destroyed)
              return false;
            p.reading = false, p.decoder && !r ? (e = p.decoder.write(e), p.objectMode || e.length !== 0 ? Hl(t, p, e, false) : Kl2(t, p)) : Hl(t, p, e, false);
          }
        else
          o || (p.reading = false, Kl2(t, p));
      }
      return !p.ended && (p.length < p.highWaterMark || p.length === 0);
    }
    function Hl(t, e, r, o) {
      e.flowing && e.length === 0 && !e.sync ? (e.awaitDrain = 0, t.emit("data", r)) : (e.length += e.objectMode ? 1 : r.length, o ? e.buffer.unshift(r) : e.buffer.push(r), e.needReadable && js(t)), Kl2(t, e);
    }
    function IA(t, e) {
      var r;
      return !MA(e) && typeof e != "string" && e !== undefined && !t.objectMode && (r = new EA("chunk", ["string", "Buffer", "Uint8Array"], e)), r;
    }
    Oe.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Oe.prototype.setEncoding = function(t) {
      qf || (qf = (ra(), ur(ta)).StringDecoder);
      var e = new qf(t);
      this._readableState.decoder = e, this._readableState.encoding = this._readableState.decoder.encoding;
      for (var r = this._readableState.buffer.head, o = "";r !== null; )
        o += e.write(r.data), r = r.next;
      return this._readableState.buffer.clear(), o !== "" && this._readableState.buffer.push(o), this._readableState.length = o.length, this;
    };
    var h2 = 1073741824;
    function TA(t) {
      return t >= h2 ? t = h2 : (t--, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, t |= t >>> 16, t++), t;
    }
    function u2(t, e) {
      return t <= 0 || e.length === 0 && e.ended ? 0 : e.objectMode ? 1 : t !== t ? e.flowing && e.length ? e.buffer.head.data.length : e.length : (t > e.highWaterMark && (e.highWaterMark = TA(t)), t <= e.length ? t : e.ended ? e.length : (e.needReadable = true, 0));
    }
    Oe.prototype.read = function(t) {
      Pe("read", t), t = parseInt(t, 10);
      var e = this._readableState, r = t;
      if (t !== 0 && (e.emittedReadable = false), t === 0 && e.needReadable && ((e.highWaterMark !== 0 ? e.length >= e.highWaterMark : e.length > 0) || e.ended))
        return Pe("read: emitReadable", e.length, e.ended), e.length === 0 && e.ended ? Wl(this) : js(this), null;
      if (t = u2(t, e), t === 0 && e.ended)
        return e.length === 0 && Wl(this), null;
      var o = e.needReadable;
      Pe("need readable", o), (e.length === 0 || e.length - t < e.highWaterMark) && (o = true, Pe("length less than watermark", o)), e.ended || e.reading ? (o = false, Pe("reading or ended", o)) : o && (Pe("do read"), e.reading = true, e.sync = true, e.length === 0 && (e.needReadable = true), this._read(e.highWaterMark), e.sync = false, e.reading || (t = u2(r, e)));
      var f2;
      return t > 0 ? f2 = b2(t, e) : f2 = null, f2 === null ? (e.needReadable = e.length <= e.highWaterMark, t = 0) : (e.length -= t, e.awaitDrain = 0), e.length === 0 && (e.ended || (e.needReadable = true), r !== t && e.ended && Wl(this)), f2 !== null && this.emit("data", f2), f2;
    };
    function kA(t, e) {
      if (Pe("onEofChunk"), !e.ended) {
        if (e.decoder) {
          var r = e.decoder.end();
          r && r.length && (e.buffer.push(r), e.length += e.objectMode ? 1 : r.length);
        }
        e.ended = true, e.sync ? js(t) : (e.needReadable = false, e.emittedReadable || (e.emittedReadable = true, p2(t)));
      }
    }
    function js(t) {
      var e = t._readableState;
      Pe("emitReadable", e.needReadable, e.emittedReadable), e.needReadable = false, e.emittedReadable || (Pe("emitReadable", e.flowing), e.emittedReadable = true, process.nextTick(p2, t));
    }
    function p2(t) {
      var e = t._readableState;
      Pe("emitReadable_", e.destroyed, e.length, e.ended), !e.destroyed && (e.length || e.ended) && (t.emit("readable"), e.emittedReadable = false), e.needReadable = !e.flowing && !e.ended && e.length <= e.highWaterMark, Zl(t);
    }
    function Kl2(t, e) {
      e.readingMore || (e.readingMore = true, process.nextTick(LA, t, e));
    }
    function LA(t, e) {
      for (;!e.reading && !e.ended && (e.length < e.highWaterMark || e.flowing && e.length === 0); ) {
        var r = e.length;
        if (Pe("maybeReadMore read 0"), t.read(0), r === e.length)
          break;
      }
      e.readingMore = false;
    }
    Oe.prototype._read = function(t) {
      Fa(this, new RA("_read()"));
    };
    Oe.prototype.pipe = function(t, e) {
      var r = this, o = this._readableState;
      switch (o.pipesCount) {
        case 0:
          o.pipes = t;
          break;
        case 1:
          o.pipes = [o.pipes, t];
          break;
        default:
          o.pipes.push(t);
          break;
      }
      o.pipesCount += 1, Pe("pipe count=%d opts=%j", o.pipesCount, e);
      var f2 = (!e || e.end !== false) && t !== process.stdout && t !== process.stderr, p = f2 ? y : ye;
      o.endEmitted ? process.nextTick(p) : r.once("end", p), t.on("unpipe", m);
      function m(_e, P) {
        Pe("onunpipe"), _e === r && P && P.hasUnpiped === false && (P.hasUnpiped = true, S2());
      }
      function y() {
        Pe("onend"), t.end();
      }
      var M = NA(r);
      t.on("drain", M);
      var x = false;
      function S2() {
        Pe("cleanup"), t.removeListener("close", q), t.removeListener("finish", T), t.removeListener("drain", M), t.removeListener("error", R), t.removeListener("unpipe", m), r.removeListener("end", y), r.removeListener("end", ye), r.removeListener("data", E), x = true, o.awaitDrain && (!t._writableState || t._writableState.needDrain) && M();
      }
      r.on("data", E);
      function E(_e) {
        Pe("ondata");
        var P = t.write(_e);
        Pe("dest.write", P), P === false && ((o.pipesCount === 1 && o.pipes === t || o.pipesCount > 1 && m2(o.pipes, t) !== -1) && !x && (Pe("false write response, pause", o.awaitDrain), o.awaitDrain++), r.pause());
      }
      function R(_e) {
        Pe("onerror", _e), ye(), t.removeListener("error", R), l2(t, "error") === 0 && Fa(t, _e);
      }
      qA(t, "error", R);
      function q() {
        t.removeListener("finish", T), ye();
      }
      t.once("close", q);
      function T() {
        Pe("onfinish"), t.removeListener("close", q), ye();
      }
      t.once("finish", T);
      function ye() {
        Pe("unpipe"), r.unpipe(t);
      }
      return t.emit("pipe", r), o.flowing || (Pe("pipe resume"), r.resume()), t;
    };
    function NA(t) {
      return function() {
        var r = t._readableState;
        Pe("pipeOnDrain", r.awaitDrain), r.awaitDrain && r.awaitDrain--, r.awaitDrain === 0 && l2(t, "data") && (r.flowing = true, Zl(t));
      };
    }
    Oe.prototype.unpipe = function(t) {
      var e = this._readableState, r = { hasUnpiped: false };
      if (e.pipesCount === 0)
        return this;
      if (e.pipesCount === 1)
        return t && t !== e.pipes ? this : (t || (t = e.pipes), e.pipes = null, e.pipesCount = 0, e.flowing = false, t && t.emit("unpipe", this, r), this);
      if (!t) {
        var { pipes: o, pipesCount: f2 } = e;
        e.pipes = null, e.pipesCount = 0, e.flowing = false;
        for (var p = 0;p < f2; p++)
          o[p].emit("unpipe", this, { hasUnpiped: false });
        return this;
      }
      var m = m2(e.pipes, t);
      return m === -1 ? this : (e.pipes.splice(m, 1), e.pipesCount -= 1, e.pipesCount === 1 && (e.pipes = e.pipes[0]), t.emit("unpipe", this, r), this);
    };
    Oe.prototype.on = function(t, e) {
      var r = Ua.prototype.on.call(this, t, e), o = this._readableState;
      return t === "data" ? (o.readableListening = this.listenerCount("readable") > 0, o.flowing !== false && this.resume()) : t === "readable" && !o.endEmitted && !o.readableListening && (o.readableListening = o.needReadable = true, o.flowing = false, o.emittedReadable = false, Pe("on readable", o.length, o.reading), o.length ? js(this) : o.reading || process.nextTick(PA, this)), r;
    };
    Oe.prototype.addListener = Oe.prototype.on;
    Oe.prototype.removeListener = function(t, e) {
      var r = Ua.prototype.removeListener.call(this, t, e);
      return t === "readable" && process.nextTick(v2, this), r;
    };
    Oe.prototype.removeAllListeners = function(t) {
      var e = Ua.prototype.removeAllListeners.apply(this, arguments);
      return (t === "readable" || t === undefined) && process.nextTick(v2, this), e;
    };
    function v2(t) {
      var e = t._readableState;
      e.readableListening = t.listenerCount("readable") > 0, e.resumeScheduled && !e.paused ? e.flowing = true : t.listenerCount("data") > 0 && t.resume();
    }
    function PA(t) {
      Pe("readable nexttick read 0"), t.read(0);
    }
    Oe.prototype.resume = function() {
      var t = this._readableState;
      return t.flowing || (Pe("resume"), t.flowing = !t.readableListening, DA(this, t)), t.paused = false, this;
    };
    function DA(t, e) {
      e.resumeScheduled || (e.resumeScheduled = true, process.nextTick(CA, t, e));
    }
    function CA(t, e) {
      Pe("resume", e.reading), e.reading || t.read(0), e.resumeScheduled = false, t.emit("resume"), Zl(t), e.flowing && !e.reading && t.read(0);
    }
    Oe.prototype.pause = function() {
      return Pe("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (Pe("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState.paused = true, this;
    };
    function Zl(t) {
      var e = t._readableState;
      for (Pe("flow", e.flowing);e.flowing && t.read() !== null; )
        ;
    }
    Oe.prototype.wrap = function(t) {
      var e = this, r = this._readableState, o = false;
      t.on("end", function() {
        if (Pe("wrapped end"), r.decoder && !r.ended) {
          var m = r.decoder.end();
          m && m.length && e.push(m);
        }
        e.push(null);
      }), t.on("data", function(m) {
        if (Pe("wrapped data"), r.decoder && (m = r.decoder.write(m)), !(r.objectMode && m == null) && !(!r.objectMode && (!m || !m.length))) {
          var y = e.push(m);
          y || (o = true, t.pause());
        }
      });
      for (var f2 in t)
        this[f2] === undefined && typeof t[f2] == "function" && (this[f2] = function(y) {
          return function() {
            return t[y].apply(t, arguments);
          };
        }(f2));
      for (var p = 0;p < zl.length; p++)
        t.on(zl[p], this.emit.bind(this, zl[p]));
      return this._read = function(m) {
        Pe("wrapped _read", m), o && (o = false, t.resume());
      }, this;
    };
    typeof Symbol == "function" && (Oe.prototype[Symbol.asyncIterator] = function() {
      return Fl === undefined && (Fl = a2()), Fl(this);
    });
    Object.defineProperty(Oe.prototype, "readableHighWaterMark", { enumerable: false, get: function() {
      return this._readableState.highWaterMark;
    } });
    Object.defineProperty(Oe.prototype, "readableBuffer", { enumerable: false, get: function() {
      return this._readableState && this._readableState.buffer;
    } });
    Object.defineProperty(Oe.prototype, "readableFlowing", { enumerable: false, get: function() {
      return this._readableState.flowing;
    }, set: function(e) {
      this._readableState && (this._readableState.flowing = e);
    } });
    Oe._fromList = b2;
    Object.defineProperty(Oe.prototype, "readableLength", { enumerable: false, get: function() {
      return this._readableState.length;
    } });
    function b2(t, e) {
      if (e.length === 0)
        return null;
      var r;
      return e.objectMode ? r = e.buffer.shift() : !t || t >= e.length ? (e.decoder ? r = e.buffer.join("") : e.buffer.length === 1 ? r = e.buffer.first() : r = e.buffer.concat(e.length), e.buffer.clear()) : r = e.buffer.consume(t, e.decoder), r;
    }
    function Wl(t) {
      var e = t._readableState;
      Pe("endReadable", e.endEmitted), e.endEmitted || (e.ended = true, process.nextTick(OA, e, t));
    }
    function OA(t, e) {
      if (Pe("endReadableNT", t.endEmitted, t.length), !t.endEmitted && t.length === 0 && (t.endEmitted = true, e.readable = false, e.emit("end"), t.autoDestroy)) {
        var r = e._writableState;
        (!r || r.autoDestroy && r.finished) && e.destroy();
      }
    }
    typeof Symbol == "function" && (Oe.from = function(t, e) {
      return Ul === undefined && (Ul = s2()), Ul(Oe, t, e);
    });
    function m2(t, e) {
      for (var r = 0, o = t.length;r < o; r++)
        if (t[r] === e)
          return r;
      return -1;
    }
  });
  Vl = k((sL, w2) => {
    w2.exports = qi;
    var Zs = Cn().codes, FA = Zs.ERR_METHOD_NOT_IMPLEMENTED, UA = Zs.ERR_MULTIPLE_CALLBACK, zA = Zs.ERR_TRANSFORM_ALREADY_TRANSFORMING, HA = Zs.ERR_TRANSFORM_WITH_LENGTH_0, Vs = On();
    Ie()(qi, Vs);
    function WA(t, e) {
      var r = this._transformState;
      r.transforming = false;
      var o = r.writecb;
      if (o === null)
        return this.emit("error", new UA);
      r.writechunk = null, r.writecb = null, e != null && this.push(e), o(t);
      var f2 = this._readableState;
      f2.reading = false, (f2.needReadable || f2.length < f2.highWaterMark) && this._read(f2.highWaterMark);
    }
    function qi(t) {
      if (!(this instanceof qi))
        return new qi(t);
      Vs.call(this, t), this._transformState = { afterTransform: WA.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = true, this._readableState.sync = false, t && (typeof t.transform == "function" && (this._transform = t.transform), typeof t.flush == "function" && (this._flush = t.flush)), this.on("prefinish", KA);
    }
    function KA() {
      var t = this;
      typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(e, r) {
        y2(t, e, r);
      }) : y2(this, null, null);
    }
    qi.prototype.push = function(t, e) {
      return this._transformState.needTransform = false, Vs.prototype.push.call(this, t, e);
    };
    qi.prototype._transform = function(t, e, r) {
      r(new FA("_transform()"));
    };
    qi.prototype._write = function(t, e, r) {
      var o = this._transformState;
      if (o.writecb = r, o.writechunk = t, o.writeencoding = e, !o.transforming) {
        var f2 = this._readableState;
        (o.needTransform || f2.needReadable || f2.length < f2.highWaterMark) && this._read(f2.highWaterMark);
      }
    };
    qi.prototype._read = function(t) {
      var e = this._transformState;
      e.writechunk !== null && !e.transforming ? (e.transforming = true, this._transform(e.writechunk, e.writeencoding, e.afterTransform)) : e.needTransform = true;
    };
    qi.prototype._destroy = function(t, e) {
      Vs.prototype._destroy.call(this, t, function(r) {
        e(r);
      });
    };
    function y2(t, e, r) {
      if (e)
        return t.emit("error", e);
      if (r != null && t.push(r), t._writableState.length)
        throw new HA;
      if (t._transformState.transforming)
        throw new zA;
      return t.push(null);
    }
  });
  x2 = k((hL, _2) => {
    _2.exports = za;
    var M2 = Vl();
    Ie()(za, M2);
    function za(t) {
      if (!(this instanceof za))
        return new za(t);
      M2.call(this, t);
    }
    za.prototype._transform = function(t, e, r) {
      r(null, t);
    };
  });
  B2 = k((uL, R2) => {
    var $l;
    function jA(t) {
      var e = false;
      return function() {
        e || (e = true, t.apply(undefined, arguments));
      };
    }
    var A2 = Cn().codes, ZA = A2.ERR_MISSING_ARGS, VA = A2.ERR_STREAM_DESTROYED;
    function S2(t) {
      if (t)
        throw t;
    }
    function $A(t) {
      return t.setHeader && typeof t.abort == "function";
    }
    function GA(t, e, r, o) {
      o = jA(o);
      var f2 = false;
      t.on("close", function() {
        f2 = true;
      }), $l === undefined && ($l = Us()), $l(t, { readable: e, writable: r }, function(m) {
        if (m)
          return o(m);
        f2 = true, o();
      });
      var p = false;
      return function(m) {
        if (!f2 && !p) {
          if (p = true, $A(t))
            return t.abort();
          if (typeof t.destroy == "function")
            return t.destroy();
          o(m || new VA("pipe"));
        }
      };
    }
    function E2(t) {
      t();
    }
    function YA(t, e) {
      return t.pipe(e);
    }
    function XA(t) {
      return !t.length || typeof t[t.length - 1] != "function" ? S2 : t.pop();
    }
    function JA() {
      for (var t = arguments.length, e = new Array(t), r = 0;r < t; r++)
        e[r] = arguments[r];
      var o = XA(e);
      if (Array.isArray(e[0]) && (e = e[0]), e.length < 2)
        throw new ZA("streams");
      var f2, p = e.map(function(m, y) {
        var M = y < e.length - 1, x = y > 0;
        return GA(m, M, x, function(S3) {
          f2 || (f2 = S3), S3 && p.forEach(E2), !M && (p.forEach(E2), o(f2));
        });
      });
      return e.reduce(YA);
    }
    R2.exports = JA;
  });
  I2 = k((_r, q2) => {
    _r = q2.exports = Dl();
    _r.Stream = _r;
    _r.Readable = _r;
    _r.Writable = Ll();
    _r.Duplex = On();
    _r.Transform = Vl();
    _r.PassThrough = x2();
    _r.finished = Us();
    _r.pipeline = B2();
  });
  $s = k((T2, Gl) => {
    (function(t, e) {
      function r(h, s) {
        if (!h)
          throw new Error(s || "Assertion failed");
      }
      function o(h, s) {
        h.super_ = s;
        var u = function() {
        };
        u.prototype = s.prototype, h.prototype = new u, h.prototype.constructor = h;
      }
      function f2(h, s, u) {
        if (f2.isBN(h))
          return h;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, h !== null && ((s === "le" || s === "be") && (u = s, s = 10), this._init(h || 0, s || 10, u || "be"));
      }
      typeof t == "object" ? t.exports = f2 : e.BN = f2, f2.BN = f2, f2.wordSize = 26;
      var p;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? p = window.Buffer : p = Vi().Buffer;
      } catch {
      }
      f2.isBN = function(s) {
        return s instanceof f2 ? true : s !== null && typeof s == "object" && s.constructor.wordSize === f2.wordSize && Array.isArray(s.words);
      }, f2.max = function(s, u) {
        return s.cmp(u) > 0 ? s : u;
      }, f2.min = function(s, u) {
        return s.cmp(u) < 0 ? s : u;
      }, f2.prototype._init = function(s, u, c) {
        if (typeof s == "number")
          return this._initNumber(s, u, c);
        if (typeof s == "object")
          return this._initArray(s, u, c);
        u === "hex" && (u = 16), r(u === (u | 0) && u >= 2 && u <= 36), s = s.toString().replace(/\s+/g, "");
        var b2 = 0;
        s[0] === "-" && (b2++, this.negative = 1), b2 < s.length && (u === 16 ? this._parseHex(s, b2, c) : (this._parseBase(s, u, b2), c === "le" && this._initArray(this.toArray(), u, c)));
      }, f2.prototype._initNumber = function(s, u, c) {
        s < 0 && (this.negative = 1, s = -s), s < 67108864 ? (this.words = [s & 67108863], this.length = 1) : s < 4503599627370496 ? (this.words = [s & 67108863, s / 67108864 & 67108863], this.length = 2) : (r(s < 9007199254740992), this.words = [s & 67108863, s / 67108864 & 67108863, 1], this.length = 3), c === "le" && this._initArray(this.toArray(), u, c);
      }, f2.prototype._initArray = function(s, u, c) {
        if (r(typeof s.length == "number"), s.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(s.length / 3), this.words = new Array(this.length);
        for (var b2 = 0;b2 < this.length; b2++)
          this.words[b2] = 0;
        var l, n, d = 0;
        if (c === "be")
          for (b2 = s.length - 1, l = 0;b2 >= 0; b2 -= 3)
            n = s[b2] | s[b2 - 1] << 8 | s[b2 - 2] << 16, this.words[l] |= n << d & 67108863, this.words[l + 1] = n >>> 26 - d & 67108863, d += 24, d >= 26 && (d -= 26, l++);
        else if (c === "le")
          for (b2 = 0, l = 0;b2 < s.length; b2 += 3)
            n = s[b2] | s[b2 + 1] << 8 | s[b2 + 2] << 16, this.words[l] |= n << d & 67108863, this.words[l + 1] = n >>> 26 - d & 67108863, d += 24, d >= 26 && (d -= 26, l++);
        return this._strip();
      };
      function m(h, s) {
        var u = h.charCodeAt(s);
        if (u >= 48 && u <= 57)
          return u - 48;
        if (u >= 65 && u <= 70)
          return u - 55;
        if (u >= 97 && u <= 102)
          return u - 87;
        r(false, "Invalid character in " + h);
      }
      function y(h, s, u) {
        var c = m(h, u);
        return u - 1 >= s && (c |= m(h, u - 1) << 4), c;
      }
      f2.prototype._parseHex = function(s, u, c) {
        this.length = Math.ceil((s.length - u) / 6), this.words = new Array(this.length);
        for (var b2 = 0;b2 < this.length; b2++)
          this.words[b2] = 0;
        var l = 0, n = 0, d;
        if (c === "be")
          for (b2 = s.length - 1;b2 >= u; b2 -= 2)
            d = y(s, u, b2) << l, this.words[n] |= d & 67108863, l >= 18 ? (l -= 18, n += 1, this.words[n] |= d >>> 26) : l += 8;
        else {
          var w = s.length - u;
          for (b2 = w % 2 === 0 ? u + 1 : u;b2 < s.length; b2 += 2)
            d = y(s, u, b2) << l, this.words[n] |= d & 67108863, l >= 18 ? (l -= 18, n += 1, this.words[n] |= d >>> 26) : l += 8;
        }
        this._strip();
      };
      function M(h, s, u, c) {
        for (var b2 = 0, l = 0, n = Math.min(h.length, u), d = s;d < n; d++) {
          var w = h.charCodeAt(d) - 48;
          b2 *= c, w >= 49 ? l = w - 49 + 10 : w >= 17 ? l = w - 17 + 10 : l = w, r(w >= 0 && l < c, "Invalid character"), b2 += l;
        }
        return b2;
      }
      f2.prototype._parseBase = function(s, u, c) {
        this.words = [0], this.length = 1;
        for (var b2 = 0, l = 1;l <= 67108863; l *= u)
          b2++;
        b2--, l = l / u | 0;
        for (var n = s.length - c, d = n % b2, w = Math.min(n, n - d) + c, g = 0, _2 = c;_2 < w; _2 += b2)
          g = M(s, _2, _2 + b2, u), this.imuln(l), this.words[0] + g < 67108864 ? this.words[0] += g : this._iaddn(g);
        if (d !== 0) {
          var A = 1;
          for (g = M(s, _2, s.length, u), _2 = 0;_2 < d; _2++)
            A *= u;
          this.imuln(A), this.words[0] + g < 67108864 ? this.words[0] += g : this._iaddn(g);
        }
        this._strip();
      }, f2.prototype.copy = function(s) {
        s.words = new Array(this.length);
        for (var u = 0;u < this.length; u++)
          s.words[u] = this.words[u];
        s.length = this.length, s.negative = this.negative, s.red = this.red;
      };
      function x(h, s) {
        h.words = s.words, h.length = s.length, h.negative = s.negative, h.red = s.red;
      }
      if (f2.prototype._move = function(s) {
        x(s, this);
      }, f2.prototype.clone = function() {
        var s = new f2(null);
        return this.copy(s), s;
      }, f2.prototype._expand = function(s) {
        for (;this.length < s; )
          this.words[this.length++] = 0;
        return this;
      }, f2.prototype._strip = function() {
        for (;this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, f2.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, typeof Symbol < "u" && typeof Symbol.for == "function")
        try {
          f2.prototype[Symbol.for("nodejs.util.inspect.custom")] = S2;
        } catch {
          f2.prototype.inspect = S2;
        }
      else
        f2.prototype.inspect = S2;
      function S2() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var E = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], R = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], q = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      f2.prototype.toString = function(s, u) {
        s = s || 10, u = u | 0 || 1;
        var c;
        if (s === 16 || s === "hex") {
          c = "";
          for (var b2 = 0, l = 0, n = 0;n < this.length; n++) {
            var d = this.words[n], w = ((d << b2 | l) & 16777215).toString(16);
            l = d >>> 24 - b2 & 16777215, b2 += 2, b2 >= 26 && (b2 -= 26, n--), l !== 0 || n !== this.length - 1 ? c = E[6 - w.length] + w + c : c = w + c;
          }
          for (l !== 0 && (c = l.toString(16) + c);c.length % u !== 0; )
            c = "0" + c;
          return this.negative !== 0 && (c = "-" + c), c;
        }
        if (s === (s | 0) && s >= 2 && s <= 36) {
          var g = R[s], _2 = q[s];
          c = "";
          var A = this.clone();
          for (A.negative = 0;!A.isZero(); ) {
            var B = A.modrn(_2).toString(s);
            A = A.idivn(_2), A.isZero() ? c = B + c : c = E[g - B.length] + B + c;
          }
          for (this.isZero() && (c = "0" + c);c.length % u !== 0; )
            c = "0" + c;
          return this.negative !== 0 && (c = "-" + c), c;
        }
        r(false, "Base should be between 2 and 36");
      }, f2.prototype.toNumber = function() {
        var s = this.words[0];
        return this.length === 2 ? s += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? s += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -s : s;
      }, f2.prototype.toJSON = function() {
        return this.toString(16, 2);
      }, p && (f2.prototype.toBuffer = function(s, u) {
        return this.toArrayLike(p, s, u);
      }), f2.prototype.toArray = function(s, u) {
        return this.toArrayLike(Array, s, u);
      };
      var T = function(s, u) {
        return s.allocUnsafe ? s.allocUnsafe(u) : new s(u);
      };
      f2.prototype.toArrayLike = function(s, u, c) {
        this._strip();
        var b2 = this.byteLength(), l = c || Math.max(1, b2);
        r(b2 <= l, "byte array longer than desired length"), r(l > 0, "Requested array length <= 0");
        var n = T(s, l), d = u === "le" ? "LE" : "BE";
        return this["_toArrayLike" + d](n, b2), n;
      }, f2.prototype._toArrayLikeLE = function(s, u) {
        for (var c = 0, b2 = 0, l = 0, n = 0;l < this.length; l++) {
          var d = this.words[l] << n | b2;
          s[c++] = d & 255, c < s.length && (s[c++] = d >> 8 & 255), c < s.length && (s[c++] = d >> 16 & 255), n === 6 ? (c < s.length && (s[c++] = d >> 24 & 255), b2 = 0, n = 0) : (b2 = d >>> 24, n += 2);
        }
        if (c < s.length)
          for (s[c++] = b2;c < s.length; )
            s[c++] = 0;
      }, f2.prototype._toArrayLikeBE = function(s, u) {
        for (var c = s.length - 1, b2 = 0, l = 0, n = 0;l < this.length; l++) {
          var d = this.words[l] << n | b2;
          s[c--] = d & 255, c >= 0 && (s[c--] = d >> 8 & 255), c >= 0 && (s[c--] = d >> 16 & 255), n === 6 ? (c >= 0 && (s[c--] = d >> 24 & 255), b2 = 0, n = 0) : (b2 = d >>> 24, n += 2);
        }
        if (c >= 0)
          for (s[c--] = b2;c >= 0; )
            s[c--] = 0;
      }, Math.clz32 ? f2.prototype._countBits = function(s) {
        return 32 - Math.clz32(s);
      } : f2.prototype._countBits = function(s) {
        var u = s, c = 0;
        return u >= 4096 && (c += 13, u >>>= 13), u >= 64 && (c += 7, u >>>= 7), u >= 8 && (c += 4, u >>>= 4), u >= 2 && (c += 2, u >>>= 2), c + u;
      }, f2.prototype._zeroBits = function(s) {
        if (s === 0)
          return 26;
        var u = s, c = 0;
        return (u & 8191) === 0 && (c += 13, u >>>= 13), (u & 127) === 0 && (c += 7, u >>>= 7), (u & 15) === 0 && (c += 4, u >>>= 4), (u & 3) === 0 && (c += 2, u >>>= 2), (u & 1) === 0 && c++, c;
      }, f2.prototype.bitLength = function() {
        var s = this.words[this.length - 1], u = this._countBits(s);
        return (this.length - 1) * 26 + u;
      };
      function ye(h) {
        for (var s = new Array(h.bitLength()), u = 0;u < s.length; u++) {
          var c = u / 26 | 0, b2 = u % 26;
          s[u] = h.words[c] >>> b2 & 1;
        }
        return s;
      }
      f2.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var s = 0, u = 0;u < this.length; u++) {
          var c = this._zeroBits(this.words[u]);
          if (s += c, c !== 26)
            break;
        }
        return s;
      }, f2.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, f2.prototype.toTwos = function(s) {
        return this.negative !== 0 ? this.abs().inotn(s).iaddn(1) : this.clone();
      }, f2.prototype.fromTwos = function(s) {
        return this.testn(s - 1) ? this.notn(s).iaddn(1).ineg() : this.clone();
      }, f2.prototype.isNeg = function() {
        return this.negative !== 0;
      }, f2.prototype.neg = function() {
        return this.clone().ineg();
      }, f2.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, f2.prototype.iuor = function(s) {
        for (;this.length < s.length; )
          this.words[this.length++] = 0;
        for (var u = 0;u < s.length; u++)
          this.words[u] = this.words[u] | s.words[u];
        return this._strip();
      }, f2.prototype.ior = function(s) {
        return r((this.negative | s.negative) === 0), this.iuor(s);
      }, f2.prototype.or = function(s) {
        return this.length > s.length ? this.clone().ior(s) : s.clone().ior(this);
      }, f2.prototype.uor = function(s) {
        return this.length > s.length ? this.clone().iuor(s) : s.clone().iuor(this);
      }, f2.prototype.iuand = function(s) {
        var u;
        this.length > s.length ? u = s : u = this;
        for (var c = 0;c < u.length; c++)
          this.words[c] = this.words[c] & s.words[c];
        return this.length = u.length, this._strip();
      }, f2.prototype.iand = function(s) {
        return r((this.negative | s.negative) === 0), this.iuand(s);
      }, f2.prototype.and = function(s) {
        return this.length > s.length ? this.clone().iand(s) : s.clone().iand(this);
      }, f2.prototype.uand = function(s) {
        return this.length > s.length ? this.clone().iuand(s) : s.clone().iuand(this);
      }, f2.prototype.iuxor = function(s) {
        var u, c;
        this.length > s.length ? (u = this, c = s) : (u = s, c = this);
        for (var b2 = 0;b2 < c.length; b2++)
          this.words[b2] = u.words[b2] ^ c.words[b2];
        if (this !== u)
          for (;b2 < u.length; b2++)
            this.words[b2] = u.words[b2];
        return this.length = u.length, this._strip();
      }, f2.prototype.ixor = function(s) {
        return r((this.negative | s.negative) === 0), this.iuxor(s);
      }, f2.prototype.xor = function(s) {
        return this.length > s.length ? this.clone().ixor(s) : s.clone().ixor(this);
      }, f2.prototype.uxor = function(s) {
        return this.length > s.length ? this.clone().iuxor(s) : s.clone().iuxor(this);
      }, f2.prototype.inotn = function(s) {
        r(typeof s == "number" && s >= 0);
        var u = Math.ceil(s / 26) | 0, c = s % 26;
        this._expand(u), c > 0 && u--;
        for (var b2 = 0;b2 < u; b2++)
          this.words[b2] = ~this.words[b2] & 67108863;
        return c > 0 && (this.words[b2] = ~this.words[b2] & 67108863 >> 26 - c), this._strip();
      }, f2.prototype.notn = function(s) {
        return this.clone().inotn(s);
      }, f2.prototype.setn = function(s, u) {
        r(typeof s == "number" && s >= 0);
        var c = s / 26 | 0, b2 = s % 26;
        return this._expand(c + 1), u ? this.words[c] = this.words[c] | 1 << b2 : this.words[c] = this.words[c] & ~(1 << b2), this._strip();
      }, f2.prototype.iadd = function(s) {
        var u;
        if (this.negative !== 0 && s.negative === 0)
          return this.negative = 0, u = this.isub(s), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && s.negative !== 0)
          return s.negative = 0, u = this.isub(s), s.negative = 1, u._normSign();
        var c, b2;
        this.length > s.length ? (c = this, b2 = s) : (c = s, b2 = this);
        for (var l = 0, n = 0;n < b2.length; n++)
          u = (c.words[n] | 0) + (b2.words[n] | 0) + l, this.words[n] = u & 67108863, l = u >>> 26;
        for (;l !== 0 && n < c.length; n++)
          u = (c.words[n] | 0) + l, this.words[n] = u & 67108863, l = u >>> 26;
        if (this.length = c.length, l !== 0)
          this.words[this.length] = l, this.length++;
        else if (c !== this)
          for (;n < c.length; n++)
            this.words[n] = c.words[n];
        return this;
      }, f2.prototype.add = function(s) {
        var u;
        return s.negative !== 0 && this.negative === 0 ? (s.negative = 0, u = this.sub(s), s.negative ^= 1, u) : s.negative === 0 && this.negative !== 0 ? (this.negative = 0, u = s.sub(this), this.negative = 1, u) : this.length > s.length ? this.clone().iadd(s) : s.clone().iadd(this);
      }, f2.prototype.isub = function(s) {
        if (s.negative !== 0) {
          s.negative = 0;
          var u = this.iadd(s);
          return s.negative = 1, u._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(s), this.negative = 1, this._normSign();
        var c = this.cmp(s);
        if (c === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var b2, l;
        c > 0 ? (b2 = this, l = s) : (b2 = s, l = this);
        for (var n = 0, d = 0;d < l.length; d++)
          u = (b2.words[d] | 0) - (l.words[d] | 0) + n, n = u >> 26, this.words[d] = u & 67108863;
        for (;n !== 0 && d < b2.length; d++)
          u = (b2.words[d] | 0) + n, n = u >> 26, this.words[d] = u & 67108863;
        if (n === 0 && d < b2.length && b2 !== this)
          for (;d < b2.length; d++)
            this.words[d] = b2.words[d];
        return this.length = Math.max(this.length, d), b2 !== this && (this.negative = 1), this._strip();
      }, f2.prototype.sub = function(s) {
        return this.clone().isub(s);
      };
      function _e(h, s, u) {
        u.negative = s.negative ^ h.negative;
        var c = h.length + s.length | 0;
        u.length = c, c = c - 1 | 0;
        var b2 = h.words[0] | 0, l = s.words[0] | 0, n = b2 * l, d = n & 67108863, w = n / 67108864 | 0;
        u.words[0] = d;
        for (var g = 1;g < c; g++) {
          for (var _2 = w >>> 26, A = w & 67108863, B = Math.min(g, s.length - 1), I = Math.max(0, g - h.length + 1);I <= B; I++) {
            var we = g - I | 0;
            b2 = h.words[we] | 0, l = s.words[I] | 0, n = b2 * l + A, _2 += n / 67108864 | 0, A = n & 67108863;
          }
          u.words[g] = A | 0, w = _2 | 0;
        }
        return w !== 0 ? u.words[g] = w | 0 : u.length--, u._strip();
      }
      var P = function(s, u, c) {
        var b2 = s.words, l = u.words, n = c.words, d = 0, w, g, _2, A = b2[0] | 0, B = A & 8191, I = A >>> 13, we = b2[1] | 0, L = we & 8191, N = we >>> 13, nt = b2[2] | 0, C = nt & 8191, O = nt >>> 13, vt = b2[3] | 0, F = vt & 8191, U = vt >>> 13, bt = b2[4] | 0, z2 = bt & 8191, H = bt >>> 13, mt = b2[5] | 0, W = mt & 8191, K = mt >>> 13, gt = b2[6] | 0, j = gt & 8191, Z = gt >>> 13, yt = b2[7] | 0, V = yt & 8191, $2 = yt >>> 13, wt = b2[8] | 0, G = wt & 8191, Y = wt >>> 13, Mt = b2[9] | 0, X = Mt & 8191, J2 = Mt >>> 13, _t = l[0] | 0, Q2 = _t & 8191, ee = _t >>> 13, xt = l[1] | 0, te = xt & 8191, re = xt >>> 13, St = l[2] | 0, ie = St & 8191, ne = St >>> 13, Et = l[3] | 0, fe = Et & 8191, ae = Et >>> 13, At = l[4] | 0, oe = At & 8191, se = At >>> 13, Rt = l[5] | 0, he = Rt & 8191, ue = Rt >>> 13, Bt = l[6] | 0, le = Bt & 8191, de = Bt >>> 13, qt = l[7] | 0, ce = qt & 8191, pe = qt >>> 13, It = l[8] | 0, ve = It & 8191, be = It >>> 13, ft = l[9] | 0, Be = ft & 8191, qe = ft >>> 13;
        c.negative = s.negative ^ u.negative, c.length = 19, w = Math.imul(B, Q2), g = Math.imul(B, ee), g = g + Math.imul(I, Q2) | 0, _2 = Math.imul(I, ee);
        var ze = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_2 + (g >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, w = Math.imul(L, Q2), g = Math.imul(L, ee), g = g + Math.imul(N, Q2) | 0, _2 = Math.imul(N, ee), w = w + Math.imul(B, te) | 0, g = g + Math.imul(B, re) | 0, g = g + Math.imul(I, te) | 0, _2 = _2 + Math.imul(I, re) | 0;
        var He = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_2 + (g >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, w = Math.imul(C, Q2), g = Math.imul(C, ee), g = g + Math.imul(O, Q2) | 0, _2 = Math.imul(O, ee), w = w + Math.imul(L, te) | 0, g = g + Math.imul(L, re) | 0, g = g + Math.imul(N, te) | 0, _2 = _2 + Math.imul(N, re) | 0, w = w + Math.imul(B, ie) | 0, g = g + Math.imul(B, ne) | 0, g = g + Math.imul(I, ie) | 0, _2 = _2 + Math.imul(I, ne) | 0;
        var We = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_2 + (g >>> 13) | 0) + (We >>> 26) | 0, We &= 67108863, w = Math.imul(F, Q2), g = Math.imul(F, ee), g = g + Math.imul(U, Q2) | 0, _2 = Math.imul(U, ee), w = w + Math.imul(C, te) | 0, g = g + Math.imul(C, re) | 0, g = g + Math.imul(O, te) | 0, _2 = _2 + Math.imul(O, re) | 0, w = w + Math.imul(L, ie) | 0, g = g + Math.imul(L, ne) | 0, g = g + Math.imul(N, ie) | 0, _2 = _2 + Math.imul(N, ne) | 0, w = w + Math.imul(B, fe) | 0, g = g + Math.imul(B, ae) | 0, g = g + Math.imul(I, fe) | 0, _2 = _2 + Math.imul(I, ae) | 0;
        var Ke = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_2 + (g >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, w = Math.imul(z2, Q2), g = Math.imul(z2, ee), g = g + Math.imul(H, Q2) | 0, _2 = Math.imul(H, ee), w = w + Math.imul(F, te) | 0, g = g + Math.imul(F, re) | 0, g = g + Math.imul(U, te) | 0, _2 = _2 + Math.imul(U, re) | 0, w = w + Math.imul(C, ie) | 0, g = g + Math.imul(C, ne) | 0, g = g + Math.imul(O, ie) | 0, _2 = _2 + Math.imul(O, ne) | 0, w = w + Math.imul(L, fe) | 0, g = g + Math.imul(L, ae) | 0, g = g + Math.imul(N, fe) | 0, _2 = _2 + Math.imul(N, ae) | 0, w = w + Math.imul(B, oe) | 0, g = g + Math.imul(B, se) | 0, g = g + Math.imul(I, oe) | 0, _2 = _2 + Math.imul(I, se) | 0;
        var je = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_2 + (g >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, w = Math.imul(W, Q2), g = Math.imul(W, ee), g = g + Math.imul(K, Q2) | 0, _2 = Math.imul(K, ee), w = w + Math.imul(z2, te) | 0, g = g + Math.imul(z2, re) | 0, g = g + Math.imul(H, te) | 0, _2 = _2 + Math.imul(H, re) | 0, w = w + Math.imul(F, ie) | 0, g = g + Math.imul(F, ne) | 0, g = g + Math.imul(U, ie) | 0, _2 = _2 + Math.imul(U, ne) | 0, w = w + Math.imul(C, fe) | 0, g = g + Math.imul(C, ae) | 0, g = g + Math.imul(O, fe) | 0, _2 = _2 + Math.imul(O, ae) | 0, w = w + Math.imul(L, oe) | 0, g = g + Math.imul(L, se) | 0, g = g + Math.imul(N, oe) | 0, _2 = _2 + Math.imul(N, se) | 0, w = w + Math.imul(B, he) | 0, g = g + Math.imul(B, ue) | 0, g = g + Math.imul(I, he) | 0, _2 = _2 + Math.imul(I, ue) | 0;
        var Ze = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_2 + (g >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, w = Math.imul(j, Q2), g = Math.imul(j, ee), g = g + Math.imul(Z, Q2) | 0, _2 = Math.imul(Z, ee), w = w + Math.imul(W, te) | 0, g = g + Math.imul(W, re) | 0, g = g + Math.imul(K, te) | 0, _2 = _2 + Math.imul(K, re) | 0, w = w + Math.imul(z2, ie) | 0, g = g + Math.imul(z2, ne) | 0, g = g + Math.imul(H, ie) | 0, _2 = _2 + Math.imul(H, ne) | 0, w = w + Math.imul(F, fe) | 0, g = g + Math.imul(F, ae) | 0, g = g + Math.imul(U, fe) | 0, _2 = _2 + Math.imul(U, ae) | 0, w = w + Math.imul(C, oe) | 0, g = g + Math.imul(C, se) | 0, g = g + Math.imul(O, oe) | 0, _2 = _2 + Math.imul(O, se) | 0, w = w + Math.imul(L, he) | 0, g = g + Math.imul(L, ue) | 0, g = g + Math.imul(N, he) | 0, _2 = _2 + Math.imul(N, ue) | 0, w = w + Math.imul(B, le) | 0, g = g + Math.imul(B, de) | 0, g = g + Math.imul(I, le) | 0, _2 = _2 + Math.imul(I, de) | 0;
        var Ve = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_2 + (g >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, w = Math.imul(V, Q2), g = Math.imul(V, ee), g = g + Math.imul($2, Q2) | 0, _2 = Math.imul($2, ee), w = w + Math.imul(j, te) | 0, g = g + Math.imul(j, re) | 0, g = g + Math.imul(Z, te) | 0, _2 = _2 + Math.imul(Z, re) | 0, w = w + Math.imul(W, ie) | 0, g = g + Math.imul(W, ne) | 0, g = g + Math.imul(K, ie) | 0, _2 = _2 + Math.imul(K, ne) | 0, w = w + Math.imul(z2, fe) | 0, g = g + Math.imul(z2, ae) | 0, g = g + Math.imul(H, fe) | 0, _2 = _2 + Math.imul(H, ae) | 0, w = w + Math.imul(F, oe) | 0, g = g + Math.imul(F, se) | 0, g = g + Math.imul(U, oe) | 0, _2 = _2 + Math.imul(U, se) | 0, w = w + Math.imul(C, he) | 0, g = g + Math.imul(C, ue) | 0, g = g + Math.imul(O, he) | 0, _2 = _2 + Math.imul(O, ue) | 0, w = w + Math.imul(L, le) | 0, g = g + Math.imul(L, de) | 0, g = g + Math.imul(N, le) | 0, _2 = _2 + Math.imul(N, de) | 0, w = w + Math.imul(B, ce) | 0, g = g + Math.imul(B, pe) | 0, g = g + Math.imul(I, ce) | 0, _2 = _2 + Math.imul(I, pe) | 0;
        var $e = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_2 + (g >>> 13) | 0) + ($e >>> 26) | 0, $e &= 67108863, w = Math.imul(G, Q2), g = Math.imul(G, ee), g = g + Math.imul(Y, Q2) | 0, _2 = Math.imul(Y, ee), w = w + Math.imul(V, te) | 0, g = g + Math.imul(V, re) | 0, g = g + Math.imul($2, te) | 0, _2 = _2 + Math.imul($2, re) | 0, w = w + Math.imul(j, ie) | 0, g = g + Math.imul(j, ne) | 0, g = g + Math.imul(Z, ie) | 0, _2 = _2 + Math.imul(Z, ne) | 0, w = w + Math.imul(W, fe) | 0, g = g + Math.imul(W, ae) | 0, g = g + Math.imul(K, fe) | 0, _2 = _2 + Math.imul(K, ae) | 0, w = w + Math.imul(z2, oe) | 0, g = g + Math.imul(z2, se) | 0, g = g + Math.imul(H, oe) | 0, _2 = _2 + Math.imul(H, se) | 0, w = w + Math.imul(F, he) | 0, g = g + Math.imul(F, ue) | 0, g = g + Math.imul(U, he) | 0, _2 = _2 + Math.imul(U, ue) | 0, w = w + Math.imul(C, le) | 0, g = g + Math.imul(C, de) | 0, g = g + Math.imul(O, le) | 0, _2 = _2 + Math.imul(O, de) | 0, w = w + Math.imul(L, ce) | 0, g = g + Math.imul(L, pe) | 0, g = g + Math.imul(N, ce) | 0, _2 = _2 + Math.imul(N, pe) | 0, w = w + Math.imul(B, ve) | 0, g = g + Math.imul(B, be) | 0, g = g + Math.imul(I, ve) | 0, _2 = _2 + Math.imul(I, be) | 0;
        var Ge = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_2 + (g >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, w = Math.imul(X, Q2), g = Math.imul(X, ee), g = g + Math.imul(J2, Q2) | 0, _2 = Math.imul(J2, ee), w = w + Math.imul(G, te) | 0, g = g + Math.imul(G, re) | 0, g = g + Math.imul(Y, te) | 0, _2 = _2 + Math.imul(Y, re) | 0, w = w + Math.imul(V, ie) | 0, g = g + Math.imul(V, ne) | 0, g = g + Math.imul($2, ie) | 0, _2 = _2 + Math.imul($2, ne) | 0, w = w + Math.imul(j, fe) | 0, g = g + Math.imul(j, ae) | 0, g = g + Math.imul(Z, fe) | 0, _2 = _2 + Math.imul(Z, ae) | 0, w = w + Math.imul(W, oe) | 0, g = g + Math.imul(W, se) | 0, g = g + Math.imul(K, oe) | 0, _2 = _2 + Math.imul(K, se) | 0, w = w + Math.imul(z2, he) | 0, g = g + Math.imul(z2, ue) | 0, g = g + Math.imul(H, he) | 0, _2 = _2 + Math.imul(H, ue) | 0, w = w + Math.imul(F, le) | 0, g = g + Math.imul(F, de) | 0, g = g + Math.imul(U, le) | 0, _2 = _2 + Math.imul(U, de) | 0, w = w + Math.imul(C, ce) | 0, g = g + Math.imul(C, pe) | 0, g = g + Math.imul(O, ce) | 0, _2 = _2 + Math.imul(O, pe) | 0, w = w + Math.imul(L, ve) | 0, g = g + Math.imul(L, be) | 0, g = g + Math.imul(N, ve) | 0, _2 = _2 + Math.imul(N, be) | 0, w = w + Math.imul(B, Be) | 0, g = g + Math.imul(B, qe) | 0, g = g + Math.imul(I, Be) | 0, _2 = _2 + Math.imul(I, qe) | 0;
        var Ye = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_2 + (g >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, w = Math.imul(X, te), g = Math.imul(X, re), g = g + Math.imul(J2, te) | 0, _2 = Math.imul(J2, re), w = w + Math.imul(G, ie) | 0, g = g + Math.imul(G, ne) | 0, g = g + Math.imul(Y, ie) | 0, _2 = _2 + Math.imul(Y, ne) | 0, w = w + Math.imul(V, fe) | 0, g = g + Math.imul(V, ae) | 0, g = g + Math.imul($2, fe) | 0, _2 = _2 + Math.imul($2, ae) | 0, w = w + Math.imul(j, oe) | 0, g = g + Math.imul(j, se) | 0, g = g + Math.imul(Z, oe) | 0, _2 = _2 + Math.imul(Z, se) | 0, w = w + Math.imul(W, he) | 0, g = g + Math.imul(W, ue) | 0, g = g + Math.imul(K, he) | 0, _2 = _2 + Math.imul(K, ue) | 0, w = w + Math.imul(z2, le) | 0, g = g + Math.imul(z2, de) | 0, g = g + Math.imul(H, le) | 0, _2 = _2 + Math.imul(H, de) | 0, w = w + Math.imul(F, ce) | 0, g = g + Math.imul(F, pe) | 0, g = g + Math.imul(U, ce) | 0, _2 = _2 + Math.imul(U, pe) | 0, w = w + Math.imul(C, ve) | 0, g = g + Math.imul(C, be) | 0, g = g + Math.imul(O, ve) | 0, _2 = _2 + Math.imul(O, be) | 0, w = w + Math.imul(L, Be) | 0, g = g + Math.imul(L, qe) | 0, g = g + Math.imul(N, Be) | 0, _2 = _2 + Math.imul(N, qe) | 0;
        var Xe = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_2 + (g >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, w = Math.imul(X, ie), g = Math.imul(X, ne), g = g + Math.imul(J2, ie) | 0, _2 = Math.imul(J2, ne), w = w + Math.imul(G, fe) | 0, g = g + Math.imul(G, ae) | 0, g = g + Math.imul(Y, fe) | 0, _2 = _2 + Math.imul(Y, ae) | 0, w = w + Math.imul(V, oe) | 0, g = g + Math.imul(V, se) | 0, g = g + Math.imul($2, oe) | 0, _2 = _2 + Math.imul($2, se) | 0, w = w + Math.imul(j, he) | 0, g = g + Math.imul(j, ue) | 0, g = g + Math.imul(Z, he) | 0, _2 = _2 + Math.imul(Z, ue) | 0, w = w + Math.imul(W, le) | 0, g = g + Math.imul(W, de) | 0, g = g + Math.imul(K, le) | 0, _2 = _2 + Math.imul(K, de) | 0, w = w + Math.imul(z2, ce) | 0, g = g + Math.imul(z2, pe) | 0, g = g + Math.imul(H, ce) | 0, _2 = _2 + Math.imul(H, pe) | 0, w = w + Math.imul(F, ve) | 0, g = g + Math.imul(F, be) | 0, g = g + Math.imul(U, ve) | 0, _2 = _2 + Math.imul(U, be) | 0, w = w + Math.imul(C, Be) | 0, g = g + Math.imul(C, qe) | 0, g = g + Math.imul(O, Be) | 0, _2 = _2 + Math.imul(O, qe) | 0;
        var Je = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_2 + (g >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, w = Math.imul(X, fe), g = Math.imul(X, ae), g = g + Math.imul(J2, fe) | 0, _2 = Math.imul(J2, ae), w = w + Math.imul(G, oe) | 0, g = g + Math.imul(G, se) | 0, g = g + Math.imul(Y, oe) | 0, _2 = _2 + Math.imul(Y, se) | 0, w = w + Math.imul(V, he) | 0, g = g + Math.imul(V, ue) | 0, g = g + Math.imul($2, he) | 0, _2 = _2 + Math.imul($2, ue) | 0, w = w + Math.imul(j, le) | 0, g = g + Math.imul(j, de) | 0, g = g + Math.imul(Z, le) | 0, _2 = _2 + Math.imul(Z, de) | 0, w = w + Math.imul(W, ce) | 0, g = g + Math.imul(W, pe) | 0, g = g + Math.imul(K, ce) | 0, _2 = _2 + Math.imul(K, pe) | 0, w = w + Math.imul(z2, ve) | 0, g = g + Math.imul(z2, be) | 0, g = g + Math.imul(H, ve) | 0, _2 = _2 + Math.imul(H, be) | 0, w = w + Math.imul(F, Be) | 0, g = g + Math.imul(F, qe) | 0, g = g + Math.imul(U, Be) | 0, _2 = _2 + Math.imul(U, qe) | 0;
        var Qe = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_2 + (g >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, w = Math.imul(X, oe), g = Math.imul(X, se), g = g + Math.imul(J2, oe) | 0, _2 = Math.imul(J2, se), w = w + Math.imul(G, he) | 0, g = g + Math.imul(G, ue) | 0, g = g + Math.imul(Y, he) | 0, _2 = _2 + Math.imul(Y, ue) | 0, w = w + Math.imul(V, le) | 0, g = g + Math.imul(V, de) | 0, g = g + Math.imul($2, le) | 0, _2 = _2 + Math.imul($2, de) | 0, w = w + Math.imul(j, ce) | 0, g = g + Math.imul(j, pe) | 0, g = g + Math.imul(Z, ce) | 0, _2 = _2 + Math.imul(Z, pe) | 0, w = w + Math.imul(W, ve) | 0, g = g + Math.imul(W, be) | 0, g = g + Math.imul(K, ve) | 0, _2 = _2 + Math.imul(K, be) | 0, w = w + Math.imul(z2, Be) | 0, g = g + Math.imul(z2, qe) | 0, g = g + Math.imul(H, Be) | 0, _2 = _2 + Math.imul(H, qe) | 0;
        var et = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_2 + (g >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, w = Math.imul(X, he), g = Math.imul(X, ue), g = g + Math.imul(J2, he) | 0, _2 = Math.imul(J2, ue), w = w + Math.imul(G, le) | 0, g = g + Math.imul(G, de) | 0, g = g + Math.imul(Y, le) | 0, _2 = _2 + Math.imul(Y, de) | 0, w = w + Math.imul(V, ce) | 0, g = g + Math.imul(V, pe) | 0, g = g + Math.imul($2, ce) | 0, _2 = _2 + Math.imul($2, pe) | 0, w = w + Math.imul(j, ve) | 0, g = g + Math.imul(j, be) | 0, g = g + Math.imul(Z, ve) | 0, _2 = _2 + Math.imul(Z, be) | 0, w = w + Math.imul(W, Be) | 0, g = g + Math.imul(W, qe) | 0, g = g + Math.imul(K, Be) | 0, _2 = _2 + Math.imul(K, qe) | 0;
        var tt = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_2 + (g >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, w = Math.imul(X, le), g = Math.imul(X, de), g = g + Math.imul(J2, le) | 0, _2 = Math.imul(J2, de), w = w + Math.imul(G, ce) | 0, g = g + Math.imul(G, pe) | 0, g = g + Math.imul(Y, ce) | 0, _2 = _2 + Math.imul(Y, pe) | 0, w = w + Math.imul(V, ve) | 0, g = g + Math.imul(V, be) | 0, g = g + Math.imul($2, ve) | 0, _2 = _2 + Math.imul($2, be) | 0, w = w + Math.imul(j, Be) | 0, g = g + Math.imul(j, qe) | 0, g = g + Math.imul(Z, Be) | 0, _2 = _2 + Math.imul(Z, qe) | 0;
        var rt = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_2 + (g >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, w = Math.imul(X, ce), g = Math.imul(X, pe), g = g + Math.imul(J2, ce) | 0, _2 = Math.imul(J2, pe), w = w + Math.imul(G, ve) | 0, g = g + Math.imul(G, be) | 0, g = g + Math.imul(Y, ve) | 0, _2 = _2 + Math.imul(Y, be) | 0, w = w + Math.imul(V, Be) | 0, g = g + Math.imul(V, qe) | 0, g = g + Math.imul($2, Be) | 0, _2 = _2 + Math.imul($2, qe) | 0;
        var q0 = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_2 + (g >>> 13) | 0) + (q0 >>> 26) | 0, q0 &= 67108863, w = Math.imul(X, ve), g = Math.imul(X, be), g = g + Math.imul(J2, ve) | 0, _2 = Math.imul(J2, be), w = w + Math.imul(G, Be) | 0, g = g + Math.imul(G, qe) | 0, g = g + Math.imul(Y, Be) | 0, _2 = _2 + Math.imul(Y, qe) | 0;
        var I0 = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_2 + (g >>> 13) | 0) + (I0 >>> 26) | 0, I0 &= 67108863, w = Math.imul(X, Be), g = Math.imul(X, qe), g = g + Math.imul(J2, Be) | 0, _2 = Math.imul(J2, qe);
        var T0 = (d + w | 0) + ((g & 8191) << 13) | 0;
        return d = (_2 + (g >>> 13) | 0) + (T0 >>> 26) | 0, T0 &= 67108863, n[0] = ze, n[1] = He, n[2] = We, n[3] = Ke, n[4] = je, n[5] = Ze, n[6] = Ve, n[7] = $e, n[8] = Ge, n[9] = Ye, n[10] = Xe, n[11] = Je, n[12] = Qe, n[13] = et, n[14] = tt, n[15] = rt, n[16] = q0, n[17] = I0, n[18] = T0, d !== 0 && (n[19] = d, c.length++), c;
      };
      Math.imul || (P = _e);
      function Me(h, s, u) {
        u.negative = s.negative ^ h.negative, u.length = h.length + s.length;
        for (var c = 0, b2 = 0, l = 0;l < u.length - 1; l++) {
          var n = b2;
          b2 = 0;
          for (var d = c & 67108863, w = Math.min(l, s.length - 1), g = Math.max(0, l - h.length + 1);g <= w; g++) {
            var _2 = l - g, A = h.words[_2] | 0, B = s.words[g] | 0, I = A * B, we = I & 67108863;
            n = n + (I / 67108864 | 0) | 0, we = we + d | 0, d = we & 67108863, n = n + (we >>> 26) | 0, b2 += n >>> 26, n &= 67108863;
          }
          u.words[l] = d, c = n, n = b2;
        }
        return c !== 0 ? u.words[l] = c : u.length--, u._strip();
      }
      function me(h, s, u) {
        return Me(h, s, u);
      }
      f2.prototype.mulTo = function(s, u) {
        var c, b2 = this.length + s.length;
        return this.length === 10 && s.length === 10 ? c = P(this, s, u) : b2 < 63 ? c = _e(this, s, u) : b2 < 1024 ? c = Me(this, s, u) : c = me(this, s, u), c;
      };
      function xe(h, s) {
        this.x = h, this.y = s;
      }
      xe.prototype.makeRBT = function(s) {
        for (var u = new Array(s), c = f2.prototype._countBits(s) - 1, b2 = 0;b2 < s; b2++)
          u[b2] = this.revBin(b2, c, s);
        return u;
      }, xe.prototype.revBin = function(s, u, c) {
        if (s === 0 || s === c - 1)
          return s;
        for (var b2 = 0, l = 0;l < u; l++)
          b2 |= (s & 1) << u - l - 1, s >>= 1;
        return b2;
      }, xe.prototype.permute = function(s, u, c, b2, l, n) {
        for (var d = 0;d < n; d++)
          b2[d] = u[s[d]], l[d] = c[s[d]];
      }, xe.prototype.transform = function(s, u, c, b2, l, n) {
        this.permute(n, s, u, c, b2, l);
        for (var d = 1;d < l; d <<= 1)
          for (var w = d << 1, g = Math.cos(2 * Math.PI / w), _2 = Math.sin(2 * Math.PI / w), A = 0;A < l; A += w)
            for (var B = g, I = _2, we = 0;we < d; we++) {
              var L = c[A + we], N = b2[A + we], nt = c[A + we + d], C = b2[A + we + d], O = B * nt - I * C;
              C = B * C + I * nt, nt = O, c[A + we] = L + nt, b2[A + we] = N + C, c[A + we + d] = L - nt, b2[A + we + d] = N - C, we !== w && (O = g * B - _2 * I, I = g * I + _2 * B, B = O);
            }
      }, xe.prototype.guessLen13b = function(s, u) {
        var c = Math.max(u, s) | 1, b2 = c & 1, l = 0;
        for (c = c / 2 | 0;c; c = c >>> 1)
          l++;
        return 1 << l + 1 + b2;
      }, xe.prototype.conjugate = function(s, u, c) {
        if (!(c <= 1))
          for (var b2 = 0;b2 < c / 2; b2++) {
            var l = s[b2];
            s[b2] = s[c - b2 - 1], s[c - b2 - 1] = l, l = u[b2], u[b2] = -u[c - b2 - 1], u[c - b2 - 1] = -l;
          }
      }, xe.prototype.normalize13b = function(s, u) {
        for (var c = 0, b2 = 0;b2 < u / 2; b2++) {
          var l = Math.round(s[2 * b2 + 1] / u) * 8192 + Math.round(s[2 * b2] / u) + c;
          s[b2] = l & 67108863, l < 67108864 ? c = 0 : c = l / 67108864 | 0;
        }
        return s;
      }, xe.prototype.convert13b = function(s, u, c, b2) {
        for (var l = 0, n = 0;n < u; n++)
          l = l + (s[n] | 0), c[2 * n] = l & 8191, l = l >>> 13, c[2 * n + 1] = l & 8191, l = l >>> 13;
        for (n = 2 * u;n < b2; ++n)
          c[n] = 0;
        r(l === 0), r((l & -8192) === 0);
      }, xe.prototype.stub = function(s) {
        for (var u = new Array(s), c = 0;c < s; c++)
          u[c] = 0;
        return u;
      }, xe.prototype.mulp = function(s, u, c) {
        var b2 = 2 * this.guessLen13b(s.length, u.length), l = this.makeRBT(b2), n = this.stub(b2), d = new Array(b2), w = new Array(b2), g = new Array(b2), _2 = new Array(b2), A = new Array(b2), B = new Array(b2), I = c.words;
        I.length = b2, this.convert13b(s.words, s.length, d, b2), this.convert13b(u.words, u.length, _2, b2), this.transform(d, n, w, g, b2, l), this.transform(_2, n, A, B, b2, l);
        for (var we = 0;we < b2; we++) {
          var L = w[we] * A[we] - g[we] * B[we];
          g[we] = w[we] * B[we] + g[we] * A[we], w[we] = L;
        }
        return this.conjugate(w, g, b2), this.transform(w, g, I, n, b2, l), this.conjugate(I, n, b2), this.normalize13b(I, b2), c.negative = s.negative ^ u.negative, c.length = s.length + u.length, c._strip();
      }, f2.prototype.mul = function(s) {
        var u = new f2(null);
        return u.words = new Array(this.length + s.length), this.mulTo(s, u);
      }, f2.prototype.mulf = function(s) {
        var u = new f2(null);
        return u.words = new Array(this.length + s.length), me(this, s, u);
      }, f2.prototype.imul = function(s) {
        return this.clone().mulTo(s, this);
      }, f2.prototype.imuln = function(s) {
        var u = s < 0;
        u && (s = -s), r(typeof s == "number"), r(s < 67108864);
        for (var c = 0, b2 = 0;b2 < this.length; b2++) {
          var l = (this.words[b2] | 0) * s, n = (l & 67108863) + (c & 67108863);
          c >>= 26, c += l / 67108864 | 0, c += n >>> 26, this.words[b2] = n & 67108863;
        }
        return c !== 0 && (this.words[b2] = c, this.length++), u ? this.ineg() : this;
      }, f2.prototype.muln = function(s) {
        return this.clone().imuln(s);
      }, f2.prototype.sqr = function() {
        return this.mul(this);
      }, f2.prototype.isqr = function() {
        return this.imul(this.clone());
      }, f2.prototype.pow = function(s) {
        var u = ye(s);
        if (u.length === 0)
          return new f2(1);
        for (var c = this, b2 = 0;b2 < u.length && u[b2] === 0; b2++, c = c.sqr())
          ;
        if (++b2 < u.length)
          for (var l = c.sqr();b2 < u.length; b2++, l = l.sqr())
            u[b2] !== 0 && (c = c.mul(l));
        return c;
      }, f2.prototype.iushln = function(s) {
        r(typeof s == "number" && s >= 0);
        var u = s % 26, c = (s - u) / 26, b2 = 67108863 >>> 26 - u << 26 - u, l;
        if (u !== 0) {
          var n = 0;
          for (l = 0;l < this.length; l++) {
            var d = this.words[l] & b2, w = (this.words[l] | 0) - d << u;
            this.words[l] = w | n, n = d >>> 26 - u;
          }
          n && (this.words[l] = n, this.length++);
        }
        if (c !== 0) {
          for (l = this.length - 1;l >= 0; l--)
            this.words[l + c] = this.words[l];
          for (l = 0;l < c; l++)
            this.words[l] = 0;
          this.length += c;
        }
        return this._strip();
      }, f2.prototype.ishln = function(s) {
        return r(this.negative === 0), this.iushln(s);
      }, f2.prototype.iushrn = function(s, u, c) {
        r(typeof s == "number" && s >= 0);
        var b2;
        u ? b2 = (u - u % 26) / 26 : b2 = 0;
        var l = s % 26, n = Math.min((s - l) / 26, this.length), d = 67108863 ^ 67108863 >>> l << l, w = c;
        if (b2 -= n, b2 = Math.max(0, b2), w) {
          for (var g = 0;g < n; g++)
            w.words[g] = this.words[g];
          w.length = n;
        }
        if (n !== 0)
          if (this.length > n)
            for (this.length -= n, g = 0;g < this.length; g++)
              this.words[g] = this.words[g + n];
          else
            this.words[0] = 0, this.length = 1;
        var _2 = 0;
        for (g = this.length - 1;g >= 0 && (_2 !== 0 || g >= b2); g--) {
          var A = this.words[g] | 0;
          this.words[g] = _2 << 26 - l | A >>> l, _2 = A & d;
        }
        return w && _2 !== 0 && (w.words[w.length++] = _2), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
      }, f2.prototype.ishrn = function(s, u, c) {
        return r(this.negative === 0), this.iushrn(s, u, c);
      }, f2.prototype.shln = function(s) {
        return this.clone().ishln(s);
      }, f2.prototype.ushln = function(s) {
        return this.clone().iushln(s);
      }, f2.prototype.shrn = function(s) {
        return this.clone().ishrn(s);
      }, f2.prototype.ushrn = function(s) {
        return this.clone().iushrn(s);
      }, f2.prototype.testn = function(s) {
        r(typeof s == "number" && s >= 0);
        var u = s % 26, c = (s - u) / 26, b2 = 1 << u;
        if (this.length <= c)
          return false;
        var l = this.words[c];
        return !!(l & b2);
      }, f2.prototype.imaskn = function(s) {
        r(typeof s == "number" && s >= 0);
        var u = s % 26, c = (s - u) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= c)
          return this;
        if (u !== 0 && c++, this.length = Math.min(c, this.length), u !== 0) {
          var b2 = 67108863 ^ 67108863 >>> u << u;
          this.words[this.length - 1] &= b2;
        }
        return this._strip();
      }, f2.prototype.maskn = function(s) {
        return this.clone().imaskn(s);
      }, f2.prototype.iaddn = function(s) {
        return r(typeof s == "number"), r(s < 67108864), s < 0 ? this.isubn(-s) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= s ? (this.words[0] = s - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(s), this.negative = 1, this) : this._iaddn(s);
      }, f2.prototype._iaddn = function(s) {
        this.words[0] += s;
        for (var u = 0;u < this.length && this.words[u] >= 67108864; u++)
          this.words[u] -= 67108864, u === this.length - 1 ? this.words[u + 1] = 1 : this.words[u + 1]++;
        return this.length = Math.max(this.length, u + 1), this;
      }, f2.prototype.isubn = function(s) {
        if (r(typeof s == "number"), r(s < 67108864), s < 0)
          return this.iaddn(-s);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(s), this.negative = 1, this;
        if (this.words[0] -= s, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var u = 0;u < this.length && this.words[u] < 0; u++)
            this.words[u] += 67108864, this.words[u + 1] -= 1;
        return this._strip();
      }, f2.prototype.addn = function(s) {
        return this.clone().iaddn(s);
      }, f2.prototype.subn = function(s) {
        return this.clone().isubn(s);
      }, f2.prototype.iabs = function() {
        return this.negative = 0, this;
      }, f2.prototype.abs = function() {
        return this.clone().iabs();
      }, f2.prototype._ishlnsubmul = function(s, u, c) {
        var b2 = s.length + c, l;
        this._expand(b2);
        var n, d = 0;
        for (l = 0;l < s.length; l++) {
          n = (this.words[l + c] | 0) + d;
          var w = (s.words[l] | 0) * u;
          n -= w & 67108863, d = (n >> 26) - (w / 67108864 | 0), this.words[l + c] = n & 67108863;
        }
        for (;l < this.length - c; l++)
          n = (this.words[l + c] | 0) + d, d = n >> 26, this.words[l + c] = n & 67108863;
        if (d === 0)
          return this._strip();
        for (r(d === -1), d = 0, l = 0;l < this.length; l++)
          n = -(this.words[l] | 0) + d, d = n >> 26, this.words[l] = n & 67108863;
        return this.negative = 1, this._strip();
      }, f2.prototype._wordDiv = function(s, u) {
        var c = this.length - s.length, b2 = this.clone(), l = s, n = l.words[l.length - 1] | 0, d = this._countBits(n);
        c = 26 - d, c !== 0 && (l = l.ushln(c), b2.iushln(c), n = l.words[l.length - 1] | 0);
        var w = b2.length - l.length, g;
        if (u !== "mod") {
          g = new f2(null), g.length = w + 1, g.words = new Array(g.length);
          for (var _2 = 0;_2 < g.length; _2++)
            g.words[_2] = 0;
        }
        var A = b2.clone()._ishlnsubmul(l, 1, w);
        A.negative === 0 && (b2 = A, g && (g.words[w] = 1));
        for (var B = w - 1;B >= 0; B--) {
          var I = (b2.words[l.length + B] | 0) * 67108864 + (b2.words[l.length + B - 1] | 0);
          for (I = Math.min(I / n | 0, 67108863), b2._ishlnsubmul(l, I, B);b2.negative !== 0; )
            I--, b2.negative = 0, b2._ishlnsubmul(l, 1, B), b2.isZero() || (b2.negative ^= 1);
          g && (g.words[B] = I);
        }
        return g && g._strip(), b2._strip(), u !== "div" && c !== 0 && b2.iushrn(c), { div: g || null, mod: b2 };
      }, f2.prototype.divmod = function(s, u, c) {
        if (r(!s.isZero()), this.isZero())
          return { div: new f2(0), mod: new f2(0) };
        var b2, l, n;
        return this.negative !== 0 && s.negative === 0 ? (n = this.neg().divmod(s, u), u !== "mod" && (b2 = n.div.neg()), u !== "div" && (l = n.mod.neg(), c && l.negative !== 0 && l.iadd(s)), { div: b2, mod: l }) : this.negative === 0 && s.negative !== 0 ? (n = this.divmod(s.neg(), u), u !== "mod" && (b2 = n.div.neg()), { div: b2, mod: n.mod }) : (this.negative & s.negative) !== 0 ? (n = this.neg().divmod(s.neg(), u), u !== "div" && (l = n.mod.neg(), c && l.negative !== 0 && l.isub(s)), { div: n.div, mod: l }) : s.length > this.length || this.cmp(s) < 0 ? { div: new f2(0), mod: this } : s.length === 1 ? u === "div" ? { div: this.divn(s.words[0]), mod: null } : u === "mod" ? { div: null, mod: new f2(this.modrn(s.words[0])) } : { div: this.divn(s.words[0]), mod: new f2(this.modrn(s.words[0])) } : this._wordDiv(s, u);
      }, f2.prototype.div = function(s) {
        return this.divmod(s, "div", false).div;
      }, f2.prototype.mod = function(s) {
        return this.divmod(s, "mod", false).mod;
      }, f2.prototype.umod = function(s) {
        return this.divmod(s, "mod", true).mod;
      }, f2.prototype.divRound = function(s) {
        var u = this.divmod(s);
        if (u.mod.isZero())
          return u.div;
        var c = u.div.negative !== 0 ? u.mod.isub(s) : u.mod, b2 = s.ushrn(1), l = s.andln(1), n = c.cmp(b2);
        return n < 0 || l === 1 && n === 0 ? u.div : u.div.negative !== 0 ? u.div.isubn(1) : u.div.iaddn(1);
      }, f2.prototype.modrn = function(s) {
        var u = s < 0;
        u && (s = -s), r(s <= 67108863);
        for (var c = (1 << 26) % s, b2 = 0, l = this.length - 1;l >= 0; l--)
          b2 = (c * b2 + (this.words[l] | 0)) % s;
        return u ? -b2 : b2;
      }, f2.prototype.modn = function(s) {
        return this.modrn(s);
      }, f2.prototype.idivn = function(s) {
        var u = s < 0;
        u && (s = -s), r(s <= 67108863);
        for (var c = 0, b2 = this.length - 1;b2 >= 0; b2--) {
          var l = (this.words[b2] | 0) + c * 67108864;
          this.words[b2] = l / s | 0, c = l % s;
        }
        return this._strip(), u ? this.ineg() : this;
      }, f2.prototype.divn = function(s) {
        return this.clone().idivn(s);
      }, f2.prototype.egcd = function(s) {
        r(s.negative === 0), r(!s.isZero());
        var u = this, c = s.clone();
        u.negative !== 0 ? u = u.umod(s) : u = u.clone();
        for (var b2 = new f2(1), l = new f2(0), n = new f2(0), d = new f2(1), w = 0;u.isEven() && c.isEven(); )
          u.iushrn(1), c.iushrn(1), ++w;
        for (var g = c.clone(), _2 = u.clone();!u.isZero(); ) {
          for (var A = 0, B = 1;(u.words[0] & B) === 0 && A < 26; ++A, B <<= 1)
            ;
          if (A > 0)
            for (u.iushrn(A);A-- > 0; )
              (b2.isOdd() || l.isOdd()) && (b2.iadd(g), l.isub(_2)), b2.iushrn(1), l.iushrn(1);
          for (var I = 0, we = 1;(c.words[0] & we) === 0 && I < 26; ++I, we <<= 1)
            ;
          if (I > 0)
            for (c.iushrn(I);I-- > 0; )
              (n.isOdd() || d.isOdd()) && (n.iadd(g), d.isub(_2)), n.iushrn(1), d.iushrn(1);
          u.cmp(c) >= 0 ? (u.isub(c), b2.isub(n), l.isub(d)) : (c.isub(u), n.isub(b2), d.isub(l));
        }
        return { a: n, b: d, gcd: c.iushln(w) };
      }, f2.prototype._invmp = function(s) {
        r(s.negative === 0), r(!s.isZero());
        var u = this, c = s.clone();
        u.negative !== 0 ? u = u.umod(s) : u = u.clone();
        for (var b2 = new f2(1), l = new f2(0), n = c.clone();u.cmpn(1) > 0 && c.cmpn(1) > 0; ) {
          for (var d = 0, w = 1;(u.words[0] & w) === 0 && d < 26; ++d, w <<= 1)
            ;
          if (d > 0)
            for (u.iushrn(d);d-- > 0; )
              b2.isOdd() && b2.iadd(n), b2.iushrn(1);
          for (var g = 0, _2 = 1;(c.words[0] & _2) === 0 && g < 26; ++g, _2 <<= 1)
            ;
          if (g > 0)
            for (c.iushrn(g);g-- > 0; )
              l.isOdd() && l.iadd(n), l.iushrn(1);
          u.cmp(c) >= 0 ? (u.isub(c), b2.isub(l)) : (c.isub(u), l.isub(b2));
        }
        var A;
        return u.cmpn(1) === 0 ? A = b2 : A = l, A.cmpn(0) < 0 && A.iadd(s), A;
      }, f2.prototype.gcd = function(s) {
        if (this.isZero())
          return s.abs();
        if (s.isZero())
          return this.abs();
        var u = this.clone(), c = s.clone();
        u.negative = 0, c.negative = 0;
        for (var b2 = 0;u.isEven() && c.isEven(); b2++)
          u.iushrn(1), c.iushrn(1);
        do {
          for (;u.isEven(); )
            u.iushrn(1);
          for (;c.isEven(); )
            c.iushrn(1);
          var l = u.cmp(c);
          if (l < 0) {
            var n = u;
            u = c, c = n;
          } else if (l === 0 || c.cmpn(1) === 0)
            break;
          u.isub(c);
        } while (true);
        return c.iushln(b2);
      }, f2.prototype.invm = function(s) {
        return this.egcd(s).a.umod(s);
      }, f2.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, f2.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, f2.prototype.andln = function(s) {
        return this.words[0] & s;
      }, f2.prototype.bincn = function(s) {
        r(typeof s == "number");
        var u = s % 26, c = (s - u) / 26, b2 = 1 << u;
        if (this.length <= c)
          return this._expand(c + 1), this.words[c] |= b2, this;
        for (var l = b2, n = c;l !== 0 && n < this.length; n++) {
          var d = this.words[n] | 0;
          d += l, l = d >>> 26, d &= 67108863, this.words[n] = d;
        }
        return l !== 0 && (this.words[n] = l, this.length++), this;
      }, f2.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, f2.prototype.cmpn = function(s) {
        var u = s < 0;
        if (this.negative !== 0 && !u)
          return -1;
        if (this.negative === 0 && u)
          return 1;
        this._strip();
        var c;
        if (this.length > 1)
          c = 1;
        else {
          u && (s = -s), r(s <= 67108863, "Number is too big");
          var b2 = this.words[0] | 0;
          c = b2 === s ? 0 : b2 < s ? -1 : 1;
        }
        return this.negative !== 0 ? -c | 0 : c;
      }, f2.prototype.cmp = function(s) {
        if (this.negative !== 0 && s.negative === 0)
          return -1;
        if (this.negative === 0 && s.negative !== 0)
          return 1;
        var u = this.ucmp(s);
        return this.negative !== 0 ? -u | 0 : u;
      }, f2.prototype.ucmp = function(s) {
        if (this.length > s.length)
          return 1;
        if (this.length < s.length)
          return -1;
        for (var u = 0, c = this.length - 1;c >= 0; c--) {
          var b2 = this.words[c] | 0, l = s.words[c] | 0;
          if (b2 !== l) {
            b2 < l ? u = -1 : b2 > l && (u = 1);
            break;
          }
        }
        return u;
      }, f2.prototype.gtn = function(s) {
        return this.cmpn(s) === 1;
      }, f2.prototype.gt = function(s) {
        return this.cmp(s) === 1;
      }, f2.prototype.gten = function(s) {
        return this.cmpn(s) >= 0;
      }, f2.prototype.gte = function(s) {
        return this.cmp(s) >= 0;
      }, f2.prototype.ltn = function(s) {
        return this.cmpn(s) === -1;
      }, f2.prototype.lt = function(s) {
        return this.cmp(s) === -1;
      }, f2.prototype.lten = function(s) {
        return this.cmpn(s) <= 0;
      }, f2.prototype.lte = function(s) {
        return this.cmp(s) <= 0;
      }, f2.prototype.eqn = function(s) {
        return this.cmpn(s) === 0;
      }, f2.prototype.eq = function(s) {
        return this.cmp(s) === 0;
      }, f2.red = function(s) {
        return new i(s);
      }, f2.prototype.toRed = function(s) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), s.convertTo(this)._forceRed(s);
      }, f2.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, f2.prototype._forceRed = function(s) {
        return this.red = s, this;
      }, f2.prototype.forceRed = function(s) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(s);
      }, f2.prototype.redAdd = function(s) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, s);
      }, f2.prototype.redIAdd = function(s) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, s);
      }, f2.prototype.redSub = function(s) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, s);
      }, f2.prototype.redISub = function(s) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, s);
      }, f2.prototype.redShl = function(s) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, s);
      }, f2.prototype.redMul = function(s) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, s), this.red.mul(this, s);
      }, f2.prototype.redIMul = function(s) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, s), this.red.imul(this, s);
      }, f2.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, f2.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, f2.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, f2.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, f2.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, f2.prototype.redPow = function(s) {
        return r(this.red && !s.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, s);
      };
      var Ae = { k256: null, p224: null, p192: null, p25519: null };
      function Ee(h, s) {
        this.name = h, this.p = new f2(s, 16), this.n = this.p.bitLength(), this.k = new f2(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      Ee.prototype._tmp = function() {
        var s = new f2(null);
        return s.words = new Array(Math.ceil(this.n / 13)), s;
      }, Ee.prototype.ireduce = function(s) {
        var u = s, c;
        do
          this.split(u, this.tmp), u = this.imulK(u), u = u.iadd(this.tmp), c = u.bitLength();
        while (c > this.n);
        var b2 = c < this.n ? -1 : u.ucmp(this.p);
        return b2 === 0 ? (u.words[0] = 0, u.length = 1) : b2 > 0 ? u.isub(this.p) : u.strip !== undefined ? u.strip() : u._strip(), u;
      }, Ee.prototype.split = function(s, u) {
        s.iushrn(this.n, 0, u);
      }, Ee.prototype.imulK = function(s) {
        return s.imul(this.k);
      };
      function Re() {
        Ee.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      o(Re, Ee), Re.prototype.split = function(s, u) {
        for (var c = 4194303, b2 = Math.min(s.length, 9), l = 0;l < b2; l++)
          u.words[l] = s.words[l];
        if (u.length = b2, s.length <= 9) {
          s.words[0] = 0, s.length = 1;
          return;
        }
        var n = s.words[9];
        for (u.words[u.length++] = n & c, l = 10;l < s.length; l++) {
          var d = s.words[l] | 0;
          s.words[l - 10] = (d & c) << 4 | n >>> 22, n = d;
        }
        n >>>= 22, s.words[l - 10] = n, n === 0 && s.length > 10 ? s.length -= 10 : s.length -= 9;
      }, Re.prototype.imulK = function(s) {
        s.words[s.length] = 0, s.words[s.length + 1] = 0, s.length += 2;
        for (var u = 0, c = 0;c < s.length; c++) {
          var b2 = s.words[c] | 0;
          u += b2 * 977, s.words[c] = u & 67108863, u = b2 * 64 + (u / 67108864 | 0);
        }
        return s.words[s.length - 1] === 0 && (s.length--, s.words[s.length - 1] === 0 && s.length--), s;
      };
      function D2() {
        Ee.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      o(D2, Ee);
      function Se() {
        Ee.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      o(Se, Ee);
      function v2() {
        Ee.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      o(v2, Ee), v2.prototype.imulK = function(s) {
        for (var u = 0, c = 0;c < s.length; c++) {
          var b2 = (s.words[c] | 0) * 19 + u, l = b2 & 67108863;
          b2 >>>= 26, s.words[c] = l, u = b2;
        }
        return u !== 0 && (s.words[s.length++] = u), s;
      }, f2._prime = function(s) {
        if (Ae[s])
          return Ae[s];
        var u;
        if (s === "k256")
          u = new Re;
        else if (s === "p224")
          u = new D2;
        else if (s === "p192")
          u = new Se;
        else if (s === "p25519")
          u = new v2;
        else
          throw new Error("Unknown prime " + s);
        return Ae[s] = u, u;
      };
      function i(h) {
        if (typeof h == "string") {
          var s = f2._prime(h);
          this.m = s.p, this.prime = s;
        } else
          r(h.gtn(1), "modulus must be greater than 1"), this.m = h, this.prime = null;
      }
      i.prototype._verify1 = function(s) {
        r(s.negative === 0, "red works only with positives"), r(s.red, "red works only with red numbers");
      }, i.prototype._verify2 = function(s, u) {
        r((s.negative | u.negative) === 0, "red works only with positives"), r(s.red && s.red === u.red, "red works only with red numbers");
      }, i.prototype.imod = function(s) {
        return this.prime ? this.prime.ireduce(s)._forceRed(this) : (x(s, s.umod(this.m)._forceRed(this)), s);
      }, i.prototype.neg = function(s) {
        return s.isZero() ? s.clone() : this.m.sub(s)._forceRed(this);
      }, i.prototype.add = function(s, u) {
        this._verify2(s, u);
        var c = s.add(u);
        return c.cmp(this.m) >= 0 && c.isub(this.m), c._forceRed(this);
      }, i.prototype.iadd = function(s, u) {
        this._verify2(s, u);
        var c = s.iadd(u);
        return c.cmp(this.m) >= 0 && c.isub(this.m), c;
      }, i.prototype.sub = function(s, u) {
        this._verify2(s, u);
        var c = s.sub(u);
        return c.cmpn(0) < 0 && c.iadd(this.m), c._forceRed(this);
      }, i.prototype.isub = function(s, u) {
        this._verify2(s, u);
        var c = s.isub(u);
        return c.cmpn(0) < 0 && c.iadd(this.m), c;
      }, i.prototype.shl = function(s, u) {
        return this._verify1(s), this.imod(s.ushln(u));
      }, i.prototype.imul = function(s, u) {
        return this._verify2(s, u), this.imod(s.imul(u));
      }, i.prototype.mul = function(s, u) {
        return this._verify2(s, u), this.imod(s.mul(u));
      }, i.prototype.isqr = function(s) {
        return this.imul(s, s.clone());
      }, i.prototype.sqr = function(s) {
        return this.mul(s, s);
      }, i.prototype.sqrt = function(s) {
        if (s.isZero())
          return s.clone();
        var u = this.m.andln(3);
        if (r(u % 2 === 1), u === 3) {
          var c = this.m.add(new f2(1)).iushrn(2);
          return this.pow(s, c);
        }
        for (var b2 = this.m.subn(1), l = 0;!b2.isZero() && b2.andln(1) === 0; )
          l++, b2.iushrn(1);
        r(!b2.isZero());
        var n = new f2(1).toRed(this), d = n.redNeg(), w = this.m.subn(1).iushrn(1), g = this.m.bitLength();
        for (g = new f2(2 * g * g).toRed(this);this.pow(g, w).cmp(d) !== 0; )
          g.redIAdd(d);
        for (var _2 = this.pow(g, b2), A = this.pow(s, b2.addn(1).iushrn(1)), B = this.pow(s, b2), I = l;B.cmp(n) !== 0; ) {
          for (var we = B, L = 0;we.cmp(n) !== 0; L++)
            we = we.redSqr();
          r(L < I);
          var N = this.pow(_2, new f2(1).iushln(I - L - 1));
          A = A.redMul(N), _2 = N.redSqr(), B = B.redMul(_2), I = L;
        }
        return A;
      }, i.prototype.invm = function(s) {
        var u = s._invmp(this.m);
        return u.negative !== 0 ? (u.negative = 0, this.imod(u).redNeg()) : this.imod(u);
      }, i.prototype.pow = function(s, u) {
        if (u.isZero())
          return new f2(1).toRed(this);
        if (u.cmpn(1) === 0)
          return s.clone();
        var c = 4, b2 = new Array(1 << c);
        b2[0] = new f2(1).toRed(this), b2[1] = s;
        for (var l = 2;l < b2.length; l++)
          b2[l] = this.mul(b2[l - 1], s);
        var n = b2[0], d = 0, w = 0, g = u.bitLength() % 26;
        for (g === 0 && (g = 26), l = u.length - 1;l >= 0; l--) {
          for (var _2 = u.words[l], A = g - 1;A >= 0; A--) {
            var B = _2 >> A & 1;
            if (n !== b2[0] && (n = this.sqr(n)), B === 0 && d === 0) {
              w = 0;
              continue;
            }
            d <<= 1, d |= B, w++, !(w !== c && (l !== 0 || A !== 0)) && (n = this.mul(n, b2[d]), w = 0, d = 0);
          }
          g = 26;
        }
        return n;
      }, i.prototype.convertTo = function(s) {
        var u = s.umod(this.m);
        return u === s ? u.clone() : u;
      }, i.prototype.convertFrom = function(s) {
        var u = s.clone();
        return u.red = null, u;
      }, f2.mont = function(s) {
        return new a(s);
      };
      function a(h) {
        i.call(this, h), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f2(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o(a, i), a.prototype.convertTo = function(s) {
        return this.imod(s.ushln(this.shift));
      }, a.prototype.convertFrom = function(s) {
        var u = this.imod(s.mul(this.rinv));
        return u.red = null, u;
      }, a.prototype.imul = function(s, u) {
        if (s.isZero() || u.isZero())
          return s.words[0] = 0, s.length = 1, s;
        var c = s.imul(u), b2 = c.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), l = c.isub(b2).iushrn(this.shift), n = l;
        return l.cmp(this.m) >= 0 ? n = l.isub(this.m) : l.cmpn(0) < 0 && (n = l.iadd(this.m)), n._forceRed(this);
      }, a.prototype.mul = function(s, u) {
        if (s.isZero() || u.isZero())
          return new f2(0)._forceRed(this);
        var c = s.mul(u), b2 = c.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), l = c.isub(b2).iushrn(this.shift), n = l;
        return l.cmp(this.m) >= 0 ? n = l.isub(this.m) : l.cmpn(0) < 0 && (n = l.iadd(this.m)), n._forceRed(this);
      }, a.prototype.invm = function(s) {
        var u = this.imod(s._invmp(this.m).mul(this.r2));
        return u._forceRed(this);
      };
    })(typeof Gl > "u" || Gl, T2);
  });
  Gs = k((lL, N2) => {
    var If = $s(), QA = hn();
    function eR(t) {
      var e = k2(t), r = e.toRed(If.mont(t.modulus)).redPow(new If(t.publicExponent)).fromRed();
      return { blinder: r, unblinder: e.invm(t.modulus) };
    }
    function k2(t) {
      var e = t.modulus.byteLength(), r;
      do
        r = new If(QA(e));
      while (r.cmp(t.modulus) >= 0 || !r.umod(t.prime1) || !r.umod(t.prime2));
      return r;
    }
    function L2(t, e) {
      var r = eR(e), o = e.modulus.byteLength(), f2 = new If(t).mul(r.blinder).umod(e.modulus), p = f2.toRed(If.mont(e.prime1)), m = f2.toRed(If.mont(e.prime2)), y = e.coefficient, M = e.prime1, x = e.prime2, S2 = p.redPow(e.exponent1).fromRed(), E = m.redPow(e.exponent2).fromRed(), R = S2.isub(E).imul(y).umod(M).imul(x);
      return E.iadd(R).imul(r.unblinder).umod(e.modulus).toArrayLike(Buffer, "be", o);
    }
    L2.getr = k2;
    N2.exports = L2;
  });
  P2 = k((dL, tR) => {
    tR.exports = { name: "elliptic", version: "6.5.4", description: "EC cryptography", main: "lib/elliptic.js", files: ["lib"], scripts: { lint: "eslint lib test", "lint:fix": "npm run lint -- --fix", unit: "istanbul test _mocha --reporter=spec test/index.js", test: "npm run lint && npm run unit", version: "grunt dist && git add dist/" }, repository: { type: "git", url: "git@github.com:indutny/elliptic" }, keywords: ["EC", "Elliptic", "curve", "Cryptography"], author: "Fedor Indutny <fedor@indutny.com>", license: "MIT", bugs: { url: "https://github.com/indutny/elliptic/issues" }, homepage: "https://github.com/indutny/elliptic", devDependencies: { brfs: "^2.0.2", coveralls: "^3.1.0", eslint: "^7.6.0", grunt: "^1.2.1", "grunt-browserify": "^5.3.0", "grunt-cli": "^1.3.2", "grunt-contrib-connect": "^3.0.0", "grunt-contrib-copy": "^1.0.0", "grunt-contrib-uglify": "^5.0.0", "grunt-mocha-istanbul": "^5.0.2", "grunt-saucelabs": "^9.0.1", istanbul: "^0.4.5", mocha: "^8.0.1" }, dependencies: { "bn.js": "^4.11.9", brorand: "^1.1.0", "hash.js": "^1.0.0", "hmac-drbg": "^1.0.1", inherits: "^2.0.4", "minimalistic-assert": "^1.0.1", "minimalistic-crypto-utils": "^1.0.1" } };
  });
  fi = k((D2, Yl) => {
    (function(t, e) {
      function r(v2, i) {
        if (!v2)
          throw new Error(i || "Assertion failed");
      }
      function o(v2, i) {
        v2.super_ = i;
        var a = function() {
        };
        a.prototype = i.prototype, v2.prototype = new a, v2.prototype.constructor = v2;
      }
      function f2(v2, i, a) {
        if (f2.isBN(v2))
          return v2;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, v2 !== null && ((i === "le" || i === "be") && (a = i, i = 10), this._init(v2 || 0, i || 10, a || "be"));
      }
      typeof t == "object" ? t.exports = f2 : e.BN = f2, f2.BN = f2, f2.wordSize = 26;
      var p;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? p = window.Buffer : p = Vi().Buffer;
      } catch {
      }
      f2.isBN = function(i) {
        return i instanceof f2 ? true : i !== null && typeof i == "object" && i.constructor.wordSize === f2.wordSize && Array.isArray(i.words);
      }, f2.max = function(i, a) {
        return i.cmp(a) > 0 ? i : a;
      }, f2.min = function(i, a) {
        return i.cmp(a) < 0 ? i : a;
      }, f2.prototype._init = function(i, a, h) {
        if (typeof i == "number")
          return this._initNumber(i, a, h);
        if (typeof i == "object")
          return this._initArray(i, a, h);
        a === "hex" && (a = 16), r(a === (a | 0) && a >= 2 && a <= 36), i = i.toString().replace(/\s+/g, "");
        var s = 0;
        i[0] === "-" && (s++, this.negative = 1), s < i.length && (a === 16 ? this._parseHex(i, s, h) : (this._parseBase(i, a, s), h === "le" && this._initArray(this.toArray(), a, h)));
      }, f2.prototype._initNumber = function(i, a, h) {
        i < 0 && (this.negative = 1, i = -i), i < 67108864 ? (this.words = [i & 67108863], this.length = 1) : i < 4503599627370496 ? (this.words = [i & 67108863, i / 67108864 & 67108863], this.length = 2) : (r(i < 9007199254740992), this.words = [i & 67108863, i / 67108864 & 67108863, 1], this.length = 3), h === "le" && this._initArray(this.toArray(), a, h);
      }, f2.prototype._initArray = function(i, a, h) {
        if (r(typeof i.length == "number"), i.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(i.length / 3), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u, c, b2 = 0;
        if (h === "be")
          for (s = i.length - 1, u = 0;s >= 0; s -= 3)
            c = i[s] | i[s - 1] << 8 | i[s - 2] << 16, this.words[u] |= c << b2 & 67108863, this.words[u + 1] = c >>> 26 - b2 & 67108863, b2 += 24, b2 >= 26 && (b2 -= 26, u++);
        else if (h === "le")
          for (s = 0, u = 0;s < i.length; s += 3)
            c = i[s] | i[s + 1] << 8 | i[s + 2] << 16, this.words[u] |= c << b2 & 67108863, this.words[u + 1] = c >>> 26 - b2 & 67108863, b2 += 24, b2 >= 26 && (b2 -= 26, u++);
        return this.strip();
      };
      function m(v2, i) {
        var a = v2.charCodeAt(i);
        return a >= 65 && a <= 70 ? a - 55 : a >= 97 && a <= 102 ? a - 87 : a - 48 & 15;
      }
      function y(v2, i, a) {
        var h = m(v2, a);
        return a - 1 >= i && (h |= m(v2, a - 1) << 4), h;
      }
      f2.prototype._parseHex = function(i, a, h) {
        this.length = Math.ceil((i.length - a) / 6), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u = 0, c = 0, b2;
        if (h === "be")
          for (s = i.length - 1;s >= a; s -= 2)
            b2 = y(i, a, s) << u, this.words[c] |= b2 & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b2 >>> 26) : u += 8;
        else {
          var l = i.length - a;
          for (s = l % 2 === 0 ? a + 1 : a;s < i.length; s += 2)
            b2 = y(i, a, s) << u, this.words[c] |= b2 & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b2 >>> 26) : u += 8;
        }
        this.strip();
      };
      function M(v2, i, a, h) {
        for (var s = 0, u = Math.min(v2.length, a), c = i;c < u; c++) {
          var b2 = v2.charCodeAt(c) - 48;
          s *= h, b2 >= 49 ? s += b2 - 49 + 10 : b2 >= 17 ? s += b2 - 17 + 10 : s += b2;
        }
        return s;
      }
      f2.prototype._parseBase = function(i, a, h) {
        this.words = [0], this.length = 1;
        for (var s = 0, u = 1;u <= 67108863; u *= a)
          s++;
        s--, u = u / a | 0;
        for (var c = i.length - h, b2 = c % s, l = Math.min(c, c - b2) + h, n = 0, d = h;d < l; d += s)
          n = M(i, d, d + s, a), this.imuln(u), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        if (b2 !== 0) {
          var w = 1;
          for (n = M(i, d, i.length, a), d = 0;d < b2; d++)
            w *= a;
          this.imuln(w), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        }
        this.strip();
      }, f2.prototype.copy = function(i) {
        i.words = new Array(this.length);
        for (var a = 0;a < this.length; a++)
          i.words[a] = this.words[a];
        i.length = this.length, i.negative = this.negative, i.red = this.red;
      }, f2.prototype.clone = function() {
        var i = new f2(null);
        return this.copy(i), i;
      }, f2.prototype._expand = function(i) {
        for (;this.length < i; )
          this.words[this.length++] = 0;
        return this;
      }, f2.prototype.strip = function() {
        for (;this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, f2.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, f2.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var x = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], S2 = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], E = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      f2.prototype.toString = function(i, a) {
        i = i || 10, a = a | 0 || 1;
        var h;
        if (i === 16 || i === "hex") {
          h = "";
          for (var s = 0, u = 0, c = 0;c < this.length; c++) {
            var b2 = this.words[c], l = ((b2 << s | u) & 16777215).toString(16);
            u = b2 >>> 24 - s & 16777215, u !== 0 || c !== this.length - 1 ? h = x[6 - l.length] + l + h : h = l + h, s += 2, s >= 26 && (s -= 26, c--);
          }
          for (u !== 0 && (h = u.toString(16) + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        if (i === (i | 0) && i >= 2 && i <= 36) {
          var n = S2[i], d = E[i];
          h = "";
          var w = this.clone();
          for (w.negative = 0;!w.isZero(); ) {
            var g = w.modn(d).toString(i);
            w = w.idivn(d), w.isZero() ? h = g + h : h = x[n - g.length] + g + h;
          }
          for (this.isZero() && (h = "0" + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        r(false, "Base should be between 2 and 36");
      }, f2.prototype.toNumber = function() {
        var i = this.words[0];
        return this.length === 2 ? i += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? i += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -i : i;
      }, f2.prototype.toJSON = function() {
        return this.toString(16);
      }, f2.prototype.toBuffer = function(i, a) {
        return r(typeof p < "u"), this.toArrayLike(p, i, a);
      }, f2.prototype.toArray = function(i, a) {
        return this.toArrayLike(Array, i, a);
      }, f2.prototype.toArrayLike = function(i, a, h) {
        var s = this.byteLength(), u = h || Math.max(1, s);
        r(s <= u, "byte array longer than desired length"), r(u > 0, "Requested array length <= 0"), this.strip();
        var c = a === "le", b2 = new i(u), l, n, d = this.clone();
        if (c) {
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b2[n] = l;
          for (;n < u; n++)
            b2[n] = 0;
        } else {
          for (n = 0;n < u - s; n++)
            b2[n] = 0;
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b2[u - n - 1] = l;
        }
        return b2;
      }, Math.clz32 ? f2.prototype._countBits = function(i) {
        return 32 - Math.clz32(i);
      } : f2.prototype._countBits = function(i) {
        var a = i, h = 0;
        return a >= 4096 && (h += 13, a >>>= 13), a >= 64 && (h += 7, a >>>= 7), a >= 8 && (h += 4, a >>>= 4), a >= 2 && (h += 2, a >>>= 2), h + a;
      }, f2.prototype._zeroBits = function(i) {
        if (i === 0)
          return 26;
        var a = i, h = 0;
        return (a & 8191) === 0 && (h += 13, a >>>= 13), (a & 127) === 0 && (h += 7, a >>>= 7), (a & 15) === 0 && (h += 4, a >>>= 4), (a & 3) === 0 && (h += 2, a >>>= 2), (a & 1) === 0 && h++, h;
      }, f2.prototype.bitLength = function() {
        var i = this.words[this.length - 1], a = this._countBits(i);
        return (this.length - 1) * 26 + a;
      };
      function R(v2) {
        for (var i = new Array(v2.bitLength()), a = 0;a < i.length; a++) {
          var h = a / 26 | 0, s = a % 26;
          i[a] = (v2.words[h] & 1 << s) >>> s;
        }
        return i;
      }
      f2.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var i = 0, a = 0;a < this.length; a++) {
          var h = this._zeroBits(this.words[a]);
          if (i += h, h !== 26)
            break;
        }
        return i;
      }, f2.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, f2.prototype.toTwos = function(i) {
        return this.negative !== 0 ? this.abs().inotn(i).iaddn(1) : this.clone();
      }, f2.prototype.fromTwos = function(i) {
        return this.testn(i - 1) ? this.notn(i).iaddn(1).ineg() : this.clone();
      }, f2.prototype.isNeg = function() {
        return this.negative !== 0;
      }, f2.prototype.neg = function() {
        return this.clone().ineg();
      }, f2.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, f2.prototype.iuor = function(i) {
        for (;this.length < i.length; )
          this.words[this.length++] = 0;
        for (var a = 0;a < i.length; a++)
          this.words[a] = this.words[a] | i.words[a];
        return this.strip();
      }, f2.prototype.ior = function(i) {
        return r((this.negative | i.negative) === 0), this.iuor(i);
      }, f2.prototype.or = function(i) {
        return this.length > i.length ? this.clone().ior(i) : i.clone().ior(this);
      }, f2.prototype.uor = function(i) {
        return this.length > i.length ? this.clone().iuor(i) : i.clone().iuor(this);
      }, f2.prototype.iuand = function(i) {
        var a;
        this.length > i.length ? a = i : a = this;
        for (var h = 0;h < a.length; h++)
          this.words[h] = this.words[h] & i.words[h];
        return this.length = a.length, this.strip();
      }, f2.prototype.iand = function(i) {
        return r((this.negative | i.negative) === 0), this.iuand(i);
      }, f2.prototype.and = function(i) {
        return this.length > i.length ? this.clone().iand(i) : i.clone().iand(this);
      }, f2.prototype.uand = function(i) {
        return this.length > i.length ? this.clone().iuand(i) : i.clone().iuand(this);
      }, f2.prototype.iuxor = function(i) {
        var a, h;
        this.length > i.length ? (a = this, h = i) : (a = i, h = this);
        for (var s = 0;s < h.length; s++)
          this.words[s] = a.words[s] ^ h.words[s];
        if (this !== a)
          for (;s < a.length; s++)
            this.words[s] = a.words[s];
        return this.length = a.length, this.strip();
      }, f2.prototype.ixor = function(i) {
        return r((this.negative | i.negative) === 0), this.iuxor(i);
      }, f2.prototype.xor = function(i) {
        return this.length > i.length ? this.clone().ixor(i) : i.clone().ixor(this);
      }, f2.prototype.uxor = function(i) {
        return this.length > i.length ? this.clone().iuxor(i) : i.clone().iuxor(this);
      }, f2.prototype.inotn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = Math.ceil(i / 26) | 0, h = i % 26;
        this._expand(a), h > 0 && a--;
        for (var s = 0;s < a; s++)
          this.words[s] = ~this.words[s] & 67108863;
        return h > 0 && (this.words[s] = ~this.words[s] & 67108863 >> 26 - h), this.strip();
      }, f2.prototype.notn = function(i) {
        return this.clone().inotn(i);
      }, f2.prototype.setn = function(i, a) {
        r(typeof i == "number" && i >= 0);
        var h = i / 26 | 0, s = i % 26;
        return this._expand(h + 1), a ? this.words[h] = this.words[h] | 1 << s : this.words[h] = this.words[h] & ~(1 << s), this.strip();
      }, f2.prototype.iadd = function(i) {
        var a;
        if (this.negative !== 0 && i.negative === 0)
          return this.negative = 0, a = this.isub(i), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && i.negative !== 0)
          return i.negative = 0, a = this.isub(i), i.negative = 1, a._normSign();
        var h, s;
        this.length > i.length ? (h = this, s = i) : (h = i, s = this);
        for (var u = 0, c = 0;c < s.length; c++)
          a = (h.words[c] | 0) + (s.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        for (;u !== 0 && c < h.length; c++)
          a = (h.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        if (this.length = h.length, u !== 0)
          this.words[this.length] = u, this.length++;
        else if (h !== this)
          for (;c < h.length; c++)
            this.words[c] = h.words[c];
        return this;
      }, f2.prototype.add = function(i) {
        var a;
        return i.negative !== 0 && this.negative === 0 ? (i.negative = 0, a = this.sub(i), i.negative ^= 1, a) : i.negative === 0 && this.negative !== 0 ? (this.negative = 0, a = i.sub(this), this.negative = 1, a) : this.length > i.length ? this.clone().iadd(i) : i.clone().iadd(this);
      }, f2.prototype.isub = function(i) {
        if (i.negative !== 0) {
          i.negative = 0;
          var a = this.iadd(i);
          return i.negative = 1, a._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(i), this.negative = 1, this._normSign();
        var h = this.cmp(i);
        if (h === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var s, u;
        h > 0 ? (s = this, u = i) : (s = i, u = this);
        for (var c = 0, b2 = 0;b2 < u.length; b2++)
          a = (s.words[b2] | 0) - (u.words[b2] | 0) + c, c = a >> 26, this.words[b2] = a & 67108863;
        for (;c !== 0 && b2 < s.length; b2++)
          a = (s.words[b2] | 0) + c, c = a >> 26, this.words[b2] = a & 67108863;
        if (c === 0 && b2 < s.length && s !== this)
          for (;b2 < s.length; b2++)
            this.words[b2] = s.words[b2];
        return this.length = Math.max(this.length, b2), s !== this && (this.negative = 1), this.strip();
      }, f2.prototype.sub = function(i) {
        return this.clone().isub(i);
      };
      function q(v2, i, a) {
        a.negative = i.negative ^ v2.negative;
        var h = v2.length + i.length | 0;
        a.length = h, h = h - 1 | 0;
        var s = v2.words[0] | 0, u = i.words[0] | 0, c = s * u, b2 = c & 67108863, l = c / 67108864 | 0;
        a.words[0] = b2;
        for (var n = 1;n < h; n++) {
          for (var d = l >>> 26, w = l & 67108863, g = Math.min(n, i.length - 1), _2 = Math.max(0, n - v2.length + 1);_2 <= g; _2++) {
            var A = n - _2 | 0;
            s = v2.words[A] | 0, u = i.words[_2] | 0, c = s * u + w, d += c / 67108864 | 0, w = c & 67108863;
          }
          a.words[n] = w | 0, l = d | 0;
        }
        return l !== 0 ? a.words[n] = l | 0 : a.length--, a.strip();
      }
      var T = function(i, a, h) {
        var s = i.words, u = a.words, c = h.words, b2 = 0, l, n, d, w = s[0] | 0, g = w & 8191, _2 = w >>> 13, A = s[1] | 0, B = A & 8191, I = A >>> 13, we = s[2] | 0, L = we & 8191, N = we >>> 13, nt = s[3] | 0, C = nt & 8191, O = nt >>> 13, vt = s[4] | 0, F = vt & 8191, U = vt >>> 13, bt = s[5] | 0, z2 = bt & 8191, H = bt >>> 13, mt = s[6] | 0, W = mt & 8191, K = mt >>> 13, gt = s[7] | 0, j = gt & 8191, Z = gt >>> 13, yt = s[8] | 0, V = yt & 8191, $2 = yt >>> 13, wt = s[9] | 0, G = wt & 8191, Y = wt >>> 13, Mt = u[0] | 0, X = Mt & 8191, J2 = Mt >>> 13, _t = u[1] | 0, Q2 = _t & 8191, ee = _t >>> 13, xt = u[2] | 0, te = xt & 8191, re = xt >>> 13, St = u[3] | 0, ie = St & 8191, ne = St >>> 13, Et = u[4] | 0, fe = Et & 8191, ae = Et >>> 13, At = u[5] | 0, oe = At & 8191, se = At >>> 13, Rt = u[6] | 0, he = Rt & 8191, ue = Rt >>> 13, Bt = u[7] | 0, le = Bt & 8191, de = Bt >>> 13, qt = u[8] | 0, ce = qt & 8191, pe = qt >>> 13, It = u[9] | 0, ve = It & 8191, be = It >>> 13;
        h.negative = i.negative ^ a.negative, h.length = 19, l = Math.imul(g, X), n = Math.imul(g, J2), n = n + Math.imul(_2, X) | 0, d = Math.imul(_2, J2);
        var ft = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, l = Math.imul(B, X), n = Math.imul(B, J2), n = n + Math.imul(I, X) | 0, d = Math.imul(I, J2), l = l + Math.imul(g, Q2) | 0, n = n + Math.imul(g, ee) | 0, n = n + Math.imul(_2, Q2) | 0, d = d + Math.imul(_2, ee) | 0;
        var Be = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, l = Math.imul(L, X), n = Math.imul(L, J2), n = n + Math.imul(N, X) | 0, d = Math.imul(N, J2), l = l + Math.imul(B, Q2) | 0, n = n + Math.imul(B, ee) | 0, n = n + Math.imul(I, Q2) | 0, d = d + Math.imul(I, ee) | 0, l = l + Math.imul(g, te) | 0, n = n + Math.imul(g, re) | 0, n = n + Math.imul(_2, te) | 0, d = d + Math.imul(_2, re) | 0;
        var qe = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (qe >>> 26) | 0, qe &= 67108863, l = Math.imul(C, X), n = Math.imul(C, J2), n = n + Math.imul(O, X) | 0, d = Math.imul(O, J2), l = l + Math.imul(L, Q2) | 0, n = n + Math.imul(L, ee) | 0, n = n + Math.imul(N, Q2) | 0, d = d + Math.imul(N, ee) | 0, l = l + Math.imul(B, te) | 0, n = n + Math.imul(B, re) | 0, n = n + Math.imul(I, te) | 0, d = d + Math.imul(I, re) | 0, l = l + Math.imul(g, ie) | 0, n = n + Math.imul(g, ne) | 0, n = n + Math.imul(_2, ie) | 0, d = d + Math.imul(_2, ne) | 0;
        var ze = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, l = Math.imul(F, X), n = Math.imul(F, J2), n = n + Math.imul(U, X) | 0, d = Math.imul(U, J2), l = l + Math.imul(C, Q2) | 0, n = n + Math.imul(C, ee) | 0, n = n + Math.imul(O, Q2) | 0, d = d + Math.imul(O, ee) | 0, l = l + Math.imul(L, te) | 0, n = n + Math.imul(L, re) | 0, n = n + Math.imul(N, te) | 0, d = d + Math.imul(N, re) | 0, l = l + Math.imul(B, ie) | 0, n = n + Math.imul(B, ne) | 0, n = n + Math.imul(I, ie) | 0, d = d + Math.imul(I, ne) | 0, l = l + Math.imul(g, fe) | 0, n = n + Math.imul(g, ae) | 0, n = n + Math.imul(_2, fe) | 0, d = d + Math.imul(_2, ae) | 0;
        var He = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, l = Math.imul(z2, X), n = Math.imul(z2, J2), n = n + Math.imul(H, X) | 0, d = Math.imul(H, J2), l = l + Math.imul(F, Q2) | 0, n = n + Math.imul(F, ee) | 0, n = n + Math.imul(U, Q2) | 0, d = d + Math.imul(U, ee) | 0, l = l + Math.imul(C, te) | 0, n = n + Math.imul(C, re) | 0, n = n + Math.imul(O, te) | 0, d = d + Math.imul(O, re) | 0, l = l + Math.imul(L, ie) | 0, n = n + Math.imul(L, ne) | 0, n = n + Math.imul(N, ie) | 0, d = d + Math.imul(N, ne) | 0, l = l + Math.imul(B, fe) | 0, n = n + Math.imul(B, ae) | 0, n = n + Math.imul(I, fe) | 0, d = d + Math.imul(I, ae) | 0, l = l + Math.imul(g, oe) | 0, n = n + Math.imul(g, se) | 0, n = n + Math.imul(_2, oe) | 0, d = d + Math.imul(_2, se) | 0;
        var We = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (We >>> 26) | 0, We &= 67108863, l = Math.imul(W, X), n = Math.imul(W, J2), n = n + Math.imul(K, X) | 0, d = Math.imul(K, J2), l = l + Math.imul(z2, Q2) | 0, n = n + Math.imul(z2, ee) | 0, n = n + Math.imul(H, Q2) | 0, d = d + Math.imul(H, ee) | 0, l = l + Math.imul(F, te) | 0, n = n + Math.imul(F, re) | 0, n = n + Math.imul(U, te) | 0, d = d + Math.imul(U, re) | 0, l = l + Math.imul(C, ie) | 0, n = n + Math.imul(C, ne) | 0, n = n + Math.imul(O, ie) | 0, d = d + Math.imul(O, ne) | 0, l = l + Math.imul(L, fe) | 0, n = n + Math.imul(L, ae) | 0, n = n + Math.imul(N, fe) | 0, d = d + Math.imul(N, ae) | 0, l = l + Math.imul(B, oe) | 0, n = n + Math.imul(B, se) | 0, n = n + Math.imul(I, oe) | 0, d = d + Math.imul(I, se) | 0, l = l + Math.imul(g, he) | 0, n = n + Math.imul(g, ue) | 0, n = n + Math.imul(_2, he) | 0, d = d + Math.imul(_2, ue) | 0;
        var Ke = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, l = Math.imul(j, X), n = Math.imul(j, J2), n = n + Math.imul(Z, X) | 0, d = Math.imul(Z, J2), l = l + Math.imul(W, Q2) | 0, n = n + Math.imul(W, ee) | 0, n = n + Math.imul(K, Q2) | 0, d = d + Math.imul(K, ee) | 0, l = l + Math.imul(z2, te) | 0, n = n + Math.imul(z2, re) | 0, n = n + Math.imul(H, te) | 0, d = d + Math.imul(H, re) | 0, l = l + Math.imul(F, ie) | 0, n = n + Math.imul(F, ne) | 0, n = n + Math.imul(U, ie) | 0, d = d + Math.imul(U, ne) | 0, l = l + Math.imul(C, fe) | 0, n = n + Math.imul(C, ae) | 0, n = n + Math.imul(O, fe) | 0, d = d + Math.imul(O, ae) | 0, l = l + Math.imul(L, oe) | 0, n = n + Math.imul(L, se) | 0, n = n + Math.imul(N, oe) | 0, d = d + Math.imul(N, se) | 0, l = l + Math.imul(B, he) | 0, n = n + Math.imul(B, ue) | 0, n = n + Math.imul(I, he) | 0, d = d + Math.imul(I, ue) | 0, l = l + Math.imul(g, le) | 0, n = n + Math.imul(g, de) | 0, n = n + Math.imul(_2, le) | 0, d = d + Math.imul(_2, de) | 0;
        var je = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, l = Math.imul(V, X), n = Math.imul(V, J2), n = n + Math.imul($2, X) | 0, d = Math.imul($2, J2), l = l + Math.imul(j, Q2) | 0, n = n + Math.imul(j, ee) | 0, n = n + Math.imul(Z, Q2) | 0, d = d + Math.imul(Z, ee) | 0, l = l + Math.imul(W, te) | 0, n = n + Math.imul(W, re) | 0, n = n + Math.imul(K, te) | 0, d = d + Math.imul(K, re) | 0, l = l + Math.imul(z2, ie) | 0, n = n + Math.imul(z2, ne) | 0, n = n + Math.imul(H, ie) | 0, d = d + Math.imul(H, ne) | 0, l = l + Math.imul(F, fe) | 0, n = n + Math.imul(F, ae) | 0, n = n + Math.imul(U, fe) | 0, d = d + Math.imul(U, ae) | 0, l = l + Math.imul(C, oe) | 0, n = n + Math.imul(C, se) | 0, n = n + Math.imul(O, oe) | 0, d = d + Math.imul(O, se) | 0, l = l + Math.imul(L, he) | 0, n = n + Math.imul(L, ue) | 0, n = n + Math.imul(N, he) | 0, d = d + Math.imul(N, ue) | 0, l = l + Math.imul(B, le) | 0, n = n + Math.imul(B, de) | 0, n = n + Math.imul(I, le) | 0, d = d + Math.imul(I, de) | 0, l = l + Math.imul(g, ce) | 0, n = n + Math.imul(g, pe) | 0, n = n + Math.imul(_2, ce) | 0, d = d + Math.imul(_2, pe) | 0;
        var Ze = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, l = Math.imul(G, X), n = Math.imul(G, J2), n = n + Math.imul(Y, X) | 0, d = Math.imul(Y, J2), l = l + Math.imul(V, Q2) | 0, n = n + Math.imul(V, ee) | 0, n = n + Math.imul($2, Q2) | 0, d = d + Math.imul($2, ee) | 0, l = l + Math.imul(j, te) | 0, n = n + Math.imul(j, re) | 0, n = n + Math.imul(Z, te) | 0, d = d + Math.imul(Z, re) | 0, l = l + Math.imul(W, ie) | 0, n = n + Math.imul(W, ne) | 0, n = n + Math.imul(K, ie) | 0, d = d + Math.imul(K, ne) | 0, l = l + Math.imul(z2, fe) | 0, n = n + Math.imul(z2, ae) | 0, n = n + Math.imul(H, fe) | 0, d = d + Math.imul(H, ae) | 0, l = l + Math.imul(F, oe) | 0, n = n + Math.imul(F, se) | 0, n = n + Math.imul(U, oe) | 0, d = d + Math.imul(U, se) | 0, l = l + Math.imul(C, he) | 0, n = n + Math.imul(C, ue) | 0, n = n + Math.imul(O, he) | 0, d = d + Math.imul(O, ue) | 0, l = l + Math.imul(L, le) | 0, n = n + Math.imul(L, de) | 0, n = n + Math.imul(N, le) | 0, d = d + Math.imul(N, de) | 0, l = l + Math.imul(B, ce) | 0, n = n + Math.imul(B, pe) | 0, n = n + Math.imul(I, ce) | 0, d = d + Math.imul(I, pe) | 0, l = l + Math.imul(g, ve) | 0, n = n + Math.imul(g, be) | 0, n = n + Math.imul(_2, ve) | 0, d = d + Math.imul(_2, be) | 0;
        var Ve = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, l = Math.imul(G, Q2), n = Math.imul(G, ee), n = n + Math.imul(Y, Q2) | 0, d = Math.imul(Y, ee), l = l + Math.imul(V, te) | 0, n = n + Math.imul(V, re) | 0, n = n + Math.imul($2, te) | 0, d = d + Math.imul($2, re) | 0, l = l + Math.imul(j, ie) | 0, n = n + Math.imul(j, ne) | 0, n = n + Math.imul(Z, ie) | 0, d = d + Math.imul(Z, ne) | 0, l = l + Math.imul(W, fe) | 0, n = n + Math.imul(W, ae) | 0, n = n + Math.imul(K, fe) | 0, d = d + Math.imul(K, ae) | 0, l = l + Math.imul(z2, oe) | 0, n = n + Math.imul(z2, se) | 0, n = n + Math.imul(H, oe) | 0, d = d + Math.imul(H, se) | 0, l = l + Math.imul(F, he) | 0, n = n + Math.imul(F, ue) | 0, n = n + Math.imul(U, he) | 0, d = d + Math.imul(U, ue) | 0, l = l + Math.imul(C, le) | 0, n = n + Math.imul(C, de) | 0, n = n + Math.imul(O, le) | 0, d = d + Math.imul(O, de) | 0, l = l + Math.imul(L, ce) | 0, n = n + Math.imul(L, pe) | 0, n = n + Math.imul(N, ce) | 0, d = d + Math.imul(N, pe) | 0, l = l + Math.imul(B, ve) | 0, n = n + Math.imul(B, be) | 0, n = n + Math.imul(I, ve) | 0, d = d + Math.imul(I, be) | 0;
        var $e = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + ($e >>> 26) | 0, $e &= 67108863, l = Math.imul(G, te), n = Math.imul(G, re), n = n + Math.imul(Y, te) | 0, d = Math.imul(Y, re), l = l + Math.imul(V, ie) | 0, n = n + Math.imul(V, ne) | 0, n = n + Math.imul($2, ie) | 0, d = d + Math.imul($2, ne) | 0, l = l + Math.imul(j, fe) | 0, n = n + Math.imul(j, ae) | 0, n = n + Math.imul(Z, fe) | 0, d = d + Math.imul(Z, ae) | 0, l = l + Math.imul(W, oe) | 0, n = n + Math.imul(W, se) | 0, n = n + Math.imul(K, oe) | 0, d = d + Math.imul(K, se) | 0, l = l + Math.imul(z2, he) | 0, n = n + Math.imul(z2, ue) | 0, n = n + Math.imul(H, he) | 0, d = d + Math.imul(H, ue) | 0, l = l + Math.imul(F, le) | 0, n = n + Math.imul(F, de) | 0, n = n + Math.imul(U, le) | 0, d = d + Math.imul(U, de) | 0, l = l + Math.imul(C, ce) | 0, n = n + Math.imul(C, pe) | 0, n = n + Math.imul(O, ce) | 0, d = d + Math.imul(O, pe) | 0, l = l + Math.imul(L, ve) | 0, n = n + Math.imul(L, be) | 0, n = n + Math.imul(N, ve) | 0, d = d + Math.imul(N, be) | 0;
        var Ge = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, l = Math.imul(G, ie), n = Math.imul(G, ne), n = n + Math.imul(Y, ie) | 0, d = Math.imul(Y, ne), l = l + Math.imul(V, fe) | 0, n = n + Math.imul(V, ae) | 0, n = n + Math.imul($2, fe) | 0, d = d + Math.imul($2, ae) | 0, l = l + Math.imul(j, oe) | 0, n = n + Math.imul(j, se) | 0, n = n + Math.imul(Z, oe) | 0, d = d + Math.imul(Z, se) | 0, l = l + Math.imul(W, he) | 0, n = n + Math.imul(W, ue) | 0, n = n + Math.imul(K, he) | 0, d = d + Math.imul(K, ue) | 0, l = l + Math.imul(z2, le) | 0, n = n + Math.imul(z2, de) | 0, n = n + Math.imul(H, le) | 0, d = d + Math.imul(H, de) | 0, l = l + Math.imul(F, ce) | 0, n = n + Math.imul(F, pe) | 0, n = n + Math.imul(U, ce) | 0, d = d + Math.imul(U, pe) | 0, l = l + Math.imul(C, ve) | 0, n = n + Math.imul(C, be) | 0, n = n + Math.imul(O, ve) | 0, d = d + Math.imul(O, be) | 0;
        var Ye = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, l = Math.imul(G, fe), n = Math.imul(G, ae), n = n + Math.imul(Y, fe) | 0, d = Math.imul(Y, ae), l = l + Math.imul(V, oe) | 0, n = n + Math.imul(V, se) | 0, n = n + Math.imul($2, oe) | 0, d = d + Math.imul($2, se) | 0, l = l + Math.imul(j, he) | 0, n = n + Math.imul(j, ue) | 0, n = n + Math.imul(Z, he) | 0, d = d + Math.imul(Z, ue) | 0, l = l + Math.imul(W, le) | 0, n = n + Math.imul(W, de) | 0, n = n + Math.imul(K, le) | 0, d = d + Math.imul(K, de) | 0, l = l + Math.imul(z2, ce) | 0, n = n + Math.imul(z2, pe) | 0, n = n + Math.imul(H, ce) | 0, d = d + Math.imul(H, pe) | 0, l = l + Math.imul(F, ve) | 0, n = n + Math.imul(F, be) | 0, n = n + Math.imul(U, ve) | 0, d = d + Math.imul(U, be) | 0;
        var Xe = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, l = Math.imul(G, oe), n = Math.imul(G, se), n = n + Math.imul(Y, oe) | 0, d = Math.imul(Y, se), l = l + Math.imul(V, he) | 0, n = n + Math.imul(V, ue) | 0, n = n + Math.imul($2, he) | 0, d = d + Math.imul($2, ue) | 0, l = l + Math.imul(j, le) | 0, n = n + Math.imul(j, de) | 0, n = n + Math.imul(Z, le) | 0, d = d + Math.imul(Z, de) | 0, l = l + Math.imul(W, ce) | 0, n = n + Math.imul(W, pe) | 0, n = n + Math.imul(K, ce) | 0, d = d + Math.imul(K, pe) | 0, l = l + Math.imul(z2, ve) | 0, n = n + Math.imul(z2, be) | 0, n = n + Math.imul(H, ve) | 0, d = d + Math.imul(H, be) | 0;
        var Je = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, l = Math.imul(G, he), n = Math.imul(G, ue), n = n + Math.imul(Y, he) | 0, d = Math.imul(Y, ue), l = l + Math.imul(V, le) | 0, n = n + Math.imul(V, de) | 0, n = n + Math.imul($2, le) | 0, d = d + Math.imul($2, de) | 0, l = l + Math.imul(j, ce) | 0, n = n + Math.imul(j, pe) | 0, n = n + Math.imul(Z, ce) | 0, d = d + Math.imul(Z, pe) | 0, l = l + Math.imul(W, ve) | 0, n = n + Math.imul(W, be) | 0, n = n + Math.imul(K, ve) | 0, d = d + Math.imul(K, be) | 0;
        var Qe = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, l = Math.imul(G, le), n = Math.imul(G, de), n = n + Math.imul(Y, le) | 0, d = Math.imul(Y, de), l = l + Math.imul(V, ce) | 0, n = n + Math.imul(V, pe) | 0, n = n + Math.imul($2, ce) | 0, d = d + Math.imul($2, pe) | 0, l = l + Math.imul(j, ve) | 0, n = n + Math.imul(j, be) | 0, n = n + Math.imul(Z, ve) | 0, d = d + Math.imul(Z, be) | 0;
        var et = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, l = Math.imul(G, ce), n = Math.imul(G, pe), n = n + Math.imul(Y, ce) | 0, d = Math.imul(Y, pe), l = l + Math.imul(V, ve) | 0, n = n + Math.imul(V, be) | 0, n = n + Math.imul($2, ve) | 0, d = d + Math.imul($2, be) | 0;
        var tt = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, l = Math.imul(G, ve), n = Math.imul(G, be), n = n + Math.imul(Y, ve) | 0, d = Math.imul(Y, be);
        var rt = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        return b2 = (d + (n >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, c[0] = ft, c[1] = Be, c[2] = qe, c[3] = ze, c[4] = He, c[5] = We, c[6] = Ke, c[7] = je, c[8] = Ze, c[9] = Ve, c[10] = $e, c[11] = Ge, c[12] = Ye, c[13] = Xe, c[14] = Je, c[15] = Qe, c[16] = et, c[17] = tt, c[18] = rt, b2 !== 0 && (c[19] = b2, h.length++), h;
      };
      Math.imul || (T = q);
      function ye(v2, i, a) {
        a.negative = i.negative ^ v2.negative, a.length = v2.length + i.length;
        for (var h = 0, s = 0, u = 0;u < a.length - 1; u++) {
          var c = s;
          s = 0;
          for (var b2 = h & 67108863, l = Math.min(u, i.length - 1), n = Math.max(0, u - v2.length + 1);n <= l; n++) {
            var d = u - n, w = v2.words[d] | 0, g = i.words[n] | 0, _2 = w * g, A = _2 & 67108863;
            c = c + (_2 / 67108864 | 0) | 0, A = A + b2 | 0, b2 = A & 67108863, c = c + (A >>> 26) | 0, s += c >>> 26, c &= 67108863;
          }
          a.words[u] = b2, h = c, c = s;
        }
        return h !== 0 ? a.words[u] = h : a.length--, a.strip();
      }
      function _e(v2, i, a) {
        var h = new P;
        return h.mulp(v2, i, a);
      }
      f2.prototype.mulTo = function(i, a) {
        var h, s = this.length + i.length;
        return this.length === 10 && i.length === 10 ? h = T(this, i, a) : s < 63 ? h = q(this, i, a) : s < 1024 ? h = ye(this, i, a) : h = _e(this, i, a), h;
      };
      function P(v2, i) {
        this.x = v2, this.y = i;
      }
      P.prototype.makeRBT = function(i) {
        for (var a = new Array(i), h = f2.prototype._countBits(i) - 1, s = 0;s < i; s++)
          a[s] = this.revBin(s, h, i);
        return a;
      }, P.prototype.revBin = function(i, a, h) {
        if (i === 0 || i === h - 1)
          return i;
        for (var s = 0, u = 0;u < a; u++)
          s |= (i & 1) << a - u - 1, i >>= 1;
        return s;
      }, P.prototype.permute = function(i, a, h, s, u, c) {
        for (var b2 = 0;b2 < c; b2++)
          s[b2] = a[i[b2]], u[b2] = h[i[b2]];
      }, P.prototype.transform = function(i, a, h, s, u, c) {
        this.permute(c, i, a, h, s, u);
        for (var b2 = 1;b2 < u; b2 <<= 1)
          for (var l = b2 << 1, n = Math.cos(2 * Math.PI / l), d = Math.sin(2 * Math.PI / l), w = 0;w < u; w += l)
            for (var g = n, _2 = d, A = 0;A < b2; A++) {
              var B = h[w + A], I = s[w + A], we = h[w + A + b2], L = s[w + A + b2], N = g * we - _2 * L;
              L = g * L + _2 * we, we = N, h[w + A] = B + we, s[w + A] = I + L, h[w + A + b2] = B - we, s[w + A + b2] = I - L, A !== l && (N = n * g - d * _2, _2 = n * _2 + d * g, g = N);
            }
      }, P.prototype.guessLen13b = function(i, a) {
        var h = Math.max(a, i) | 1, s = h & 1, u = 0;
        for (h = h / 2 | 0;h; h = h >>> 1)
          u++;
        return 1 << u + 1 + s;
      }, P.prototype.conjugate = function(i, a, h) {
        if (!(h <= 1))
          for (var s = 0;s < h / 2; s++) {
            var u = i[s];
            i[s] = i[h - s - 1], i[h - s - 1] = u, u = a[s], a[s] = -a[h - s - 1], a[h - s - 1] = -u;
          }
      }, P.prototype.normalize13b = function(i, a) {
        for (var h = 0, s = 0;s < a / 2; s++) {
          var u = Math.round(i[2 * s + 1] / a) * 8192 + Math.round(i[2 * s] / a) + h;
          i[s] = u & 67108863, u < 67108864 ? h = 0 : h = u / 67108864 | 0;
        }
        return i;
      }, P.prototype.convert13b = function(i, a, h, s) {
        for (var u = 0, c = 0;c < a; c++)
          u = u + (i[c] | 0), h[2 * c] = u & 8191, u = u >>> 13, h[2 * c + 1] = u & 8191, u = u >>> 13;
        for (c = 2 * a;c < s; ++c)
          h[c] = 0;
        r(u === 0), r((u & -8192) === 0);
      }, P.prototype.stub = function(i) {
        for (var a = new Array(i), h = 0;h < i; h++)
          a[h] = 0;
        return a;
      }, P.prototype.mulp = function(i, a, h) {
        var s = 2 * this.guessLen13b(i.length, a.length), u = this.makeRBT(s), c = this.stub(s), b2 = new Array(s), l = new Array(s), n = new Array(s), d = new Array(s), w = new Array(s), g = new Array(s), _2 = h.words;
        _2.length = s, this.convert13b(i.words, i.length, b2, s), this.convert13b(a.words, a.length, d, s), this.transform(b2, c, l, n, s, u), this.transform(d, c, w, g, s, u);
        for (var A = 0;A < s; A++) {
          var B = l[A] * w[A] - n[A] * g[A];
          n[A] = l[A] * g[A] + n[A] * w[A], l[A] = B;
        }
        return this.conjugate(l, n, s), this.transform(l, n, _2, c, s, u), this.conjugate(_2, c, s), this.normalize13b(_2, s), h.negative = i.negative ^ a.negative, h.length = i.length + a.length, h.strip();
      }, f2.prototype.mul = function(i) {
        var a = new f2(null);
        return a.words = new Array(this.length + i.length), this.mulTo(i, a);
      }, f2.prototype.mulf = function(i) {
        var a = new f2(null);
        return a.words = new Array(this.length + i.length), _e(this, i, a);
      }, f2.prototype.imul = function(i) {
        return this.clone().mulTo(i, this);
      }, f2.prototype.imuln = function(i) {
        r(typeof i == "number"), r(i < 67108864);
        for (var a = 0, h = 0;h < this.length; h++) {
          var s = (this.words[h] | 0) * i, u = (s & 67108863) + (a & 67108863);
          a >>= 26, a += s / 67108864 | 0, a += u >>> 26, this.words[h] = u & 67108863;
        }
        return a !== 0 && (this.words[h] = a, this.length++), this;
      }, f2.prototype.muln = function(i) {
        return this.clone().imuln(i);
      }, f2.prototype.sqr = function() {
        return this.mul(this);
      }, f2.prototype.isqr = function() {
        return this.imul(this.clone());
      }, f2.prototype.pow = function(i) {
        var a = R(i);
        if (a.length === 0)
          return new f2(1);
        for (var h = this, s = 0;s < a.length && a[s] === 0; s++, h = h.sqr())
          ;
        if (++s < a.length)
          for (var u = h.sqr();s < a.length; s++, u = u.sqr())
            a[s] !== 0 && (h = h.mul(u));
        return h;
      }, f2.prototype.iushln = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 67108863 >>> 26 - a << 26 - a, u;
        if (a !== 0) {
          var c = 0;
          for (u = 0;u < this.length; u++) {
            var b2 = this.words[u] & s, l = (this.words[u] | 0) - b2 << a;
            this.words[u] = l | c, c = b2 >>> 26 - a;
          }
          c && (this.words[u] = c, this.length++);
        }
        if (h !== 0) {
          for (u = this.length - 1;u >= 0; u--)
            this.words[u + h] = this.words[u];
          for (u = 0;u < h; u++)
            this.words[u] = 0;
          this.length += h;
        }
        return this.strip();
      }, f2.prototype.ishln = function(i) {
        return r(this.negative === 0), this.iushln(i);
      }, f2.prototype.iushrn = function(i, a, h) {
        r(typeof i == "number" && i >= 0);
        var s;
        a ? s = (a - a % 26) / 26 : s = 0;
        var u = i % 26, c = Math.min((i - u) / 26, this.length), b2 = 67108863 ^ 67108863 >>> u << u, l = h;
        if (s -= c, s = Math.max(0, s), l) {
          for (var n = 0;n < c; n++)
            l.words[n] = this.words[n];
          l.length = c;
        }
        if (c !== 0)
          if (this.length > c)
            for (this.length -= c, n = 0;n < this.length; n++)
              this.words[n] = this.words[n + c];
          else
            this.words[0] = 0, this.length = 1;
        var d = 0;
        for (n = this.length - 1;n >= 0 && (d !== 0 || n >= s); n--) {
          var w = this.words[n] | 0;
          this.words[n] = d << 26 - u | w >>> u, d = w & b2;
        }
        return l && d !== 0 && (l.words[l.length++] = d), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, f2.prototype.ishrn = function(i, a, h) {
        return r(this.negative === 0), this.iushrn(i, a, h);
      }, f2.prototype.shln = function(i) {
        return this.clone().ishln(i);
      }, f2.prototype.ushln = function(i) {
        return this.clone().iushln(i);
      }, f2.prototype.shrn = function(i) {
        return this.clone().ishrn(i);
      }, f2.prototype.ushrn = function(i) {
        return this.clone().iushrn(i);
      }, f2.prototype.testn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return false;
        var u = this.words[h];
        return !!(u & s);
      }, f2.prototype.imaskn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= h)
          return this;
        if (a !== 0 && h++, this.length = Math.min(h, this.length), a !== 0) {
          var s = 67108863 ^ 67108863 >>> a << a;
          this.words[this.length - 1] &= s;
        }
        return this.strip();
      }, f2.prototype.maskn = function(i) {
        return this.clone().imaskn(i);
      }, f2.prototype.iaddn = function(i) {
        return r(typeof i == "number"), r(i < 67108864), i < 0 ? this.isubn(-i) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < i ? (this.words[0] = i - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(i), this.negative = 1, this) : this._iaddn(i);
      }, f2.prototype._iaddn = function(i) {
        this.words[0] += i;
        for (var a = 0;a < this.length && this.words[a] >= 67108864; a++)
          this.words[a] -= 67108864, a === this.length - 1 ? this.words[a + 1] = 1 : this.words[a + 1]++;
        return this.length = Math.max(this.length, a + 1), this;
      }, f2.prototype.isubn = function(i) {
        if (r(typeof i == "number"), r(i < 67108864), i < 0)
          return this.iaddn(-i);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(i), this.negative = 1, this;
        if (this.words[0] -= i, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var a = 0;a < this.length && this.words[a] < 0; a++)
            this.words[a] += 67108864, this.words[a + 1] -= 1;
        return this.strip();
      }, f2.prototype.addn = function(i) {
        return this.clone().iaddn(i);
      }, f2.prototype.subn = function(i) {
        return this.clone().isubn(i);
      }, f2.prototype.iabs = function() {
        return this.negative = 0, this;
      }, f2.prototype.abs = function() {
        return this.clone().iabs();
      }, f2.prototype._ishlnsubmul = function(i, a, h) {
        var s = i.length + h, u;
        this._expand(s);
        var c, b2 = 0;
        for (u = 0;u < i.length; u++) {
          c = (this.words[u + h] | 0) + b2;
          var l = (i.words[u] | 0) * a;
          c -= l & 67108863, b2 = (c >> 26) - (l / 67108864 | 0), this.words[u + h] = c & 67108863;
        }
        for (;u < this.length - h; u++)
          c = (this.words[u + h] | 0) + b2, b2 = c >> 26, this.words[u + h] = c & 67108863;
        if (b2 === 0)
          return this.strip();
        for (r(b2 === -1), b2 = 0, u = 0;u < this.length; u++)
          c = -(this.words[u] | 0) + b2, b2 = c >> 26, this.words[u] = c & 67108863;
        return this.negative = 1, this.strip();
      }, f2.prototype._wordDiv = function(i, a) {
        var h = this.length - i.length, s = this.clone(), u = i, c = u.words[u.length - 1] | 0, b2 = this._countBits(c);
        h = 26 - b2, h !== 0 && (u = u.ushln(h), s.iushln(h), c = u.words[u.length - 1] | 0);
        var l = s.length - u.length, n;
        if (a !== "mod") {
          n = new f2(null), n.length = l + 1, n.words = new Array(n.length);
          for (var d = 0;d < n.length; d++)
            n.words[d] = 0;
        }
        var w = s.clone()._ishlnsubmul(u, 1, l);
        w.negative === 0 && (s = w, n && (n.words[l] = 1));
        for (var g = l - 1;g >= 0; g--) {
          var _2 = (s.words[u.length + g] | 0) * 67108864 + (s.words[u.length + g - 1] | 0);
          for (_2 = Math.min(_2 / c | 0, 67108863), s._ishlnsubmul(u, _2, g);s.negative !== 0; )
            _2--, s.negative = 0, s._ishlnsubmul(u, 1, g), s.isZero() || (s.negative ^= 1);
          n && (n.words[g] = _2);
        }
        return n && n.strip(), s.strip(), a !== "div" && h !== 0 && s.iushrn(h), { div: n || null, mod: s };
      }, f2.prototype.divmod = function(i, a, h) {
        if (r(!i.isZero()), this.isZero())
          return { div: new f2(0), mod: new f2(0) };
        var s, u, c;
        return this.negative !== 0 && i.negative === 0 ? (c = this.neg().divmod(i, a), a !== "mod" && (s = c.div.neg()), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.iadd(i)), { div: s, mod: u }) : this.negative === 0 && i.negative !== 0 ? (c = this.divmod(i.neg(), a), a !== "mod" && (s = c.div.neg()), { div: s, mod: c.mod }) : (this.negative & i.negative) !== 0 ? (c = this.neg().divmod(i.neg(), a), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.isub(i)), { div: c.div, mod: u }) : i.length > this.length || this.cmp(i) < 0 ? { div: new f2(0), mod: this } : i.length === 1 ? a === "div" ? { div: this.divn(i.words[0]), mod: null } : a === "mod" ? { div: null, mod: new f2(this.modn(i.words[0])) } : { div: this.divn(i.words[0]), mod: new f2(this.modn(i.words[0])) } : this._wordDiv(i, a);
      }, f2.prototype.div = function(i) {
        return this.divmod(i, "div", false).div;
      }, f2.prototype.mod = function(i) {
        return this.divmod(i, "mod", false).mod;
      }, f2.prototype.umod = function(i) {
        return this.divmod(i, "mod", true).mod;
      }, f2.prototype.divRound = function(i) {
        var a = this.divmod(i);
        if (a.mod.isZero())
          return a.div;
        var h = a.div.negative !== 0 ? a.mod.isub(i) : a.mod, s = i.ushrn(1), u = i.andln(1), c = h.cmp(s);
        return c < 0 || u === 1 && c === 0 ? a.div : a.div.negative !== 0 ? a.div.isubn(1) : a.div.iaddn(1);
      }, f2.prototype.modn = function(i) {
        r(i <= 67108863);
        for (var a = (1 << 26) % i, h = 0, s = this.length - 1;s >= 0; s--)
          h = (a * h + (this.words[s] | 0)) % i;
        return h;
      }, f2.prototype.idivn = function(i) {
        r(i <= 67108863);
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = (this.words[h] | 0) + a * 67108864;
          this.words[h] = s / i | 0, a = s % i;
        }
        return this.strip();
      }, f2.prototype.divn = function(i) {
        return this.clone().idivn(i);
      }, f2.prototype.egcd = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f2(1), u = new f2(0), c = new f2(0), b2 = new f2(1), l = 0;a.isEven() && h.isEven(); )
          a.iushrn(1), h.iushrn(1), ++l;
        for (var n = h.clone(), d = a.clone();!a.isZero(); ) {
          for (var w = 0, g = 1;(a.words[0] & g) === 0 && w < 26; ++w, g <<= 1)
            ;
          if (w > 0)
            for (a.iushrn(w);w-- > 0; )
              (s.isOdd() || u.isOdd()) && (s.iadd(n), u.isub(d)), s.iushrn(1), u.iushrn(1);
          for (var _2 = 0, A = 1;(h.words[0] & A) === 0 && _2 < 26; ++_2, A <<= 1)
            ;
          if (_2 > 0)
            for (h.iushrn(_2);_2-- > 0; )
              (c.isOdd() || b2.isOdd()) && (c.iadd(n), b2.isub(d)), c.iushrn(1), b2.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(c), u.isub(b2)) : (h.isub(a), c.isub(s), b2.isub(u));
        }
        return { a: c, b: b2, gcd: h.iushln(l) };
      }, f2.prototype._invmp = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f2(1), u = new f2(0), c = h.clone();a.cmpn(1) > 0 && h.cmpn(1) > 0; ) {
          for (var b2 = 0, l = 1;(a.words[0] & l) === 0 && b2 < 26; ++b2, l <<= 1)
            ;
          if (b2 > 0)
            for (a.iushrn(b2);b2-- > 0; )
              s.isOdd() && s.iadd(c), s.iushrn(1);
          for (var n = 0, d = 1;(h.words[0] & d) === 0 && n < 26; ++n, d <<= 1)
            ;
          if (n > 0)
            for (h.iushrn(n);n-- > 0; )
              u.isOdd() && u.iadd(c), u.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(u)) : (h.isub(a), u.isub(s));
        }
        var w;
        return a.cmpn(1) === 0 ? w = s : w = u, w.cmpn(0) < 0 && w.iadd(i), w;
      }, f2.prototype.gcd = function(i) {
        if (this.isZero())
          return i.abs();
        if (i.isZero())
          return this.abs();
        var a = this.clone(), h = i.clone();
        a.negative = 0, h.negative = 0;
        for (var s = 0;a.isEven() && h.isEven(); s++)
          a.iushrn(1), h.iushrn(1);
        do {
          for (;a.isEven(); )
            a.iushrn(1);
          for (;h.isEven(); )
            h.iushrn(1);
          var u = a.cmp(h);
          if (u < 0) {
            var c = a;
            a = h, h = c;
          } else if (u === 0 || h.cmpn(1) === 0)
            break;
          a.isub(h);
        } while (true);
        return h.iushln(s);
      }, f2.prototype.invm = function(i) {
        return this.egcd(i).a.umod(i);
      }, f2.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, f2.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, f2.prototype.andln = function(i) {
        return this.words[0] & i;
      }, f2.prototype.bincn = function(i) {
        r(typeof i == "number");
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return this._expand(h + 1), this.words[h] |= s, this;
        for (var u = s, c = h;u !== 0 && c < this.length; c++) {
          var b2 = this.words[c] | 0;
          b2 += u, u = b2 >>> 26, b2 &= 67108863, this.words[c] = b2;
        }
        return u !== 0 && (this.words[c] = u, this.length++), this;
      }, f2.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, f2.prototype.cmpn = function(i) {
        var a = i < 0;
        if (this.negative !== 0 && !a)
          return -1;
        if (this.negative === 0 && a)
          return 1;
        this.strip();
        var h;
        if (this.length > 1)
          h = 1;
        else {
          a && (i = -i), r(i <= 67108863, "Number is too big");
          var s = this.words[0] | 0;
          h = s === i ? 0 : s < i ? -1 : 1;
        }
        return this.negative !== 0 ? -h | 0 : h;
      }, f2.prototype.cmp = function(i) {
        if (this.negative !== 0 && i.negative === 0)
          return -1;
        if (this.negative === 0 && i.negative !== 0)
          return 1;
        var a = this.ucmp(i);
        return this.negative !== 0 ? -a | 0 : a;
      }, f2.prototype.ucmp = function(i) {
        if (this.length > i.length)
          return 1;
        if (this.length < i.length)
          return -1;
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = this.words[h] | 0, u = i.words[h] | 0;
          if (s !== u) {
            s < u ? a = -1 : s > u && (a = 1);
            break;
          }
        }
        return a;
      }, f2.prototype.gtn = function(i) {
        return this.cmpn(i) === 1;
      }, f2.prototype.gt = function(i) {
        return this.cmp(i) === 1;
      }, f2.prototype.gten = function(i) {
        return this.cmpn(i) >= 0;
      }, f2.prototype.gte = function(i) {
        return this.cmp(i) >= 0;
      }, f2.prototype.ltn = function(i) {
        return this.cmpn(i) === -1;
      }, f2.prototype.lt = function(i) {
        return this.cmp(i) === -1;
      }, f2.prototype.lten = function(i) {
        return this.cmpn(i) <= 0;
      }, f2.prototype.lte = function(i) {
        return this.cmp(i) <= 0;
      }, f2.prototype.eqn = function(i) {
        return this.cmpn(i) === 0;
      }, f2.prototype.eq = function(i) {
        return this.cmp(i) === 0;
      }, f2.red = function(i) {
        return new D3(i);
      }, f2.prototype.toRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), i.convertTo(this)._forceRed(i);
      }, f2.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, f2.prototype._forceRed = function(i) {
        return this.red = i, this;
      }, f2.prototype.forceRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(i);
      }, f2.prototype.redAdd = function(i) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, i);
      }, f2.prototype.redIAdd = function(i) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, i);
      }, f2.prototype.redSub = function(i) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, i);
      }, f2.prototype.redISub = function(i) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, i);
      }, f2.prototype.redShl = function(i) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, i);
      }, f2.prototype.redMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.mul(this, i);
      }, f2.prototype.redIMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.imul(this, i);
      }, f2.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, f2.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, f2.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, f2.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, f2.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, f2.prototype.redPow = function(i) {
        return r(this.red && !i.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, i);
      };
      var Me = { k256: null, p224: null, p192: null, p25519: null };
      function me(v2, i) {
        this.name = v2, this.p = new f2(i, 16), this.n = this.p.bitLength(), this.k = new f2(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      me.prototype._tmp = function() {
        var i = new f2(null);
        return i.words = new Array(Math.ceil(this.n / 13)), i;
      }, me.prototype.ireduce = function(i) {
        var a = i, h;
        do
          this.split(a, this.tmp), a = this.imulK(a), a = a.iadd(this.tmp), h = a.bitLength();
        while (h > this.n);
        var s = h < this.n ? -1 : a.ucmp(this.p);
        return s === 0 ? (a.words[0] = 0, a.length = 1) : s > 0 ? a.isub(this.p) : a.strip !== undefined ? a.strip() : a._strip(), a;
      }, me.prototype.split = function(i, a) {
        i.iushrn(this.n, 0, a);
      }, me.prototype.imulK = function(i) {
        return i.imul(this.k);
      };
      function xe() {
        me.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      o(xe, me), xe.prototype.split = function(i, a) {
        for (var h = 4194303, s = Math.min(i.length, 9), u = 0;u < s; u++)
          a.words[u] = i.words[u];
        if (a.length = s, i.length <= 9) {
          i.words[0] = 0, i.length = 1;
          return;
        }
        var c = i.words[9];
        for (a.words[a.length++] = c & h, u = 10;u < i.length; u++) {
          var b2 = i.words[u] | 0;
          i.words[u - 10] = (b2 & h) << 4 | c >>> 22, c = b2;
        }
        c >>>= 22, i.words[u - 10] = c, c === 0 && i.length > 10 ? i.length -= 10 : i.length -= 9;
      }, xe.prototype.imulK = function(i) {
        i.words[i.length] = 0, i.words[i.length + 1] = 0, i.length += 2;
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = i.words[h] | 0;
          a += s * 977, i.words[h] = a & 67108863, a = s * 64 + (a / 67108864 | 0);
        }
        return i.words[i.length - 1] === 0 && (i.length--, i.words[i.length - 1] === 0 && i.length--), i;
      };
      function Ae() {
        me.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      o(Ae, me);
      function Ee() {
        me.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      o(Ee, me);
      function Re() {
        me.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      o(Re, me), Re.prototype.imulK = function(i) {
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = (i.words[h] | 0) * 19 + a, u = s & 67108863;
          s >>>= 26, i.words[h] = u, a = s;
        }
        return a !== 0 && (i.words[i.length++] = a), i;
      }, f2._prime = function(i) {
        if (Me[i])
          return Me[i];
        var a;
        if (i === "k256")
          a = new xe;
        else if (i === "p224")
          a = new Ae;
        else if (i === "p192")
          a = new Ee;
        else if (i === "p25519")
          a = new Re;
        else
          throw new Error("Unknown prime " + i);
        return Me[i] = a, a;
      };
      function D3(v2) {
        if (typeof v2 == "string") {
          var i = f2._prime(v2);
          this.m = i.p, this.prime = i;
        } else
          r(v2.gtn(1), "modulus must be greater than 1"), this.m = v2, this.prime = null;
      }
      D3.prototype._verify1 = function(i) {
        r(i.negative === 0, "red works only with positives"), r(i.red, "red works only with red numbers");
      }, D3.prototype._verify2 = function(i, a) {
        r((i.negative | a.negative) === 0, "red works only with positives"), r(i.red && i.red === a.red, "red works only with red numbers");
      }, D3.prototype.imod = function(i) {
        return this.prime ? this.prime.ireduce(i)._forceRed(this) : i.umod(this.m)._forceRed(this);
      }, D3.prototype.neg = function(i) {
        return i.isZero() ? i.clone() : this.m.sub(i)._forceRed(this);
      }, D3.prototype.add = function(i, a) {
        this._verify2(i, a);
        var h = i.add(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h._forceRed(this);
      }, D3.prototype.iadd = function(i, a) {
        this._verify2(i, a);
        var h = i.iadd(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h;
      }, D3.prototype.sub = function(i, a) {
        this._verify2(i, a);
        var h = i.sub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h._forceRed(this);
      }, D3.prototype.isub = function(i, a) {
        this._verify2(i, a);
        var h = i.isub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h;
      }, D3.prototype.shl = function(i, a) {
        return this._verify1(i), this.imod(i.ushln(a));
      }, D3.prototype.imul = function(i, a) {
        return this._verify2(i, a), this.imod(i.imul(a));
      }, D3.prototype.mul = function(i, a) {
        return this._verify2(i, a), this.imod(i.mul(a));
      }, D3.prototype.isqr = function(i) {
        return this.imul(i, i.clone());
      }, D3.prototype.sqr = function(i) {
        return this.mul(i, i);
      }, D3.prototype.sqrt = function(i) {
        if (i.isZero())
          return i.clone();
        var a = this.m.andln(3);
        if (r(a % 2 === 1), a === 3) {
          var h = this.m.add(new f2(1)).iushrn(2);
          return this.pow(i, h);
        }
        for (var s = this.m.subn(1), u = 0;!s.isZero() && s.andln(1) === 0; )
          u++, s.iushrn(1);
        r(!s.isZero());
        var c = new f2(1).toRed(this), b2 = c.redNeg(), l = this.m.subn(1).iushrn(1), n = this.m.bitLength();
        for (n = new f2(2 * n * n).toRed(this);this.pow(n, l).cmp(b2) !== 0; )
          n.redIAdd(b2);
        for (var d = this.pow(n, s), w = this.pow(i, s.addn(1).iushrn(1)), g = this.pow(i, s), _2 = u;g.cmp(c) !== 0; ) {
          for (var A = g, B = 0;A.cmp(c) !== 0; B++)
            A = A.redSqr();
          r(B < _2);
          var I = this.pow(d, new f2(1).iushln(_2 - B - 1));
          w = w.redMul(I), d = I.redSqr(), g = g.redMul(d), _2 = B;
        }
        return w;
      }, D3.prototype.invm = function(i) {
        var a = i._invmp(this.m);
        return a.negative !== 0 ? (a.negative = 0, this.imod(a).redNeg()) : this.imod(a);
      }, D3.prototype.pow = function(i, a) {
        if (a.isZero())
          return new f2(1).toRed(this);
        if (a.cmpn(1) === 0)
          return i.clone();
        var h = 4, s = new Array(1 << h);
        s[0] = new f2(1).toRed(this), s[1] = i;
        for (var u = 2;u < s.length; u++)
          s[u] = this.mul(s[u - 1], i);
        var c = s[0], b2 = 0, l = 0, n = a.bitLength() % 26;
        for (n === 0 && (n = 26), u = a.length - 1;u >= 0; u--) {
          for (var d = a.words[u], w = n - 1;w >= 0; w--) {
            var g = d >> w & 1;
            if (c !== s[0] && (c = this.sqr(c)), g === 0 && b2 === 0) {
              l = 0;
              continue;
            }
            b2 <<= 1, b2 |= g, l++, !(l !== h && (u !== 0 || w !== 0)) && (c = this.mul(c, s[b2]), l = 0, b2 = 0);
          }
          n = 26;
        }
        return c;
      }, D3.prototype.convertTo = function(i) {
        var a = i.umod(this.m);
        return a === i ? a.clone() : a;
      }, D3.prototype.convertFrom = function(i) {
        var a = i.clone();
        return a.red = null, a;
      }, f2.mont = function(i) {
        return new Se(i);
      };
      function Se(v2) {
        D3.call(this, v2), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f2(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o(Se, D3), Se.prototype.convertTo = function(i) {
        return this.imod(i.ushln(this.shift));
      }, Se.prototype.convertFrom = function(i) {
        var a = this.imod(i.mul(this.rinv));
        return a.red = null, a;
      }, Se.prototype.imul = function(i, a) {
        if (i.isZero() || a.isZero())
          return i.words[0] = 0, i.length = 1, i;
        var h = i.imul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se.prototype.mul = function(i, a) {
        if (i.isZero() || a.isZero())
          return new f2(0)._forceRed(this);
        var h = i.mul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se.prototype.invm = function(i) {
        var a = this.imod(i._invmp(this.m).mul(this.r2));
        return a._forceRed(this);
      };
    })(typeof Yl > "u" || Yl, D2);
  });
  Xl = k((F2) => {
    var Ys = F2;
    function rR(t, e) {
      if (Array.isArray(t))
        return t.slice();
      if (!t)
        return [];
      var r = [];
      if (typeof t != "string") {
        for (var o = 0;o < t.length; o++)
          r[o] = t[o] | 0;
        return r;
      }
      if (e === "hex") {
        t = t.replace(/[^a-z0-9]+/ig, ""), t.length % 2 !== 0 && (t = "0" + t);
        for (var o = 0;o < t.length; o += 2)
          r.push(parseInt(t[o] + t[o + 1], 16));
      } else
        for (var o = 0;o < t.length; o++) {
          var f2 = t.charCodeAt(o), p = f2 >> 8, m = f2 & 255;
          p ? r.push(p, m) : r.push(m);
        }
      return r;
    }
    Ys.toArray = rR;
    function C2(t) {
      return t.length === 1 ? "0" + t : t;
    }
    Ys.zero2 = C2;
    function O2(t) {
      for (var e = "", r = 0;r < t.length; r++)
        e += C2(t[r].toString(16));
      return e;
    }
    Ys.toHex = O2;
    Ys.encode = function(e, r) {
      return r === "hex" ? O2(e) : e;
    };
  });
  or = k((U2) => {
    var Dr = U2, iR = fi(), nR = ar(), Xs = Xl();
    Dr.assert = nR;
    Dr.toArray = Xs.toArray;
    Dr.zero2 = Xs.zero2;
    Dr.toHex = Xs.toHex;
    Dr.encode = Xs.encode;
    function fR(t, e, r) {
      var o = new Array(Math.max(t.bitLength(), r) + 1);
      o.fill(0);
      for (var f2 = 1 << e + 1, p = t.clone(), m = 0;m < o.length; m++) {
        var y, M = p.andln(f2 - 1);
        p.isOdd() ? (M > (f2 >> 1) - 1 ? y = (f2 >> 1) - M : y = M, p.isubn(y)) : y = 0, o[m] = y, p.iushrn(1);
      }
      return o;
    }
    Dr.getNAF = fR;
    function aR(t, e) {
      var r = [[], []];
      t = t.clone(), e = e.clone();
      for (var o = 0, f2 = 0, p;t.cmpn(-o) > 0 || e.cmpn(-f2) > 0; ) {
        var m = t.andln(3) + o & 3, y = e.andln(3) + f2 & 3;
        m === 3 && (m = -1), y === 3 && (y = -1);
        var M;
        (m & 1) === 0 ? M = 0 : (p = t.andln(7) + o & 7, (p === 3 || p === 5) && y === 2 ? M = -m : M = m), r[0].push(M);
        var x;
        (y & 1) === 0 ? x = 0 : (p = e.andln(7) + f2 & 7, (p === 3 || p === 5) && m === 2 ? x = -y : x = y), r[1].push(x), 2 * o === M + 1 && (o = 1 - o), 2 * f2 === x + 1 && (f2 = 1 - f2), t.iushrn(1), e.iushrn(1);
      }
      return r;
    }
    Dr.getJSF = aR;
    function oR(t, e, r) {
      var o = "_" + e;
      t.prototype[e] = function() {
        return this[o] !== undefined ? this[o] : this[o] = r.call(this);
      };
    }
    Dr.cachedProperty = oR;
    function sR(t) {
      return typeof t == "string" ? Dr.toArray(t, "hex") : t;
    }
    Dr.parseBytes = sR;
    function hR(t) {
      return new iR(t, "hex", "le");
    }
    Dr.intFromLE = hR;
  });
  Wa = k((vL, z2) => {
    var Hn = fi(), Ha = or(), Js = Ha.getNAF, uR = Ha.getJSF, Qs = Ha.assert;
    function Qi(t, e) {
      this.type = t, this.p = new Hn(e.p, 16), this.red = e.prime ? Hn.red(e.prime) : Hn.mont(this.p), this.zero = new Hn(0).toRed(this.red), this.one = new Hn(1).toRed(this.red), this.two = new Hn(2).toRed(this.red), this.n = e.n && new Hn(e.n, 16), this.g = e.g && this.pointFromJSON(e.g, e.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
      var r = this.n && this.p.div(this.n);
      !r || r.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = true, this.redN = this.n.toRed(this.red));
    }
    z2.exports = Qi;
    Qi.prototype.point = function() {
      throw new Error("Not implemented");
    };
    Qi.prototype.validate = function() {
      throw new Error("Not implemented");
    };
    Qi.prototype._fixedNafMul = function(e, r) {
      Qs(e.precomputed);
      var o = e._getDoubles(), f2 = Js(r, 1, this._bitLength), p = (1 << o.step + 1) - (o.step % 2 === 0 ? 2 : 1);
      p /= 3;
      var m = [], y, M;
      for (y = 0;y < f2.length; y += o.step) {
        M = 0;
        for (var x = y + o.step - 1;x >= y; x--)
          M = (M << 1) + f2[x];
        m.push(M);
      }
      for (var S2 = this.jpoint(null, null, null), E = this.jpoint(null, null, null), R = p;R > 0; R--) {
        for (y = 0;y < m.length; y++)
          M = m[y], M === R ? E = E.mixedAdd(o.points[y]) : M === -R && (E = E.mixedAdd(o.points[y].neg()));
        S2 = S2.add(E);
      }
      return S2.toP();
    };
    Qi.prototype._wnafMul = function(e, r) {
      var o = 4, f2 = e._getNAFPoints(o);
      o = f2.wnd;
      for (var p = f2.points, m = Js(r, o, this._bitLength), y = this.jpoint(null, null, null), M = m.length - 1;M >= 0; M--) {
        for (var x = 0;M >= 0 && m[M] === 0; M--)
          x++;
        if (M >= 0 && x++, y = y.dblp(x), M < 0)
          break;
        var S2 = m[M];
        Qs(S2 !== 0), e.type === "affine" ? S2 > 0 ? y = y.mixedAdd(p[S2 - 1 >> 1]) : y = y.mixedAdd(p[-S2 - 1 >> 1].neg()) : S2 > 0 ? y = y.add(p[S2 - 1 >> 1]) : y = y.add(p[-S2 - 1 >> 1].neg());
      }
      return e.type === "affine" ? y.toP() : y;
    };
    Qi.prototype._wnafMulAdd = function(e, r, o, f2, p) {
      var m = this._wnafT1, y = this._wnafT2, M = this._wnafT3, x = 0, S2, E, R;
      for (S2 = 0;S2 < f2; S2++) {
        R = r[S2];
        var q = R._getNAFPoints(e);
        m[S2] = q.wnd, y[S2] = q.points;
      }
      for (S2 = f2 - 1;S2 >= 1; S2 -= 2) {
        var T = S2 - 1, ye = S2;
        if (m[T] !== 1 || m[ye] !== 1) {
          M[T] = Js(o[T], m[T], this._bitLength), M[ye] = Js(o[ye], m[ye], this._bitLength), x = Math.max(M[T].length, x), x = Math.max(M[ye].length, x);
          continue;
        }
        var _e = [r[T], null, null, r[ye]];
        r[T].y.cmp(r[ye].y) === 0 ? (_e[1] = r[T].add(r[ye]), _e[2] = r[T].toJ().mixedAdd(r[ye].neg())) : r[T].y.cmp(r[ye].y.redNeg()) === 0 ? (_e[1] = r[T].toJ().mixedAdd(r[ye]), _e[2] = r[T].add(r[ye].neg())) : (_e[1] = r[T].toJ().mixedAdd(r[ye]), _e[2] = r[T].toJ().mixedAdd(r[ye].neg()));
        var P = [-3, -1, -5, -7, 0, 7, 5, 1, 3], Me = uR(o[T], o[ye]);
        for (x = Math.max(Me[0].length, x), M[T] = new Array(x), M[ye] = new Array(x), E = 0;E < x; E++) {
          var me = Me[0][E] | 0, xe = Me[1][E] | 0;
          M[T][E] = P[(me + 1) * 3 + (xe + 1)], M[ye][E] = 0, y[T] = _e;
        }
      }
      var Ae = this.jpoint(null, null, null), Ee = this._wnafT4;
      for (S2 = x;S2 >= 0; S2--) {
        for (var Re = 0;S2 >= 0; ) {
          var D2 = true;
          for (E = 0;E < f2; E++)
            Ee[E] = M[E][S2] | 0, Ee[E] !== 0 && (D2 = false);
          if (!D2)
            break;
          Re++, S2--;
        }
        if (S2 >= 0 && Re++, Ae = Ae.dblp(Re), S2 < 0)
          break;
        for (E = 0;E < f2; E++) {
          var Se = Ee[E];
          Se !== 0 && (Se > 0 ? R = y[E][Se - 1 >> 1] : Se < 0 && (R = y[E][-Se - 1 >> 1].neg()), R.type === "affine" ? Ae = Ae.mixedAdd(R) : Ae = Ae.add(R));
        }
      }
      for (S2 = 0;S2 < f2; S2++)
        y[S2] = null;
      return p ? Ae : Ae.toP();
    };
    function xr2(t, e) {
      this.curve = t, this.type = e, this.precomputed = null;
    }
    Qi.BasePoint = xr2;
    xr2.prototype.eq = function() {
      throw new Error("Not implemented");
    };
    xr2.prototype.validate = function() {
      return this.curve.validate(this);
    };
    Qi.prototype.decodePoint = function(e, r) {
      e = Ha.toArray(e, r);
      var o = this.p.byteLength();
      if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 === 2 * o) {
        e[0] === 6 ? Qs(e[e.length - 1] % 2 === 0) : e[0] === 7 && Qs(e[e.length - 1] % 2 === 1);
        var f2 = this.point(e.slice(1, 1 + o), e.slice(1 + o, 1 + 2 * o));
        return f2;
      } else if ((e[0] === 2 || e[0] === 3) && e.length - 1 === o)
        return this.pointFromX(e.slice(1, 1 + o), e[0] === 3);
      throw new Error("Unknown point format");
    };
    xr2.prototype.encodeCompressed = function(e) {
      return this.encode(e, true);
    };
    xr2.prototype._encode = function(e) {
      var r = this.curve.p.byteLength(), o = this.getX().toArray("be", r);
      return e ? [this.getY().isEven() ? 2 : 3].concat(o) : [4].concat(o, this.getY().toArray("be", r));
    };
    xr2.prototype.encode = function(e, r) {
      return Ha.encode(this._encode(r), e);
    };
    xr2.prototype.precompute = function(e) {
      if (this.precomputed)
        return this;
      var r = { doubles: null, naf: null, beta: null };
      return r.naf = this._getNAFPoints(8), r.doubles = this._getDoubles(4, e), r.beta = this._getBeta(), this.precomputed = r, this;
    };
    xr2.prototype._hasDoubles = function(e) {
      if (!this.precomputed)
        return false;
      var r = this.precomputed.doubles;
      return r ? r.points.length >= Math.ceil((e.bitLength() + 1) / r.step) : false;
    };
    xr2.prototype._getDoubles = function(e, r) {
      if (this.precomputed && this.precomputed.doubles)
        return this.precomputed.doubles;
      for (var o = [this], f2 = this, p = 0;p < r; p += e) {
        for (var m = 0;m < e; m++)
          f2 = f2.dbl();
        o.push(f2);
      }
      return { step: e, points: o };
    };
    xr2.prototype._getNAFPoints = function(e) {
      if (this.precomputed && this.precomputed.naf)
        return this.precomputed.naf;
      for (var r = [this], o = (1 << e) - 1, f2 = o === 1 ? null : this.dbl(), p = 1;p < o; p++)
        r[p] = r[p - 1].add(f2);
      return { wnd: e, points: r };
    };
    xr2.prototype._getBeta = function() {
      return null;
    };
    xr2.prototype.dblp = function(e) {
      for (var r = this, o = 0;o < e; o++)
        r = r.dbl();
      return r;
    };
  });
  W2 = k((bL, H2) => {
    var lR = or(), lt = fi(), Jl = Ie(), Tf = Wa(), dR = lR.assert;
    function Sr(t) {
      Tf.call(this, "short", t), this.a = new lt(t.a, 16).toRed(this.red), this.b = new lt(t.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(t), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
    }
    Jl(Sr, Tf);
    H2.exports = Sr;
    Sr.prototype._getEndomorphism = function(e) {
      if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
        var r, o;
        if (e.beta)
          r = new lt(e.beta, 16).toRed(this.red);
        else {
          var f2 = this._getEndoRoots(this.p);
          r = f2[0].cmp(f2[1]) < 0 ? f2[0] : f2[1], r = r.toRed(this.red);
        }
        if (e.lambda)
          o = new lt(e.lambda, 16);
        else {
          var p = this._getEndoRoots(this.n);
          this.g.mul(p[0]).x.cmp(this.g.x.redMul(r)) === 0 ? o = p[0] : (o = p[1], dR(this.g.mul(o).x.cmp(this.g.x.redMul(r)) === 0));
        }
        var m;
        return e.basis ? m = e.basis.map(function(y) {
          return { a: new lt(y.a, 16), b: new lt(y.b, 16) };
        }) : m = this._getEndoBasis(o), { beta: r, lambda: o, basis: m };
      }
    };
    Sr.prototype._getEndoRoots = function(e) {
      var r = e === this.p ? this.red : lt.mont(e), o = new lt(2).toRed(r).redInvm(), f2 = o.redNeg(), p = new lt(3).toRed(r).redNeg().redSqrt().redMul(o), m = f2.redAdd(p).fromRed(), y = f2.redSub(p).fromRed();
      return [m, y];
    };
    Sr.prototype._getEndoBasis = function(e) {
      for (var r = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), o = e, f2 = this.n.clone(), p = new lt(1), m = new lt(0), y = new lt(0), M = new lt(1), x, S2, E, R, q, T, ye, _e = 0, P, Me;o.cmpn(0) !== 0; ) {
        var me = f2.div(o);
        P = f2.sub(me.mul(o)), Me = y.sub(me.mul(p));
        var xe = M.sub(me.mul(m));
        if (!E && P.cmp(r) < 0)
          x = ye.neg(), S2 = p, E = P.neg(), R = Me;
        else if (E && ++_e === 2)
          break;
        ye = P, f2 = o, o = P, y = p, p = Me, M = m, m = xe;
      }
      q = P.neg(), T = Me;
      var Ae = E.sqr().add(R.sqr()), Ee = q.sqr().add(T.sqr());
      return Ee.cmp(Ae) >= 0 && (q = x, T = S2), E.negative && (E = E.neg(), R = R.neg()), q.negative && (q = q.neg(), T = T.neg()), [{ a: E, b: R }, { a: q, b: T }];
    };
    Sr.prototype._endoSplit = function(e) {
      var r = this.endo.basis, o = r[0], f2 = r[1], p = f2.b.mul(e).divRound(this.n), m = o.b.neg().mul(e).divRound(this.n), y = p.mul(o.a), M = m.mul(f2.a), x = p.mul(o.b), S2 = m.mul(f2.b), E = e.sub(y).sub(M), R = x.add(S2).neg();
      return { k1: E, k2: R };
    };
    Sr.prototype.pointFromX = function(e, r) {
      e = new lt(e, 16), e.red || (e = e.toRed(this.red));
      var o = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b), f2 = o.redSqrt();
      if (f2.redSqr().redSub(o).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var p = f2.fromRed().isOdd();
      return (r && !p || !r && p) && (f2 = f2.redNeg()), this.point(e, f2);
    };
    Sr.prototype.validate = function(e) {
      if (e.inf)
        return true;
      var { x: r, y: o } = e, f2 = this.a.redMul(r), p = r.redSqr().redMul(r).redIAdd(f2).redIAdd(this.b);
      return o.redSqr().redISub(p).cmpn(0) === 0;
    };
    Sr.prototype._endoWnafMulAdd = function(e, r, o) {
      for (var f2 = this._endoWnafT1, p = this._endoWnafT2, m = 0;m < e.length; m++) {
        var y = this._endoSplit(r[m]), M = e[m], x = M._getBeta();
        y.k1.negative && (y.k1.ineg(), M = M.neg(true)), y.k2.negative && (y.k2.ineg(), x = x.neg(true)), f2[m * 2] = M, f2[m * 2 + 1] = x, p[m * 2] = y.k1, p[m * 2 + 1] = y.k2;
      }
      for (var S2 = this._wnafMulAdd(1, f2, p, m * 2, o), E = 0;E < m * 2; E++)
        f2[E] = null, p[E] = null;
      return S2;
    };
    function Ct(t, e, r, o) {
      Tf.BasePoint.call(this, t, "affine"), e === null && r === null ? (this.x = null, this.y = null, this.inf = true) : (this.x = new lt(e, 16), this.y = new lt(r, 16), o && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = false);
    }
    Jl(Ct, Tf.BasePoint);
    Sr.prototype.point = function(e, r, o) {
      return new Ct(this, e, r, o);
    };
    Sr.prototype.pointFromJSON = function(e, r) {
      return Ct.fromJSON(this, e, r);
    };
    Ct.prototype._getBeta = function() {
      if (!!this.curve.endo) {
        var e = this.precomputed;
        if (e && e.beta)
          return e.beta;
        var r = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
        if (e) {
          var o = this.curve, f2 = function(p) {
            return o.point(p.x.redMul(o.endo.beta), p.y);
          };
          e.beta = r, r.precomputed = { beta: null, naf: e.naf && { wnd: e.naf.wnd, points: e.naf.points.map(f2) }, doubles: e.doubles && { step: e.doubles.step, points: e.doubles.points.map(f2) } };
        }
        return r;
      }
    };
    Ct.prototype.toJSON = function() {
      return this.precomputed ? [this.x, this.y, this.precomputed && { doubles: this.precomputed.doubles && { step: this.precomputed.doubles.step, points: this.precomputed.doubles.points.slice(1) }, naf: this.precomputed.naf && { wnd: this.precomputed.naf.wnd, points: this.precomputed.naf.points.slice(1) } }] : [this.x, this.y];
    };
    Ct.fromJSON = function(e, r, o) {
      typeof r == "string" && (r = JSON.parse(r));
      var f2 = e.point(r[0], r[1], o);
      if (!r[2])
        return f2;
      function p(y) {
        return e.point(y[0], y[1], o);
      }
      var m = r[2];
      return f2.precomputed = { beta: null, doubles: m.doubles && { step: m.doubles.step, points: [f2].concat(m.doubles.points.map(p)) }, naf: m.naf && { wnd: m.naf.wnd, points: [f2].concat(m.naf.points.map(p)) } }, f2;
    };
    Ct.prototype.inspect = function() {
      return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
    };
    Ct.prototype.isInfinity = function() {
      return this.inf;
    };
    Ct.prototype.add = function(e) {
      if (this.inf)
        return e;
      if (e.inf)
        return this;
      if (this.eq(e))
        return this.dbl();
      if (this.neg().eq(e))
        return this.curve.point(null, null);
      if (this.x.cmp(e.x) === 0)
        return this.curve.point(null, null);
      var r = this.y.redSub(e.y);
      r.cmpn(0) !== 0 && (r = r.redMul(this.x.redSub(e.x).redInvm()));
      var o = r.redSqr().redISub(this.x).redISub(e.x), f2 = r.redMul(this.x.redSub(o)).redISub(this.y);
      return this.curve.point(o, f2);
    };
    Ct.prototype.dbl = function() {
      if (this.inf)
        return this;
      var e = this.y.redAdd(this.y);
      if (e.cmpn(0) === 0)
        return this.curve.point(null, null);
      var r = this.curve.a, o = this.x.redSqr(), f2 = e.redInvm(), p = o.redAdd(o).redIAdd(o).redIAdd(r).redMul(f2), m = p.redSqr().redISub(this.x.redAdd(this.x)), y = p.redMul(this.x.redSub(m)).redISub(this.y);
      return this.curve.point(m, y);
    };
    Ct.prototype.getX = function() {
      return this.x.fromRed();
    };
    Ct.prototype.getY = function() {
      return this.y.fromRed();
    };
    Ct.prototype.mul = function(e) {
      return e = new lt(e, 16), this.isInfinity() ? this : this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [e]) : this.curve._wnafMul(this, e);
    };
    Ct.prototype.mulAdd = function(e, r, o) {
      var f2 = [this, r], p = [e, o];
      return this.curve.endo ? this.curve._endoWnafMulAdd(f2, p) : this.curve._wnafMulAdd(1, f2, p, 2);
    };
    Ct.prototype.jmulAdd = function(e, r, o) {
      var f2 = [this, r], p = [e, o];
      return this.curve.endo ? this.curve._endoWnafMulAdd(f2, p, true) : this.curve._wnafMulAdd(1, f2, p, 2, true);
    };
    Ct.prototype.eq = function(e) {
      return this === e || this.inf === e.inf && (this.inf || this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0);
    };
    Ct.prototype.neg = function(e) {
      if (this.inf)
        return this;
      var r = this.curve.point(this.x, this.y.redNeg());
      if (e && this.precomputed) {
        var o = this.precomputed, f2 = function(p) {
          return p.neg();
        };
        r.precomputed = { naf: o.naf && { wnd: o.naf.wnd, points: o.naf.points.map(f2) }, doubles: o.doubles && { step: o.doubles.step, points: o.doubles.points.map(f2) } };
      }
      return r;
    };
    Ct.prototype.toJ = function() {
      if (this.inf)
        return this.curve.jpoint(null, null, null);
      var e = this.curve.jpoint(this.x, this.y, this.curve.one);
      return e;
    };
    function Wt(t, e, r, o) {
      Tf.BasePoint.call(this, t, "jacobian"), e === null && r === null && o === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new lt(0)) : (this.x = new lt(e, 16), this.y = new lt(r, 16), this.z = new lt(o, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
    }
    Jl(Wt, Tf.BasePoint);
    Sr.prototype.jpoint = function(e, r, o) {
      return new Wt(this, e, r, o);
    };
    Wt.prototype.toP = function() {
      if (this.isInfinity())
        return this.curve.point(null, null);
      var e = this.z.redInvm(), r = e.redSqr(), o = this.x.redMul(r), f2 = this.y.redMul(r).redMul(e);
      return this.curve.point(o, f2);
    };
    Wt.prototype.neg = function() {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    };
    Wt.prototype.add = function(e) {
      if (this.isInfinity())
        return e;
      if (e.isInfinity())
        return this;
      var r = e.z.redSqr(), o = this.z.redSqr(), f2 = this.x.redMul(r), p = e.x.redMul(o), m = this.y.redMul(r.redMul(e.z)), y = e.y.redMul(o.redMul(this.z)), M = f2.redSub(p), x = m.redSub(y);
      if (M.cmpn(0) === 0)
        return x.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
      var S2 = M.redSqr(), E = S2.redMul(M), R = f2.redMul(S2), q = x.redSqr().redIAdd(E).redISub(R).redISub(R), T = x.redMul(R.redISub(q)).redISub(m.redMul(E)), ye = this.z.redMul(e.z).redMul(M);
      return this.curve.jpoint(q, T, ye);
    };
    Wt.prototype.mixedAdd = function(e) {
      if (this.isInfinity())
        return e.toJ();
      if (e.isInfinity())
        return this;
      var r = this.z.redSqr(), o = this.x, f2 = e.x.redMul(r), p = this.y, m = e.y.redMul(r).redMul(this.z), y = o.redSub(f2), M = p.redSub(m);
      if (y.cmpn(0) === 0)
        return M.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
      var x = y.redSqr(), S2 = x.redMul(y), E = o.redMul(x), R = M.redSqr().redIAdd(S2).redISub(E).redISub(E), q = M.redMul(E.redISub(R)).redISub(p.redMul(S2)), T = this.z.redMul(y);
      return this.curve.jpoint(R, q, T);
    };
    Wt.prototype.dblp = function(e) {
      if (e === 0)
        return this;
      if (this.isInfinity())
        return this;
      if (!e)
        return this.dbl();
      var r;
      if (this.curve.zeroA || this.curve.threeA) {
        var o = this;
        for (r = 0;r < e; r++)
          o = o.dbl();
        return o;
      }
      var f2 = this.curve.a, p = this.curve.tinv, m = this.x, y = this.y, M = this.z, x = M.redSqr().redSqr(), S2 = y.redAdd(y);
      for (r = 0;r < e; r++) {
        var E = m.redSqr(), R = S2.redSqr(), q = R.redSqr(), T = E.redAdd(E).redIAdd(E).redIAdd(f2.redMul(x)), ye = m.redMul(R), _e = T.redSqr().redISub(ye.redAdd(ye)), P = ye.redISub(_e), Me = T.redMul(P);
        Me = Me.redIAdd(Me).redISub(q);
        var me = S2.redMul(M);
        r + 1 < e && (x = x.redMul(q)), m = _e, M = me, S2 = Me;
      }
      return this.curve.jpoint(m, S2.redMul(p), M);
    };
    Wt.prototype.dbl = function() {
      return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
    };
    Wt.prototype._zeroDbl = function() {
      var e, r, o;
      if (this.zOne) {
        var f2 = this.x.redSqr(), p = this.y.redSqr(), m = p.redSqr(), y = this.x.redAdd(p).redSqr().redISub(f2).redISub(m);
        y = y.redIAdd(y);
        var M = f2.redAdd(f2).redIAdd(f2), x = M.redSqr().redISub(y).redISub(y), S2 = m.redIAdd(m);
        S2 = S2.redIAdd(S2), S2 = S2.redIAdd(S2), e = x, r = M.redMul(y.redISub(x)).redISub(S2), o = this.y.redAdd(this.y);
      } else {
        var E = this.x.redSqr(), R = this.y.redSqr(), q = R.redSqr(), T = this.x.redAdd(R).redSqr().redISub(E).redISub(q);
        T = T.redIAdd(T);
        var ye = E.redAdd(E).redIAdd(E), _e = ye.redSqr(), P = q.redIAdd(q);
        P = P.redIAdd(P), P = P.redIAdd(P), e = _e.redISub(T).redISub(T), r = ye.redMul(T.redISub(e)).redISub(P), o = this.y.redMul(this.z), o = o.redIAdd(o);
      }
      return this.curve.jpoint(e, r, o);
    };
    Wt.prototype._threeDbl = function() {
      var e, r, o;
      if (this.zOne) {
        var f2 = this.x.redSqr(), p = this.y.redSqr(), m = p.redSqr(), y = this.x.redAdd(p).redSqr().redISub(f2).redISub(m);
        y = y.redIAdd(y);
        var M = f2.redAdd(f2).redIAdd(f2).redIAdd(this.curve.a), x = M.redSqr().redISub(y).redISub(y);
        e = x;
        var S2 = m.redIAdd(m);
        S2 = S2.redIAdd(S2), S2 = S2.redIAdd(S2), r = M.redMul(y.redISub(x)).redISub(S2), o = this.y.redAdd(this.y);
      } else {
        var E = this.z.redSqr(), R = this.y.redSqr(), q = this.x.redMul(R), T = this.x.redSub(E).redMul(this.x.redAdd(E));
        T = T.redAdd(T).redIAdd(T);
        var ye = q.redIAdd(q);
        ye = ye.redIAdd(ye);
        var _e = ye.redAdd(ye);
        e = T.redSqr().redISub(_e), o = this.y.redAdd(this.z).redSqr().redISub(R).redISub(E);
        var P = R.redSqr();
        P = P.redIAdd(P), P = P.redIAdd(P), P = P.redIAdd(P), r = T.redMul(ye.redISub(e)).redISub(P);
      }
      return this.curve.jpoint(e, r, o);
    };
    Wt.prototype._dbl = function() {
      var e = this.curve.a, r = this.x, o = this.y, f2 = this.z, p = f2.redSqr().redSqr(), m = r.redSqr(), y = o.redSqr(), M = m.redAdd(m).redIAdd(m).redIAdd(e.redMul(p)), x = r.redAdd(r);
      x = x.redIAdd(x);
      var S2 = x.redMul(y), E = M.redSqr().redISub(S2.redAdd(S2)), R = S2.redISub(E), q = y.redSqr();
      q = q.redIAdd(q), q = q.redIAdd(q), q = q.redIAdd(q);
      var T = M.redMul(R).redISub(q), ye = o.redAdd(o).redMul(f2);
      return this.curve.jpoint(E, T, ye);
    };
    Wt.prototype.trpl = function() {
      if (!this.curve.zeroA)
        return this.dbl().add(this);
      var e = this.x.redSqr(), r = this.y.redSqr(), o = this.z.redSqr(), f2 = r.redSqr(), p = e.redAdd(e).redIAdd(e), m = p.redSqr(), y = this.x.redAdd(r).redSqr().redISub(e).redISub(f2);
      y = y.redIAdd(y), y = y.redAdd(y).redIAdd(y), y = y.redISub(m);
      var M = y.redSqr(), x = f2.redIAdd(f2);
      x = x.redIAdd(x), x = x.redIAdd(x), x = x.redIAdd(x);
      var S2 = p.redIAdd(y).redSqr().redISub(m).redISub(M).redISub(x), E = r.redMul(S2);
      E = E.redIAdd(E), E = E.redIAdd(E);
      var R = this.x.redMul(M).redISub(E);
      R = R.redIAdd(R), R = R.redIAdd(R);
      var q = this.y.redMul(S2.redMul(x.redISub(S2)).redISub(y.redMul(M)));
      q = q.redIAdd(q), q = q.redIAdd(q), q = q.redIAdd(q);
      var T = this.z.redAdd(y).redSqr().redISub(o).redISub(M);
      return this.curve.jpoint(R, q, T);
    };
    Wt.prototype.mul = function(e, r) {
      return e = new lt(e, r), this.curve._wnafMul(this, e);
    };
    Wt.prototype.eq = function(e) {
      if (e.type === "affine")
        return this.eq(e.toJ());
      if (this === e)
        return true;
      var r = this.z.redSqr(), o = e.z.redSqr();
      if (this.x.redMul(o).redISub(e.x.redMul(r)).cmpn(0) !== 0)
        return false;
      var f2 = r.redMul(this.z), p = o.redMul(e.z);
      return this.y.redMul(p).redISub(e.y.redMul(f2)).cmpn(0) === 0;
    };
    Wt.prototype.eqXToP = function(e) {
      var r = this.z.redSqr(), o = e.toRed(this.curve.red).redMul(r);
      if (this.x.cmp(o) === 0)
        return true;
      for (var f2 = e.clone(), p = this.curve.redN.redMul(r);; ) {
        if (f2.iadd(this.curve.n), f2.cmp(this.curve.p) >= 0)
          return false;
        if (o.redIAdd(p), this.x.cmp(o) === 0)
          return true;
      }
    };
    Wt.prototype.inspect = function() {
      return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
    };
    Wt.prototype.isInfinity = function() {
      return this.z.cmpn(0) === 0;
    };
  });
  Z2 = k((mL, j2) => {
    var kf = fi(), K2 = Ie(), e0 = Wa(), cR = or();
    function Lf(t) {
      e0.call(this, "mont", t), this.a = new kf(t.a, 16).toRed(this.red), this.b = new kf(t.b, 16).toRed(this.red), this.i4 = new kf(4).toRed(this.red).redInvm(), this.two = new kf(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
    }
    K2(Lf, e0);
    j2.exports = Lf;
    Lf.prototype.validate = function(e) {
      var r = e.normalize().x, o = r.redSqr(), f2 = o.redMul(r).redAdd(o.redMul(this.a)).redAdd(r), p = f2.redSqrt();
      return p.redSqr().cmp(f2) === 0;
    };
    function Ot(t, e, r) {
      e0.BasePoint.call(this, t, "projective"), e === null && r === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new kf(e, 16), this.z = new kf(r, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
    }
    K2(Ot, e0.BasePoint);
    Lf.prototype.decodePoint = function(e, r) {
      return this.point(cR.toArray(e, r), 1);
    };
    Lf.prototype.point = function(e, r) {
      return new Ot(this, e, r);
    };
    Lf.prototype.pointFromJSON = function(e) {
      return Ot.fromJSON(this, e);
    };
    Ot.prototype.precompute = function() {
    };
    Ot.prototype._encode = function() {
      return this.getX().toArray("be", this.curve.p.byteLength());
    };
    Ot.fromJSON = function(e, r) {
      return new Ot(e, r[0], r[1] || e.one);
    };
    Ot.prototype.inspect = function() {
      return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Ot.prototype.isInfinity = function() {
      return this.z.cmpn(0) === 0;
    };
    Ot.prototype.dbl = function() {
      var e = this.x.redAdd(this.z), r = e.redSqr(), o = this.x.redSub(this.z), f2 = o.redSqr(), p = r.redSub(f2), m = r.redMul(f2), y = p.redMul(f2.redAdd(this.curve.a24.redMul(p)));
      return this.curve.point(m, y);
    };
    Ot.prototype.add = function() {
      throw new Error("Not supported on Montgomery curve");
    };
    Ot.prototype.diffAdd = function(e, r) {
      var o = this.x.redAdd(this.z), f2 = this.x.redSub(this.z), p = e.x.redAdd(e.z), m = e.x.redSub(e.z), y = m.redMul(o), M = p.redMul(f2), x = r.z.redMul(y.redAdd(M).redSqr()), S2 = r.x.redMul(y.redISub(M).redSqr());
      return this.curve.point(x, S2);
    };
    Ot.prototype.mul = function(e) {
      for (var r = e.clone(), o = this, f2 = this.curve.point(null, null), p = this, m = [];r.cmpn(0) !== 0; r.iushrn(1))
        m.push(r.andln(1));
      for (var y = m.length - 1;y >= 0; y--)
        m[y] === 0 ? (o = o.diffAdd(f2, p), f2 = f2.dbl()) : (f2 = o.diffAdd(f2, p), o = o.dbl());
      return f2;
    };
    Ot.prototype.mulAdd = function() {
      throw new Error("Not supported on Montgomery curve");
    };
    Ot.prototype.jumlAdd = function() {
      throw new Error("Not supported on Montgomery curve");
    };
    Ot.prototype.eq = function(e) {
      return this.getX().cmp(e.getX()) === 0;
    };
    Ot.prototype.normalize = function() {
      return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
    };
    Ot.prototype.getX = function() {
      return this.normalize(), this.x.fromRed();
    };
  });
  G2 = k((gL, $2) => {
    var pR = or(), Ii = fi(), V2 = Ie(), t0 = Wa(), vR = pR.assert;
    function ai(t) {
      this.twisted = (t.a | 0) !== 1, this.mOneA = this.twisted && (t.a | 0) === -1, this.extended = this.mOneA, t0.call(this, "edwards", t), this.a = new Ii(t.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new Ii(t.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new Ii(t.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), vR(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (t.c | 0) === 1;
    }
    V2(ai, t0);
    $2.exports = ai;
    ai.prototype._mulA = function(e) {
      return this.mOneA ? e.redNeg() : this.a.redMul(e);
    };
    ai.prototype._mulC = function(e) {
      return this.oneC ? e : this.c.redMul(e);
    };
    ai.prototype.jpoint = function(e, r, o, f2) {
      return this.point(e, r, o, f2);
    };
    ai.prototype.pointFromX = function(e, r) {
      e = new Ii(e, 16), e.red || (e = e.toRed(this.red));
      var o = e.redSqr(), f2 = this.c2.redSub(this.a.redMul(o)), p = this.one.redSub(this.c2.redMul(this.d).redMul(o)), m = f2.redMul(p.redInvm()), y = m.redSqrt();
      if (y.redSqr().redSub(m).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var M = y.fromRed().isOdd();
      return (r && !M || !r && M) && (y = y.redNeg()), this.point(e, y);
    };
    ai.prototype.pointFromY = function(e, r) {
      e = new Ii(e, 16), e.red || (e = e.toRed(this.red));
      var o = e.redSqr(), f2 = o.redSub(this.c2), p = o.redMul(this.d).redMul(this.c2).redSub(this.a), m = f2.redMul(p.redInvm());
      if (m.cmp(this.zero) === 0) {
        if (r)
          throw new Error("invalid point");
        return this.point(this.zero, e);
      }
      var y = m.redSqrt();
      if (y.redSqr().redSub(m).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      return y.fromRed().isOdd() !== r && (y = y.redNeg()), this.point(y, e);
    };
    ai.prototype.validate = function(e) {
      if (e.isInfinity())
        return true;
      e.normalize();
      var r = e.x.redSqr(), o = e.y.redSqr(), f2 = r.redMul(this.a).redAdd(o), p = this.c2.redMul(this.one.redAdd(this.d.redMul(r).redMul(o)));
      return f2.cmp(p) === 0;
    };
    function at(t, e, r, o, f2) {
      t0.BasePoint.call(this, t, "projective"), e === null && r === null && o === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = true) : (this.x = new Ii(e, 16), this.y = new Ii(r, 16), this.z = o ? new Ii(o, 16) : this.curve.one, this.t = f2 && new Ii(f2, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
    }
    V2(at, t0.BasePoint);
    ai.prototype.pointFromJSON = function(e) {
      return at.fromJSON(this, e);
    };
    ai.prototype.point = function(e, r, o, f2) {
      return new at(this, e, r, o, f2);
    };
    at.fromJSON = function(e, r) {
      return new at(e, r[0], r[1], r[2]);
    };
    at.prototype.inspect = function() {
      return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    at.prototype.isInfinity = function() {
      return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
    };
    at.prototype._extDbl = function() {
      var e = this.x.redSqr(), r = this.y.redSqr(), o = this.z.redSqr();
      o = o.redIAdd(o);
      var f2 = this.curve._mulA(e), p = this.x.redAdd(this.y).redSqr().redISub(e).redISub(r), m = f2.redAdd(r), y = m.redSub(o), M = f2.redSub(r), x = p.redMul(y), S2 = m.redMul(M), E = p.redMul(M), R = y.redMul(m);
      return this.curve.point(x, S2, R, E);
    };
    at.prototype._projDbl = function() {
      var e = this.x.redAdd(this.y).redSqr(), r = this.x.redSqr(), o = this.y.redSqr(), f2, p, m, y, M, x;
      if (this.curve.twisted) {
        y = this.curve._mulA(r);
        var S2 = y.redAdd(o);
        this.zOne ? (f2 = e.redSub(r).redSub(o).redMul(S2.redSub(this.curve.two)), p = S2.redMul(y.redSub(o)), m = S2.redSqr().redSub(S2).redSub(S2)) : (M = this.z.redSqr(), x = S2.redSub(M).redISub(M), f2 = e.redSub(r).redISub(o).redMul(x), p = S2.redMul(y.redSub(o)), m = S2.redMul(x));
      } else
        y = r.redAdd(o), M = this.curve._mulC(this.z).redSqr(), x = y.redSub(M).redSub(M), f2 = this.curve._mulC(e.redISub(y)).redMul(x), p = this.curve._mulC(y).redMul(r.redISub(o)), m = y.redMul(x);
      return this.curve.point(f2, p, m);
    };
    at.prototype.dbl = function() {
      return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
    };
    at.prototype._extAdd = function(e) {
      var r = this.y.redSub(this.x).redMul(e.y.redSub(e.x)), o = this.y.redAdd(this.x).redMul(e.y.redAdd(e.x)), f2 = this.t.redMul(this.curve.dd).redMul(e.t), p = this.z.redMul(e.z.redAdd(e.z)), m = o.redSub(r), y = p.redSub(f2), M = p.redAdd(f2), x = o.redAdd(r), S2 = m.redMul(y), E = M.redMul(x), R = m.redMul(x), q = y.redMul(M);
      return this.curve.point(S2, E, q, R);
    };
    at.prototype._projAdd = function(e) {
      var r = this.z.redMul(e.z), o = r.redSqr(), f2 = this.x.redMul(e.x), p = this.y.redMul(e.y), m = this.curve.d.redMul(f2).redMul(p), y = o.redSub(m), M = o.redAdd(m), x = this.x.redAdd(this.y).redMul(e.x.redAdd(e.y)).redISub(f2).redISub(p), S2 = r.redMul(y).redMul(x), E, R;
      return this.curve.twisted ? (E = r.redMul(M).redMul(p.redSub(this.curve._mulA(f2))), R = y.redMul(M)) : (E = r.redMul(M).redMul(p.redSub(f2)), R = this.curve._mulC(y).redMul(M)), this.curve.point(S2, E, R);
    };
    at.prototype.add = function(e) {
      return this.isInfinity() ? e : e.isInfinity() ? this : this.curve.extended ? this._extAdd(e) : this._projAdd(e);
    };
    at.prototype.mul = function(e) {
      return this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve._wnafMul(this, e);
    };
    at.prototype.mulAdd = function(e, r, o) {
      return this.curve._wnafMulAdd(1, [this, r], [e, o], 2, false);
    };
    at.prototype.jmulAdd = function(e, r, o) {
      return this.curve._wnafMulAdd(1, [this, r], [e, o], 2, true);
    };
    at.prototype.normalize = function() {
      if (this.zOne)
        return this;
      var e = this.z.redInvm();
      return this.x = this.x.redMul(e), this.y = this.y.redMul(e), this.t && (this.t = this.t.redMul(e)), this.z = this.curve.one, this.zOne = true, this;
    };
    at.prototype.neg = function() {
      return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
    };
    at.prototype.getX = function() {
      return this.normalize(), this.x.fromRed();
    };
    at.prototype.getY = function() {
      return this.normalize(), this.y.fromRed();
    };
    at.prototype.eq = function(e) {
      return this === e || this.getX().cmp(e.getX()) === 0 && this.getY().cmp(e.getY()) === 0;
    };
    at.prototype.eqXToP = function(e) {
      var r = e.toRed(this.curve.red).redMul(this.z);
      if (this.x.cmp(r) === 0)
        return true;
      for (var o = e.clone(), f2 = this.curve.redN.redMul(this.z);; ) {
        if (o.iadd(this.curve.n), o.cmp(this.curve.p) >= 0)
          return false;
        if (r.redIAdd(f2), this.x.cmp(r) === 0)
          return true;
      }
    };
    at.prototype.toP = at.prototype.normalize;
    at.prototype.mixedAdd = at.prototype.add;
  });
  Ql = k((Y2) => {
    var r0 = Y2;
    r0.base = Wa();
    r0.short = W2();
    r0.mont = Z2();
    r0.edwards = G2();
  });
  Cr = k((it) => {
    var bR = ar(), mR = Ie();
    it.inherits = mR;
    function gR(t, e) {
      return (t.charCodeAt(e) & 64512) !== 55296 || e < 0 || e + 1 >= t.length ? false : (t.charCodeAt(e + 1) & 64512) === 56320;
    }
    function yR(t, e) {
      if (Array.isArray(t))
        return t.slice();
      if (!t)
        return [];
      var r = [];
      if (typeof t == "string")
        if (e) {
          if (e === "hex")
            for (t = t.replace(/[^a-z0-9]+/ig, ""), t.length % 2 !== 0 && (t = "0" + t), f2 = 0;f2 < t.length; f2 += 2)
              r.push(parseInt(t[f2] + t[f2 + 1], 16));
        } else
          for (var o = 0, f2 = 0;f2 < t.length; f2++) {
            var p = t.charCodeAt(f2);
            p < 128 ? r[o++] = p : p < 2048 ? (r[o++] = p >> 6 | 192, r[o++] = p & 63 | 128) : gR(t, f2) ? (p = 65536 + ((p & 1023) << 10) + (t.charCodeAt(++f2) & 1023), r[o++] = p >> 18 | 240, r[o++] = p >> 12 & 63 | 128, r[o++] = p >> 6 & 63 | 128, r[o++] = p & 63 | 128) : (r[o++] = p >> 12 | 224, r[o++] = p >> 6 & 63 | 128, r[o++] = p & 63 | 128);
          }
      else
        for (f2 = 0;f2 < t.length; f2++)
          r[f2] = t[f2] | 0;
      return r;
    }
    it.toArray = yR;
    function wR(t) {
      for (var e = "", r = 0;r < t.length; r++)
        e += J2(t[r].toString(16));
      return e;
    }
    it.toHex = wR;
    function X2(t) {
      var e = t >>> 24 | t >>> 8 & 65280 | t << 8 & 16711680 | (t & 255) << 24;
      return e >>> 0;
    }
    it.htonl = X2;
    function MR(t, e) {
      for (var r = "", o = 0;o < t.length; o++) {
        var f2 = t[o];
        e === "little" && (f2 = X2(f2)), r += Q2(f2.toString(16));
      }
      return r;
    }
    it.toHex32 = MR;
    function J2(t) {
      return t.length === 1 ? "0" + t : t;
    }
    it.zero2 = J2;
    function Q2(t) {
      return t.length === 7 ? "0" + t : t.length === 6 ? "00" + t : t.length === 5 ? "000" + t : t.length === 4 ? "0000" + t : t.length === 3 ? "00000" + t : t.length === 2 ? "000000" + t : t.length === 1 ? "0000000" + t : t;
    }
    it.zero8 = Q2;
    function _R(t, e, r, o) {
      var f2 = r - e;
      bR(f2 % 4 === 0);
      for (var p = new Array(f2 / 4), m = 0, y = e;m < p.length; m++, y += 4) {
        var M;
        o === "big" ? M = t[y] << 24 | t[y + 1] << 16 | t[y + 2] << 8 | t[y + 3] : M = t[y + 3] << 24 | t[y + 2] << 16 | t[y + 1] << 8 | t[y], p[m] = M >>> 0;
      }
      return p;
    }
    it.join32 = _R;
    function xR(t, e) {
      for (var r = new Array(t.length * 4), o = 0, f2 = 0;o < t.length; o++, f2 += 4) {
        var p = t[o];
        e === "big" ? (r[f2] = p >>> 24, r[f2 + 1] = p >>> 16 & 255, r[f2 + 2] = p >>> 8 & 255, r[f2 + 3] = p & 255) : (r[f2 + 3] = p >>> 24, r[f2 + 2] = p >>> 16 & 255, r[f2 + 1] = p >>> 8 & 255, r[f2] = p & 255);
      }
      return r;
    }
    it.split32 = xR;
    function SR(t, e) {
      return t >>> e | t << 32 - e;
    }
    it.rotr32 = SR;
    function ER(t, e) {
      return t << e | t >>> 32 - e;
    }
    it.rotl32 = ER;
    function AR(t, e) {
      return t + e >>> 0;
    }
    it.sum32 = AR;
    function RR(t, e, r) {
      return t + e + r >>> 0;
    }
    it.sum32_3 = RR;
    function BR(t, e, r, o) {
      return t + e + r + o >>> 0;
    }
    it.sum32_4 = BR;
    function qR(t, e, r, o, f2) {
      return t + e + r + o + f2 >>> 0;
    }
    it.sum32_5 = qR;
    function IR(t, e, r, o) {
      var f2 = t[e], p = t[e + 1], m = o + p >>> 0, y = (m < o ? 1 : 0) + r + f2;
      t[e] = y >>> 0, t[e + 1] = m;
    }
    it.sum64 = IR;
    function TR(t, e, r, o) {
      var f2 = e + o >>> 0, p = (f2 < e ? 1 : 0) + t + r;
      return p >>> 0;
    }
    it.sum64_hi = TR;
    function kR(t, e, r, o) {
      var f2 = e + o;
      return f2 >>> 0;
    }
    it.sum64_lo = kR;
    function LR(t, e, r, o, f2, p, m, y) {
      var M = 0, x = e;
      x = x + o >>> 0, M += x < e ? 1 : 0, x = x + p >>> 0, M += x < p ? 1 : 0, x = x + y >>> 0, M += x < y ? 1 : 0;
      var S2 = t + r + f2 + m + M;
      return S2 >>> 0;
    }
    it.sum64_4_hi = LR;
    function NR(t, e, r, o, f2, p, m, y) {
      var M = e + o + p + y;
      return M >>> 0;
    }
    it.sum64_4_lo = NR;
    function PR(t, e, r, o, f2, p, m, y, M, x) {
      var S2 = 0, E = e;
      E = E + o >>> 0, S2 += E < e ? 1 : 0, E = E + p >>> 0, S2 += E < p ? 1 : 0, E = E + y >>> 0, S2 += E < y ? 1 : 0, E = E + x >>> 0, S2 += E < x ? 1 : 0;
      var R = t + r + f2 + m + M + S2;
      return R >>> 0;
    }
    it.sum64_5_hi = PR;
    function DR(t, e, r, o, f2, p, m, y, M, x) {
      var S2 = e + o + p + y + x;
      return S2 >>> 0;
    }
    it.sum64_5_lo = DR;
    function CR(t, e, r) {
      var o = e << 32 - r | t >>> r;
      return o >>> 0;
    }
    it.rotr64_hi = CR;
    function OR(t, e, r) {
      var o = t << 32 - r | e >>> r;
      return o >>> 0;
    }
    it.rotr64_lo = OR;
    function FR(t, e, r) {
      return t >>> r;
    }
    it.shr64_hi = FR;
    function UR(t, e, r) {
      var o = t << 32 - r | e >>> r;
      return o >>> 0;
    }
    it.shr64_lo = UR;
  });
  Nf = k((ty) => {
    var ey = Cr(), zR = ar();
    function i0() {
      this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
    }
    ty.BlockHash = i0;
    i0.prototype.update = function(e, r) {
      if (e = ey.toArray(e, r), this.pending ? this.pending = this.pending.concat(e) : this.pending = e, this.pendingTotal += e.length, this.pending.length >= this._delta8) {
        e = this.pending;
        var o = e.length % this._delta8;
        this.pending = e.slice(e.length - o, e.length), this.pending.length === 0 && (this.pending = null), e = ey.join32(e, 0, e.length - o, this.endian);
        for (var f2 = 0;f2 < e.length; f2 += this._delta32)
          this._update(e, f2, f2 + this._delta32);
      }
      return this;
    };
    i0.prototype.digest = function(e) {
      return this.update(this._pad()), zR(this.pending === null), this._digest(e);
    };
    i0.prototype._pad = function() {
      var e = this.pendingTotal, r = this._delta8, o = r - (e + this.padLength) % r, f2 = new Array(o + this.padLength);
      f2[0] = 128;
      for (var p = 1;p < o; p++)
        f2[p] = 0;
      if (e <<= 3, this.endian === "big") {
        for (var m = 8;m < this.padLength; m++)
          f2[p++] = 0;
        f2[p++] = 0, f2[p++] = 0, f2[p++] = 0, f2[p++] = 0, f2[p++] = e >>> 24 & 255, f2[p++] = e >>> 16 & 255, f2[p++] = e >>> 8 & 255, f2[p++] = e & 255;
      } else
        for (f2[p++] = e & 255, f2[p++] = e >>> 8 & 255, f2[p++] = e >>> 16 & 255, f2[p++] = e >>> 24 & 255, f2[p++] = 0, f2[p++] = 0, f2[p++] = 0, f2[p++] = 0, m = 8;m < this.padLength; m++)
          f2[p++] = 0;
      return f2;
    };
  });
  ed = k((Ti) => {
    var HR = Cr(), oi = HR.rotr32;
    function WR(t, e, r, o) {
      if (t === 0)
        return ry(e, r, o);
      if (t === 1 || t === 3)
        return ny(e, r, o);
      if (t === 2)
        return iy(e, r, o);
    }
    Ti.ft_1 = WR;
    function ry(t, e, r) {
      return t & e ^ ~t & r;
    }
    Ti.ch32 = ry;
    function iy(t, e, r) {
      return t & e ^ t & r ^ e & r;
    }
    Ti.maj32 = iy;
    function ny(t, e, r) {
      return t ^ e ^ r;
    }
    Ti.p32 = ny;
    function KR(t) {
      return oi(t, 2) ^ oi(t, 13) ^ oi(t, 22);
    }
    Ti.s0_256 = KR;
    function jR(t) {
      return oi(t, 6) ^ oi(t, 11) ^ oi(t, 25);
    }
    Ti.s1_256 = jR;
    function ZR(t) {
      return oi(t, 7) ^ oi(t, 18) ^ t >>> 3;
    }
    Ti.g0_256 = ZR;
    function VR(t) {
      return oi(t, 17) ^ oi(t, 19) ^ t >>> 10;
    }
    Ti.g1_256 = VR;
  });
  oy = k((xL, ay) => {
    var Pf = Cr(), $R = Nf(), GR = ed(), td = Pf.rotl32, Ka = Pf.sum32, YR = Pf.sum32_5, XR = GR.ft_1, fy = $R.BlockHash, JR = [1518500249, 1859775393, 2400959708, 3395469782];
    function si() {
      if (!(this instanceof si))
        return new si;
      fy.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = new Array(80);
    }
    Pf.inherits(si, fy);
    ay.exports = si;
    si.blockSize = 512;
    si.outSize = 160;
    si.hmacStrength = 80;
    si.padLength = 64;
    si.prototype._update = function(e, r) {
      for (var o = this.W, f2 = 0;f2 < 16; f2++)
        o[f2] = e[r + f2];
      for (;f2 < o.length; f2++)
        o[f2] = td(o[f2 - 3] ^ o[f2 - 8] ^ o[f2 - 14] ^ o[f2 - 16], 1);
      var p = this.h[0], m = this.h[1], y = this.h[2], M = this.h[3], x = this.h[4];
      for (f2 = 0;f2 < o.length; f2++) {
        var S2 = ~~(f2 / 20), E = YR(td(p, 5), XR(S2, m, y, M), x, o[f2], JR[S2]);
        x = M, M = y, y = td(m, 30), m = p, p = E;
      }
      this.h[0] = Ka(this.h[0], p), this.h[1] = Ka(this.h[1], m), this.h[2] = Ka(this.h[2], y), this.h[3] = Ka(this.h[3], M), this.h[4] = Ka(this.h[4], x);
    };
    si.prototype._digest = function(e) {
      return e === "hex" ? Pf.toHex32(this.h, "big") : Pf.split32(this.h, "big");
    };
  });
  rd = k((SL, hy) => {
    var Df = Cr(), QR = Nf(), Cf = ed(), eB = ar(), Or = Df.sum32, tB = Df.sum32_4, rB = Df.sum32_5, iB = Cf.ch32, nB = Cf.maj32, fB = Cf.s0_256, aB = Cf.s1_256, oB = Cf.g0_256, sB = Cf.g1_256, sy = QR.BlockHash, hB = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
    function hi() {
      if (!(this instanceof hi))
        return new hi;
      sy.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = hB, this.W = new Array(64);
    }
    Df.inherits(hi, sy);
    hy.exports = hi;
    hi.blockSize = 512;
    hi.outSize = 256;
    hi.hmacStrength = 192;
    hi.padLength = 64;
    hi.prototype._update = function(e, r) {
      for (var o = this.W, f2 = 0;f2 < 16; f2++)
        o[f2] = e[r + f2];
      for (;f2 < o.length; f2++)
        o[f2] = tB(sB(o[f2 - 2]), o[f2 - 7], oB(o[f2 - 15]), o[f2 - 16]);
      var p = this.h[0], m = this.h[1], y = this.h[2], M = this.h[3], x = this.h[4], S2 = this.h[5], E = this.h[6], R = this.h[7];
      for (eB(this.k.length === o.length), f2 = 0;f2 < o.length; f2++) {
        var q = rB(R, aB(x), iB(x, S2, E), this.k[f2], o[f2]), T = Or(fB(p), nB(p, m, y));
        R = E, E = S2, S2 = x, x = Or(M, q), M = y, y = m, m = p, p = Or(q, T);
      }
      this.h[0] = Or(this.h[0], p), this.h[1] = Or(this.h[1], m), this.h[2] = Or(this.h[2], y), this.h[3] = Or(this.h[3], M), this.h[4] = Or(this.h[4], x), this.h[5] = Or(this.h[5], S2), this.h[6] = Or(this.h[6], E), this.h[7] = Or(this.h[7], R);
    };
    hi.prototype._digest = function(e) {
      return e === "hex" ? Df.toHex32(this.h, "big") : Df.split32(this.h, "big");
    };
  });
  dy = k((EL, ly) => {
    var id = Cr(), uy = rd();
    function ki() {
      if (!(this instanceof ki))
        return new ki;
      uy.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428];
    }
    id.inherits(ki, uy);
    ly.exports = ki;
    ki.blockSize = 512;
    ki.outSize = 224;
    ki.hmacStrength = 192;
    ki.padLength = 64;
    ki.prototype._digest = function(e) {
      return e === "hex" ? id.toHex32(this.h.slice(0, 7), "big") : id.split32(this.h.slice(0, 7), "big");
    };
  });
  ad = k((AL, by) => {
    var ir = Cr(), uB = Nf(), lB = ar(), ui = ir.rotr64_hi, li = ir.rotr64_lo, cy = ir.shr64_hi, py = ir.shr64_lo, en = ir.sum64, nd = ir.sum64_hi, fd = ir.sum64_lo, dB = ir.sum64_4_hi, cB = ir.sum64_4_lo, pB = ir.sum64_5_hi, vB = ir.sum64_5_lo, vy = uB.BlockHash, bB = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
    function Fr2() {
      if (!(this instanceof Fr2))
        return new Fr2;
      vy.call(this), this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this.k = bB, this.W = new Array(160);
    }
    ir.inherits(Fr2, vy);
    by.exports = Fr2;
    Fr2.blockSize = 1024;
    Fr2.outSize = 512;
    Fr2.hmacStrength = 192;
    Fr2.padLength = 128;
    Fr2.prototype._prepareBlock = function(e, r) {
      for (var o = this.W, f2 = 0;f2 < 32; f2++)
        o[f2] = e[r + f2];
      for (;f2 < o.length; f2 += 2) {
        var p = RB(o[f2 - 4], o[f2 - 3]), m = BB(o[f2 - 4], o[f2 - 3]), y = o[f2 - 14], M = o[f2 - 13], x = EB(o[f2 - 30], o[f2 - 29]), S2 = AB(o[f2 - 30], o[f2 - 29]), E = o[f2 - 32], R = o[f2 - 31];
        o[f2] = dB(p, m, y, M, x, S2, E, R), o[f2 + 1] = cB(p, m, y, M, x, S2, E, R);
      }
    };
    Fr2.prototype._update = function(e, r) {
      this._prepareBlock(e, r);
      var o = this.W, f2 = this.h[0], p = this.h[1], m = this.h[2], y = this.h[3], M = this.h[4], x = this.h[5], S2 = this.h[6], E = this.h[7], R = this.h[8], q = this.h[9], T = this.h[10], ye = this.h[11], _e = this.h[12], P = this.h[13], Me = this.h[14], me = this.h[15];
      lB(this.k.length === o.length);
      for (var xe = 0;xe < o.length; xe += 2) {
        var Ae = Me, Ee = me, Re = xB(R, q), D2 = SB(R, q), Se = mB(R, q, T, ye, _e, P), v2 = gB(R, q, T, ye, _e, P), i = this.k[xe], a = this.k[xe + 1], h = o[xe], s = o[xe + 1], u = pB(Ae, Ee, Re, D2, Se, v2, i, a, h, s), c = vB(Ae, Ee, Re, D2, Se, v2, i, a, h, s);
        Ae = MB(f2, p), Ee = _B(f2, p), Re = yB(f2, p, m, y, M, x), D2 = wB(f2, p, m, y, M, x);
        var b2 = nd(Ae, Ee, Re, D2), l = fd(Ae, Ee, Re, D2);
        Me = _e, me = P, _e = T, P = ye, T = R, ye = q, R = nd(S2, E, u, c), q = fd(E, E, u, c), S2 = M, E = x, M = m, x = y, m = f2, y = p, f2 = nd(u, c, b2, l), p = fd(u, c, b2, l);
      }
      en(this.h, 0, f2, p), en(this.h, 2, m, y), en(this.h, 4, M, x), en(this.h, 6, S2, E), en(this.h, 8, R, q), en(this.h, 10, T, ye), en(this.h, 12, _e, P), en(this.h, 14, Me, me);
    };
    Fr2.prototype._digest = function(e) {
      return e === "hex" ? ir.toHex32(this.h, "big") : ir.split32(this.h, "big");
    };
    function mB(t, e, r, o, f2) {
      var p = t & r ^ ~t & f2;
      return p < 0 && (p += 4294967296), p;
    }
    function gB(t, e, r, o, f2, p) {
      var m = e & o ^ ~e & p;
      return m < 0 && (m += 4294967296), m;
    }
    function yB(t, e, r, o, f2) {
      var p = t & r ^ t & f2 ^ r & f2;
      return p < 0 && (p += 4294967296), p;
    }
    function wB(t, e, r, o, f2, p) {
      var m = e & o ^ e & p ^ o & p;
      return m < 0 && (m += 4294967296), m;
    }
    function MB(t, e) {
      var r = ui(t, e, 28), o = ui(e, t, 2), f2 = ui(e, t, 7), p = r ^ o ^ f2;
      return p < 0 && (p += 4294967296), p;
    }
    function _B(t, e) {
      var r = li(t, e, 28), o = li(e, t, 2), f2 = li(e, t, 7), p = r ^ o ^ f2;
      return p < 0 && (p += 4294967296), p;
    }
    function xB(t, e) {
      var r = ui(t, e, 14), o = ui(t, e, 18), f2 = ui(e, t, 9), p = r ^ o ^ f2;
      return p < 0 && (p += 4294967296), p;
    }
    function SB(t, e) {
      var r = li(t, e, 14), o = li(t, e, 18), f2 = li(e, t, 9), p = r ^ o ^ f2;
      return p < 0 && (p += 4294967296), p;
    }
    function EB(t, e) {
      var r = ui(t, e, 1), o = ui(t, e, 8), f2 = cy(t, e, 7), p = r ^ o ^ f2;
      return p < 0 && (p += 4294967296), p;
    }
    function AB(t, e) {
      var r = li(t, e, 1), o = li(t, e, 8), f2 = py(t, e, 7), p = r ^ o ^ f2;
      return p < 0 && (p += 4294967296), p;
    }
    function RB(t, e) {
      var r = ui(t, e, 19), o = ui(e, t, 29), f2 = cy(t, e, 6), p = r ^ o ^ f2;
      return p < 0 && (p += 4294967296), p;
    }
    function BB(t, e) {
      var r = li(t, e, 19), o = li(e, t, 29), f2 = py(t, e, 6), p = r ^ o ^ f2;
      return p < 0 && (p += 4294967296), p;
    }
  });
  yy = k((RL, gy) => {
    var od = Cr(), my = ad();
    function Li() {
      if (!(this instanceof Li))
        return new Li;
      my.call(this), this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428];
    }
    od.inherits(Li, my);
    gy.exports = Li;
    Li.blockSize = 1024;
    Li.outSize = 384;
    Li.hmacStrength = 192;
    Li.padLength = 128;
    Li.prototype._digest = function(e) {
      return e === "hex" ? od.toHex32(this.h.slice(0, 12), "big") : od.split32(this.h.slice(0, 12), "big");
    };
  });
  wy = k((Of) => {
    Of.sha1 = oy();
    Of.sha224 = dy();
    Of.sha256 = rd();
    Of.sha384 = yy();
    Of.sha512 = ad();
  });
  Ay = k((Ey) => {
    var Wn = Cr(), qB = Nf(), n0 = Wn.rotl32, My = Wn.sum32, ja = Wn.sum32_3, _y = Wn.sum32_4, Sy = qB.BlockHash;
    function di() {
      if (!(this instanceof di))
        return new di;
      Sy.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
    }
    Wn.inherits(di, Sy);
    Ey.ripemd160 = di;
    di.blockSize = 512;
    di.outSize = 160;
    di.hmacStrength = 192;
    di.padLength = 64;
    di.prototype._update = function(e, r) {
      for (var o = this.h[0], f2 = this.h[1], p = this.h[2], m = this.h[3], y = this.h[4], M = o, x = f2, S2 = p, E = m, R = y, q = 0;q < 80; q++) {
        var T = My(n0(_y(o, xy(q, f2, p, m), e[kB[q] + r], IB(q)), NB[q]), y);
        o = y, y = m, m = n0(p, 10), p = f2, f2 = T, T = My(n0(_y(M, xy(79 - q, x, S2, E), e[LB[q] + r], TB(q)), PB[q]), R), M = R, R = E, E = n0(S2, 10), S2 = x, x = T;
      }
      T = ja(this.h[1], p, E), this.h[1] = ja(this.h[2], m, R), this.h[2] = ja(this.h[3], y, M), this.h[3] = ja(this.h[4], o, x), this.h[4] = ja(this.h[0], f2, S2), this.h[0] = T;
    };
    di.prototype._digest = function(e) {
      return e === "hex" ? Wn.toHex32(this.h, "little") : Wn.split32(this.h, "little");
    };
    function xy(t, e, r, o) {
      return t <= 15 ? e ^ r ^ o : t <= 31 ? e & r | ~e & o : t <= 47 ? (e | ~r) ^ o : t <= 63 ? e & o | r & ~o : e ^ (r | ~o);
    }
    function IB(t) {
      return t <= 15 ? 0 : t <= 31 ? 1518500249 : t <= 47 ? 1859775393 : t <= 63 ? 2400959708 : 2840853838;
    }
    function TB(t) {
      return t <= 15 ? 1352829926 : t <= 31 ? 1548603684 : t <= 47 ? 1836072691 : t <= 63 ? 2053994217 : 0;
    }
    var kB = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], LB = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], NB = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], PB = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
  });
  By = k((IL, Ry) => {
    var DB = Cr(), CB = ar();
    function Ff(t, e, r) {
      if (!(this instanceof Ff))
        return new Ff(t, e, r);
      this.Hash = t, this.blockSize = t.blockSize / 8, this.outSize = t.outSize / 8, this.inner = null, this.outer = null, this._init(DB.toArray(e, r));
    }
    Ry.exports = Ff;
    Ff.prototype._init = function(e) {
      e.length > this.blockSize && (e = new this.Hash().update(e).digest()), CB(e.length <= this.blockSize);
      for (var r = e.length;r < this.blockSize; r++)
        e.push(0);
      for (r = 0;r < e.length; r++)
        e[r] ^= 54;
      for (this.inner = new this.Hash().update(e), r = 0;r < e.length; r++)
        e[r] ^= 106;
      this.outer = new this.Hash().update(e);
    };
    Ff.prototype.update = function(e, r) {
      return this.inner.update(e, r), this;
    };
    Ff.prototype.digest = function(e) {
      return this.outer.update(this.inner.digest()), this.outer.digest(e);
    };
  });
  f0 = k((qy) => {
    var Kt = qy;
    Kt.utils = Cr();
    Kt.common = Nf();
    Kt.sha = wy();
    Kt.ripemd = Ay();
    Kt.hmac = By();
    Kt.sha1 = Kt.sha.sha1;
    Kt.sha256 = Kt.sha.sha256;
    Kt.sha224 = Kt.sha.sha224;
    Kt.sha384 = Kt.sha.sha384;
    Kt.sha512 = Kt.sha.sha512;
    Kt.ripemd160 = Kt.ripemd.ripemd160;
  });
  Ty = k((kL, Iy) => {
    Iy.exports = { doubles: { step: 4, points: [["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a", "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"], ["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508", "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"], ["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739", "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"], ["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640", "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"], ["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c", "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"], ["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda", "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"], ["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa", "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"], ["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0", "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"], ["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d", "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"], ["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d", "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"], ["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1", "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"], ["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0", "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"], ["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047", "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"], ["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862", "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"], ["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7", "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"], ["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd", "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"], ["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83", "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"], ["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a", "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"], ["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8", "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"], ["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d", "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"], ["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725", "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"], ["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754", "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"], ["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c", "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"], ["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6", "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"], ["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39", "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"], ["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891", "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"], ["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b", "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"], ["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03", "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"], ["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d", "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"], ["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070", "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"], ["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4", "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"], ["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da", "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"], ["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11", "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"], ["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e", "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"], ["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41", "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"], ["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef", "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"], ["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8", "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"], ["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d", "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"], ["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96", "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"], ["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd", "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"], ["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5", "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"], ["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266", "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"], ["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71", "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"], ["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac", "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"], ["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751", "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"], ["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e", "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"], ["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241", "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"], ["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3", "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"], ["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f", "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"], ["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19", "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"], ["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be", "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"], ["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9", "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"], ["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2", "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"], ["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13", "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"], ["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c", "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"], ["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba", "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"], ["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151", "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"], ["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073", "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"], ["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458", "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"], ["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b", "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"], ["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366", "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"], ["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa", "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"], ["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0", "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"], ["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787", "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"], ["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e", "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]] }, naf: { wnd: 7, points: [["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9", "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"], ["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4", "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"], ["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc", "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"], ["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe", "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"], ["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb", "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"], ["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8", "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"], ["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e", "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"], ["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34", "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"], ["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c", "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"], ["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5", "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"], ["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f", "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"], ["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714", "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"], ["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729", "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"], ["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db", "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"], ["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4", "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"], ["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5", "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"], ["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479", "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"], ["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d", "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"], ["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f", "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"], ["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb", "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"], ["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9", "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"], ["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963", "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"], ["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74", "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"], ["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530", "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"], ["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b", "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"], ["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247", "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"], ["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1", "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"], ["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120", "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"], ["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435", "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"], ["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18", "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"], ["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8", "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"], ["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb", "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"], ["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f", "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"], ["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143", "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"], ["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba", "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"], ["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45", "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"], ["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a", "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"], ["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e", "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"], ["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8", "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"], ["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c", "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"], ["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519", "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"], ["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab", "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"], ["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca", "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"], ["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf", "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"], ["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610", "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"], ["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4", "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"], ["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c", "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"], ["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940", "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"], ["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980", "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"], ["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3", "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"], ["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf", "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"], ["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63", "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"], ["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448", "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"], ["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf", "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"], ["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5", "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"], ["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6", "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"], ["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5", "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"], ["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99", "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"], ["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51", "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"], ["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5", "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"], ["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5", "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"], ["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997", "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"], ["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881", "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"], ["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5", "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"], ["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66", "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"], ["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726", "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"], ["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede", "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"], ["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94", "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"], ["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31", "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"], ["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51", "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"], ["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252", "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"], ["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5", "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"], ["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b", "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"], ["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4", "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"], ["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f", "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"], ["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889", "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"], ["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246", "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"], ["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984", "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"], ["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a", "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"], ["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030", "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"], ["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197", "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"], ["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593", "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"], ["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef", "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"], ["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38", "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"], ["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a", "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"], ["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111", "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"], ["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502", "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"], ["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea", "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"], ["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26", "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"], ["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986", "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"], ["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e", "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"], ["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4", "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"], ["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda", "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"], ["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859", "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"], ["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f", "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"], ["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c", "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"], ["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942", "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"], ["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a", "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"], ["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80", "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"], ["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d", "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"], ["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1", "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"], ["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63", "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"], ["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352", "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"], ["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193", "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"], ["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00", "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"], ["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58", "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"], ["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7", "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"], ["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8", "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"], ["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e", "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"], ["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d", "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"], ["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b", "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"], ["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f", "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"], ["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6", "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"], ["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297", "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"], ["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a", "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"], ["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c", "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"], ["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52", "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"], ["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb", "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"], ["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065", "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"], ["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917", "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"], ["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9", "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"], ["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3", "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"], ["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57", "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"], ["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66", "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"], ["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8", "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"], ["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721", "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"], ["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180", "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]] } };
  });
  a0 = k((Ny) => {
    var hd = Ny, tn = f0(), sd = Ql(), OB = or(), ky = OB.assert;
    function Ly(t) {
      t.type === "short" ? this.curve = new sd.short(t) : t.type === "edwards" ? this.curve = new sd.edwards(t) : this.curve = new sd.mont(t), this.g = this.curve.g, this.n = this.curve.n, this.hash = t.hash, ky(this.g.validate(), "Invalid curve"), ky(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    hd.PresetCurve = Ly;
    function rn(t, e) {
      Object.defineProperty(hd, t, { configurable: true, enumerable: true, get: function() {
        var r = new Ly(e);
        return Object.defineProperty(hd, t, { configurable: true, enumerable: true, value: r }), r;
      } });
    }
    rn("p192", { type: "short", prime: "p192", p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff", a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc", b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1", n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831", hash: tn.sha256, gRed: false, g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"] });
    rn("p224", { type: "short", prime: "p224", p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001", a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe", b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4", n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d", hash: tn.sha256, gRed: false, g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"] });
    rn("p256", { type: "short", prime: null, p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff", a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc", b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b", n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551", hash: tn.sha256, gRed: false, g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"] });
    rn("p384", { type: "short", prime: null, p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff", a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc", b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef", n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973", hash: tn.sha384, gRed: false, g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"] });
    rn("p521", { type: "short", prime: null, p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff", a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc", b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00", n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409", hash: tn.sha512, gRed: false, g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"] });
    rn("curve25519", { type: "mont", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "76d06", b: "1", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: tn.sha256, gRed: false, g: ["9"] });
    rn("ed25519", { type: "edwards", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "-1", c: "1", d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: tn.sha256, gRed: false, g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"] });
    var ud;
    try {
      ud = Ty();
    } catch {
      ud = undefined;
    }
    rn("secp256k1", { type: "short", prime: "k256", p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f", a: "0", b: "7", n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141", h: "1", hash: tn.sha256, beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee", lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72", basis: [{ a: "3086d221a7d46bcde86c90e49284eb15", b: "-e4437ed6010e88286f547fa90abfe4c3" }, { a: "114ca50f7a8e2f3f657c1108d9d44cfd8", b: "3086d221a7d46bcde86c90e49284eb15" }], gRed: false, g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", ud] });
  });
  Cy = k((NL, Dy) => {
    var FB = f0(), Kn = Xl(), Py = ar();
    function nn(t) {
      if (!(this instanceof nn))
        return new nn(t);
      this.hash = t.hash, this.predResist = !!t.predResist, this.outLen = this.hash.outSize, this.minEntropy = t.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
      var e = Kn.toArray(t.entropy, t.entropyEnc || "hex"), r = Kn.toArray(t.nonce, t.nonceEnc || "hex"), o = Kn.toArray(t.pers, t.persEnc || "hex");
      Py(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(e, r, o);
    }
    Dy.exports = nn;
    nn.prototype._init = function(e, r, o) {
      var f2 = e.concat(r).concat(o);
      this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
      for (var p = 0;p < this.V.length; p++)
        this.K[p] = 0, this.V[p] = 1;
      this._update(f2), this._reseed = 1, this.reseedInterval = 281474976710656;
    };
    nn.prototype._hmac = function() {
      return new FB.hmac(this.hash, this.K);
    };
    nn.prototype._update = function(e) {
      var r = this._hmac().update(this.V).update([0]);
      e && (r = r.update(e)), this.K = r.digest(), this.V = this._hmac().update(this.V).digest(), e && (this.K = this._hmac().update(this.V).update([1]).update(e).digest(), this.V = this._hmac().update(this.V).digest());
    };
    nn.prototype.reseed = function(e, r, o, f2) {
      typeof r != "string" && (f2 = o, o = r, r = null), e = Kn.toArray(e, r), o = Kn.toArray(o, f2), Py(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(e.concat(o || [])), this._reseed = 1;
    };
    nn.prototype.generate = function(e, r, o, f2) {
      if (this._reseed > this.reseedInterval)
        throw new Error("Reseed is required");
      typeof r != "string" && (f2 = o, o = r, r = null), o && (o = Kn.toArray(o, f2 || "hex"), this._update(o));
      for (var p = [];p.length < e; )
        this.V = this._hmac().update(this.V).digest(), p = p.concat(this.V);
      var m = p.slice(0, e);
      return this._update(o), this._reseed++, Kn.encode(m, r);
    };
  });
  Fy = k((PL, Oy) => {
    var UB = fi(), zB = or(), ld = zB.assert;
    function Gt(t, e) {
      this.ec = t, this.priv = null, this.pub = null, e.priv && this._importPrivate(e.priv, e.privEnc), e.pub && this._importPublic(e.pub, e.pubEnc);
    }
    Oy.exports = Gt;
    Gt.fromPublic = function(e, r, o) {
      return r instanceof Gt ? r : new Gt(e, { pub: r, pubEnc: o });
    };
    Gt.fromPrivate = function(e, r, o) {
      return r instanceof Gt ? r : new Gt(e, { priv: r, privEnc: o });
    };
    Gt.prototype.validate = function() {
      var e = this.getPublic();
      return e.isInfinity() ? { result: false, reason: "Invalid public key" } : e.validate() ? e.mul(this.ec.curve.n).isInfinity() ? { result: true, reason: null } : { result: false, reason: "Public key * N != O" } : { result: false, reason: "Public key is not a point" };
    };
    Gt.prototype.getPublic = function(e, r) {
      return typeof e == "string" && (r = e, e = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), r ? this.pub.encode(r, e) : this.pub;
    };
    Gt.prototype.getPrivate = function(e) {
      return e === "hex" ? this.priv.toString(16, 2) : this.priv;
    };
    Gt.prototype._importPrivate = function(e, r) {
      this.priv = new UB(e, r || 16), this.priv = this.priv.umod(this.ec.curve.n);
    };
    Gt.prototype._importPublic = function(e, r) {
      if (e.x || e.y) {
        this.ec.curve.type === "mont" ? ld(e.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && ld(e.x && e.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(e.x, e.y);
        return;
      }
      this.pub = this.ec.curve.decodePoint(e, r);
    };
    Gt.prototype.derive = function(e) {
      return e.validate() || ld(e.validate(), "public point not validated"), e.mul(this.priv).getX();
    };
    Gt.prototype.sign = function(e, r, o) {
      return this.ec.sign(e, this, r, o);
    };
    Gt.prototype.verify = function(e, r) {
      return this.ec.verify(e, r, this);
    };
    Gt.prototype.inspect = function() {
      return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
    };
  });
  Hy = k((DL, zy) => {
    var o0 = fi(), pd = or(), HB = pd.assert;
    function s0(t, e) {
      if (t instanceof s0)
        return t;
      this._importDER(t, e) || (HB(t.r && t.s, "Signature without r or s"), this.r = new o0(t.r, 16), this.s = new o0(t.s, 16), t.recoveryParam === undefined ? this.recoveryParam = null : this.recoveryParam = t.recoveryParam);
    }
    zy.exports = s0;
    function WB() {
      this.place = 0;
    }
    function dd(t, e) {
      var r = t[e.place++];
      if (!(r & 128))
        return r;
      var o = r & 15;
      if (o === 0 || o > 4)
        return false;
      for (var f2 = 0, p = 0, m = e.place;p < o; p++, m++)
        f2 <<= 8, f2 |= t[m], f2 >>>= 0;
      return f2 <= 127 ? false : (e.place = m, f2);
    }
    function Uy(t) {
      for (var e = 0, r = t.length - 1;!t[e] && !(t[e + 1] & 128) && e < r; )
        e++;
      return e === 0 ? t : t.slice(e);
    }
    s0.prototype._importDER = function(e, r) {
      e = pd.toArray(e, r);
      var o = new WB;
      if (e[o.place++] !== 48)
        return false;
      var f2 = dd(e, o);
      if (f2 === false || f2 + o.place !== e.length || e[o.place++] !== 2)
        return false;
      var p = dd(e, o);
      if (p === false)
        return false;
      var m = e.slice(o.place, p + o.place);
      if (o.place += p, e[o.place++] !== 2)
        return false;
      var y = dd(e, o);
      if (y === false || e.length !== y + o.place)
        return false;
      var M = e.slice(o.place, y + o.place);
      if (m[0] === 0)
        if (m[1] & 128)
          m = m.slice(1);
        else
          return false;
      if (M[0] === 0)
        if (M[1] & 128)
          M = M.slice(1);
        else
          return false;
      return this.r = new o0(m), this.s = new o0(M), this.recoveryParam = null, true;
    };
    function cd(t, e) {
      if (e < 128) {
        t.push(e);
        return;
      }
      var r = 1 + (Math.log(e) / Math.LN2 >>> 3);
      for (t.push(r | 128);--r; )
        t.push(e >>> (r << 3) & 255);
      t.push(e);
    }
    s0.prototype.toDER = function(e) {
      var r = this.r.toArray(), o = this.s.toArray();
      for (r[0] & 128 && (r = [0].concat(r)), o[0] & 128 && (o = [0].concat(o)), r = Uy(r), o = Uy(o);!o[0] && !(o[1] & 128); )
        o = o.slice(1);
      var f2 = [2];
      cd(f2, r.length), f2 = f2.concat(r), f2.push(2), cd(f2, o.length);
      var p = f2.concat(o), m = [48];
      return cd(m, p.length), m = m.concat(p), pd.encode(m, e);
    };
  });
  Zy = k((CL, jy) => {
    var jn = fi(), Wy = Cy(), KB = or(), vd = a0(), jB = Ts(), Ky = KB.assert, bd = Fy(), h0 = Hy();
    function Er2(t) {
      if (!(this instanceof Er2))
        return new Er2(t);
      typeof t == "string" && (Ky(Object.prototype.hasOwnProperty.call(vd, t), "Unknown curve " + t), t = vd[t]), t instanceof vd.PresetCurve && (t = { curve: t }), this.curve = t.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = t.curve.g, this.g.precompute(t.curve.n.bitLength() + 1), this.hash = t.hash || t.curve.hash;
    }
    jy.exports = Er2;
    Er2.prototype.keyPair = function(e) {
      return new bd(this, e);
    };
    Er2.prototype.keyFromPrivate = function(e, r) {
      return bd.fromPrivate(this, e, r);
    };
    Er2.prototype.keyFromPublic = function(e, r) {
      return bd.fromPublic(this, e, r);
    };
    Er2.prototype.genKeyPair = function(e) {
      e || (e = {});
      for (var r = new Wy({ hash: this.hash, pers: e.pers, persEnc: e.persEnc || "utf8", entropy: e.entropy || jB(this.hash.hmacStrength), entropyEnc: e.entropy && e.entropyEnc || "utf8", nonce: this.n.toArray() }), o = this.n.byteLength(), f2 = this.n.sub(new jn(2));; ) {
        var p = new jn(r.generate(o));
        if (!(p.cmp(f2) > 0))
          return p.iaddn(1), this.keyFromPrivate(p);
      }
    };
    Er2.prototype._truncateToN = function(e, r) {
      var o = e.byteLength() * 8 - this.n.bitLength();
      return o > 0 && (e = e.ushrn(o)), !r && e.cmp(this.n) >= 0 ? e.sub(this.n) : e;
    };
    Er2.prototype.sign = function(e, r, o, f2) {
      typeof o == "object" && (f2 = o, o = null), f2 || (f2 = {}), r = this.keyFromPrivate(r, o), e = this._truncateToN(new jn(e, 16));
      for (var p = this.n.byteLength(), m = r.getPrivate().toArray("be", p), y = e.toArray("be", p), M = new Wy({ hash: this.hash, entropy: m, nonce: y, pers: f2.pers, persEnc: f2.persEnc || "utf8" }), x = this.n.sub(new jn(1)), S2 = 0;; S2++) {
        var E = f2.k ? f2.k(S2) : new jn(M.generate(this.n.byteLength()));
        if (E = this._truncateToN(E, true), !(E.cmpn(1) <= 0 || E.cmp(x) >= 0)) {
          var R = this.g.mul(E);
          if (!R.isInfinity()) {
            var q = R.getX(), T = q.umod(this.n);
            if (T.cmpn(0) !== 0) {
              var ye = E.invm(this.n).mul(T.mul(r.getPrivate()).iadd(e));
              if (ye = ye.umod(this.n), ye.cmpn(0) !== 0) {
                var _e = (R.getY().isOdd() ? 1 : 0) | (q.cmp(T) !== 0 ? 2 : 0);
                return f2.canonical && ye.cmp(this.nh) > 0 && (ye = this.n.sub(ye), _e ^= 1), new h0({ r: T, s: ye, recoveryParam: _e });
              }
            }
          }
        }
      }
    };
    Er2.prototype.verify = function(e, r, o, f2) {
      e = this._truncateToN(new jn(e, 16)), o = this.keyFromPublic(o, f2), r = new h0(r, "hex");
      var { r: p, s: m } = r;
      if (p.cmpn(1) < 0 || p.cmp(this.n) >= 0 || m.cmpn(1) < 0 || m.cmp(this.n) >= 0)
        return false;
      var y = m.invm(this.n), M = y.mul(e).umod(this.n), x = y.mul(p).umod(this.n), S2;
      return this.curve._maxwellTrick ? (S2 = this.g.jmulAdd(M, o.getPublic(), x), S2.isInfinity() ? false : S2.eqXToP(p)) : (S2 = this.g.mulAdd(M, o.getPublic(), x), S2.isInfinity() ? false : S2.getX().umod(this.n).cmp(p) === 0);
    };
    Er2.prototype.recoverPubKey = function(t, e, r, o) {
      Ky((3 & r) === r, "The recovery param is more than two bits"), e = new h0(e, o);
      var f2 = this.n, p = new jn(t), m = e.r, y = e.s, M = r & 1, x = r >> 1;
      if (m.cmp(this.curve.p.umod(this.curve.n)) >= 0 && x)
        throw new Error("Unable to find sencond key candinate");
      x ? m = this.curve.pointFromX(m.add(this.curve.n), M) : m = this.curve.pointFromX(m, M);
      var S2 = e.r.invm(f2), E = f2.sub(p).mul(S2).umod(f2), R = y.mul(S2).umod(f2);
      return this.g.mulAdd(E, m, R);
    };
    Er2.prototype.getKeyRecoveryParam = function(t, e, r, o) {
      if (e = new h0(e, o), e.recoveryParam !== null)
        return e.recoveryParam;
      for (var f2 = 0;f2 < 4; f2++) {
        var p;
        try {
          p = this.recoverPubKey(t, e, f2);
        } catch {
          continue;
        }
        if (p.eq(r))
          return f2;
      }
      throw new Error("Unable to find valid recovery factor");
    };
  });
  Yy = k((OL, Gy) => {
    var Za = or(), $y = Za.assert, Vy = Za.parseBytes, Uf = Za.cachedProperty;
    function Ft(t, e) {
      this.eddsa = t, this._secret = Vy(e.secret), t.isPoint(e.pub) ? this._pub = e.pub : this._pubBytes = Vy(e.pub);
    }
    Ft.fromPublic = function(e, r) {
      return r instanceof Ft ? r : new Ft(e, { pub: r });
    };
    Ft.fromSecret = function(e, r) {
      return r instanceof Ft ? r : new Ft(e, { secret: r });
    };
    Ft.prototype.secret = function() {
      return this._secret;
    };
    Uf(Ft, "pubBytes", function() {
      return this.eddsa.encodePoint(this.pub());
    });
    Uf(Ft, "pub", function() {
      return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
    });
    Uf(Ft, "privBytes", function() {
      var e = this.eddsa, r = this.hash(), o = e.encodingLength - 1, f2 = r.slice(0, e.encodingLength);
      return f2[0] &= 248, f2[o] &= 127, f2[o] |= 64, f2;
    });
    Uf(Ft, "priv", function() {
      return this.eddsa.decodeInt(this.privBytes());
    });
    Uf(Ft, "hash", function() {
      return this.eddsa.hash().update(this.secret()).digest();
    });
    Uf(Ft, "messagePrefix", function() {
      return this.hash().slice(this.eddsa.encodingLength);
    });
    Ft.prototype.sign = function(e) {
      return $y(this._secret, "KeyPair can only verify"), this.eddsa.sign(e, this);
    };
    Ft.prototype.verify = function(e, r) {
      return this.eddsa.verify(e, r, this);
    };
    Ft.prototype.getSecret = function(e) {
      return $y(this._secret, "KeyPair is public only"), Za.encode(this.secret(), e);
    };
    Ft.prototype.getPublic = function(e) {
      return Za.encode(this.pubBytes(), e);
    };
    Gy.exports = Ft;
  });
  Jy = k((FL, Xy) => {
    var ZB = fi(), u0 = or(), VB = u0.assert, l0 = u0.cachedProperty, $B = u0.parseBytes;
    function Zn(t, e) {
      this.eddsa = t, typeof e != "object" && (e = $B(e)), Array.isArray(e) && (e = { R: e.slice(0, t.encodingLength), S: e.slice(t.encodingLength) }), VB(e.R && e.S, "Signature without R or S"), t.isPoint(e.R) && (this._R = e.R), e.S instanceof ZB && (this._S = e.S), this._Rencoded = Array.isArray(e.R) ? e.R : e.Rencoded, this._Sencoded = Array.isArray(e.S) ? e.S : e.Sencoded;
    }
    l0(Zn, "S", function() {
      return this.eddsa.decodeInt(this.Sencoded());
    });
    l0(Zn, "R", function() {
      return this.eddsa.decodePoint(this.Rencoded());
    });
    l0(Zn, "Rencoded", function() {
      return this.eddsa.encodePoint(this.R());
    });
    l0(Zn, "Sencoded", function() {
      return this.eddsa.encodeInt(this.S());
    });
    Zn.prototype.toBytes = function() {
      return this.Rencoded().concat(this.Sencoded());
    };
    Zn.prototype.toHex = function() {
      return u0.encode(this.toBytes(), "hex").toUpperCase();
    };
    Xy.exports = Zn;
  });
  iw = k((UL, rw) => {
    var GB = f0(), YB = a0(), zf = or(), XB = zf.assert, ew = zf.parseBytes, tw = Yy(), Qy = Jy();
    function nr(t) {
      if (XB(t === "ed25519", "only tested with ed25519 so far"), !(this instanceof nr))
        return new nr(t);
      t = YB[t].curve, this.curve = t, this.g = t.g, this.g.precompute(t.n.bitLength() + 1), this.pointClass = t.point().constructor, this.encodingLength = Math.ceil(t.n.bitLength() / 8), this.hash = GB.sha512;
    }
    rw.exports = nr;
    nr.prototype.sign = function(e, r) {
      e = ew(e);
      var o = this.keyFromSecret(r), f2 = this.hashInt(o.messagePrefix(), e), p = this.g.mul(f2), m = this.encodePoint(p), y = this.hashInt(m, o.pubBytes(), e).mul(o.priv()), M = f2.add(y).umod(this.curve.n);
      return this.makeSignature({ R: p, S: M, Rencoded: m });
    };
    nr.prototype.verify = function(e, r, o) {
      e = ew(e), r = this.makeSignature(r);
      var f2 = this.keyFromPublic(o), p = this.hashInt(r.Rencoded(), f2.pubBytes(), e), m = this.g.mul(r.S()), y = r.R().add(f2.pub().mul(p));
      return y.eq(m);
    };
    nr.prototype.hashInt = function() {
      for (var e = this.hash(), r = 0;r < arguments.length; r++)
        e.update(arguments[r]);
      return zf.intFromLE(e.digest()).umod(this.curve.n);
    };
    nr.prototype.keyFromPublic = function(e) {
      return tw.fromPublic(this, e);
    };
    nr.prototype.keyFromSecret = function(e) {
      return tw.fromSecret(this, e);
    };
    nr.prototype.makeSignature = function(e) {
      return e instanceof Qy ? e : new Qy(this, e);
    };
    nr.prototype.encodePoint = function(e) {
      var r = e.getY().toArray("le", this.encodingLength);
      return r[this.encodingLength - 1] |= e.getX().isOdd() ? 128 : 0, r;
    };
    nr.prototype.decodePoint = function(e) {
      e = zf.parseBytes(e);
      var r = e.length - 1, o = e.slice(0, r).concat(e[r] & -129), f2 = (e[r] & 128) !== 0, p = zf.intFromLE(o);
      return this.curve.pointFromY(p, f2);
    };
    nr.prototype.encodeInt = function(e) {
      return e.toArray("le", this.encodingLength);
    };
    nr.prototype.decodeInt = function(e) {
      return zf.intFromLE(e);
    };
    nr.prototype.isPoint = function(e) {
      return e instanceof this.pointClass;
    };
  });
  d0 = k((nw) => {
    var Vn = nw;
    Vn.version = P2().version;
    Vn.utils = or();
    Vn.rand = Ts();
    Vn.curve = Ql();
    Vn.curves = a0();
    Vn.ec = Zy();
    Vn.eddsa = iw();
  });
  gd = k((fw, md) => {
    (function(t, e) {
      function r(v2, i) {
        if (!v2)
          throw new Error(i || "Assertion failed");
      }
      function o(v2, i) {
        v2.super_ = i;
        var a = function() {
        };
        a.prototype = i.prototype, v2.prototype = new a, v2.prototype.constructor = v2;
      }
      function f2(v2, i, a) {
        if (f2.isBN(v2))
          return v2;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, v2 !== null && ((i === "le" || i === "be") && (a = i, i = 10), this._init(v2 || 0, i || 10, a || "be"));
      }
      typeof t == "object" ? t.exports = f2 : e.BN = f2, f2.BN = f2, f2.wordSize = 26;
      var p;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? p = window.Buffer : p = Vi().Buffer;
      } catch {
      }
      f2.isBN = function(i) {
        return i instanceof f2 ? true : i !== null && typeof i == "object" && i.constructor.wordSize === f2.wordSize && Array.isArray(i.words);
      }, f2.max = function(i, a) {
        return i.cmp(a) > 0 ? i : a;
      }, f2.min = function(i, a) {
        return i.cmp(a) < 0 ? i : a;
      }, f2.prototype._init = function(i, a, h) {
        if (typeof i == "number")
          return this._initNumber(i, a, h);
        if (typeof i == "object")
          return this._initArray(i, a, h);
        a === "hex" && (a = 16), r(a === (a | 0) && a >= 2 && a <= 36), i = i.toString().replace(/\s+/g, "");
        var s = 0;
        i[0] === "-" && (s++, this.negative = 1), s < i.length && (a === 16 ? this._parseHex(i, s, h) : (this._parseBase(i, a, s), h === "le" && this._initArray(this.toArray(), a, h)));
      }, f2.prototype._initNumber = function(i, a, h) {
        i < 0 && (this.negative = 1, i = -i), i < 67108864 ? (this.words = [i & 67108863], this.length = 1) : i < 4503599627370496 ? (this.words = [i & 67108863, i / 67108864 & 67108863], this.length = 2) : (r(i < 9007199254740992), this.words = [i & 67108863, i / 67108864 & 67108863, 1], this.length = 3), h === "le" && this._initArray(this.toArray(), a, h);
      }, f2.prototype._initArray = function(i, a, h) {
        if (r(typeof i.length == "number"), i.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(i.length / 3), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u, c, b2 = 0;
        if (h === "be")
          for (s = i.length - 1, u = 0;s >= 0; s -= 3)
            c = i[s] | i[s - 1] << 8 | i[s - 2] << 16, this.words[u] |= c << b2 & 67108863, this.words[u + 1] = c >>> 26 - b2 & 67108863, b2 += 24, b2 >= 26 && (b2 -= 26, u++);
        else if (h === "le")
          for (s = 0, u = 0;s < i.length; s += 3)
            c = i[s] | i[s + 1] << 8 | i[s + 2] << 16, this.words[u] |= c << b2 & 67108863, this.words[u + 1] = c >>> 26 - b2 & 67108863, b2 += 24, b2 >= 26 && (b2 -= 26, u++);
        return this.strip();
      };
      function m(v2, i) {
        var a = v2.charCodeAt(i);
        return a >= 65 && a <= 70 ? a - 55 : a >= 97 && a <= 102 ? a - 87 : a - 48 & 15;
      }
      function y(v2, i, a) {
        var h = m(v2, a);
        return a - 1 >= i && (h |= m(v2, a - 1) << 4), h;
      }
      f2.prototype._parseHex = function(i, a, h) {
        this.length = Math.ceil((i.length - a) / 6), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u = 0, c = 0, b2;
        if (h === "be")
          for (s = i.length - 1;s >= a; s -= 2)
            b2 = y(i, a, s) << u, this.words[c] |= b2 & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b2 >>> 26) : u += 8;
        else {
          var l = i.length - a;
          for (s = l % 2 === 0 ? a + 1 : a;s < i.length; s += 2)
            b2 = y(i, a, s) << u, this.words[c] |= b2 & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b2 >>> 26) : u += 8;
        }
        this.strip();
      };
      function M(v2, i, a, h) {
        for (var s = 0, u = Math.min(v2.length, a), c = i;c < u; c++) {
          var b2 = v2.charCodeAt(c) - 48;
          s *= h, b2 >= 49 ? s += b2 - 49 + 10 : b2 >= 17 ? s += b2 - 17 + 10 : s += b2;
        }
        return s;
      }
      f2.prototype._parseBase = function(i, a, h) {
        this.words = [0], this.length = 1;
        for (var s = 0, u = 1;u <= 67108863; u *= a)
          s++;
        s--, u = u / a | 0;
        for (var c = i.length - h, b2 = c % s, l = Math.min(c, c - b2) + h, n = 0, d = h;d < l; d += s)
          n = M(i, d, d + s, a), this.imuln(u), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        if (b2 !== 0) {
          var w = 1;
          for (n = M(i, d, i.length, a), d = 0;d < b2; d++)
            w *= a;
          this.imuln(w), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        }
        this.strip();
      }, f2.prototype.copy = function(i) {
        i.words = new Array(this.length);
        for (var a = 0;a < this.length; a++)
          i.words[a] = this.words[a];
        i.length = this.length, i.negative = this.negative, i.red = this.red;
      }, f2.prototype.clone = function() {
        var i = new f2(null);
        return this.copy(i), i;
      }, f2.prototype._expand = function(i) {
        for (;this.length < i; )
          this.words[this.length++] = 0;
        return this;
      }, f2.prototype.strip = function() {
        for (;this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, f2.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, f2.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var x = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], S2 = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], E = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      f2.prototype.toString = function(i, a) {
        i = i || 10, a = a | 0 || 1;
        var h;
        if (i === 16 || i === "hex") {
          h = "";
          for (var s = 0, u = 0, c = 0;c < this.length; c++) {
            var b2 = this.words[c], l = ((b2 << s | u) & 16777215).toString(16);
            u = b2 >>> 24 - s & 16777215, u !== 0 || c !== this.length - 1 ? h = x[6 - l.length] + l + h : h = l + h, s += 2, s >= 26 && (s -= 26, c--);
          }
          for (u !== 0 && (h = u.toString(16) + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        if (i === (i | 0) && i >= 2 && i <= 36) {
          var n = S2[i], d = E[i];
          h = "";
          var w = this.clone();
          for (w.negative = 0;!w.isZero(); ) {
            var g = w.modn(d).toString(i);
            w = w.idivn(d), w.isZero() ? h = g + h : h = x[n - g.length] + g + h;
          }
          for (this.isZero() && (h = "0" + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        r(false, "Base should be between 2 and 36");
      }, f2.prototype.toNumber = function() {
        var i = this.words[0];
        return this.length === 2 ? i += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? i += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -i : i;
      }, f2.prototype.toJSON = function() {
        return this.toString(16);
      }, f2.prototype.toBuffer = function(i, a) {
        return r(typeof p < "u"), this.toArrayLike(p, i, a);
      }, f2.prototype.toArray = function(i, a) {
        return this.toArrayLike(Array, i, a);
      }, f2.prototype.toArrayLike = function(i, a, h) {
        var s = this.byteLength(), u = h || Math.max(1, s);
        r(s <= u, "byte array longer than desired length"), r(u > 0, "Requested array length <= 0"), this.strip();
        var c = a === "le", b2 = new i(u), l, n, d = this.clone();
        if (c) {
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b2[n] = l;
          for (;n < u; n++)
            b2[n] = 0;
        } else {
          for (n = 0;n < u - s; n++)
            b2[n] = 0;
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b2[u - n - 1] = l;
        }
        return b2;
      }, Math.clz32 ? f2.prototype._countBits = function(i) {
        return 32 - Math.clz32(i);
      } : f2.prototype._countBits = function(i) {
        var a = i, h = 0;
        return a >= 4096 && (h += 13, a >>>= 13), a >= 64 && (h += 7, a >>>= 7), a >= 8 && (h += 4, a >>>= 4), a >= 2 && (h += 2, a >>>= 2), h + a;
      }, f2.prototype._zeroBits = function(i) {
        if (i === 0)
          return 26;
        var a = i, h = 0;
        return (a & 8191) === 0 && (h += 13, a >>>= 13), (a & 127) === 0 && (h += 7, a >>>= 7), (a & 15) === 0 && (h += 4, a >>>= 4), (a & 3) === 0 && (h += 2, a >>>= 2), (a & 1) === 0 && h++, h;
      }, f2.prototype.bitLength = function() {
        var i = this.words[this.length - 1], a = this._countBits(i);
        return (this.length - 1) * 26 + a;
      };
      function R(v2) {
        for (var i = new Array(v2.bitLength()), a = 0;a < i.length; a++) {
          var h = a / 26 | 0, s = a % 26;
          i[a] = (v2.words[h] & 1 << s) >>> s;
        }
        return i;
      }
      f2.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var i = 0, a = 0;a < this.length; a++) {
          var h = this._zeroBits(this.words[a]);
          if (i += h, h !== 26)
            break;
        }
        return i;
      }, f2.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, f2.prototype.toTwos = function(i) {
        return this.negative !== 0 ? this.abs().inotn(i).iaddn(1) : this.clone();
      }, f2.prototype.fromTwos = function(i) {
        return this.testn(i - 1) ? this.notn(i).iaddn(1).ineg() : this.clone();
      }, f2.prototype.isNeg = function() {
        return this.negative !== 0;
      }, f2.prototype.neg = function() {
        return this.clone().ineg();
      }, f2.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, f2.prototype.iuor = function(i) {
        for (;this.length < i.length; )
          this.words[this.length++] = 0;
        for (var a = 0;a < i.length; a++)
          this.words[a] = this.words[a] | i.words[a];
        return this.strip();
      }, f2.prototype.ior = function(i) {
        return r((this.negative | i.negative) === 0), this.iuor(i);
      }, f2.prototype.or = function(i) {
        return this.length > i.length ? this.clone().ior(i) : i.clone().ior(this);
      }, f2.prototype.uor = function(i) {
        return this.length > i.length ? this.clone().iuor(i) : i.clone().iuor(this);
      }, f2.prototype.iuand = function(i) {
        var a;
        this.length > i.length ? a = i : a = this;
        for (var h = 0;h < a.length; h++)
          this.words[h] = this.words[h] & i.words[h];
        return this.length = a.length, this.strip();
      }, f2.prototype.iand = function(i) {
        return r((this.negative | i.negative) === 0), this.iuand(i);
      }, f2.prototype.and = function(i) {
        return this.length > i.length ? this.clone().iand(i) : i.clone().iand(this);
      }, f2.prototype.uand = function(i) {
        return this.length > i.length ? this.clone().iuand(i) : i.clone().iuand(this);
      }, f2.prototype.iuxor = function(i) {
        var a, h;
        this.length > i.length ? (a = this, h = i) : (a = i, h = this);
        for (var s = 0;s < h.length; s++)
          this.words[s] = a.words[s] ^ h.words[s];
        if (this !== a)
          for (;s < a.length; s++)
            this.words[s] = a.words[s];
        return this.length = a.length, this.strip();
      }, f2.prototype.ixor = function(i) {
        return r((this.negative | i.negative) === 0), this.iuxor(i);
      }, f2.prototype.xor = function(i) {
        return this.length > i.length ? this.clone().ixor(i) : i.clone().ixor(this);
      }, f2.prototype.uxor = function(i) {
        return this.length > i.length ? this.clone().iuxor(i) : i.clone().iuxor(this);
      }, f2.prototype.inotn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = Math.ceil(i / 26) | 0, h = i % 26;
        this._expand(a), h > 0 && a--;
        for (var s = 0;s < a; s++)
          this.words[s] = ~this.words[s] & 67108863;
        return h > 0 && (this.words[s] = ~this.words[s] & 67108863 >> 26 - h), this.strip();
      }, f2.prototype.notn = function(i) {
        return this.clone().inotn(i);
      }, f2.prototype.setn = function(i, a) {
        r(typeof i == "number" && i >= 0);
        var h = i / 26 | 0, s = i % 26;
        return this._expand(h + 1), a ? this.words[h] = this.words[h] | 1 << s : this.words[h] = this.words[h] & ~(1 << s), this.strip();
      }, f2.prototype.iadd = function(i) {
        var a;
        if (this.negative !== 0 && i.negative === 0)
          return this.negative = 0, a = this.isub(i), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && i.negative !== 0)
          return i.negative = 0, a = this.isub(i), i.negative = 1, a._normSign();
        var h, s;
        this.length > i.length ? (h = this, s = i) : (h = i, s = this);
        for (var u = 0, c = 0;c < s.length; c++)
          a = (h.words[c] | 0) + (s.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        for (;u !== 0 && c < h.length; c++)
          a = (h.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        if (this.length = h.length, u !== 0)
          this.words[this.length] = u, this.length++;
        else if (h !== this)
          for (;c < h.length; c++)
            this.words[c] = h.words[c];
        return this;
      }, f2.prototype.add = function(i) {
        var a;
        return i.negative !== 0 && this.negative === 0 ? (i.negative = 0, a = this.sub(i), i.negative ^= 1, a) : i.negative === 0 && this.negative !== 0 ? (this.negative = 0, a = i.sub(this), this.negative = 1, a) : this.length > i.length ? this.clone().iadd(i) : i.clone().iadd(this);
      }, f2.prototype.isub = function(i) {
        if (i.negative !== 0) {
          i.negative = 0;
          var a = this.iadd(i);
          return i.negative = 1, a._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(i), this.negative = 1, this._normSign();
        var h = this.cmp(i);
        if (h === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var s, u;
        h > 0 ? (s = this, u = i) : (s = i, u = this);
        for (var c = 0, b2 = 0;b2 < u.length; b2++)
          a = (s.words[b2] | 0) - (u.words[b2] | 0) + c, c = a >> 26, this.words[b2] = a & 67108863;
        for (;c !== 0 && b2 < s.length; b2++)
          a = (s.words[b2] | 0) + c, c = a >> 26, this.words[b2] = a & 67108863;
        if (c === 0 && b2 < s.length && s !== this)
          for (;b2 < s.length; b2++)
            this.words[b2] = s.words[b2];
        return this.length = Math.max(this.length, b2), s !== this && (this.negative = 1), this.strip();
      }, f2.prototype.sub = function(i) {
        return this.clone().isub(i);
      };
      function q(v2, i, a) {
        a.negative = i.negative ^ v2.negative;
        var h = v2.length + i.length | 0;
        a.length = h, h = h - 1 | 0;
        var s = v2.words[0] | 0, u = i.words[0] | 0, c = s * u, b2 = c & 67108863, l = c / 67108864 | 0;
        a.words[0] = b2;
        for (var n = 1;n < h; n++) {
          for (var d = l >>> 26, w = l & 67108863, g = Math.min(n, i.length - 1), _2 = Math.max(0, n - v2.length + 1);_2 <= g; _2++) {
            var A = n - _2 | 0;
            s = v2.words[A] | 0, u = i.words[_2] | 0, c = s * u + w, d += c / 67108864 | 0, w = c & 67108863;
          }
          a.words[n] = w | 0, l = d | 0;
        }
        return l !== 0 ? a.words[n] = l | 0 : a.length--, a.strip();
      }
      var T = function(i, a, h) {
        var s = i.words, u = a.words, c = h.words, b2 = 0, l, n, d, w = s[0] | 0, g = w & 8191, _2 = w >>> 13, A = s[1] | 0, B = A & 8191, I = A >>> 13, we = s[2] | 0, L = we & 8191, N = we >>> 13, nt = s[3] | 0, C = nt & 8191, O = nt >>> 13, vt = s[4] | 0, F = vt & 8191, U = vt >>> 13, bt = s[5] | 0, z2 = bt & 8191, H = bt >>> 13, mt = s[6] | 0, W = mt & 8191, K = mt >>> 13, gt = s[7] | 0, j = gt & 8191, Z = gt >>> 13, yt = s[8] | 0, V = yt & 8191, $2 = yt >>> 13, wt = s[9] | 0, G = wt & 8191, Y = wt >>> 13, Mt = u[0] | 0, X = Mt & 8191, J2 = Mt >>> 13, _t = u[1] | 0, Q2 = _t & 8191, ee = _t >>> 13, xt = u[2] | 0, te = xt & 8191, re = xt >>> 13, St = u[3] | 0, ie = St & 8191, ne = St >>> 13, Et = u[4] | 0, fe = Et & 8191, ae = Et >>> 13, At = u[5] | 0, oe = At & 8191, se = At >>> 13, Rt = u[6] | 0, he = Rt & 8191, ue = Rt >>> 13, Bt = u[7] | 0, le = Bt & 8191, de = Bt >>> 13, qt = u[8] | 0, ce = qt & 8191, pe = qt >>> 13, It = u[9] | 0, ve = It & 8191, be = It >>> 13;
        h.negative = i.negative ^ a.negative, h.length = 19, l = Math.imul(g, X), n = Math.imul(g, J2), n = n + Math.imul(_2, X) | 0, d = Math.imul(_2, J2);
        var ft = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, l = Math.imul(B, X), n = Math.imul(B, J2), n = n + Math.imul(I, X) | 0, d = Math.imul(I, J2), l = l + Math.imul(g, Q2) | 0, n = n + Math.imul(g, ee) | 0, n = n + Math.imul(_2, Q2) | 0, d = d + Math.imul(_2, ee) | 0;
        var Be = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, l = Math.imul(L, X), n = Math.imul(L, J2), n = n + Math.imul(N, X) | 0, d = Math.imul(N, J2), l = l + Math.imul(B, Q2) | 0, n = n + Math.imul(B, ee) | 0, n = n + Math.imul(I, Q2) | 0, d = d + Math.imul(I, ee) | 0, l = l + Math.imul(g, te) | 0, n = n + Math.imul(g, re) | 0, n = n + Math.imul(_2, te) | 0, d = d + Math.imul(_2, re) | 0;
        var qe = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (qe >>> 26) | 0, qe &= 67108863, l = Math.imul(C, X), n = Math.imul(C, J2), n = n + Math.imul(O, X) | 0, d = Math.imul(O, J2), l = l + Math.imul(L, Q2) | 0, n = n + Math.imul(L, ee) | 0, n = n + Math.imul(N, Q2) | 0, d = d + Math.imul(N, ee) | 0, l = l + Math.imul(B, te) | 0, n = n + Math.imul(B, re) | 0, n = n + Math.imul(I, te) | 0, d = d + Math.imul(I, re) | 0, l = l + Math.imul(g, ie) | 0, n = n + Math.imul(g, ne) | 0, n = n + Math.imul(_2, ie) | 0, d = d + Math.imul(_2, ne) | 0;
        var ze = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, l = Math.imul(F, X), n = Math.imul(F, J2), n = n + Math.imul(U, X) | 0, d = Math.imul(U, J2), l = l + Math.imul(C, Q2) | 0, n = n + Math.imul(C, ee) | 0, n = n + Math.imul(O, Q2) | 0, d = d + Math.imul(O, ee) | 0, l = l + Math.imul(L, te) | 0, n = n + Math.imul(L, re) | 0, n = n + Math.imul(N, te) | 0, d = d + Math.imul(N, re) | 0, l = l + Math.imul(B, ie) | 0, n = n + Math.imul(B, ne) | 0, n = n + Math.imul(I, ie) | 0, d = d + Math.imul(I, ne) | 0, l = l + Math.imul(g, fe) | 0, n = n + Math.imul(g, ae) | 0, n = n + Math.imul(_2, fe) | 0, d = d + Math.imul(_2, ae) | 0;
        var He = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, l = Math.imul(z2, X), n = Math.imul(z2, J2), n = n + Math.imul(H, X) | 0, d = Math.imul(H, J2), l = l + Math.imul(F, Q2) | 0, n = n + Math.imul(F, ee) | 0, n = n + Math.imul(U, Q2) | 0, d = d + Math.imul(U, ee) | 0, l = l + Math.imul(C, te) | 0, n = n + Math.imul(C, re) | 0, n = n + Math.imul(O, te) | 0, d = d + Math.imul(O, re) | 0, l = l + Math.imul(L, ie) | 0, n = n + Math.imul(L, ne) | 0, n = n + Math.imul(N, ie) | 0, d = d + Math.imul(N, ne) | 0, l = l + Math.imul(B, fe) | 0, n = n + Math.imul(B, ae) | 0, n = n + Math.imul(I, fe) | 0, d = d + Math.imul(I, ae) | 0, l = l + Math.imul(g, oe) | 0, n = n + Math.imul(g, se) | 0, n = n + Math.imul(_2, oe) | 0, d = d + Math.imul(_2, se) | 0;
        var We = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (We >>> 26) | 0, We &= 67108863, l = Math.imul(W, X), n = Math.imul(W, J2), n = n + Math.imul(K, X) | 0, d = Math.imul(K, J2), l = l + Math.imul(z2, Q2) | 0, n = n + Math.imul(z2, ee) | 0, n = n + Math.imul(H, Q2) | 0, d = d + Math.imul(H, ee) | 0, l = l + Math.imul(F, te) | 0, n = n + Math.imul(F, re) | 0, n = n + Math.imul(U, te) | 0, d = d + Math.imul(U, re) | 0, l = l + Math.imul(C, ie) | 0, n = n + Math.imul(C, ne) | 0, n = n + Math.imul(O, ie) | 0, d = d + Math.imul(O, ne) | 0, l = l + Math.imul(L, fe) | 0, n = n + Math.imul(L, ae) | 0, n = n + Math.imul(N, fe) | 0, d = d + Math.imul(N, ae) | 0, l = l + Math.imul(B, oe) | 0, n = n + Math.imul(B, se) | 0, n = n + Math.imul(I, oe) | 0, d = d + Math.imul(I, se) | 0, l = l + Math.imul(g, he) | 0, n = n + Math.imul(g, ue) | 0, n = n + Math.imul(_2, he) | 0, d = d + Math.imul(_2, ue) | 0;
        var Ke = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, l = Math.imul(j, X), n = Math.imul(j, J2), n = n + Math.imul(Z, X) | 0, d = Math.imul(Z, J2), l = l + Math.imul(W, Q2) | 0, n = n + Math.imul(W, ee) | 0, n = n + Math.imul(K, Q2) | 0, d = d + Math.imul(K, ee) | 0, l = l + Math.imul(z2, te) | 0, n = n + Math.imul(z2, re) | 0, n = n + Math.imul(H, te) | 0, d = d + Math.imul(H, re) | 0, l = l + Math.imul(F, ie) | 0, n = n + Math.imul(F, ne) | 0, n = n + Math.imul(U, ie) | 0, d = d + Math.imul(U, ne) | 0, l = l + Math.imul(C, fe) | 0, n = n + Math.imul(C, ae) | 0, n = n + Math.imul(O, fe) | 0, d = d + Math.imul(O, ae) | 0, l = l + Math.imul(L, oe) | 0, n = n + Math.imul(L, se) | 0, n = n + Math.imul(N, oe) | 0, d = d + Math.imul(N, se) | 0, l = l + Math.imul(B, he) | 0, n = n + Math.imul(B, ue) | 0, n = n + Math.imul(I, he) | 0, d = d + Math.imul(I, ue) | 0, l = l + Math.imul(g, le) | 0, n = n + Math.imul(g, de) | 0, n = n + Math.imul(_2, le) | 0, d = d + Math.imul(_2, de) | 0;
        var je = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, l = Math.imul(V, X), n = Math.imul(V, J2), n = n + Math.imul($2, X) | 0, d = Math.imul($2, J2), l = l + Math.imul(j, Q2) | 0, n = n + Math.imul(j, ee) | 0, n = n + Math.imul(Z, Q2) | 0, d = d + Math.imul(Z, ee) | 0, l = l + Math.imul(W, te) | 0, n = n + Math.imul(W, re) | 0, n = n + Math.imul(K, te) | 0, d = d + Math.imul(K, re) | 0, l = l + Math.imul(z2, ie) | 0, n = n + Math.imul(z2, ne) | 0, n = n + Math.imul(H, ie) | 0, d = d + Math.imul(H, ne) | 0, l = l + Math.imul(F, fe) | 0, n = n + Math.imul(F, ae) | 0, n = n + Math.imul(U, fe) | 0, d = d + Math.imul(U, ae) | 0, l = l + Math.imul(C, oe) | 0, n = n + Math.imul(C, se) | 0, n = n + Math.imul(O, oe) | 0, d = d + Math.imul(O, se) | 0, l = l + Math.imul(L, he) | 0, n = n + Math.imul(L, ue) | 0, n = n + Math.imul(N, he) | 0, d = d + Math.imul(N, ue) | 0, l = l + Math.imul(B, le) | 0, n = n + Math.imul(B, de) | 0, n = n + Math.imul(I, le) | 0, d = d + Math.imul(I, de) | 0, l = l + Math.imul(g, ce) | 0, n = n + Math.imul(g, pe) | 0, n = n + Math.imul(_2, ce) | 0, d = d + Math.imul(_2, pe) | 0;
        var Ze = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, l = Math.imul(G, X), n = Math.imul(G, J2), n = n + Math.imul(Y, X) | 0, d = Math.imul(Y, J2), l = l + Math.imul(V, Q2) | 0, n = n + Math.imul(V, ee) | 0, n = n + Math.imul($2, Q2) | 0, d = d + Math.imul($2, ee) | 0, l = l + Math.imul(j, te) | 0, n = n + Math.imul(j, re) | 0, n = n + Math.imul(Z, te) | 0, d = d + Math.imul(Z, re) | 0, l = l + Math.imul(W, ie) | 0, n = n + Math.imul(W, ne) | 0, n = n + Math.imul(K, ie) | 0, d = d + Math.imul(K, ne) | 0, l = l + Math.imul(z2, fe) | 0, n = n + Math.imul(z2, ae) | 0, n = n + Math.imul(H, fe) | 0, d = d + Math.imul(H, ae) | 0, l = l + Math.imul(F, oe) | 0, n = n + Math.imul(F, se) | 0, n = n + Math.imul(U, oe) | 0, d = d + Math.imul(U, se) | 0, l = l + Math.imul(C, he) | 0, n = n + Math.imul(C, ue) | 0, n = n + Math.imul(O, he) | 0, d = d + Math.imul(O, ue) | 0, l = l + Math.imul(L, le) | 0, n = n + Math.imul(L, de) | 0, n = n + Math.imul(N, le) | 0, d = d + Math.imul(N, de) | 0, l = l + Math.imul(B, ce) | 0, n = n + Math.imul(B, pe) | 0, n = n + Math.imul(I, ce) | 0, d = d + Math.imul(I, pe) | 0, l = l + Math.imul(g, ve) | 0, n = n + Math.imul(g, be) | 0, n = n + Math.imul(_2, ve) | 0, d = d + Math.imul(_2, be) | 0;
        var Ve = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, l = Math.imul(G, Q2), n = Math.imul(G, ee), n = n + Math.imul(Y, Q2) | 0, d = Math.imul(Y, ee), l = l + Math.imul(V, te) | 0, n = n + Math.imul(V, re) | 0, n = n + Math.imul($2, te) | 0, d = d + Math.imul($2, re) | 0, l = l + Math.imul(j, ie) | 0, n = n + Math.imul(j, ne) | 0, n = n + Math.imul(Z, ie) | 0, d = d + Math.imul(Z, ne) | 0, l = l + Math.imul(W, fe) | 0, n = n + Math.imul(W, ae) | 0, n = n + Math.imul(K, fe) | 0, d = d + Math.imul(K, ae) | 0, l = l + Math.imul(z2, oe) | 0, n = n + Math.imul(z2, se) | 0, n = n + Math.imul(H, oe) | 0, d = d + Math.imul(H, se) | 0, l = l + Math.imul(F, he) | 0, n = n + Math.imul(F, ue) | 0, n = n + Math.imul(U, he) | 0, d = d + Math.imul(U, ue) | 0, l = l + Math.imul(C, le) | 0, n = n + Math.imul(C, de) | 0, n = n + Math.imul(O, le) | 0, d = d + Math.imul(O, de) | 0, l = l + Math.imul(L, ce) | 0, n = n + Math.imul(L, pe) | 0, n = n + Math.imul(N, ce) | 0, d = d + Math.imul(N, pe) | 0, l = l + Math.imul(B, ve) | 0, n = n + Math.imul(B, be) | 0, n = n + Math.imul(I, ve) | 0, d = d + Math.imul(I, be) | 0;
        var $e = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + ($e >>> 26) | 0, $e &= 67108863, l = Math.imul(G, te), n = Math.imul(G, re), n = n + Math.imul(Y, te) | 0, d = Math.imul(Y, re), l = l + Math.imul(V, ie) | 0, n = n + Math.imul(V, ne) | 0, n = n + Math.imul($2, ie) | 0, d = d + Math.imul($2, ne) | 0, l = l + Math.imul(j, fe) | 0, n = n + Math.imul(j, ae) | 0, n = n + Math.imul(Z, fe) | 0, d = d + Math.imul(Z, ae) | 0, l = l + Math.imul(W, oe) | 0, n = n + Math.imul(W, se) | 0, n = n + Math.imul(K, oe) | 0, d = d + Math.imul(K, se) | 0, l = l + Math.imul(z2, he) | 0, n = n + Math.imul(z2, ue) | 0, n = n + Math.imul(H, he) | 0, d = d + Math.imul(H, ue) | 0, l = l + Math.imul(F, le) | 0, n = n + Math.imul(F, de) | 0, n = n + Math.imul(U, le) | 0, d = d + Math.imul(U, de) | 0, l = l + Math.imul(C, ce) | 0, n = n + Math.imul(C, pe) | 0, n = n + Math.imul(O, ce) | 0, d = d + Math.imul(O, pe) | 0, l = l + Math.imul(L, ve) | 0, n = n + Math.imul(L, be) | 0, n = n + Math.imul(N, ve) | 0, d = d + Math.imul(N, be) | 0;
        var Ge = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, l = Math.imul(G, ie), n = Math.imul(G, ne), n = n + Math.imul(Y, ie) | 0, d = Math.imul(Y, ne), l = l + Math.imul(V, fe) | 0, n = n + Math.imul(V, ae) | 0, n = n + Math.imul($2, fe) | 0, d = d + Math.imul($2, ae) | 0, l = l + Math.imul(j, oe) | 0, n = n + Math.imul(j, se) | 0, n = n + Math.imul(Z, oe) | 0, d = d + Math.imul(Z, se) | 0, l = l + Math.imul(W, he) | 0, n = n + Math.imul(W, ue) | 0, n = n + Math.imul(K, he) | 0, d = d + Math.imul(K, ue) | 0, l = l + Math.imul(z2, le) | 0, n = n + Math.imul(z2, de) | 0, n = n + Math.imul(H, le) | 0, d = d + Math.imul(H, de) | 0, l = l + Math.imul(F, ce) | 0, n = n + Math.imul(F, pe) | 0, n = n + Math.imul(U, ce) | 0, d = d + Math.imul(U, pe) | 0, l = l + Math.imul(C, ve) | 0, n = n + Math.imul(C, be) | 0, n = n + Math.imul(O, ve) | 0, d = d + Math.imul(O, be) | 0;
        var Ye = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, l = Math.imul(G, fe), n = Math.imul(G, ae), n = n + Math.imul(Y, fe) | 0, d = Math.imul(Y, ae), l = l + Math.imul(V, oe) | 0, n = n + Math.imul(V, se) | 0, n = n + Math.imul($2, oe) | 0, d = d + Math.imul($2, se) | 0, l = l + Math.imul(j, he) | 0, n = n + Math.imul(j, ue) | 0, n = n + Math.imul(Z, he) | 0, d = d + Math.imul(Z, ue) | 0, l = l + Math.imul(W, le) | 0, n = n + Math.imul(W, de) | 0, n = n + Math.imul(K, le) | 0, d = d + Math.imul(K, de) | 0, l = l + Math.imul(z2, ce) | 0, n = n + Math.imul(z2, pe) | 0, n = n + Math.imul(H, ce) | 0, d = d + Math.imul(H, pe) | 0, l = l + Math.imul(F, ve) | 0, n = n + Math.imul(F, be) | 0, n = n + Math.imul(U, ve) | 0, d = d + Math.imul(U, be) | 0;
        var Xe = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, l = Math.imul(G, oe), n = Math.imul(G, se), n = n + Math.imul(Y, oe) | 0, d = Math.imul(Y, se), l = l + Math.imul(V, he) | 0, n = n + Math.imul(V, ue) | 0, n = n + Math.imul($2, he) | 0, d = d + Math.imul($2, ue) | 0, l = l + Math.imul(j, le) | 0, n = n + Math.imul(j, de) | 0, n = n + Math.imul(Z, le) | 0, d = d + Math.imul(Z, de) | 0, l = l + Math.imul(W, ce) | 0, n = n + Math.imul(W, pe) | 0, n = n + Math.imul(K, ce) | 0, d = d + Math.imul(K, pe) | 0, l = l + Math.imul(z2, ve) | 0, n = n + Math.imul(z2, be) | 0, n = n + Math.imul(H, ve) | 0, d = d + Math.imul(H, be) | 0;
        var Je = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, l = Math.imul(G, he), n = Math.imul(G, ue), n = n + Math.imul(Y, he) | 0, d = Math.imul(Y, ue), l = l + Math.imul(V, le) | 0, n = n + Math.imul(V, de) | 0, n = n + Math.imul($2, le) | 0, d = d + Math.imul($2, de) | 0, l = l + Math.imul(j, ce) | 0, n = n + Math.imul(j, pe) | 0, n = n + Math.imul(Z, ce) | 0, d = d + Math.imul(Z, pe) | 0, l = l + Math.imul(W, ve) | 0, n = n + Math.imul(W, be) | 0, n = n + Math.imul(K, ve) | 0, d = d + Math.imul(K, be) | 0;
        var Qe = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, l = Math.imul(G, le), n = Math.imul(G, de), n = n + Math.imul(Y, le) | 0, d = Math.imul(Y, de), l = l + Math.imul(V, ce) | 0, n = n + Math.imul(V, pe) | 0, n = n + Math.imul($2, ce) | 0, d = d + Math.imul($2, pe) | 0, l = l + Math.imul(j, ve) | 0, n = n + Math.imul(j, be) | 0, n = n + Math.imul(Z, ve) | 0, d = d + Math.imul(Z, be) | 0;
        var et = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, l = Math.imul(G, ce), n = Math.imul(G, pe), n = n + Math.imul(Y, ce) | 0, d = Math.imul(Y, pe), l = l + Math.imul(V, ve) | 0, n = n + Math.imul(V, be) | 0, n = n + Math.imul($2, ve) | 0, d = d + Math.imul($2, be) | 0;
        var tt = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, l = Math.imul(G, ve), n = Math.imul(G, be), n = n + Math.imul(Y, ve) | 0, d = Math.imul(Y, be);
        var rt = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        return b2 = (d + (n >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, c[0] = ft, c[1] = Be, c[2] = qe, c[3] = ze, c[4] = He, c[5] = We, c[6] = Ke, c[7] = je, c[8] = Ze, c[9] = Ve, c[10] = $e, c[11] = Ge, c[12] = Ye, c[13] = Xe, c[14] = Je, c[15] = Qe, c[16] = et, c[17] = tt, c[18] = rt, b2 !== 0 && (c[19] = b2, h.length++), h;
      };
      Math.imul || (T = q);
      function ye(v2, i, a) {
        a.negative = i.negative ^ v2.negative, a.length = v2.length + i.length;
        for (var h = 0, s = 0, u = 0;u < a.length - 1; u++) {
          var c = s;
          s = 0;
          for (var b2 = h & 67108863, l = Math.min(u, i.length - 1), n = Math.max(0, u - v2.length + 1);n <= l; n++) {
            var d = u - n, w = v2.words[d] | 0, g = i.words[n] | 0, _2 = w * g, A = _2 & 67108863;
            c = c + (_2 / 67108864 | 0) | 0, A = A + b2 | 0, b2 = A & 67108863, c = c + (A >>> 26) | 0, s += c >>> 26, c &= 67108863;
          }
          a.words[u] = b2, h = c, c = s;
        }
        return h !== 0 ? a.words[u] = h : a.length--, a.strip();
      }
      function _e(v2, i, a) {
        var h = new P;
        return h.mulp(v2, i, a);
      }
      f2.prototype.mulTo = function(i, a) {
        var h, s = this.length + i.length;
        return this.length === 10 && i.length === 10 ? h = T(this, i, a) : s < 63 ? h = q(this, i, a) : s < 1024 ? h = ye(this, i, a) : h = _e(this, i, a), h;
      };
      function P(v2, i) {
        this.x = v2, this.y = i;
      }
      P.prototype.makeRBT = function(i) {
        for (var a = new Array(i), h = f2.prototype._countBits(i) - 1, s = 0;s < i; s++)
          a[s] = this.revBin(s, h, i);
        return a;
      }, P.prototype.revBin = function(i, a, h) {
        if (i === 0 || i === h - 1)
          return i;
        for (var s = 0, u = 0;u < a; u++)
          s |= (i & 1) << a - u - 1, i >>= 1;
        return s;
      }, P.prototype.permute = function(i, a, h, s, u, c) {
        for (var b2 = 0;b2 < c; b2++)
          s[b2] = a[i[b2]], u[b2] = h[i[b2]];
      }, P.prototype.transform = function(i, a, h, s, u, c) {
        this.permute(c, i, a, h, s, u);
        for (var b2 = 1;b2 < u; b2 <<= 1)
          for (var l = b2 << 1, n = Math.cos(2 * Math.PI / l), d = Math.sin(2 * Math.PI / l), w = 0;w < u; w += l)
            for (var g = n, _2 = d, A = 0;A < b2; A++) {
              var B = h[w + A], I = s[w + A], we = h[w + A + b2], L = s[w + A + b2], N = g * we - _2 * L;
              L = g * L + _2 * we, we = N, h[w + A] = B + we, s[w + A] = I + L, h[w + A + b2] = B - we, s[w + A + b2] = I - L, A !== l && (N = n * g - d * _2, _2 = n * _2 + d * g, g = N);
            }
      }, P.prototype.guessLen13b = function(i, a) {
        var h = Math.max(a, i) | 1, s = h & 1, u = 0;
        for (h = h / 2 | 0;h; h = h >>> 1)
          u++;
        return 1 << u + 1 + s;
      }, P.prototype.conjugate = function(i, a, h) {
        if (!(h <= 1))
          for (var s = 0;s < h / 2; s++) {
            var u = i[s];
            i[s] = i[h - s - 1], i[h - s - 1] = u, u = a[s], a[s] = -a[h - s - 1], a[h - s - 1] = -u;
          }
      }, P.prototype.normalize13b = function(i, a) {
        for (var h = 0, s = 0;s < a / 2; s++) {
          var u = Math.round(i[2 * s + 1] / a) * 8192 + Math.round(i[2 * s] / a) + h;
          i[s] = u & 67108863, u < 67108864 ? h = 0 : h = u / 67108864 | 0;
        }
        return i;
      }, P.prototype.convert13b = function(i, a, h, s) {
        for (var u = 0, c = 0;c < a; c++)
          u = u + (i[c] | 0), h[2 * c] = u & 8191, u = u >>> 13, h[2 * c + 1] = u & 8191, u = u >>> 13;
        for (c = 2 * a;c < s; ++c)
          h[c] = 0;
        r(u === 0), r((u & -8192) === 0);
      }, P.prototype.stub = function(i) {
        for (var a = new Array(i), h = 0;h < i; h++)
          a[h] = 0;
        return a;
      }, P.prototype.mulp = function(i, a, h) {
        var s = 2 * this.guessLen13b(i.length, a.length), u = this.makeRBT(s), c = this.stub(s), b2 = new Array(s), l = new Array(s), n = new Array(s), d = new Array(s), w = new Array(s), g = new Array(s), _2 = h.words;
        _2.length = s, this.convert13b(i.words, i.length, b2, s), this.convert13b(a.words, a.length, d, s), this.transform(b2, c, l, n, s, u), this.transform(d, c, w, g, s, u);
        for (var A = 0;A < s; A++) {
          var B = l[A] * w[A] - n[A] * g[A];
          n[A] = l[A] * g[A] + n[A] * w[A], l[A] = B;
        }
        return this.conjugate(l, n, s), this.transform(l, n, _2, c, s, u), this.conjugate(_2, c, s), this.normalize13b(_2, s), h.negative = i.negative ^ a.negative, h.length = i.length + a.length, h.strip();
      }, f2.prototype.mul = function(i) {
        var a = new f2(null);
        return a.words = new Array(this.length + i.length), this.mulTo(i, a);
      }, f2.prototype.mulf = function(i) {
        var a = new f2(null);
        return a.words = new Array(this.length + i.length), _e(this, i, a);
      }, f2.prototype.imul = function(i) {
        return this.clone().mulTo(i, this);
      }, f2.prototype.imuln = function(i) {
        r(typeof i == "number"), r(i < 67108864);
        for (var a = 0, h = 0;h < this.length; h++) {
          var s = (this.words[h] | 0) * i, u = (s & 67108863) + (a & 67108863);
          a >>= 26, a += s / 67108864 | 0, a += u >>> 26, this.words[h] = u & 67108863;
        }
        return a !== 0 && (this.words[h] = a, this.length++), this;
      }, f2.prototype.muln = function(i) {
        return this.clone().imuln(i);
      }, f2.prototype.sqr = function() {
        return this.mul(this);
      }, f2.prototype.isqr = function() {
        return this.imul(this.clone());
      }, f2.prototype.pow = function(i) {
        var a = R(i);
        if (a.length === 0)
          return new f2(1);
        for (var h = this, s = 0;s < a.length && a[s] === 0; s++, h = h.sqr())
          ;
        if (++s < a.length)
          for (var u = h.sqr();s < a.length; s++, u = u.sqr())
            a[s] !== 0 && (h = h.mul(u));
        return h;
      }, f2.prototype.iushln = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 67108863 >>> 26 - a << 26 - a, u;
        if (a !== 0) {
          var c = 0;
          for (u = 0;u < this.length; u++) {
            var b2 = this.words[u] & s, l = (this.words[u] | 0) - b2 << a;
            this.words[u] = l | c, c = b2 >>> 26 - a;
          }
          c && (this.words[u] = c, this.length++);
        }
        if (h !== 0) {
          for (u = this.length - 1;u >= 0; u--)
            this.words[u + h] = this.words[u];
          for (u = 0;u < h; u++)
            this.words[u] = 0;
          this.length += h;
        }
        return this.strip();
      }, f2.prototype.ishln = function(i) {
        return r(this.negative === 0), this.iushln(i);
      }, f2.prototype.iushrn = function(i, a, h) {
        r(typeof i == "number" && i >= 0);
        var s;
        a ? s = (a - a % 26) / 26 : s = 0;
        var u = i % 26, c = Math.min((i - u) / 26, this.length), b2 = 67108863 ^ 67108863 >>> u << u, l = h;
        if (s -= c, s = Math.max(0, s), l) {
          for (var n = 0;n < c; n++)
            l.words[n] = this.words[n];
          l.length = c;
        }
        if (c !== 0)
          if (this.length > c)
            for (this.length -= c, n = 0;n < this.length; n++)
              this.words[n] = this.words[n + c];
          else
            this.words[0] = 0, this.length = 1;
        var d = 0;
        for (n = this.length - 1;n >= 0 && (d !== 0 || n >= s); n--) {
          var w = this.words[n] | 0;
          this.words[n] = d << 26 - u | w >>> u, d = w & b2;
        }
        return l && d !== 0 && (l.words[l.length++] = d), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, f2.prototype.ishrn = function(i, a, h) {
        return r(this.negative === 0), this.iushrn(i, a, h);
      }, f2.prototype.shln = function(i) {
        return this.clone().ishln(i);
      }, f2.prototype.ushln = function(i) {
        return this.clone().iushln(i);
      }, f2.prototype.shrn = function(i) {
        return this.clone().ishrn(i);
      }, f2.prototype.ushrn = function(i) {
        return this.clone().iushrn(i);
      }, f2.prototype.testn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return false;
        var u = this.words[h];
        return !!(u & s);
      }, f2.prototype.imaskn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= h)
          return this;
        if (a !== 0 && h++, this.length = Math.min(h, this.length), a !== 0) {
          var s = 67108863 ^ 67108863 >>> a << a;
          this.words[this.length - 1] &= s;
        }
        return this.strip();
      }, f2.prototype.maskn = function(i) {
        return this.clone().imaskn(i);
      }, f2.prototype.iaddn = function(i) {
        return r(typeof i == "number"), r(i < 67108864), i < 0 ? this.isubn(-i) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < i ? (this.words[0] = i - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(i), this.negative = 1, this) : this._iaddn(i);
      }, f2.prototype._iaddn = function(i) {
        this.words[0] += i;
        for (var a = 0;a < this.length && this.words[a] >= 67108864; a++)
          this.words[a] -= 67108864, a === this.length - 1 ? this.words[a + 1] = 1 : this.words[a + 1]++;
        return this.length = Math.max(this.length, a + 1), this;
      }, f2.prototype.isubn = function(i) {
        if (r(typeof i == "number"), r(i < 67108864), i < 0)
          return this.iaddn(-i);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(i), this.negative = 1, this;
        if (this.words[0] -= i, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var a = 0;a < this.length && this.words[a] < 0; a++)
            this.words[a] += 67108864, this.words[a + 1] -= 1;
        return this.strip();
      }, f2.prototype.addn = function(i) {
        return this.clone().iaddn(i);
      }, f2.prototype.subn = function(i) {
        return this.clone().isubn(i);
      }, f2.prototype.iabs = function() {
        return this.negative = 0, this;
      }, f2.prototype.abs = function() {
        return this.clone().iabs();
      }, f2.prototype._ishlnsubmul = function(i, a, h) {
        var s = i.length + h, u;
        this._expand(s);
        var c, b2 = 0;
        for (u = 0;u < i.length; u++) {
          c = (this.words[u + h] | 0) + b2;
          var l = (i.words[u] | 0) * a;
          c -= l & 67108863, b2 = (c >> 26) - (l / 67108864 | 0), this.words[u + h] = c & 67108863;
        }
        for (;u < this.length - h; u++)
          c = (this.words[u + h] | 0) + b2, b2 = c >> 26, this.words[u + h] = c & 67108863;
        if (b2 === 0)
          return this.strip();
        for (r(b2 === -1), b2 = 0, u = 0;u < this.length; u++)
          c = -(this.words[u] | 0) + b2, b2 = c >> 26, this.words[u] = c & 67108863;
        return this.negative = 1, this.strip();
      }, f2.prototype._wordDiv = function(i, a) {
        var h = this.length - i.length, s = this.clone(), u = i, c = u.words[u.length - 1] | 0, b2 = this._countBits(c);
        h = 26 - b2, h !== 0 && (u = u.ushln(h), s.iushln(h), c = u.words[u.length - 1] | 0);
        var l = s.length - u.length, n;
        if (a !== "mod") {
          n = new f2(null), n.length = l + 1, n.words = new Array(n.length);
          for (var d = 0;d < n.length; d++)
            n.words[d] = 0;
        }
        var w = s.clone()._ishlnsubmul(u, 1, l);
        w.negative === 0 && (s = w, n && (n.words[l] = 1));
        for (var g = l - 1;g >= 0; g--) {
          var _2 = (s.words[u.length + g] | 0) * 67108864 + (s.words[u.length + g - 1] | 0);
          for (_2 = Math.min(_2 / c | 0, 67108863), s._ishlnsubmul(u, _2, g);s.negative !== 0; )
            _2--, s.negative = 0, s._ishlnsubmul(u, 1, g), s.isZero() || (s.negative ^= 1);
          n && (n.words[g] = _2);
        }
        return n && n.strip(), s.strip(), a !== "div" && h !== 0 && s.iushrn(h), { div: n || null, mod: s };
      }, f2.prototype.divmod = function(i, a, h) {
        if (r(!i.isZero()), this.isZero())
          return { div: new f2(0), mod: new f2(0) };
        var s, u, c;
        return this.negative !== 0 && i.negative === 0 ? (c = this.neg().divmod(i, a), a !== "mod" && (s = c.div.neg()), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.iadd(i)), { div: s, mod: u }) : this.negative === 0 && i.negative !== 0 ? (c = this.divmod(i.neg(), a), a !== "mod" && (s = c.div.neg()), { div: s, mod: c.mod }) : (this.negative & i.negative) !== 0 ? (c = this.neg().divmod(i.neg(), a), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.isub(i)), { div: c.div, mod: u }) : i.length > this.length || this.cmp(i) < 0 ? { div: new f2(0), mod: this } : i.length === 1 ? a === "div" ? { div: this.divn(i.words[0]), mod: null } : a === "mod" ? { div: null, mod: new f2(this.modn(i.words[0])) } : { div: this.divn(i.words[0]), mod: new f2(this.modn(i.words[0])) } : this._wordDiv(i, a);
      }, f2.prototype.div = function(i) {
        return this.divmod(i, "div", false).div;
      }, f2.prototype.mod = function(i) {
        return this.divmod(i, "mod", false).mod;
      }, f2.prototype.umod = function(i) {
        return this.divmod(i, "mod", true).mod;
      }, f2.prototype.divRound = function(i) {
        var a = this.divmod(i);
        if (a.mod.isZero())
          return a.div;
        var h = a.div.negative !== 0 ? a.mod.isub(i) : a.mod, s = i.ushrn(1), u = i.andln(1), c = h.cmp(s);
        return c < 0 || u === 1 && c === 0 ? a.div : a.div.negative !== 0 ? a.div.isubn(1) : a.div.iaddn(1);
      }, f2.prototype.modn = function(i) {
        r(i <= 67108863);
        for (var a = (1 << 26) % i, h = 0, s = this.length - 1;s >= 0; s--)
          h = (a * h + (this.words[s] | 0)) % i;
        return h;
      }, f2.prototype.idivn = function(i) {
        r(i <= 67108863);
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = (this.words[h] | 0) + a * 67108864;
          this.words[h] = s / i | 0, a = s % i;
        }
        return this.strip();
      }, f2.prototype.divn = function(i) {
        return this.clone().idivn(i);
      }, f2.prototype.egcd = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f2(1), u = new f2(0), c = new f2(0), b2 = new f2(1), l = 0;a.isEven() && h.isEven(); )
          a.iushrn(1), h.iushrn(1), ++l;
        for (var n = h.clone(), d = a.clone();!a.isZero(); ) {
          for (var w = 0, g = 1;(a.words[0] & g) === 0 && w < 26; ++w, g <<= 1)
            ;
          if (w > 0)
            for (a.iushrn(w);w-- > 0; )
              (s.isOdd() || u.isOdd()) && (s.iadd(n), u.isub(d)), s.iushrn(1), u.iushrn(1);
          for (var _2 = 0, A = 1;(h.words[0] & A) === 0 && _2 < 26; ++_2, A <<= 1)
            ;
          if (_2 > 0)
            for (h.iushrn(_2);_2-- > 0; )
              (c.isOdd() || b2.isOdd()) && (c.iadd(n), b2.isub(d)), c.iushrn(1), b2.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(c), u.isub(b2)) : (h.isub(a), c.isub(s), b2.isub(u));
        }
        return { a: c, b: b2, gcd: h.iushln(l) };
      }, f2.prototype._invmp = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f2(1), u = new f2(0), c = h.clone();a.cmpn(1) > 0 && h.cmpn(1) > 0; ) {
          for (var b2 = 0, l = 1;(a.words[0] & l) === 0 && b2 < 26; ++b2, l <<= 1)
            ;
          if (b2 > 0)
            for (a.iushrn(b2);b2-- > 0; )
              s.isOdd() && s.iadd(c), s.iushrn(1);
          for (var n = 0, d = 1;(h.words[0] & d) === 0 && n < 26; ++n, d <<= 1)
            ;
          if (n > 0)
            for (h.iushrn(n);n-- > 0; )
              u.isOdd() && u.iadd(c), u.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(u)) : (h.isub(a), u.isub(s));
        }
        var w;
        return a.cmpn(1) === 0 ? w = s : w = u, w.cmpn(0) < 0 && w.iadd(i), w;
      }, f2.prototype.gcd = function(i) {
        if (this.isZero())
          return i.abs();
        if (i.isZero())
          return this.abs();
        var a = this.clone(), h = i.clone();
        a.negative = 0, h.negative = 0;
        for (var s = 0;a.isEven() && h.isEven(); s++)
          a.iushrn(1), h.iushrn(1);
        do {
          for (;a.isEven(); )
            a.iushrn(1);
          for (;h.isEven(); )
            h.iushrn(1);
          var u = a.cmp(h);
          if (u < 0) {
            var c = a;
            a = h, h = c;
          } else if (u === 0 || h.cmpn(1) === 0)
            break;
          a.isub(h);
        } while (true);
        return h.iushln(s);
      }, f2.prototype.invm = function(i) {
        return this.egcd(i).a.umod(i);
      }, f2.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, f2.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, f2.prototype.andln = function(i) {
        return this.words[0] & i;
      }, f2.prototype.bincn = function(i) {
        r(typeof i == "number");
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return this._expand(h + 1), this.words[h] |= s, this;
        for (var u = s, c = h;u !== 0 && c < this.length; c++) {
          var b2 = this.words[c] | 0;
          b2 += u, u = b2 >>> 26, b2 &= 67108863, this.words[c] = b2;
        }
        return u !== 0 && (this.words[c] = u, this.length++), this;
      }, f2.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, f2.prototype.cmpn = function(i) {
        var a = i < 0;
        if (this.negative !== 0 && !a)
          return -1;
        if (this.negative === 0 && a)
          return 1;
        this.strip();
        var h;
        if (this.length > 1)
          h = 1;
        else {
          a && (i = -i), r(i <= 67108863, "Number is too big");
          var s = this.words[0] | 0;
          h = s === i ? 0 : s < i ? -1 : 1;
        }
        return this.negative !== 0 ? -h | 0 : h;
      }, f2.prototype.cmp = function(i) {
        if (this.negative !== 0 && i.negative === 0)
          return -1;
        if (this.negative === 0 && i.negative !== 0)
          return 1;
        var a = this.ucmp(i);
        return this.negative !== 0 ? -a | 0 : a;
      }, f2.prototype.ucmp = function(i) {
        if (this.length > i.length)
          return 1;
        if (this.length < i.length)
          return -1;
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = this.words[h] | 0, u = i.words[h] | 0;
          if (s !== u) {
            s < u ? a = -1 : s > u && (a = 1);
            break;
          }
        }
        return a;
      }, f2.prototype.gtn = function(i) {
        return this.cmpn(i) === 1;
      }, f2.prototype.gt = function(i) {
        return this.cmp(i) === 1;
      }, f2.prototype.gten = function(i) {
        return this.cmpn(i) >= 0;
      }, f2.prototype.gte = function(i) {
        return this.cmp(i) >= 0;
      }, f2.prototype.ltn = function(i) {
        return this.cmpn(i) === -1;
      }, f2.prototype.lt = function(i) {
        return this.cmp(i) === -1;
      }, f2.prototype.lten = function(i) {
        return this.cmpn(i) <= 0;
      }, f2.prototype.lte = function(i) {
        return this.cmp(i) <= 0;
      }, f2.prototype.eqn = function(i) {
        return this.cmpn(i) === 0;
      }, f2.prototype.eq = function(i) {
        return this.cmp(i) === 0;
      }, f2.red = function(i) {
        return new D2(i);
      }, f2.prototype.toRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), i.convertTo(this)._forceRed(i);
      }, f2.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, f2.prototype._forceRed = function(i) {
        return this.red = i, this;
      }, f2.prototype.forceRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(i);
      }, f2.prototype.redAdd = function(i) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, i);
      }, f2.prototype.redIAdd = function(i) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, i);
      }, f2.prototype.redSub = function(i) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, i);
      }, f2.prototype.redISub = function(i) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, i);
      }, f2.prototype.redShl = function(i) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, i);
      }, f2.prototype.redMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.mul(this, i);
      }, f2.prototype.redIMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.imul(this, i);
      }, f2.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, f2.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, f2.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, f2.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, f2.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, f2.prototype.redPow = function(i) {
        return r(this.red && !i.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, i);
      };
      var Me = { k256: null, p224: null, p192: null, p25519: null };
      function me(v2, i) {
        this.name = v2, this.p = new f2(i, 16), this.n = this.p.bitLength(), this.k = new f2(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      me.prototype._tmp = function() {
        var i = new f2(null);
        return i.words = new Array(Math.ceil(this.n / 13)), i;
      }, me.prototype.ireduce = function(i) {
        var a = i, h;
        do
          this.split(a, this.tmp), a = this.imulK(a), a = a.iadd(this.tmp), h = a.bitLength();
        while (h > this.n);
        var s = h < this.n ? -1 : a.ucmp(this.p);
        return s === 0 ? (a.words[0] = 0, a.length = 1) : s > 0 ? a.isub(this.p) : a.strip !== undefined ? a.strip() : a._strip(), a;
      }, me.prototype.split = function(i, a) {
        i.iushrn(this.n, 0, a);
      }, me.prototype.imulK = function(i) {
        return i.imul(this.k);
      };
      function xe() {
        me.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      o(xe, me), xe.prototype.split = function(i, a) {
        for (var h = 4194303, s = Math.min(i.length, 9), u = 0;u < s; u++)
          a.words[u] = i.words[u];
        if (a.length = s, i.length <= 9) {
          i.words[0] = 0, i.length = 1;
          return;
        }
        var c = i.words[9];
        for (a.words[a.length++] = c & h, u = 10;u < i.length; u++) {
          var b2 = i.words[u] | 0;
          i.words[u - 10] = (b2 & h) << 4 | c >>> 22, c = b2;
        }
        c >>>= 22, i.words[u - 10] = c, c === 0 && i.length > 10 ? i.length -= 10 : i.length -= 9;
      }, xe.prototype.imulK = function(i) {
        i.words[i.length] = 0, i.words[i.length + 1] = 0, i.length += 2;
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = i.words[h] | 0;
          a += s * 977, i.words[h] = a & 67108863, a = s * 64 + (a / 67108864 | 0);
        }
        return i.words[i.length - 1] === 0 && (i.length--, i.words[i.length - 1] === 0 && i.length--), i;
      };
      function Ae() {
        me.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      o(Ae, me);
      function Ee() {
        me.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      o(Ee, me);
      function Re() {
        me.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      o(Re, me), Re.prototype.imulK = function(i) {
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = (i.words[h] | 0) * 19 + a, u = s & 67108863;
          s >>>= 26, i.words[h] = u, a = s;
        }
        return a !== 0 && (i.words[i.length++] = a), i;
      }, f2._prime = function(i) {
        if (Me[i])
          return Me[i];
        var a;
        if (i === "k256")
          a = new xe;
        else if (i === "p224")
          a = new Ae;
        else if (i === "p192")
          a = new Ee;
        else if (i === "p25519")
          a = new Re;
        else
          throw new Error("Unknown prime " + i);
        return Me[i] = a, a;
      };
      function D2(v2) {
        if (typeof v2 == "string") {
          var i = f2._prime(v2);
          this.m = i.p, this.prime = i;
        } else
          r(v2.gtn(1), "modulus must be greater than 1"), this.m = v2, this.prime = null;
      }
      D2.prototype._verify1 = function(i) {
        r(i.negative === 0, "red works only with positives"), r(i.red, "red works only with red numbers");
      }, D2.prototype._verify2 = function(i, a) {
        r((i.negative | a.negative) === 0, "red works only with positives"), r(i.red && i.red === a.red, "red works only with red numbers");
      }, D2.prototype.imod = function(i) {
        return this.prime ? this.prime.ireduce(i)._forceRed(this) : i.umod(this.m)._forceRed(this);
      }, D2.prototype.neg = function(i) {
        return i.isZero() ? i.clone() : this.m.sub(i)._forceRed(this);
      }, D2.prototype.add = function(i, a) {
        this._verify2(i, a);
        var h = i.add(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h._forceRed(this);
      }, D2.prototype.iadd = function(i, a) {
        this._verify2(i, a);
        var h = i.iadd(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h;
      }, D2.prototype.sub = function(i, a) {
        this._verify2(i, a);
        var h = i.sub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h._forceRed(this);
      }, D2.prototype.isub = function(i, a) {
        this._verify2(i, a);
        var h = i.isub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h;
      }, D2.prototype.shl = function(i, a) {
        return this._verify1(i), this.imod(i.ushln(a));
      }, D2.prototype.imul = function(i, a) {
        return this._verify2(i, a), this.imod(i.imul(a));
      }, D2.prototype.mul = function(i, a) {
        return this._verify2(i, a), this.imod(i.mul(a));
      }, D2.prototype.isqr = function(i) {
        return this.imul(i, i.clone());
      }, D2.prototype.sqr = function(i) {
        return this.mul(i, i);
      }, D2.prototype.sqrt = function(i) {
        if (i.isZero())
          return i.clone();
        var a = this.m.andln(3);
        if (r(a % 2 === 1), a === 3) {
          var h = this.m.add(new f2(1)).iushrn(2);
          return this.pow(i, h);
        }
        for (var s = this.m.subn(1), u = 0;!s.isZero() && s.andln(1) === 0; )
          u++, s.iushrn(1);
        r(!s.isZero());
        var c = new f2(1).toRed(this), b2 = c.redNeg(), l = this.m.subn(1).iushrn(1), n = this.m.bitLength();
        for (n = new f2(2 * n * n).toRed(this);this.pow(n, l).cmp(b2) !== 0; )
          n.redIAdd(b2);
        for (var d = this.pow(n, s), w = this.pow(i, s.addn(1).iushrn(1)), g = this.pow(i, s), _2 = u;g.cmp(c) !== 0; ) {
          for (var A = g, B = 0;A.cmp(c) !== 0; B++)
            A = A.redSqr();
          r(B < _2);
          var I = this.pow(d, new f2(1).iushln(_2 - B - 1));
          w = w.redMul(I), d = I.redSqr(), g = g.redMul(d), _2 = B;
        }
        return w;
      }, D2.prototype.invm = function(i) {
        var a = i._invmp(this.m);
        return a.negative !== 0 ? (a.negative = 0, this.imod(a).redNeg()) : this.imod(a);
      }, D2.prototype.pow = function(i, a) {
        if (a.isZero())
          return new f2(1).toRed(this);
        if (a.cmpn(1) === 0)
          return i.clone();
        var h = 4, s = new Array(1 << h);
        s[0] = new f2(1).toRed(this), s[1] = i;
        for (var u = 2;u < s.length; u++)
          s[u] = this.mul(s[u - 1], i);
        var c = s[0], b2 = 0, l = 0, n = a.bitLength() % 26;
        for (n === 0 && (n = 26), u = a.length - 1;u >= 0; u--) {
          for (var d = a.words[u], w = n - 1;w >= 0; w--) {
            var g = d >> w & 1;
            if (c !== s[0] && (c = this.sqr(c)), g === 0 && b2 === 0) {
              l = 0;
              continue;
            }
            b2 <<= 1, b2 |= g, l++, !(l !== h && (u !== 0 || w !== 0)) && (c = this.mul(c, s[b2]), l = 0, b2 = 0);
          }
          n = 26;
        }
        return c;
      }, D2.prototype.convertTo = function(i) {
        var a = i.umod(this.m);
        return a === i ? a.clone() : a;
      }, D2.prototype.convertFrom = function(i) {
        var a = i.clone();
        return a.red = null, a;
      }, f2.mont = function(i) {
        return new Se(i);
      };
      function Se(v2) {
        D2.call(this, v2), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f2(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o(Se, D2), Se.prototype.convertTo = function(i) {
        return this.imod(i.ushln(this.shift));
      }, Se.prototype.convertFrom = function(i) {
        var a = this.imod(i.mul(this.rinv));
        return a.red = null, a;
      }, Se.prototype.imul = function(i, a) {
        if (i.isZero() || a.isZero())
          return i.words[0] = 0, i.length = 1, i;
        var h = i.imul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se.prototype.mul = function(i, a) {
        if (i.isZero() || a.isZero())
          return new f2(0)._forceRed(this);
        var h = i.mul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se.prototype.invm = function(i) {
        var a = this.imod(i._invmp(this.m).mul(this.r2));
        return a._forceRed(this);
      };
    })(typeof md > "u" || md, fw);
  });
  p0 = k((HL, aw) => {
    var c0 = Ut(), Hf = c0.Buffer, Ar = {}, Rr;
    for (Rr in c0)
      !c0.hasOwnProperty(Rr) || Rr === "SlowBuffer" || Rr === "Buffer" || (Ar[Rr] = c0[Rr]);
    var Wf = Ar.Buffer = {};
    for (Rr in Hf)
      !Hf.hasOwnProperty(Rr) || Rr === "allocUnsafe" || Rr === "allocUnsafeSlow" || (Wf[Rr] = Hf[Rr]);
    Ar.Buffer.prototype = Hf.prototype;
    (!Wf.from || Wf.from === Uint8Array.from) && (Wf.from = function(t, e, r) {
      if (typeof t == "number")
        throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof t);
      if (t && typeof t.length > "u")
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t);
      return Hf(t, e, r);
    });
    Wf.alloc || (Wf.alloc = function(t, e, r) {
      if (typeof t != "number")
        throw new TypeError('The "size" argument must be of type number. Received type ' + typeof t);
      if (t < 0 || t >= 2 * (1 << 30))
        throw new RangeError('The value "' + t + '" is invalid for option "size"');
      var o = Hf(t);
      return !e || e.length === 0 ? o.fill(0) : typeof r == "string" ? o.fill(e, r) : o.fill(e), o;
    });
    if (!Ar.kStringMaxLength)
      try {
        Ar.kStringMaxLength = process.binding("buffer").kStringMaxLength;
      } catch {
      }
    Ar.constants || (Ar.constants = { MAX_LENGTH: Ar.kMaxLength }, Ar.kStringMaxLength && (Ar.constants.MAX_STRING_LENGTH = Ar.kStringMaxLength));
    aw.exports = Ar;
  });
  v0 = k((ow) => {
    var JB = Ie();
    function Br(t) {
      this._reporterState = { obj: null, path: [], options: t || {}, errors: [] };
    }
    ow.Reporter = Br;
    Br.prototype.isError = function(e) {
      return e instanceof Kf;
    };
    Br.prototype.save = function() {
      let e = this._reporterState;
      return { obj: e.obj, pathLen: e.path.length };
    };
    Br.prototype.restore = function(e) {
      let r = this._reporterState;
      r.obj = e.obj, r.path = r.path.slice(0, e.pathLen);
    };
    Br.prototype.enterKey = function(e) {
      return this._reporterState.path.push(e);
    };
    Br.prototype.exitKey = function(e) {
      let r = this._reporterState;
      r.path = r.path.slice(0, e - 1);
    };
    Br.prototype.leaveKey = function(e, r, o) {
      let f2 = this._reporterState;
      this.exitKey(e), f2.obj !== null && (f2.obj[r] = o);
    };
    Br.prototype.path = function() {
      return this._reporterState.path.join("/");
    };
    Br.prototype.enterObject = function() {
      let e = this._reporterState, r = e.obj;
      return e.obj = {}, r;
    };
    Br.prototype.leaveObject = function(e) {
      let r = this._reporterState, o = r.obj;
      return r.obj = e, o;
    };
    Br.prototype.error = function(e) {
      let r, o = this._reporterState, f2 = e instanceof Kf;
      if (f2 ? r = e : r = new Kf(o.path.map(function(p) {
        return "[" + JSON.stringify(p) + "]";
      }).join(""), e.message || e, e.stack), !o.options.partial)
        throw r;
      return f2 || o.errors.push(r), r;
    };
    Br.prototype.wrapResult = function(e) {
      let r = this._reporterState;
      return r.options.partial ? { result: this.isError(e) ? null : e, errors: r.errors } : e;
    };
    function Kf(t, e) {
      this.path = t, this.rethrow(e);
    }
    JB(Kf, Error);
    Kf.prototype.rethrow = function(e) {
      if (this.message = e + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, Kf), !this.stack)
        try {
          throw new Error(this.message);
        } catch (r) {
          this.stack = r.stack;
        }
      return this;
    };
  });
  Vf = k((yd) => {
    var QB = Ie(), b0 = v0().Reporter, jf = p0().Buffer;
    function qr(t, e) {
      if (b0.call(this, e), !jf.isBuffer(t)) {
        this.error("Input not Buffer");
        return;
      }
      this.base = t, this.offset = 0, this.length = t.length;
    }
    QB(qr, b0);
    yd.DecoderBuffer = qr;
    qr.isDecoderBuffer = function(e) {
      return e instanceof qr ? true : typeof e == "object" && jf.isBuffer(e.base) && e.constructor.name === "DecoderBuffer" && typeof e.offset == "number" && typeof e.length == "number" && typeof e.save == "function" && typeof e.restore == "function" && typeof e.isEmpty == "function" && typeof e.readUInt8 == "function" && typeof e.skip == "function" && typeof e.raw == "function";
    };
    qr.prototype.save = function() {
      return { offset: this.offset, reporter: b0.prototype.save.call(this) };
    };
    qr.prototype.restore = function(e) {
      let r = new qr(this.base);
      return r.offset = e.offset, r.length = this.offset, this.offset = e.offset, b0.prototype.restore.call(this, e.reporter), r;
    };
    qr.prototype.isEmpty = function() {
      return this.offset === this.length;
    };
    qr.prototype.readUInt8 = function(e) {
      return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, true) : this.error(e || "DecoderBuffer overrun");
    };
    qr.prototype.skip = function(e, r) {
      if (!(this.offset + e <= this.length))
        return this.error(r || "DecoderBuffer overrun");
      let o = new qr(this.base);
      return o._reporterState = this._reporterState, o.offset = this.offset, o.length = this.offset + e, this.offset += e, o;
    };
    qr.prototype.raw = function(e) {
      return this.base.slice(e ? e.offset : this.offset, this.length);
    };
    function Zf(t, e) {
      if (Array.isArray(t))
        this.length = 0, this.value = t.map(function(r) {
          return Zf.isEncoderBuffer(r) || (r = new Zf(r, e)), this.length += r.length, r;
        }, this);
      else if (typeof t == "number") {
        if (!(0 <= t && t <= 255))
          return e.error("non-byte EncoderBuffer value");
        this.value = t, this.length = 1;
      } else if (typeof t == "string")
        this.value = t, this.length = jf.byteLength(t);
      else if (jf.isBuffer(t))
        this.value = t, this.length = t.length;
      else
        return e.error("Unsupported type: " + typeof t);
    }
    yd.EncoderBuffer = Zf;
    Zf.isEncoderBuffer = function(e) {
      return e instanceof Zf ? true : typeof e == "object" && e.constructor.name === "EncoderBuffer" && typeof e.length == "number" && typeof e.join == "function";
    };
    Zf.prototype.join = function(e, r) {
      return e || (e = jf.alloc(this.length)), r || (r = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(o) {
        o.join(e, r), r += o.length;
      }) : (typeof this.value == "number" ? e[r] = this.value : typeof this.value == "string" ? e.write(this.value, r) : jf.isBuffer(this.value) && this.value.copy(e, r), r += this.length)), e;
    };
  });
  m0 = k((jL, hw) => {
    var eq = v0().Reporter, tq = Vf().EncoderBuffer, rq = Vf().DecoderBuffer, er = ar(), sw = ["seq", "seqof", "set", "setof", "objid", "bool", "gentime", "utctime", "null_", "enum", "int", "objDesc", "bitstr", "bmpstr", "charstr", "genstr", "graphstr", "ia5str", "iso646str", "numstr", "octstr", "printstr", "t61str", "unistr", "utf8str", "videostr"], iq = ["key", "obj", "use", "optional", "explicit", "implicit", "def", "choice", "any", "contains"].concat(sw), nq = ["_peekTag", "_decodeTag", "_use", "_decodeStr", "_decodeObjid", "_decodeTime", "_decodeNull", "_decodeInt", "_decodeBool", "_decodeList", "_encodeComposite", "_encodeStr", "_encodeObjid", "_encodeTime", "_encodeNull", "_encodeInt", "_encodeBool"];
    function Ue(t, e, r) {
      let o = {};
      this._baseState = o, o.name = r, o.enc = t, o.parent = e || null, o.children = null, o.tag = null, o.args = null, o.reverseArgs = null, o.choice = null, o.optional = false, o.any = false, o.obj = false, o.use = null, o.useDecoder = null, o.key = null, o.default = null, o.explicit = null, o.implicit = null, o.contains = null, o.parent || (o.children = [], this._wrap());
    }
    hw.exports = Ue;
    var fq = ["enc", "parent", "children", "tag", "args", "reverseArgs", "choice", "optional", "any", "obj", "use", "alteredUse", "key", "default", "explicit", "implicit", "contains"];
    Ue.prototype.clone = function() {
      let e = this._baseState, r = {};
      fq.forEach(function(f2) {
        r[f2] = e[f2];
      });
      let o = new this.constructor(r.parent);
      return o._baseState = r, o;
    };
    Ue.prototype._wrap = function() {
      let e = this._baseState;
      iq.forEach(function(r) {
        this[r] = function() {
          let f2 = new this.constructor(this);
          return e.children.push(f2), f2[r].apply(f2, arguments);
        };
      }, this);
    };
    Ue.prototype._init = function(e) {
      let r = this._baseState;
      er(r.parent === null), e.call(this), r.children = r.children.filter(function(o) {
        return o._baseState.parent === this;
      }, this), er.equal(r.children.length, 1, "Root node can have only one child");
    };
    Ue.prototype._useArgs = function(e) {
      let r = this._baseState, o = e.filter(function(f2) {
        return f2 instanceof this.constructor;
      }, this);
      e = e.filter(function(f2) {
        return !(f2 instanceof this.constructor);
      }, this), o.length !== 0 && (er(r.children === null), r.children = o, o.forEach(function(f2) {
        f2._baseState.parent = this;
      }, this)), e.length !== 0 && (er(r.args === null), r.args = e, r.reverseArgs = e.map(function(f2) {
        if (typeof f2 != "object" || f2.constructor !== Object)
          return f2;
        let p = {};
        return Object.keys(f2).forEach(function(m) {
          m == (m | 0) && (m |= 0);
          let y = f2[m];
          p[y] = m;
        }), p;
      }));
    };
    nq.forEach(function(t) {
      Ue.prototype[t] = function() {
        let r = this._baseState;
        throw new Error(t + " not implemented for encoding: " + r.enc);
      };
    });
    sw.forEach(function(t) {
      Ue.prototype[t] = function() {
        let r = this._baseState, o = Array.prototype.slice.call(arguments);
        return er(r.tag === null), r.tag = t, this._useArgs(o), this;
      };
    });
    Ue.prototype.use = function(e) {
      er(e);
      let r = this._baseState;
      return er(r.use === null), r.use = e, this;
    };
    Ue.prototype.optional = function() {
      let e = this._baseState;
      return e.optional = true, this;
    };
    Ue.prototype.def = function(e) {
      let r = this._baseState;
      return er(r.default === null), r.default = e, r.optional = true, this;
    };
    Ue.prototype.explicit = function(e) {
      let r = this._baseState;
      return er(r.explicit === null && r.implicit === null), r.explicit = e, this;
    };
    Ue.prototype.implicit = function(e) {
      let r = this._baseState;
      return er(r.explicit === null && r.implicit === null), r.implicit = e, this;
    };
    Ue.prototype.obj = function() {
      let e = this._baseState, r = Array.prototype.slice.call(arguments);
      return e.obj = true, r.length !== 0 && this._useArgs(r), this;
    };
    Ue.prototype.key = function(e) {
      let r = this._baseState;
      return er(r.key === null), r.key = e, this;
    };
    Ue.prototype.any = function() {
      let e = this._baseState;
      return e.any = true, this;
    };
    Ue.prototype.choice = function(e) {
      let r = this._baseState;
      return er(r.choice === null), r.choice = e, this._useArgs(Object.keys(e).map(function(o) {
        return e[o];
      })), this;
    };
    Ue.prototype.contains = function(e) {
      let r = this._baseState;
      return er(r.use === null), r.contains = e, this;
    };
    Ue.prototype._decode = function(e, r) {
      let o = this._baseState;
      if (o.parent === null)
        return e.wrapResult(o.children[0]._decode(e, r));
      let f2 = o.default, p = true, m = null;
      if (o.key !== null && (m = e.enterKey(o.key)), o.optional) {
        let M = null;
        if (o.explicit !== null ? M = o.explicit : o.implicit !== null ? M = o.implicit : o.tag !== null && (M = o.tag), M === null && !o.any) {
          let x = e.save();
          try {
            o.choice === null ? this._decodeGeneric(o.tag, e, r) : this._decodeChoice(e, r), p = true;
          } catch {
            p = false;
          }
          e.restore(x);
        } else if (p = this._peekTag(e, M, o.any), e.isError(p))
          return p;
      }
      let y;
      if (o.obj && p && (y = e.enterObject()), p) {
        if (o.explicit !== null) {
          let x = this._decodeTag(e, o.explicit);
          if (e.isError(x))
            return x;
          e = x;
        }
        let M = e.offset;
        if (o.use === null && o.choice === null) {
          let x;
          o.any && (x = e.save());
          let S2 = this._decodeTag(e, o.implicit !== null ? o.implicit : o.tag, o.any);
          if (e.isError(S2))
            return S2;
          o.any ? f2 = e.raw(x) : e = S2;
        }
        if (r && r.track && o.tag !== null && r.track(e.path(), M, e.length, "tagged"), r && r.track && o.tag !== null && r.track(e.path(), e.offset, e.length, "content"), o.any || (o.choice === null ? f2 = this._decodeGeneric(o.tag, e, r) : f2 = this._decodeChoice(e, r)), e.isError(f2))
          return f2;
        if (!o.any && o.choice === null && o.children !== null && o.children.forEach(function(S2) {
          S2._decode(e, r);
        }), o.contains && (o.tag === "octstr" || o.tag === "bitstr")) {
          let x = new rq(f2);
          f2 = this._getUse(o.contains, e._reporterState.obj)._decode(x, r);
        }
      }
      return o.obj && p && (f2 = e.leaveObject(y)), o.key !== null && (f2 !== null || p === true) ? e.leaveKey(m, o.key, f2) : m !== null && e.exitKey(m), f2;
    };
    Ue.prototype._decodeGeneric = function(e, r, o) {
      let f2 = this._baseState;
      return e === "seq" || e === "set" ? null : e === "seqof" || e === "setof" ? this._decodeList(r, e, f2.args[0], o) : /str$/.test(e) ? this._decodeStr(r, e, o) : e === "objid" && f2.args ? this._decodeObjid(r, f2.args[0], f2.args[1], o) : e === "objid" ? this._decodeObjid(r, null, null, o) : e === "gentime" || e === "utctime" ? this._decodeTime(r, e, o) : e === "null_" ? this._decodeNull(r, o) : e === "bool" ? this._decodeBool(r, o) : e === "objDesc" ? this._decodeStr(r, e, o) : e === "int" || e === "enum" ? this._decodeInt(r, f2.args && f2.args[0], o) : f2.use !== null ? this._getUse(f2.use, r._reporterState.obj)._decode(r, o) : r.error("unknown tag: " + e);
    };
    Ue.prototype._getUse = function(e, r) {
      let o = this._baseState;
      return o.useDecoder = this._use(e, r), er(o.useDecoder._baseState.parent === null), o.useDecoder = o.useDecoder._baseState.children[0], o.implicit !== o.useDecoder._baseState.implicit && (o.useDecoder = o.useDecoder.clone(), o.useDecoder._baseState.implicit = o.implicit), o.useDecoder;
    };
    Ue.prototype._decodeChoice = function(e, r) {
      let o = this._baseState, f2 = null, p = false;
      return Object.keys(o.choice).some(function(m) {
        let y = e.save(), M = o.choice[m];
        try {
          let x = M._decode(e, r);
          if (e.isError(x))
            return false;
          f2 = { type: m, value: x }, p = true;
        } catch {
          return e.restore(y), false;
        }
        return true;
      }, this), p ? f2 : e.error("Choice not matched");
    };
    Ue.prototype._createEncoderBuffer = function(e) {
      return new tq(e, this.reporter);
    };
    Ue.prototype._encode = function(e, r, o) {
      let f2 = this._baseState;
      if (f2.default !== null && f2.default === e)
        return;
      let p = this._encodeValue(e, r, o);
      if (p !== undefined && !this._skipDefault(p, r, o))
        return p;
    };
    Ue.prototype._encodeValue = function(e, r, o) {
      let f2 = this._baseState;
      if (f2.parent === null)
        return f2.children[0]._encode(e, r || new eq);
      let p = null;
      if (this.reporter = r, f2.optional && e === undefined)
        if (f2.default !== null)
          e = f2.default;
        else
          return;
      let m = null, y = false;
      if (f2.any)
        p = this._createEncoderBuffer(e);
      else if (f2.choice)
        p = this._encodeChoice(e, r);
      else if (f2.contains)
        m = this._getUse(f2.contains, o)._encode(e, r), y = true;
      else if (f2.children)
        m = f2.children.map(function(M) {
          if (M._baseState.tag === "null_")
            return M._encode(null, r, e);
          if (M._baseState.key === null)
            return r.error("Child should have a key");
          let x = r.enterKey(M._baseState.key);
          if (typeof e != "object")
            return r.error("Child expected, but input is not object");
          let S2 = M._encode(e[M._baseState.key], r, e);
          return r.leaveKey(x), S2;
        }, this).filter(function(M) {
          return M;
        }), m = this._createEncoderBuffer(m);
      else if (f2.tag === "seqof" || f2.tag === "setof") {
        if (!(f2.args && f2.args.length === 1))
          return r.error("Too many args for : " + f2.tag);
        if (!Array.isArray(e))
          return r.error("seqof/setof, but data is not Array");
        let M = this.clone();
        M._baseState.implicit = null, m = this._createEncoderBuffer(e.map(function(x) {
          let S2 = this._baseState;
          return this._getUse(S2.args[0], e)._encode(x, r);
        }, M));
      } else
        f2.use !== null ? p = this._getUse(f2.use, o)._encode(e, r) : (m = this._encodePrimitive(f2.tag, e), y = true);
      if (!f2.any && f2.choice === null) {
        let M = f2.implicit !== null ? f2.implicit : f2.tag, x = f2.implicit === null ? "universal" : "context";
        M === null ? f2.use === null && r.error("Tag could be omitted only for .use()") : f2.use === null && (p = this._encodeComposite(M, y, x, m));
      }
      return f2.explicit !== null && (p = this._encodeComposite(f2.explicit, false, "context", p)), p;
    };
    Ue.prototype._encodeChoice = function(e, r) {
      let o = this._baseState, f2 = o.choice[e.type];
      return f2 || er(false, e.type + " not found in " + JSON.stringify(Object.keys(o.choice))), f2._encode(e.value, r);
    };
    Ue.prototype._encodePrimitive = function(e, r) {
      let o = this._baseState;
      if (/str$/.test(e))
        return this._encodeStr(r, e);
      if (e === "objid" && o.args)
        return this._encodeObjid(r, o.reverseArgs[0], o.args[1]);
      if (e === "objid")
        return this._encodeObjid(r, null, null);
      if (e === "gentime" || e === "utctime")
        return this._encodeTime(r, e);
      if (e === "null_")
        return this._encodeNull();
      if (e === "int" || e === "enum")
        return this._encodeInt(r, o.args && o.reverseArgs[0]);
      if (e === "bool")
        return this._encodeBool(r);
      if (e === "objDesc")
        return this._encodeStr(r, e);
      throw new Error("Unsupported tag: " + e);
    };
    Ue.prototype._isNumstr = function(e) {
      return /^[0-9 ]*$/.test(e);
    };
    Ue.prototype._isPrintstr = function(e) {
      return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(e);
    };
  });
  g0 = k(($n) => {
    function uw(t) {
      let e = {};
      return Object.keys(t).forEach(function(r) {
        (r | 0) == r && (r = r | 0);
        let o = t[r];
        e[o] = r;
      }), e;
    }
    $n.tagClass = { 0: "universal", 1: "application", 2: "context", 3: "private" };
    $n.tagClassByName = uw($n.tagClass);
    $n.tag = { 0: "end", 1: "bool", 2: "int", 3: "bitstr", 4: "octstr", 5: "null_", 6: "objid", 7: "objDesc", 8: "external", 9: "real", 10: "enum", 11: "embed", 12: "utf8str", 13: "relativeOid", 16: "seq", 17: "set", 18: "numstr", 19: "printstr", 20: "t61str", 21: "videostr", 22: "ia5str", 23: "utctime", 24: "gentime", 25: "graphstr", 26: "iso646str", 27: "genstr", 28: "unistr", 29: "charstr", 30: "bmpstr" };
    $n.tagByName = uw($n.tag);
  });
  Md = k((VL, cw) => {
    var aq = Ie(), Ni = p0().Buffer, lw2 = m0(), wd = g0();
    function dw(t) {
      this.enc = "der", this.name = t.name, this.entity = t, this.tree = new Ur, this.tree._init(t.body);
    }
    cw.exports = dw;
    dw.prototype.encode = function(e, r) {
      return this.tree._encode(e, r).join();
    };
    function Ur(t) {
      lw2.call(this, "der", t);
    }
    aq(Ur, lw2);
    Ur.prototype._encodeComposite = function(e, r, o, f2) {
      let p = oq(e, r, o, this.reporter);
      if (f2.length < 128) {
        let M = Ni.alloc(2);
        return M[0] = p, M[1] = f2.length, this._createEncoderBuffer([M, f2]);
      }
      let m = 1;
      for (let M = f2.length;M >= 256; M >>= 8)
        m++;
      let y = Ni.alloc(1 + 1 + m);
      y[0] = p, y[1] = 128 | m;
      for (let M = 1 + m, x = f2.length;x > 0; M--, x >>= 8)
        y[M] = x & 255;
      return this._createEncoderBuffer([y, f2]);
    };
    Ur.prototype._encodeStr = function(e, r) {
      if (r === "bitstr")
        return this._createEncoderBuffer([e.unused | 0, e.data]);
      if (r === "bmpstr") {
        let o = Ni.alloc(e.length * 2);
        for (let f2 = 0;f2 < e.length; f2++)
          o.writeUInt16BE(e.charCodeAt(f2), f2 * 2);
        return this._createEncoderBuffer(o);
      } else
        return r === "numstr" ? this._isNumstr(e) ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : r === "printstr" ? this._isPrintstr(e) ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(r) ? this._createEncoderBuffer(e) : r === "objDesc" ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: " + r + " unsupported");
    };
    Ur.prototype._encodeObjid = function(e, r, o) {
      if (typeof e == "string") {
        if (!r)
          return this.reporter.error("string objid given, but no values map found");
        if (!r.hasOwnProperty(e))
          return this.reporter.error("objid not found in values map");
        e = r[e].split(/[\s.]+/g);
        for (let y = 0;y < e.length; y++)
          e[y] |= 0;
      } else if (Array.isArray(e)) {
        e = e.slice();
        for (let y = 0;y < e.length; y++)
          e[y] |= 0;
      }
      if (!Array.isArray(e))
        return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(e));
      if (!o) {
        if (e[1] >= 40)
          return this.reporter.error("Second objid identifier OOB");
        e.splice(0, 2, e[0] * 40 + e[1]);
      }
      let f2 = 0;
      for (let y = 0;y < e.length; y++) {
        let M = e[y];
        for (f2++;M >= 128; M >>= 7)
          f2++;
      }
      let p = Ni.alloc(f2), m = p.length - 1;
      for (let y = e.length - 1;y >= 0; y--) {
        let M = e[y];
        for (p[m--] = M & 127;(M >>= 7) > 0; )
          p[m--] = 128 | M & 127;
      }
      return this._createEncoderBuffer(p);
    };
    function Ir2(t) {
      return t < 10 ? "0" + t : t;
    }
    Ur.prototype._encodeTime = function(e, r) {
      let o, f2 = new Date(e);
      return r === "gentime" ? o = [Ir2(f2.getUTCFullYear()), Ir2(f2.getUTCMonth() + 1), Ir2(f2.getUTCDate()), Ir2(f2.getUTCHours()), Ir2(f2.getUTCMinutes()), Ir2(f2.getUTCSeconds()), "Z"].join("") : r === "utctime" ? o = [Ir2(f2.getUTCFullYear() % 100), Ir2(f2.getUTCMonth() + 1), Ir2(f2.getUTCDate()), Ir2(f2.getUTCHours()), Ir2(f2.getUTCMinutes()), Ir2(f2.getUTCSeconds()), "Z"].join("") : this.reporter.error("Encoding " + r + " time is not supported yet"), this._encodeStr(o, "octstr");
    };
    Ur.prototype._encodeNull = function() {
      return this._createEncoderBuffer("");
    };
    Ur.prototype._encodeInt = function(e, r) {
      if (typeof e == "string") {
        if (!r)
          return this.reporter.error("String int or enum given, but no values map");
        if (!r.hasOwnProperty(e))
          return this.reporter.error("Values map doesn't contain: " + JSON.stringify(e));
        e = r[e];
      }
      if (typeof e != "number" && !Ni.isBuffer(e)) {
        let p = e.toArray();
        !e.sign && p[0] & 128 && p.unshift(0), e = Ni.from(p);
      }
      if (Ni.isBuffer(e)) {
        let p = e.length;
        e.length === 0 && p++;
        let m = Ni.alloc(p);
        return e.copy(m), e.length === 0 && (m[0] = 0), this._createEncoderBuffer(m);
      }
      if (e < 128)
        return this._createEncoderBuffer(e);
      if (e < 256)
        return this._createEncoderBuffer([0, e]);
      let o = 1;
      for (let p = e;p >= 256; p >>= 8)
        o++;
      let f2 = new Array(o);
      for (let p = f2.length - 1;p >= 0; p--)
        f2[p] = e & 255, e >>= 8;
      return f2[0] & 128 && f2.unshift(0), this._createEncoderBuffer(Ni.from(f2));
    };
    Ur.prototype._encodeBool = function(e) {
      return this._createEncoderBuffer(e ? 255 : 0);
    };
    Ur.prototype._use = function(e, r) {
      return typeof e == "function" && (e = e(r)), e._getEncoder("der").tree;
    };
    Ur.prototype._skipDefault = function(e, r, o) {
      let f2 = this._baseState, p;
      if (f2.default === null)
        return false;
      let m = e.join();
      if (f2.defaultBuffer === undefined && (f2.defaultBuffer = this._encodeValue(f2.default, r, o).join()), m.length !== f2.defaultBuffer.length)
        return false;
      for (p = 0;p < m.length; p++)
        if (m[p] !== f2.defaultBuffer[p])
          return false;
      return true;
    };
    function oq(t, e, r, o) {
      let f2;
      if (t === "seqof" ? t = "seq" : t === "setof" && (t = "set"), wd.tagByName.hasOwnProperty(t))
        f2 = wd.tagByName[t];
      else if (typeof t == "number" && (t | 0) === t)
        f2 = t;
      else
        return o.error("Unknown tag: " + t);
      return f2 >= 31 ? o.error("Multi-octet tag encoding unsupported") : (e || (f2 |= 32), f2 |= wd.tagClassByName[r || "universal"] << 6, f2);
    }
  });
  vw = k(($L, pw) => {
    var sq = Ie(), _d = Md();
    function xd(t) {
      _d.call(this, t), this.enc = "pem";
    }
    sq(xd, _d);
    pw.exports = xd;
    xd.prototype.encode = function(e, r) {
      let f2 = _d.prototype.encode.call(this, e).toString("base64"), p = ["-----BEGIN " + r.label + "-----"];
      for (let m = 0;m < f2.length; m += 64)
        p.push(f2.slice(m, m + 64));
      return p.push("-----END " + r.label + "-----"), p.join(`
`);
    };
  });
  Sd = k((mw) => {
    var bw = mw;
    bw.der = Md();
    bw.pem = vw();
  });
  Ad = k((YL, xw) => {
    var hq = Ie(), uq = gd(), gw = Vf().DecoderBuffer, ww = m0(), yw = g0();
    function Mw(t) {
      this.enc = "der", this.name = t.name, this.entity = t, this.tree = new sr, this.tree._init(t.body);
    }
    xw.exports = Mw;
    Mw.prototype.decode = function(e, r) {
      return gw.isDecoderBuffer(e) || (e = new gw(e, r)), this.tree._decode(e, r);
    };
    function sr(t) {
      ww.call(this, "der", t);
    }
    hq(sr, ww);
    sr.prototype._peekTag = function(e, r, o) {
      if (e.isEmpty())
        return false;
      let f2 = e.save(), p = Ed(e, 'Failed to peek tag: "' + r + '"');
      return e.isError(p) ? p : (e.restore(f2), p.tag === r || p.tagStr === r || p.tagStr + "of" === r || o);
    };
    sr.prototype._decodeTag = function(e, r, o) {
      let f2 = Ed(e, 'Failed to decode tag of "' + r + '"');
      if (e.isError(f2))
        return f2;
      let p = _w(e, f2.primitive, 'Failed to get length of "' + r + '"');
      if (e.isError(p))
        return p;
      if (!o && f2.tag !== r && f2.tagStr !== r && f2.tagStr + "of" !== r)
        return e.error('Failed to match tag: "' + r + '"');
      if (f2.primitive || p !== null)
        return e.skip(p, 'Failed to match body of: "' + r + '"');
      let m = e.save(), y = this._skipUntilEnd(e, 'Failed to skip indefinite length body: "' + this.tag + '"');
      return e.isError(y) ? y : (p = e.offset - m.offset, e.restore(m), e.skip(p, 'Failed to match body of: "' + r + '"'));
    };
    sr.prototype._skipUntilEnd = function(e, r) {
      for (;; ) {
        let o = Ed(e, r);
        if (e.isError(o))
          return o;
        let f2 = _w(e, o.primitive, r);
        if (e.isError(f2))
          return f2;
        let p;
        if (o.primitive || f2 !== null ? p = e.skip(f2) : p = this._skipUntilEnd(e, r), e.isError(p))
          return p;
        if (o.tagStr === "end")
          break;
      }
    };
    sr.prototype._decodeList = function(e, r, o, f2) {
      let p = [];
      for (;!e.isEmpty(); ) {
        let m = this._peekTag(e, "end");
        if (e.isError(m))
          return m;
        let y = o.decode(e, "der", f2);
        if (e.isError(y) && m)
          break;
        p.push(y);
      }
      return p;
    };
    sr.prototype._decodeStr = function(e, r) {
      if (r === "bitstr") {
        let o = e.readUInt8();
        return e.isError(o) ? o : { unused: o, data: e.raw() };
      } else if (r === "bmpstr") {
        let o = e.raw();
        if (o.length % 2 === 1)
          return e.error("Decoding of string type: bmpstr length mismatch");
        let f2 = "";
        for (let p = 0;p < o.length / 2; p++)
          f2 += String.fromCharCode(o.readUInt16BE(p * 2));
        return f2;
      } else if (r === "numstr") {
        let o = e.raw().toString("ascii");
        return this._isNumstr(o) ? o : e.error("Decoding of string type: numstr unsupported characters");
      } else {
        if (r === "octstr")
          return e.raw();
        if (r === "objDesc")
          return e.raw();
        if (r === "printstr") {
          let o = e.raw().toString("ascii");
          return this._isPrintstr(o) ? o : e.error("Decoding of string type: printstr unsupported characters");
        } else
          return /str$/.test(r) ? e.raw().toString() : e.error("Decoding of string type: " + r + " unsupported");
      }
    };
    sr.prototype._decodeObjid = function(e, r, o) {
      let f2, p = [], m = 0, y = 0;
      for (;!e.isEmpty(); )
        y = e.readUInt8(), m <<= 7, m |= y & 127, (y & 128) === 0 && (p.push(m), m = 0);
      y & 128 && p.push(m);
      let M = p[0] / 40 | 0, x = p[0] % 40;
      if (o ? f2 = p : f2 = [M, x].concat(p.slice(1)), r) {
        let S2 = r[f2.join(" ")];
        S2 === undefined && (S2 = r[f2.join(".")]), S2 !== undefined && (f2 = S2);
      }
      return f2;
    };
    sr.prototype._decodeTime = function(e, r) {
      let o = e.raw().toString(), f2, p, m, y, M, x;
      if (r === "gentime")
        f2 = o.slice(0, 4) | 0, p = o.slice(4, 6) | 0, m = o.slice(6, 8) | 0, y = o.slice(8, 10) | 0, M = o.slice(10, 12) | 0, x = o.slice(12, 14) | 0;
      else if (r === "utctime")
        f2 = o.slice(0, 2) | 0, p = o.slice(2, 4) | 0, m = o.slice(4, 6) | 0, y = o.slice(6, 8) | 0, M = o.slice(8, 10) | 0, x = o.slice(10, 12) | 0, f2 < 70 ? f2 = 2000 + f2 : f2 = 1900 + f2;
      else
        return e.error("Decoding " + r + " time is not supported yet");
      return Date.UTC(f2, p - 1, m, y, M, x, 0);
    };
    sr.prototype._decodeNull = function() {
      return null;
    };
    sr.prototype._decodeBool = function(e) {
      let r = e.readUInt8();
      return e.isError(r) ? r : r !== 0;
    };
    sr.prototype._decodeInt = function(e, r) {
      let o = e.raw(), f2 = new uq(o);
      return r && (f2 = r[f2.toString(10)] || f2), f2;
    };
    sr.prototype._use = function(e, r) {
      return typeof e == "function" && (e = e(r)), e._getDecoder("der").tree;
    };
    function Ed(t, e) {
      let r = t.readUInt8(e);
      if (t.isError(r))
        return r;
      let o = yw.tagClass[r >> 6], f2 = (r & 32) === 0;
      if ((r & 31) === 31) {
        let m = r;
        for (r = 0;(m & 128) === 128; ) {
          if (m = t.readUInt8(e), t.isError(m))
            return m;
          r <<= 7, r |= m & 127;
        }
      } else
        r &= 31;
      let p = yw.tag[r];
      return { cls: o, primitive: f2, tag: r, tagStr: p };
    }
    function _w(t, e, r) {
      let o = t.readUInt8(r);
      if (t.isError(o))
        return o;
      if (!e && o === 128)
        return null;
      if ((o & 128) === 0)
        return o;
      let f2 = o & 127;
      if (f2 > 4)
        return t.error("length octect is too long");
      o = 0;
      for (let p = 0;p < f2; p++) {
        o <<= 8;
        let m = t.readUInt8(r);
        if (t.isError(m))
          return m;
        o |= m;
      }
      return o;
    }
  });
  Ew = k((XL, Sw) => {
    var lq = Ie(), dq = p0().Buffer, Rd = Ad();
    function Bd(t) {
      Rd.call(this, t), this.enc = "pem";
    }
    lq(Bd, Rd);
    Sw.exports = Bd;
    Bd.prototype.decode = function(e, r) {
      let o = e.toString().split(/[\r\n]+/g), f2 = r.label.toUpperCase(), p = /^-----(BEGIN|END) ([^-]+)-----$/, m = -1, y = -1;
      for (let S2 = 0;S2 < o.length; S2++) {
        let E = o[S2].match(p);
        if (E !== null && E[2] === f2)
          if (m === -1) {
            if (E[1] !== "BEGIN")
              break;
            m = S2;
          } else {
            if (E[1] !== "END")
              break;
            y = S2;
            break;
          }
      }
      if (m === -1 || y === -1)
        throw new Error("PEM section not found for: " + f2);
      let M = o.slice(m + 1, y).join("");
      M.replace(/[^a-z0-9+/=]+/gi, "");
      let x = dq.from(M, "base64");
      return Rd.prototype.decode.call(this, x, r);
    };
  });
  qd = k((Rw) => {
    var Aw = Rw;
    Aw.der = Ad();
    Aw.pem = Ew();
  });
  qw = k((Bw) => {
    var cq = Sd(), pq = qd(), vq = Ie(), bq = Bw;
    bq.define = function(e, r) {
      return new $f(e, r);
    };
    function $f(t, e) {
      this.name = t, this.body = e, this.decoders = {}, this.encoders = {};
    }
    $f.prototype._createNamed = function(e) {
      let r = this.name;
      function o(f2) {
        this._initNamed(f2, r);
      }
      return vq(o, e), o.prototype._initNamed = function(p, m) {
        e.call(this, p, m);
      }, new o(this);
    };
    $f.prototype._getDecoder = function(e) {
      return e = e || "der", this.decoders.hasOwnProperty(e) || (this.decoders[e] = this._createNamed(pq[e])), this.decoders[e];
    };
    $f.prototype.decode = function(e, r, o) {
      return this._getDecoder(r).decode(e, o);
    };
    $f.prototype._getEncoder = function(e) {
      return e = e || "der", this.encoders.hasOwnProperty(e) || (this.encoders[e] = this._createNamed(cq[e])), this.encoders[e];
    };
    $f.prototype.encode = function(e, r, o) {
      return this._getEncoder(r).encode(e, o);
    };
  });
  Tw = k((Iw) => {
    var y0 = Iw;
    y0.Reporter = v0().Reporter;
    y0.DecoderBuffer = Vf().DecoderBuffer;
    y0.EncoderBuffer = Vf().EncoderBuffer;
    y0.Node = m0();
  });
  Nw = k((Lw) => {
    var kw = Lw;
    kw._reverse = function(e) {
      let r = {};
      return Object.keys(e).forEach(function(o) {
        (o | 0) == o && (o = o | 0);
        let f2 = e[o];
        r[f2] = o;
      }), r;
    };
    kw.der = g0();
  });
  Id2 = k((Pw) => {
    var Gf = Pw;
    Gf.bignum = gd();
    Gf.define = qw().define;
    Gf.base = Tw();
    Gf.constants = Nw();
    Gf.decoders = qd();
    Gf.encoders = Sd();
  });
  Fw = k((iN, Ow) => {
    var zr = Id2(), Dw = zr.define("Time", function() {
      this.choice({ utcTime: this.utctime(), generalTime: this.gentime() });
    }), mq = zr.define("AttributeTypeValue", function() {
      this.seq().obj(this.key("type").objid(), this.key("value").any());
    }), Td = zr.define("AlgorithmIdentifier", function() {
      this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional(), this.key("curve").objid().optional());
    }), gq = zr.define("SubjectPublicKeyInfo", function() {
      this.seq().obj(this.key("algorithm").use(Td), this.key("subjectPublicKey").bitstr());
    }), yq = zr.define("RelativeDistinguishedName", function() {
      this.setof(mq);
    }), wq = zr.define("RDNSequence", function() {
      this.seqof(yq);
    }), Cw = zr.define("Name", function() {
      this.choice({ rdnSequence: this.use(wq) });
    }), Mq = zr.define("Validity", function() {
      this.seq().obj(this.key("notBefore").use(Dw), this.key("notAfter").use(Dw));
    }), _q = zr.define("Extension", function() {
      this.seq().obj(this.key("extnID").objid(), this.key("critical").bool().def(false), this.key("extnValue").octstr());
    }), xq = zr.define("TBSCertificate", function() {
      this.seq().obj(this.key("version").explicit(0).int().optional(), this.key("serialNumber").int(), this.key("signature").use(Td), this.key("issuer").use(Cw), this.key("validity").use(Mq), this.key("subject").use(Cw), this.key("subjectPublicKeyInfo").use(gq), this.key("issuerUniqueID").implicit(1).bitstr().optional(), this.key("subjectUniqueID").implicit(2).bitstr().optional(), this.key("extensions").explicit(3).seqof(_q).optional());
    }), Sq = zr.define("X509Certificate", function() {
      this.seq().obj(this.key("tbsCertificate").use(xq), this.key("signatureAlgorithm").use(Td), this.key("signatureValue").bitstr());
    });
    Ow.exports = Sq;
  });
  zw = k((Wr) => {
    var Hr = Id2();
    Wr.certificate = Fw();
    var Eq = Hr.define("RSAPrivateKey", function() {
      this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int());
    });
    Wr.RSAPrivateKey = Eq;
    var Aq = Hr.define("RSAPublicKey", function() {
      this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int());
    });
    Wr.RSAPublicKey = Aq;
    var Rq = Hr.define("SubjectPublicKeyInfo", function() {
      this.seq().obj(this.key("algorithm").use(Uw), this.key("subjectPublicKey").bitstr());
    });
    Wr.PublicKey = Rq;
    var Uw = Hr.define("AlgorithmIdentifier", function() {
      this.seq().obj(this.key("algorithm").objid(), this.key("none").null_().optional(), this.key("curve").objid().optional(), this.key("params").seq().obj(this.key("p").int(), this.key("q").int(), this.key("g").int()).optional());
    }), Bq = Hr.define("PrivateKeyInfo", function() {
      this.seq().obj(this.key("version").int(), this.key("algorithm").use(Uw), this.key("subjectPrivateKey").octstr());
    });
    Wr.PrivateKey = Bq;
    var qq = Hr.define("EncryptedPrivateKeyInfo", function() {
      this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(), this.key("kdeparams").seq().obj(this.key("salt").octstr(), this.key("iters").int())), this.key("cipher").seq().obj(this.key("algo").objid(), this.key("iv").octstr()))), this.key("subjectPrivateKey").octstr());
    });
    Wr.EncryptedPrivateKey = qq;
    var Iq = Hr.define("DSAPrivateKey", function() {
      this.seq().obj(this.key("version").int(), this.key("p").int(), this.key("q").int(), this.key("g").int(), this.key("pub_key").int(), this.key("priv_key").int());
    });
    Wr.DSAPrivateKey = Iq;
    Wr.DSAparam = Hr.define("DSAparam", function() {
      this.int();
    });
    var Tq = Hr.define("ECPrivateKey", function() {
      this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").optional().explicit(0).use(kq), this.key("publicKey").optional().explicit(1).bitstr());
    });
    Wr.ECPrivateKey = Tq;
    var kq = Hr.define("ECParameters", function() {
      this.choice({ namedCurve: this.objid() });
    });
    Wr.signature = Hr.define("signature", function() {
      this.seq().obj(this.key("r").int(), this.key("s").int());
    });
  });
  Hw = k((fN, Lq) => {
    Lq.exports = { "2.16.840.1.101.3.4.1.1": "aes-128-ecb", "2.16.840.1.101.3.4.1.2": "aes-128-cbc", "2.16.840.1.101.3.4.1.3": "aes-128-ofb", "2.16.840.1.101.3.4.1.4": "aes-128-cfb", "2.16.840.1.101.3.4.1.21": "aes-192-ecb", "2.16.840.1.101.3.4.1.22": "aes-192-cbc", "2.16.840.1.101.3.4.1.23": "aes-192-ofb", "2.16.840.1.101.3.4.1.24": "aes-192-cfb", "2.16.840.1.101.3.4.1.41": "aes-256-ecb", "2.16.840.1.101.3.4.1.42": "aes-256-cbc", "2.16.840.1.101.3.4.1.43": "aes-256-ofb", "2.16.840.1.101.3.4.1.44": "aes-256-cfb" };
  });
  Kw = k((aN, Ww) => {
    var Nq = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, Pq = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, Dq = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, Cq = La(), Oq = Is(), w0 = Te().Buffer;
    Ww.exports = function(t, e) {
      var r = t.toString(), o = r.match(Nq), f2;
      if (o) {
        var m = "aes" + o[1], y = w0.from(o[2], "hex"), M = w0.from(o[3].replace(/[\r\n]/g, ""), "base64"), x = Cq(e, y.slice(0, 8), parseInt(o[1], 10)).key, S2 = [], E = Oq.createDecipheriv(m, x, y);
        S2.push(E.update(M)), S2.push(E.final()), f2 = w0.concat(S2);
      } else {
        var p = r.match(Dq);
        f2 = w0.from(p[2].replace(/[\r\n]/g, ""), "base64");
      }
      var R = r.match(Pq)[1];
      return { tag: R, data: f2 };
    };
  });
  Va = k((oN, Zw) => {
    var fr = zw(), Fq = Hw(), Uq = Kw(), zq = Is(), Hq = Vu(), kd = Te().Buffer;
    Zw.exports = jw;
    function jw(t) {
      var e;
      typeof t == "object" && !kd.isBuffer(t) && (e = t.passphrase, t = t.key), typeof t == "string" && (t = kd.from(t));
      var r = Uq(t, e), o = r.tag, f2 = r.data, p, m;
      switch (o) {
        case "CERTIFICATE":
          m = fr.certificate.decode(f2, "der").tbsCertificate.subjectPublicKeyInfo;
        case "PUBLIC KEY":
          switch (m || (m = fr.PublicKey.decode(f2, "der")), p = m.algorithm.algorithm.join("."), p) {
            case "1.2.840.113549.1.1.1":
              return fr.RSAPublicKey.decode(m.subjectPublicKey.data, "der");
            case "1.2.840.10045.2.1":
              return m.subjectPrivateKey = m.subjectPublicKey, { type: "ec", data: m };
            case "1.2.840.10040.4.1":
              return m.algorithm.params.pub_key = fr.DSAparam.decode(m.subjectPublicKey.data, "der"), { type: "dsa", data: m.algorithm.params };
            default:
              throw new Error("unknown key id " + p);
          }
        case "ENCRYPTED PRIVATE KEY":
          f2 = fr.EncryptedPrivateKey.decode(f2, "der"), f2 = Wq(f2, e);
        case "PRIVATE KEY":
          switch (m = fr.PrivateKey.decode(f2, "der"), p = m.algorithm.algorithm.join("."), p) {
            case "1.2.840.113549.1.1.1":
              return fr.RSAPrivateKey.decode(m.subjectPrivateKey, "der");
            case "1.2.840.10045.2.1":
              return { curve: m.algorithm.curve, privateKey: fr.ECPrivateKey.decode(m.subjectPrivateKey, "der").privateKey };
            case "1.2.840.10040.4.1":
              return m.algorithm.params.priv_key = fr.DSAparam.decode(m.subjectPrivateKey, "der"), { type: "dsa", params: m.algorithm.params };
            default:
              throw new Error("unknown key id " + p);
          }
        case "RSA PUBLIC KEY":
          return fr.RSAPublicKey.decode(f2, "der");
        case "RSA PRIVATE KEY":
          return fr.RSAPrivateKey.decode(f2, "der");
        case "DSA PRIVATE KEY":
          return { type: "dsa", params: fr.DSAPrivateKey.decode(f2, "der") };
        case "EC PRIVATE KEY":
          return f2 = fr.ECPrivateKey.decode(f2, "der"), { curve: f2.parameters.value, privateKey: f2.privateKey };
        default:
          throw new Error("unknown key type " + o);
      }
    }
    jw.signature = fr.signature;
    function Wq(t, e) {
      var r = t.algorithm.decrypt.kde.kdeparams.salt, o = parseInt(t.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), f2 = Fq[t.algorithm.decrypt.cipher.algo.join(".")], p = t.algorithm.decrypt.cipher.iv, m = t.subjectPrivateKey, y = parseInt(f2.split("-")[1], 10) / 8, M = Hq.pbkdf2Sync(e, r, o, y, "sha1"), x = zq.createDecipheriv(f2, M, p), S2 = [];
      return S2.push(x.update(m)), S2.push(x.final()), kd.concat(S2);
    }
  });
  Ld = k((sN, Kq) => {
    Kq.exports = { "1.3.132.0.10": "secp256k1", "1.3.132.0.33": "p224", "1.2.840.10045.3.1.1": "p192", "1.2.840.10045.3.1.7": "p256", "1.3.132.0.34": "p384", "1.3.132.0.35": "p521" };
  });
  Gw = k((hN, _0) => {
    var Yt = Te().Buffer, Gn = Cu(), jq = Gs(), Zq = d0().ec, M0 = $s(), Vq = Va(), $q = Ld();
    function Gq(t, e, r, o, f2) {
      var p = Vq(e);
      if (p.curve) {
        if (o !== "ecdsa" && o !== "ecdsa/rsa")
          throw new Error("wrong private key type");
        return Yq(t, p);
      } else if (p.type === "dsa") {
        if (o !== "dsa")
          throw new Error("wrong private key type");
        return Xq(t, p, r);
      } else if (o !== "rsa" && o !== "ecdsa/rsa")
        throw new Error("wrong private key type");
      t = Yt.concat([f2, t]);
      for (var m = p.modulus.byteLength(), y = [0, 1];t.length + y.length + 1 < m; )
        y.push(255);
      y.push(0);
      for (var M = -1;++M < t.length; )
        y.push(t[M]);
      var x = jq(y, p);
      return x;
    }
    function Yq(t, e) {
      var r = $q[e.curve.join(".")];
      if (!r)
        throw new Error("unknown curve " + e.curve.join("."));
      var o = new Zq(r), f2 = o.keyFromPrivate(e.privateKey), p = f2.sign(t);
      return Yt.from(p.toDER());
    }
    function Xq(t, e, r) {
      for (var o = e.params.priv_key, f2 = e.params.p, p = e.params.q, m = e.params.g, y = new M0(0), M, x = Nd(t, p).mod(p), S2 = false, E = Vw(o, p, t, r);S2 === false; )
        M = $w(p, E, r), y = eI(m, M, f2, p), S2 = M.invm(p).imul(x.add(o.mul(y))).mod(p), S2.cmpn(0) === 0 && (S2 = false, y = new M0(0));
      return Jq(y, S2);
    }
    function Jq(t, e) {
      t = t.toArray(), e = e.toArray(), t[0] & 128 && (t = [0].concat(t)), e[0] & 128 && (e = [0].concat(e));
      var r = t.length + e.length + 4, o = [48, r, 2, t.length];
      return o = o.concat(t, [2, e.length], e), Yt.from(o);
    }
    function Vw(t, e, r, o) {
      if (t = Yt.from(t.toArray()), t.length < e.byteLength()) {
        var f2 = Yt.alloc(e.byteLength() - t.length);
        t = Yt.concat([f2, t]);
      }
      var p = r.length, m = Qq(r, e), y = Yt.alloc(p);
      y.fill(1);
      var M = Yt.alloc(p);
      return M = Gn(o, M).update(y).update(Yt.from([0])).update(t).update(m).digest(), y = Gn(o, M).update(y).digest(), M = Gn(o, M).update(y).update(Yt.from([1])).update(t).update(m).digest(), y = Gn(o, M).update(y).digest(), { k: M, v: y };
    }
    function Nd(t, e) {
      var r = new M0(t), o = (t.length << 3) - e.bitLength();
      return o > 0 && r.ishrn(o), r;
    }
    function Qq(t, e) {
      t = Nd(t, e), t = t.mod(e);
      var r = Yt.from(t.toArray());
      if (r.length < e.byteLength()) {
        var o = Yt.alloc(e.byteLength() - r.length);
        r = Yt.concat([o, r]);
      }
      return r;
    }
    function $w(t, e, r) {
      var o, f2;
      do {
        for (o = Yt.alloc(0);o.length * 8 < t.bitLength(); )
          e.v = Gn(r, e.k).update(e.v).digest(), o = Yt.concat([o, e.v]);
        f2 = Nd(o, t), e.k = Gn(r, e.k).update(e.v).update(Yt.from([0])).digest(), e.v = Gn(r, e.k).update(e.v).digest();
      } while (f2.cmp(t) !== -1);
      return f2;
    }
    function eI(t, e, r, o) {
      return t.toRed(M0.mont(r)).redPow(e).fromRed().mod(o);
    }
    _0.exports = Gq;
    _0.exports.getKey = Vw;
    _0.exports.makeKey = $w;
  });
  Qw = k((uN, Jw) => {
    var Pd = Te().Buffer, $a = $s(), tI = d0().ec, Xw = Va(), rI = Ld();
    function iI(t, e, r, o, f2) {
      var p = Xw(r);
      if (p.type === "ec") {
        if (o !== "ecdsa" && o !== "ecdsa/rsa")
          throw new Error("wrong public key type");
        return nI(t, e, p);
      } else if (p.type === "dsa") {
        if (o !== "dsa")
          throw new Error("wrong public key type");
        return fI(t, e, p);
      } else if (o !== "rsa" && o !== "ecdsa/rsa")
        throw new Error("wrong public key type");
      e = Pd.concat([f2, e]);
      for (var m = p.modulus.byteLength(), y = [1], M = 0;e.length + y.length + 2 < m; )
        y.push(255), M++;
      y.push(0);
      for (var x = -1;++x < e.length; )
        y.push(e[x]);
      y = Pd.from(y);
      var S2 = $a.mont(p.modulus);
      t = new $a(t).toRed(S2), t = t.redPow(new $a(p.publicExponent)), t = Pd.from(t.fromRed().toArray());
      var E = M < 8 ? 1 : 0;
      for (m = Math.min(t.length, y.length), t.length !== y.length && (E = 1), x = -1;++x < m; )
        E |= t[x] ^ y[x];
      return E === 0;
    }
    function nI(t, e, r) {
      var o = rI[r.data.algorithm.curve.join(".")];
      if (!o)
        throw new Error("unknown curve " + r.data.algorithm.curve.join("."));
      var f2 = new tI(o), p = r.data.subjectPrivateKey.data;
      return f2.verify(e, t, p);
    }
    function fI(t, e, r) {
      var o = r.data.p, f2 = r.data.q, p = r.data.g, m = r.data.pub_key, y = Xw.signature.decode(t, "der"), M = y.s, x = y.r;
      Yw(M, f2), Yw(x, f2);
      var S2 = $a.mont(o), E = M.invm(f2), R = p.toRed(S2).redPow(new $a(e).mul(E).mod(f2)).fromRed().mul(m.toRed(S2).redPow(x.mul(E).mod(f2)).fromRed()).mod(o).mod(f2);
      return R.cmp(x) === 0;
    }
    function Yw(t, e) {
      if (t.cmpn(0) <= 0)
        throw new Error("invalid sig");
      if (t.cmp(e) >= e)
        throw new Error("invalid sig");
    }
    Jw.exports = iI;
  });
  f3 = k((lN, n3) => {
    var x0 = Te().Buffer, r3 = yf(), S0 = I2(), i3 = Ie(), aI = Gw(), oI = Qw(), Yn = Ou();
    Object.keys(Yn).forEach(function(t) {
      Yn[t].id = x0.from(Yn[t].id, "hex"), Yn[t.toLowerCase()] = Yn[t];
    });
    function Ga(t) {
      S0.Writable.call(this);
      var e = Yn[t];
      if (!e)
        throw new Error("Unknown message digest");
      this._hashType = e.hash, this._hash = r3(e.hash), this._tag = e.id, this._signType = e.sign;
    }
    i3(Ga, S0.Writable);
    Ga.prototype._write = function(e, r, o) {
      this._hash.update(e), o();
    };
    Ga.prototype.update = function(e, r) {
      return typeof e == "string" && (e = x0.from(e, r)), this._hash.update(e), this;
    };
    Ga.prototype.sign = function(e, r) {
      this.end();
      var o = this._hash.digest(), f2 = aI(o, e, this._hashType, this._signType, this._tag);
      return r ? f2.toString(r) : f2;
    };
    function Ya(t) {
      S0.Writable.call(this);
      var e = Yn[t];
      if (!e)
        throw new Error("Unknown message digest");
      this._hash = r3(e.hash), this._tag = e.id, this._signType = e.sign;
    }
    i3(Ya, S0.Writable);
    Ya.prototype._write = function(e, r, o) {
      this._hash.update(e), o();
    };
    Ya.prototype.update = function(e, r) {
      return typeof e == "string" && (e = x0.from(e, r)), this._hash.update(e), this;
    };
    Ya.prototype.verify = function(e, r, o) {
      typeof r == "string" && (r = x0.from(r, o)), this.end();
      var f2 = this._hash.digest();
      return oI(r, f2, e, this._signType, this._tag);
    };
    function e3(t) {
      return new Ga(t);
    }
    function t3(t) {
      return new Ya(t);
    }
    n3.exports = { Sign: e3, Verify: t3, createSign: e3, createVerify: t3 };
  });
  o3 = k((a3, Dd) => {
    (function(t, e) {
      function r(v2, i) {
        if (!v2)
          throw new Error(i || "Assertion failed");
      }
      function o(v2, i) {
        v2.super_ = i;
        var a = function() {
        };
        a.prototype = i.prototype, v2.prototype = new a, v2.prototype.constructor = v2;
      }
      function f2(v2, i, a) {
        if (f2.isBN(v2))
          return v2;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, v2 !== null && ((i === "le" || i === "be") && (a = i, i = 10), this._init(v2 || 0, i || 10, a || "be"));
      }
      typeof t == "object" ? t.exports = f2 : e.BN = f2, f2.BN = f2, f2.wordSize = 26;
      var p;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? p = window.Buffer : p = Vi().Buffer;
      } catch {
      }
      f2.isBN = function(i) {
        return i instanceof f2 ? true : i !== null && typeof i == "object" && i.constructor.wordSize === f2.wordSize && Array.isArray(i.words);
      }, f2.max = function(i, a) {
        return i.cmp(a) > 0 ? i : a;
      }, f2.min = function(i, a) {
        return i.cmp(a) < 0 ? i : a;
      }, f2.prototype._init = function(i, a, h) {
        if (typeof i == "number")
          return this._initNumber(i, a, h);
        if (typeof i == "object")
          return this._initArray(i, a, h);
        a === "hex" && (a = 16), r(a === (a | 0) && a >= 2 && a <= 36), i = i.toString().replace(/\s+/g, "");
        var s = 0;
        i[0] === "-" && (s++, this.negative = 1), s < i.length && (a === 16 ? this._parseHex(i, s, h) : (this._parseBase(i, a, s), h === "le" && this._initArray(this.toArray(), a, h)));
      }, f2.prototype._initNumber = function(i, a, h) {
        i < 0 && (this.negative = 1, i = -i), i < 67108864 ? (this.words = [i & 67108863], this.length = 1) : i < 4503599627370496 ? (this.words = [i & 67108863, i / 67108864 & 67108863], this.length = 2) : (r(i < 9007199254740992), this.words = [i & 67108863, i / 67108864 & 67108863, 1], this.length = 3), h === "le" && this._initArray(this.toArray(), a, h);
      }, f2.prototype._initArray = function(i, a, h) {
        if (r(typeof i.length == "number"), i.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(i.length / 3), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u, c, b2 = 0;
        if (h === "be")
          for (s = i.length - 1, u = 0;s >= 0; s -= 3)
            c = i[s] | i[s - 1] << 8 | i[s - 2] << 16, this.words[u] |= c << b2 & 67108863, this.words[u + 1] = c >>> 26 - b2 & 67108863, b2 += 24, b2 >= 26 && (b2 -= 26, u++);
        else if (h === "le")
          for (s = 0, u = 0;s < i.length; s += 3)
            c = i[s] | i[s + 1] << 8 | i[s + 2] << 16, this.words[u] |= c << b2 & 67108863, this.words[u + 1] = c >>> 26 - b2 & 67108863, b2 += 24, b2 >= 26 && (b2 -= 26, u++);
        return this.strip();
      };
      function m(v2, i) {
        var a = v2.charCodeAt(i);
        return a >= 65 && a <= 70 ? a - 55 : a >= 97 && a <= 102 ? a - 87 : a - 48 & 15;
      }
      function y(v2, i, a) {
        var h = m(v2, a);
        return a - 1 >= i && (h |= m(v2, a - 1) << 4), h;
      }
      f2.prototype._parseHex = function(i, a, h) {
        this.length = Math.ceil((i.length - a) / 6), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u = 0, c = 0, b2;
        if (h === "be")
          for (s = i.length - 1;s >= a; s -= 2)
            b2 = y(i, a, s) << u, this.words[c] |= b2 & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b2 >>> 26) : u += 8;
        else {
          var l = i.length - a;
          for (s = l % 2 === 0 ? a + 1 : a;s < i.length; s += 2)
            b2 = y(i, a, s) << u, this.words[c] |= b2 & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b2 >>> 26) : u += 8;
        }
        this.strip();
      };
      function M(v2, i, a, h) {
        for (var s = 0, u = Math.min(v2.length, a), c = i;c < u; c++) {
          var b2 = v2.charCodeAt(c) - 48;
          s *= h, b2 >= 49 ? s += b2 - 49 + 10 : b2 >= 17 ? s += b2 - 17 + 10 : s += b2;
        }
        return s;
      }
      f2.prototype._parseBase = function(i, a, h) {
        this.words = [0], this.length = 1;
        for (var s = 0, u = 1;u <= 67108863; u *= a)
          s++;
        s--, u = u / a | 0;
        for (var c = i.length - h, b2 = c % s, l = Math.min(c, c - b2) + h, n = 0, d = h;d < l; d += s)
          n = M(i, d, d + s, a), this.imuln(u), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        if (b2 !== 0) {
          var w = 1;
          for (n = M(i, d, i.length, a), d = 0;d < b2; d++)
            w *= a;
          this.imuln(w), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        }
        this.strip();
      }, f2.prototype.copy = function(i) {
        i.words = new Array(this.length);
        for (var a = 0;a < this.length; a++)
          i.words[a] = this.words[a];
        i.length = this.length, i.negative = this.negative, i.red = this.red;
      }, f2.prototype.clone = function() {
        var i = new f2(null);
        return this.copy(i), i;
      }, f2.prototype._expand = function(i) {
        for (;this.length < i; )
          this.words[this.length++] = 0;
        return this;
      }, f2.prototype.strip = function() {
        for (;this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, f2.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, f2.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var x = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], S2 = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], E = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      f2.prototype.toString = function(i, a) {
        i = i || 10, a = a | 0 || 1;
        var h;
        if (i === 16 || i === "hex") {
          h = "";
          for (var s = 0, u = 0, c = 0;c < this.length; c++) {
            var b2 = this.words[c], l = ((b2 << s | u) & 16777215).toString(16);
            u = b2 >>> 24 - s & 16777215, u !== 0 || c !== this.length - 1 ? h = x[6 - l.length] + l + h : h = l + h, s += 2, s >= 26 && (s -= 26, c--);
          }
          for (u !== 0 && (h = u.toString(16) + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        if (i === (i | 0) && i >= 2 && i <= 36) {
          var n = S2[i], d = E[i];
          h = "";
          var w = this.clone();
          for (w.negative = 0;!w.isZero(); ) {
            var g = w.modn(d).toString(i);
            w = w.idivn(d), w.isZero() ? h = g + h : h = x[n - g.length] + g + h;
          }
          for (this.isZero() && (h = "0" + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        r(false, "Base should be between 2 and 36");
      }, f2.prototype.toNumber = function() {
        var i = this.words[0];
        return this.length === 2 ? i += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? i += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -i : i;
      }, f2.prototype.toJSON = function() {
        return this.toString(16);
      }, f2.prototype.toBuffer = function(i, a) {
        return r(typeof p < "u"), this.toArrayLike(p, i, a);
      }, f2.prototype.toArray = function(i, a) {
        return this.toArrayLike(Array, i, a);
      }, f2.prototype.toArrayLike = function(i, a, h) {
        var s = this.byteLength(), u = h || Math.max(1, s);
        r(s <= u, "byte array longer than desired length"), r(u > 0, "Requested array length <= 0"), this.strip();
        var c = a === "le", b2 = new i(u), l, n, d = this.clone();
        if (c) {
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b2[n] = l;
          for (;n < u; n++)
            b2[n] = 0;
        } else {
          for (n = 0;n < u - s; n++)
            b2[n] = 0;
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b2[u - n - 1] = l;
        }
        return b2;
      }, Math.clz32 ? f2.prototype._countBits = function(i) {
        return 32 - Math.clz32(i);
      } : f2.prototype._countBits = function(i) {
        var a = i, h = 0;
        return a >= 4096 && (h += 13, a >>>= 13), a >= 64 && (h += 7, a >>>= 7), a >= 8 && (h += 4, a >>>= 4), a >= 2 && (h += 2, a >>>= 2), h + a;
      }, f2.prototype._zeroBits = function(i) {
        if (i === 0)
          return 26;
        var a = i, h = 0;
        return (a & 8191) === 0 && (h += 13, a >>>= 13), (a & 127) === 0 && (h += 7, a >>>= 7), (a & 15) === 0 && (h += 4, a >>>= 4), (a & 3) === 0 && (h += 2, a >>>= 2), (a & 1) === 0 && h++, h;
      }, f2.prototype.bitLength = function() {
        var i = this.words[this.length - 1], a = this._countBits(i);
        return (this.length - 1) * 26 + a;
      };
      function R(v2) {
        for (var i = new Array(v2.bitLength()), a = 0;a < i.length; a++) {
          var h = a / 26 | 0, s = a % 26;
          i[a] = (v2.words[h] & 1 << s) >>> s;
        }
        return i;
      }
      f2.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var i = 0, a = 0;a < this.length; a++) {
          var h = this._zeroBits(this.words[a]);
          if (i += h, h !== 26)
            break;
        }
        return i;
      }, f2.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, f2.prototype.toTwos = function(i) {
        return this.negative !== 0 ? this.abs().inotn(i).iaddn(1) : this.clone();
      }, f2.prototype.fromTwos = function(i) {
        return this.testn(i - 1) ? this.notn(i).iaddn(1).ineg() : this.clone();
      }, f2.prototype.isNeg = function() {
        return this.negative !== 0;
      }, f2.prototype.neg = function() {
        return this.clone().ineg();
      }, f2.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, f2.prototype.iuor = function(i) {
        for (;this.length < i.length; )
          this.words[this.length++] = 0;
        for (var a = 0;a < i.length; a++)
          this.words[a] = this.words[a] | i.words[a];
        return this.strip();
      }, f2.prototype.ior = function(i) {
        return r((this.negative | i.negative) === 0), this.iuor(i);
      }, f2.prototype.or = function(i) {
        return this.length > i.length ? this.clone().ior(i) : i.clone().ior(this);
      }, f2.prototype.uor = function(i) {
        return this.length > i.length ? this.clone().iuor(i) : i.clone().iuor(this);
      }, f2.prototype.iuand = function(i) {
        var a;
        this.length > i.length ? a = i : a = this;
        for (var h = 0;h < a.length; h++)
          this.words[h] = this.words[h] & i.words[h];
        return this.length = a.length, this.strip();
      }, f2.prototype.iand = function(i) {
        return r((this.negative | i.negative) === 0), this.iuand(i);
      }, f2.prototype.and = function(i) {
        return this.length > i.length ? this.clone().iand(i) : i.clone().iand(this);
      }, f2.prototype.uand = function(i) {
        return this.length > i.length ? this.clone().iuand(i) : i.clone().iuand(this);
      }, f2.prototype.iuxor = function(i) {
        var a, h;
        this.length > i.length ? (a = this, h = i) : (a = i, h = this);
        for (var s = 0;s < h.length; s++)
          this.words[s] = a.words[s] ^ h.words[s];
        if (this !== a)
          for (;s < a.length; s++)
            this.words[s] = a.words[s];
        return this.length = a.length, this.strip();
      }, f2.prototype.ixor = function(i) {
        return r((this.negative | i.negative) === 0), this.iuxor(i);
      }, f2.prototype.xor = function(i) {
        return this.length > i.length ? this.clone().ixor(i) : i.clone().ixor(this);
      }, f2.prototype.uxor = function(i) {
        return this.length > i.length ? this.clone().iuxor(i) : i.clone().iuxor(this);
      }, f2.prototype.inotn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = Math.ceil(i / 26) | 0, h = i % 26;
        this._expand(a), h > 0 && a--;
        for (var s = 0;s < a; s++)
          this.words[s] = ~this.words[s] & 67108863;
        return h > 0 && (this.words[s] = ~this.words[s] & 67108863 >> 26 - h), this.strip();
      }, f2.prototype.notn = function(i) {
        return this.clone().inotn(i);
      }, f2.prototype.setn = function(i, a) {
        r(typeof i == "number" && i >= 0);
        var h = i / 26 | 0, s = i % 26;
        return this._expand(h + 1), a ? this.words[h] = this.words[h] | 1 << s : this.words[h] = this.words[h] & ~(1 << s), this.strip();
      }, f2.prototype.iadd = function(i) {
        var a;
        if (this.negative !== 0 && i.negative === 0)
          return this.negative = 0, a = this.isub(i), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && i.negative !== 0)
          return i.negative = 0, a = this.isub(i), i.negative = 1, a._normSign();
        var h, s;
        this.length > i.length ? (h = this, s = i) : (h = i, s = this);
        for (var u = 0, c = 0;c < s.length; c++)
          a = (h.words[c] | 0) + (s.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        for (;u !== 0 && c < h.length; c++)
          a = (h.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        if (this.length = h.length, u !== 0)
          this.words[this.length] = u, this.length++;
        else if (h !== this)
          for (;c < h.length; c++)
            this.words[c] = h.words[c];
        return this;
      }, f2.prototype.add = function(i) {
        var a;
        return i.negative !== 0 && this.negative === 0 ? (i.negative = 0, a = this.sub(i), i.negative ^= 1, a) : i.negative === 0 && this.negative !== 0 ? (this.negative = 0, a = i.sub(this), this.negative = 1, a) : this.length > i.length ? this.clone().iadd(i) : i.clone().iadd(this);
      }, f2.prototype.isub = function(i) {
        if (i.negative !== 0) {
          i.negative = 0;
          var a = this.iadd(i);
          return i.negative = 1, a._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(i), this.negative = 1, this._normSign();
        var h = this.cmp(i);
        if (h === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var s, u;
        h > 0 ? (s = this, u = i) : (s = i, u = this);
        for (var c = 0, b2 = 0;b2 < u.length; b2++)
          a = (s.words[b2] | 0) - (u.words[b2] | 0) + c, c = a >> 26, this.words[b2] = a & 67108863;
        for (;c !== 0 && b2 < s.length; b2++)
          a = (s.words[b2] | 0) + c, c = a >> 26, this.words[b2] = a & 67108863;
        if (c === 0 && b2 < s.length && s !== this)
          for (;b2 < s.length; b2++)
            this.words[b2] = s.words[b2];
        return this.length = Math.max(this.length, b2), s !== this && (this.negative = 1), this.strip();
      }, f2.prototype.sub = function(i) {
        return this.clone().isub(i);
      };
      function q(v2, i, a) {
        a.negative = i.negative ^ v2.negative;
        var h = v2.length + i.length | 0;
        a.length = h, h = h - 1 | 0;
        var s = v2.words[0] | 0, u = i.words[0] | 0, c = s * u, b2 = c & 67108863, l = c / 67108864 | 0;
        a.words[0] = b2;
        for (var n = 1;n < h; n++) {
          for (var d = l >>> 26, w = l & 67108863, g = Math.min(n, i.length - 1), _2 = Math.max(0, n - v2.length + 1);_2 <= g; _2++) {
            var A = n - _2 | 0;
            s = v2.words[A] | 0, u = i.words[_2] | 0, c = s * u + w, d += c / 67108864 | 0, w = c & 67108863;
          }
          a.words[n] = w | 0, l = d | 0;
        }
        return l !== 0 ? a.words[n] = l | 0 : a.length--, a.strip();
      }
      var T = function(i, a, h) {
        var s = i.words, u = a.words, c = h.words, b2 = 0, l, n, d, w = s[0] | 0, g = w & 8191, _2 = w >>> 13, A = s[1] | 0, B = A & 8191, I = A >>> 13, we = s[2] | 0, L = we & 8191, N = we >>> 13, nt = s[3] | 0, C = nt & 8191, O = nt >>> 13, vt = s[4] | 0, F = vt & 8191, U = vt >>> 13, bt = s[5] | 0, z2 = bt & 8191, H = bt >>> 13, mt = s[6] | 0, W = mt & 8191, K = mt >>> 13, gt = s[7] | 0, j = gt & 8191, Z = gt >>> 13, yt = s[8] | 0, V = yt & 8191, $2 = yt >>> 13, wt = s[9] | 0, G = wt & 8191, Y = wt >>> 13, Mt = u[0] | 0, X = Mt & 8191, J2 = Mt >>> 13, _t = u[1] | 0, Q2 = _t & 8191, ee = _t >>> 13, xt = u[2] | 0, te = xt & 8191, re = xt >>> 13, St = u[3] | 0, ie = St & 8191, ne = St >>> 13, Et = u[4] | 0, fe = Et & 8191, ae = Et >>> 13, At = u[5] | 0, oe = At & 8191, se = At >>> 13, Rt = u[6] | 0, he = Rt & 8191, ue = Rt >>> 13, Bt = u[7] | 0, le = Bt & 8191, de = Bt >>> 13, qt = u[8] | 0, ce = qt & 8191, pe = qt >>> 13, It = u[9] | 0, ve = It & 8191, be = It >>> 13;
        h.negative = i.negative ^ a.negative, h.length = 19, l = Math.imul(g, X), n = Math.imul(g, J2), n = n + Math.imul(_2, X) | 0, d = Math.imul(_2, J2);
        var ft = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, l = Math.imul(B, X), n = Math.imul(B, J2), n = n + Math.imul(I, X) | 0, d = Math.imul(I, J2), l = l + Math.imul(g, Q2) | 0, n = n + Math.imul(g, ee) | 0, n = n + Math.imul(_2, Q2) | 0, d = d + Math.imul(_2, ee) | 0;
        var Be = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, l = Math.imul(L, X), n = Math.imul(L, J2), n = n + Math.imul(N, X) | 0, d = Math.imul(N, J2), l = l + Math.imul(B, Q2) | 0, n = n + Math.imul(B, ee) | 0, n = n + Math.imul(I, Q2) | 0, d = d + Math.imul(I, ee) | 0, l = l + Math.imul(g, te) | 0, n = n + Math.imul(g, re) | 0, n = n + Math.imul(_2, te) | 0, d = d + Math.imul(_2, re) | 0;
        var qe = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (qe >>> 26) | 0, qe &= 67108863, l = Math.imul(C, X), n = Math.imul(C, J2), n = n + Math.imul(O, X) | 0, d = Math.imul(O, J2), l = l + Math.imul(L, Q2) | 0, n = n + Math.imul(L, ee) | 0, n = n + Math.imul(N, Q2) | 0, d = d + Math.imul(N, ee) | 0, l = l + Math.imul(B, te) | 0, n = n + Math.imul(B, re) | 0, n = n + Math.imul(I, te) | 0, d = d + Math.imul(I, re) | 0, l = l + Math.imul(g, ie) | 0, n = n + Math.imul(g, ne) | 0, n = n + Math.imul(_2, ie) | 0, d = d + Math.imul(_2, ne) | 0;
        var ze = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, l = Math.imul(F, X), n = Math.imul(F, J2), n = n + Math.imul(U, X) | 0, d = Math.imul(U, J2), l = l + Math.imul(C, Q2) | 0, n = n + Math.imul(C, ee) | 0, n = n + Math.imul(O, Q2) | 0, d = d + Math.imul(O, ee) | 0, l = l + Math.imul(L, te) | 0, n = n + Math.imul(L, re) | 0, n = n + Math.imul(N, te) | 0, d = d + Math.imul(N, re) | 0, l = l + Math.imul(B, ie) | 0, n = n + Math.imul(B, ne) | 0, n = n + Math.imul(I, ie) | 0, d = d + Math.imul(I, ne) | 0, l = l + Math.imul(g, fe) | 0, n = n + Math.imul(g, ae) | 0, n = n + Math.imul(_2, fe) | 0, d = d + Math.imul(_2, ae) | 0;
        var He = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, l = Math.imul(z2, X), n = Math.imul(z2, J2), n = n + Math.imul(H, X) | 0, d = Math.imul(H, J2), l = l + Math.imul(F, Q2) | 0, n = n + Math.imul(F, ee) | 0, n = n + Math.imul(U, Q2) | 0, d = d + Math.imul(U, ee) | 0, l = l + Math.imul(C, te) | 0, n = n + Math.imul(C, re) | 0, n = n + Math.imul(O, te) | 0, d = d + Math.imul(O, re) | 0, l = l + Math.imul(L, ie) | 0, n = n + Math.imul(L, ne) | 0, n = n + Math.imul(N, ie) | 0, d = d + Math.imul(N, ne) | 0, l = l + Math.imul(B, fe) | 0, n = n + Math.imul(B, ae) | 0, n = n + Math.imul(I, fe) | 0, d = d + Math.imul(I, ae) | 0, l = l + Math.imul(g, oe) | 0, n = n + Math.imul(g, se) | 0, n = n + Math.imul(_2, oe) | 0, d = d + Math.imul(_2, se) | 0;
        var We = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (We >>> 26) | 0, We &= 67108863, l = Math.imul(W, X), n = Math.imul(W, J2), n = n + Math.imul(K, X) | 0, d = Math.imul(K, J2), l = l + Math.imul(z2, Q2) | 0, n = n + Math.imul(z2, ee) | 0, n = n + Math.imul(H, Q2) | 0, d = d + Math.imul(H, ee) | 0, l = l + Math.imul(F, te) | 0, n = n + Math.imul(F, re) | 0, n = n + Math.imul(U, te) | 0, d = d + Math.imul(U, re) | 0, l = l + Math.imul(C, ie) | 0, n = n + Math.imul(C, ne) | 0, n = n + Math.imul(O, ie) | 0, d = d + Math.imul(O, ne) | 0, l = l + Math.imul(L, fe) | 0, n = n + Math.imul(L, ae) | 0, n = n + Math.imul(N, fe) | 0, d = d + Math.imul(N, ae) | 0, l = l + Math.imul(B, oe) | 0, n = n + Math.imul(B, se) | 0, n = n + Math.imul(I, oe) | 0, d = d + Math.imul(I, se) | 0, l = l + Math.imul(g, he) | 0, n = n + Math.imul(g, ue) | 0, n = n + Math.imul(_2, he) | 0, d = d + Math.imul(_2, ue) | 0;
        var Ke = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, l = Math.imul(j, X), n = Math.imul(j, J2), n = n + Math.imul(Z, X) | 0, d = Math.imul(Z, J2), l = l + Math.imul(W, Q2) | 0, n = n + Math.imul(W, ee) | 0, n = n + Math.imul(K, Q2) | 0, d = d + Math.imul(K, ee) | 0, l = l + Math.imul(z2, te) | 0, n = n + Math.imul(z2, re) | 0, n = n + Math.imul(H, te) | 0, d = d + Math.imul(H, re) | 0, l = l + Math.imul(F, ie) | 0, n = n + Math.imul(F, ne) | 0, n = n + Math.imul(U, ie) | 0, d = d + Math.imul(U, ne) | 0, l = l + Math.imul(C, fe) | 0, n = n + Math.imul(C, ae) | 0, n = n + Math.imul(O, fe) | 0, d = d + Math.imul(O, ae) | 0, l = l + Math.imul(L, oe) | 0, n = n + Math.imul(L, se) | 0, n = n + Math.imul(N, oe) | 0, d = d + Math.imul(N, se) | 0, l = l + Math.imul(B, he) | 0, n = n + Math.imul(B, ue) | 0, n = n + Math.imul(I, he) | 0, d = d + Math.imul(I, ue) | 0, l = l + Math.imul(g, le) | 0, n = n + Math.imul(g, de) | 0, n = n + Math.imul(_2, le) | 0, d = d + Math.imul(_2, de) | 0;
        var je = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, l = Math.imul(V, X), n = Math.imul(V, J2), n = n + Math.imul($2, X) | 0, d = Math.imul($2, J2), l = l + Math.imul(j, Q2) | 0, n = n + Math.imul(j, ee) | 0, n = n + Math.imul(Z, Q2) | 0, d = d + Math.imul(Z, ee) | 0, l = l + Math.imul(W, te) | 0, n = n + Math.imul(W, re) | 0, n = n + Math.imul(K, te) | 0, d = d + Math.imul(K, re) | 0, l = l + Math.imul(z2, ie) | 0, n = n + Math.imul(z2, ne) | 0, n = n + Math.imul(H, ie) | 0, d = d + Math.imul(H, ne) | 0, l = l + Math.imul(F, fe) | 0, n = n + Math.imul(F, ae) | 0, n = n + Math.imul(U, fe) | 0, d = d + Math.imul(U, ae) | 0, l = l + Math.imul(C, oe) | 0, n = n + Math.imul(C, se) | 0, n = n + Math.imul(O, oe) | 0, d = d + Math.imul(O, se) | 0, l = l + Math.imul(L, he) | 0, n = n + Math.imul(L, ue) | 0, n = n + Math.imul(N, he) | 0, d = d + Math.imul(N, ue) | 0, l = l + Math.imul(B, le) | 0, n = n + Math.imul(B, de) | 0, n = n + Math.imul(I, le) | 0, d = d + Math.imul(I, de) | 0, l = l + Math.imul(g, ce) | 0, n = n + Math.imul(g, pe) | 0, n = n + Math.imul(_2, ce) | 0, d = d + Math.imul(_2, pe) | 0;
        var Ze = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, l = Math.imul(G, X), n = Math.imul(G, J2), n = n + Math.imul(Y, X) | 0, d = Math.imul(Y, J2), l = l + Math.imul(V, Q2) | 0, n = n + Math.imul(V, ee) | 0, n = n + Math.imul($2, Q2) | 0, d = d + Math.imul($2, ee) | 0, l = l + Math.imul(j, te) | 0, n = n + Math.imul(j, re) | 0, n = n + Math.imul(Z, te) | 0, d = d + Math.imul(Z, re) | 0, l = l + Math.imul(W, ie) | 0, n = n + Math.imul(W, ne) | 0, n = n + Math.imul(K, ie) | 0, d = d + Math.imul(K, ne) | 0, l = l + Math.imul(z2, fe) | 0, n = n + Math.imul(z2, ae) | 0, n = n + Math.imul(H, fe) | 0, d = d + Math.imul(H, ae) | 0, l = l + Math.imul(F, oe) | 0, n = n + Math.imul(F, se) | 0, n = n + Math.imul(U, oe) | 0, d = d + Math.imul(U, se) | 0, l = l + Math.imul(C, he) | 0, n = n + Math.imul(C, ue) | 0, n = n + Math.imul(O, he) | 0, d = d + Math.imul(O, ue) | 0, l = l + Math.imul(L, le) | 0, n = n + Math.imul(L, de) | 0, n = n + Math.imul(N, le) | 0, d = d + Math.imul(N, de) | 0, l = l + Math.imul(B, ce) | 0, n = n + Math.imul(B, pe) | 0, n = n + Math.imul(I, ce) | 0, d = d + Math.imul(I, pe) | 0, l = l + Math.imul(g, ve) | 0, n = n + Math.imul(g, be) | 0, n = n + Math.imul(_2, ve) | 0, d = d + Math.imul(_2, be) | 0;
        var Ve = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, l = Math.imul(G, Q2), n = Math.imul(G, ee), n = n + Math.imul(Y, Q2) | 0, d = Math.imul(Y, ee), l = l + Math.imul(V, te) | 0, n = n + Math.imul(V, re) | 0, n = n + Math.imul($2, te) | 0, d = d + Math.imul($2, re) | 0, l = l + Math.imul(j, ie) | 0, n = n + Math.imul(j, ne) | 0, n = n + Math.imul(Z, ie) | 0, d = d + Math.imul(Z, ne) | 0, l = l + Math.imul(W, fe) | 0, n = n + Math.imul(W, ae) | 0, n = n + Math.imul(K, fe) | 0, d = d + Math.imul(K, ae) | 0, l = l + Math.imul(z2, oe) | 0, n = n + Math.imul(z2, se) | 0, n = n + Math.imul(H, oe) | 0, d = d + Math.imul(H, se) | 0, l = l + Math.imul(F, he) | 0, n = n + Math.imul(F, ue) | 0, n = n + Math.imul(U, he) | 0, d = d + Math.imul(U, ue) | 0, l = l + Math.imul(C, le) | 0, n = n + Math.imul(C, de) | 0, n = n + Math.imul(O, le) | 0, d = d + Math.imul(O, de) | 0, l = l + Math.imul(L, ce) | 0, n = n + Math.imul(L, pe) | 0, n = n + Math.imul(N, ce) | 0, d = d + Math.imul(N, pe) | 0, l = l + Math.imul(B, ve) | 0, n = n + Math.imul(B, be) | 0, n = n + Math.imul(I, ve) | 0, d = d + Math.imul(I, be) | 0;
        var $e = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + ($e >>> 26) | 0, $e &= 67108863, l = Math.imul(G, te), n = Math.imul(G, re), n = n + Math.imul(Y, te) | 0, d = Math.imul(Y, re), l = l + Math.imul(V, ie) | 0, n = n + Math.imul(V, ne) | 0, n = n + Math.imul($2, ie) | 0, d = d + Math.imul($2, ne) | 0, l = l + Math.imul(j, fe) | 0, n = n + Math.imul(j, ae) | 0, n = n + Math.imul(Z, fe) | 0, d = d + Math.imul(Z, ae) | 0, l = l + Math.imul(W, oe) | 0, n = n + Math.imul(W, se) | 0, n = n + Math.imul(K, oe) | 0, d = d + Math.imul(K, se) | 0, l = l + Math.imul(z2, he) | 0, n = n + Math.imul(z2, ue) | 0, n = n + Math.imul(H, he) | 0, d = d + Math.imul(H, ue) | 0, l = l + Math.imul(F, le) | 0, n = n + Math.imul(F, de) | 0, n = n + Math.imul(U, le) | 0, d = d + Math.imul(U, de) | 0, l = l + Math.imul(C, ce) | 0, n = n + Math.imul(C, pe) | 0, n = n + Math.imul(O, ce) | 0, d = d + Math.imul(O, pe) | 0, l = l + Math.imul(L, ve) | 0, n = n + Math.imul(L, be) | 0, n = n + Math.imul(N, ve) | 0, d = d + Math.imul(N, be) | 0;
        var Ge = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, l = Math.imul(G, ie), n = Math.imul(G, ne), n = n + Math.imul(Y, ie) | 0, d = Math.imul(Y, ne), l = l + Math.imul(V, fe) | 0, n = n + Math.imul(V, ae) | 0, n = n + Math.imul($2, fe) | 0, d = d + Math.imul($2, ae) | 0, l = l + Math.imul(j, oe) | 0, n = n + Math.imul(j, se) | 0, n = n + Math.imul(Z, oe) | 0, d = d + Math.imul(Z, se) | 0, l = l + Math.imul(W, he) | 0, n = n + Math.imul(W, ue) | 0, n = n + Math.imul(K, he) | 0, d = d + Math.imul(K, ue) | 0, l = l + Math.imul(z2, le) | 0, n = n + Math.imul(z2, de) | 0, n = n + Math.imul(H, le) | 0, d = d + Math.imul(H, de) | 0, l = l + Math.imul(F, ce) | 0, n = n + Math.imul(F, pe) | 0, n = n + Math.imul(U, ce) | 0, d = d + Math.imul(U, pe) | 0, l = l + Math.imul(C, ve) | 0, n = n + Math.imul(C, be) | 0, n = n + Math.imul(O, ve) | 0, d = d + Math.imul(O, be) | 0;
        var Ye = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, l = Math.imul(G, fe), n = Math.imul(G, ae), n = n + Math.imul(Y, fe) | 0, d = Math.imul(Y, ae), l = l + Math.imul(V, oe) | 0, n = n + Math.imul(V, se) | 0, n = n + Math.imul($2, oe) | 0, d = d + Math.imul($2, se) | 0, l = l + Math.imul(j, he) | 0, n = n + Math.imul(j, ue) | 0, n = n + Math.imul(Z, he) | 0, d = d + Math.imul(Z, ue) | 0, l = l + Math.imul(W, le) | 0, n = n + Math.imul(W, de) | 0, n = n + Math.imul(K, le) | 0, d = d + Math.imul(K, de) | 0, l = l + Math.imul(z2, ce) | 0, n = n + Math.imul(z2, pe) | 0, n = n + Math.imul(H, ce) | 0, d = d + Math.imul(H, pe) | 0, l = l + Math.imul(F, ve) | 0, n = n + Math.imul(F, be) | 0, n = n + Math.imul(U, ve) | 0, d = d + Math.imul(U, be) | 0;
        var Xe = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, l = Math.imul(G, oe), n = Math.imul(G, se), n = n + Math.imul(Y, oe) | 0, d = Math.imul(Y, se), l = l + Math.imul(V, he) | 0, n = n + Math.imul(V, ue) | 0, n = n + Math.imul($2, he) | 0, d = d + Math.imul($2, ue) | 0, l = l + Math.imul(j, le) | 0, n = n + Math.imul(j, de) | 0, n = n + Math.imul(Z, le) | 0, d = d + Math.imul(Z, de) | 0, l = l + Math.imul(W, ce) | 0, n = n + Math.imul(W, pe) | 0, n = n + Math.imul(K, ce) | 0, d = d + Math.imul(K, pe) | 0, l = l + Math.imul(z2, ve) | 0, n = n + Math.imul(z2, be) | 0, n = n + Math.imul(H, ve) | 0, d = d + Math.imul(H, be) | 0;
        var Je = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, l = Math.imul(G, he), n = Math.imul(G, ue), n = n + Math.imul(Y, he) | 0, d = Math.imul(Y, ue), l = l + Math.imul(V, le) | 0, n = n + Math.imul(V, de) | 0, n = n + Math.imul($2, le) | 0, d = d + Math.imul($2, de) | 0, l = l + Math.imul(j, ce) | 0, n = n + Math.imul(j, pe) | 0, n = n + Math.imul(Z, ce) | 0, d = d + Math.imul(Z, pe) | 0, l = l + Math.imul(W, ve) | 0, n = n + Math.imul(W, be) | 0, n = n + Math.imul(K, ve) | 0, d = d + Math.imul(K, be) | 0;
        var Qe = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, l = Math.imul(G, le), n = Math.imul(G, de), n = n + Math.imul(Y, le) | 0, d = Math.imul(Y, de), l = l + Math.imul(V, ce) | 0, n = n + Math.imul(V, pe) | 0, n = n + Math.imul($2, ce) | 0, d = d + Math.imul($2, pe) | 0, l = l + Math.imul(j, ve) | 0, n = n + Math.imul(j, be) | 0, n = n + Math.imul(Z, ve) | 0, d = d + Math.imul(Z, be) | 0;
        var et = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, l = Math.imul(G, ce), n = Math.imul(G, pe), n = n + Math.imul(Y, ce) | 0, d = Math.imul(Y, pe), l = l + Math.imul(V, ve) | 0, n = n + Math.imul(V, be) | 0, n = n + Math.imul($2, ve) | 0, d = d + Math.imul($2, be) | 0;
        var tt = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, l = Math.imul(G, ve), n = Math.imul(G, be), n = n + Math.imul(Y, ve) | 0, d = Math.imul(Y, be);
        var rt = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        return b2 = (d + (n >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, c[0] = ft, c[1] = Be, c[2] = qe, c[3] = ze, c[4] = He, c[5] = We, c[6] = Ke, c[7] = je, c[8] = Ze, c[9] = Ve, c[10] = $e, c[11] = Ge, c[12] = Ye, c[13] = Xe, c[14] = Je, c[15] = Qe, c[16] = et, c[17] = tt, c[18] = rt, b2 !== 0 && (c[19] = b2, h.length++), h;
      };
      Math.imul || (T = q);
      function ye(v2, i, a) {
        a.negative = i.negative ^ v2.negative, a.length = v2.length + i.length;
        for (var h = 0, s = 0, u = 0;u < a.length - 1; u++) {
          var c = s;
          s = 0;
          for (var b2 = h & 67108863, l = Math.min(u, i.length - 1), n = Math.max(0, u - v2.length + 1);n <= l; n++) {
            var d = u - n, w = v2.words[d] | 0, g = i.words[n] | 0, _2 = w * g, A = _2 & 67108863;
            c = c + (_2 / 67108864 | 0) | 0, A = A + b2 | 0, b2 = A & 67108863, c = c + (A >>> 26) | 0, s += c >>> 26, c &= 67108863;
          }
          a.words[u] = b2, h = c, c = s;
        }
        return h !== 0 ? a.words[u] = h : a.length--, a.strip();
      }
      function _e(v2, i, a) {
        var h = new P;
        return h.mulp(v2, i, a);
      }
      f2.prototype.mulTo = function(i, a) {
        var h, s = this.length + i.length;
        return this.length === 10 && i.length === 10 ? h = T(this, i, a) : s < 63 ? h = q(this, i, a) : s < 1024 ? h = ye(this, i, a) : h = _e(this, i, a), h;
      };
      function P(v2, i) {
        this.x = v2, this.y = i;
      }
      P.prototype.makeRBT = function(i) {
        for (var a = new Array(i), h = f2.prototype._countBits(i) - 1, s = 0;s < i; s++)
          a[s] = this.revBin(s, h, i);
        return a;
      }, P.prototype.revBin = function(i, a, h) {
        if (i === 0 || i === h - 1)
          return i;
        for (var s = 0, u = 0;u < a; u++)
          s |= (i & 1) << a - u - 1, i >>= 1;
        return s;
      }, P.prototype.permute = function(i, a, h, s, u, c) {
        for (var b2 = 0;b2 < c; b2++)
          s[b2] = a[i[b2]], u[b2] = h[i[b2]];
      }, P.prototype.transform = function(i, a, h, s, u, c) {
        this.permute(c, i, a, h, s, u);
        for (var b2 = 1;b2 < u; b2 <<= 1)
          for (var l = b2 << 1, n = Math.cos(2 * Math.PI / l), d = Math.sin(2 * Math.PI / l), w = 0;w < u; w += l)
            for (var g = n, _2 = d, A = 0;A < b2; A++) {
              var B = h[w + A], I = s[w + A], we = h[w + A + b2], L = s[w + A + b2], N = g * we - _2 * L;
              L = g * L + _2 * we, we = N, h[w + A] = B + we, s[w + A] = I + L, h[w + A + b2] = B - we, s[w + A + b2] = I - L, A !== l && (N = n * g - d * _2, _2 = n * _2 + d * g, g = N);
            }
      }, P.prototype.guessLen13b = function(i, a) {
        var h = Math.max(a, i) | 1, s = h & 1, u = 0;
        for (h = h / 2 | 0;h; h = h >>> 1)
          u++;
        return 1 << u + 1 + s;
      }, P.prototype.conjugate = function(i, a, h) {
        if (!(h <= 1))
          for (var s = 0;s < h / 2; s++) {
            var u = i[s];
            i[s] = i[h - s - 1], i[h - s - 1] = u, u = a[s], a[s] = -a[h - s - 1], a[h - s - 1] = -u;
          }
      }, P.prototype.normalize13b = function(i, a) {
        for (var h = 0, s = 0;s < a / 2; s++) {
          var u = Math.round(i[2 * s + 1] / a) * 8192 + Math.round(i[2 * s] / a) + h;
          i[s] = u & 67108863, u < 67108864 ? h = 0 : h = u / 67108864 | 0;
        }
        return i;
      }, P.prototype.convert13b = function(i, a, h, s) {
        for (var u = 0, c = 0;c < a; c++)
          u = u + (i[c] | 0), h[2 * c] = u & 8191, u = u >>> 13, h[2 * c + 1] = u & 8191, u = u >>> 13;
        for (c = 2 * a;c < s; ++c)
          h[c] = 0;
        r(u === 0), r((u & -8192) === 0);
      }, P.prototype.stub = function(i) {
        for (var a = new Array(i), h = 0;h < i; h++)
          a[h] = 0;
        return a;
      }, P.prototype.mulp = function(i, a, h) {
        var s = 2 * this.guessLen13b(i.length, a.length), u = this.makeRBT(s), c = this.stub(s), b2 = new Array(s), l = new Array(s), n = new Array(s), d = new Array(s), w = new Array(s), g = new Array(s), _2 = h.words;
        _2.length = s, this.convert13b(i.words, i.length, b2, s), this.convert13b(a.words, a.length, d, s), this.transform(b2, c, l, n, s, u), this.transform(d, c, w, g, s, u);
        for (var A = 0;A < s; A++) {
          var B = l[A] * w[A] - n[A] * g[A];
          n[A] = l[A] * g[A] + n[A] * w[A], l[A] = B;
        }
        return this.conjugate(l, n, s), this.transform(l, n, _2, c, s, u), this.conjugate(_2, c, s), this.normalize13b(_2, s), h.negative = i.negative ^ a.negative, h.length = i.length + a.length, h.strip();
      }, f2.prototype.mul = function(i) {
        var a = new f2(null);
        return a.words = new Array(this.length + i.length), this.mulTo(i, a);
      }, f2.prototype.mulf = function(i) {
        var a = new f2(null);
        return a.words = new Array(this.length + i.length), _e(this, i, a);
      }, f2.prototype.imul = function(i) {
        return this.clone().mulTo(i, this);
      }, f2.prototype.imuln = function(i) {
        r(typeof i == "number"), r(i < 67108864);
        for (var a = 0, h = 0;h < this.length; h++) {
          var s = (this.words[h] | 0) * i, u = (s & 67108863) + (a & 67108863);
          a >>= 26, a += s / 67108864 | 0, a += u >>> 26, this.words[h] = u & 67108863;
        }
        return a !== 0 && (this.words[h] = a, this.length++), this;
      }, f2.prototype.muln = function(i) {
        return this.clone().imuln(i);
      }, f2.prototype.sqr = function() {
        return this.mul(this);
      }, f2.prototype.isqr = function() {
        return this.imul(this.clone());
      }, f2.prototype.pow = function(i) {
        var a = R(i);
        if (a.length === 0)
          return new f2(1);
        for (var h = this, s = 0;s < a.length && a[s] === 0; s++, h = h.sqr())
          ;
        if (++s < a.length)
          for (var u = h.sqr();s < a.length; s++, u = u.sqr())
            a[s] !== 0 && (h = h.mul(u));
        return h;
      }, f2.prototype.iushln = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 67108863 >>> 26 - a << 26 - a, u;
        if (a !== 0) {
          var c = 0;
          for (u = 0;u < this.length; u++) {
            var b2 = this.words[u] & s, l = (this.words[u] | 0) - b2 << a;
            this.words[u] = l | c, c = b2 >>> 26 - a;
          }
          c && (this.words[u] = c, this.length++);
        }
        if (h !== 0) {
          for (u = this.length - 1;u >= 0; u--)
            this.words[u + h] = this.words[u];
          for (u = 0;u < h; u++)
            this.words[u] = 0;
          this.length += h;
        }
        return this.strip();
      }, f2.prototype.ishln = function(i) {
        return r(this.negative === 0), this.iushln(i);
      }, f2.prototype.iushrn = function(i, a, h) {
        r(typeof i == "number" && i >= 0);
        var s;
        a ? s = (a - a % 26) / 26 : s = 0;
        var u = i % 26, c = Math.min((i - u) / 26, this.length), b2 = 67108863 ^ 67108863 >>> u << u, l = h;
        if (s -= c, s = Math.max(0, s), l) {
          for (var n = 0;n < c; n++)
            l.words[n] = this.words[n];
          l.length = c;
        }
        if (c !== 0)
          if (this.length > c)
            for (this.length -= c, n = 0;n < this.length; n++)
              this.words[n] = this.words[n + c];
          else
            this.words[0] = 0, this.length = 1;
        var d = 0;
        for (n = this.length - 1;n >= 0 && (d !== 0 || n >= s); n--) {
          var w = this.words[n] | 0;
          this.words[n] = d << 26 - u | w >>> u, d = w & b2;
        }
        return l && d !== 0 && (l.words[l.length++] = d), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, f2.prototype.ishrn = function(i, a, h) {
        return r(this.negative === 0), this.iushrn(i, a, h);
      }, f2.prototype.shln = function(i) {
        return this.clone().ishln(i);
      }, f2.prototype.ushln = function(i) {
        return this.clone().iushln(i);
      }, f2.prototype.shrn = function(i) {
        return this.clone().ishrn(i);
      }, f2.prototype.ushrn = function(i) {
        return this.clone().iushrn(i);
      }, f2.prototype.testn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return false;
        var u = this.words[h];
        return !!(u & s);
      }, f2.prototype.imaskn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= h)
          return this;
        if (a !== 0 && h++, this.length = Math.min(h, this.length), a !== 0) {
          var s = 67108863 ^ 67108863 >>> a << a;
          this.words[this.length - 1] &= s;
        }
        return this.strip();
      }, f2.prototype.maskn = function(i) {
        return this.clone().imaskn(i);
      }, f2.prototype.iaddn = function(i) {
        return r(typeof i == "number"), r(i < 67108864), i < 0 ? this.isubn(-i) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < i ? (this.words[0] = i - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(i), this.negative = 1, this) : this._iaddn(i);
      }, f2.prototype._iaddn = function(i) {
        this.words[0] += i;
        for (var a = 0;a < this.length && this.words[a] >= 67108864; a++)
          this.words[a] -= 67108864, a === this.length - 1 ? this.words[a + 1] = 1 : this.words[a + 1]++;
        return this.length = Math.max(this.length, a + 1), this;
      }, f2.prototype.isubn = function(i) {
        if (r(typeof i == "number"), r(i < 67108864), i < 0)
          return this.iaddn(-i);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(i), this.negative = 1, this;
        if (this.words[0] -= i, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var a = 0;a < this.length && this.words[a] < 0; a++)
            this.words[a] += 67108864, this.words[a + 1] -= 1;
        return this.strip();
      }, f2.prototype.addn = function(i) {
        return this.clone().iaddn(i);
      }, f2.prototype.subn = function(i) {
        return this.clone().isubn(i);
      }, f2.prototype.iabs = function() {
        return this.negative = 0, this;
      }, f2.prototype.abs = function() {
        return this.clone().iabs();
      }, f2.prototype._ishlnsubmul = function(i, a, h) {
        var s = i.length + h, u;
        this._expand(s);
        var c, b2 = 0;
        for (u = 0;u < i.length; u++) {
          c = (this.words[u + h] | 0) + b2;
          var l = (i.words[u] | 0) * a;
          c -= l & 67108863, b2 = (c >> 26) - (l / 67108864 | 0), this.words[u + h] = c & 67108863;
        }
        for (;u < this.length - h; u++)
          c = (this.words[u + h] | 0) + b2, b2 = c >> 26, this.words[u + h] = c & 67108863;
        if (b2 === 0)
          return this.strip();
        for (r(b2 === -1), b2 = 0, u = 0;u < this.length; u++)
          c = -(this.words[u] | 0) + b2, b2 = c >> 26, this.words[u] = c & 67108863;
        return this.negative = 1, this.strip();
      }, f2.prototype._wordDiv = function(i, a) {
        var h = this.length - i.length, s = this.clone(), u = i, c = u.words[u.length - 1] | 0, b2 = this._countBits(c);
        h = 26 - b2, h !== 0 && (u = u.ushln(h), s.iushln(h), c = u.words[u.length - 1] | 0);
        var l = s.length - u.length, n;
        if (a !== "mod") {
          n = new f2(null), n.length = l + 1, n.words = new Array(n.length);
          for (var d = 0;d < n.length; d++)
            n.words[d] = 0;
        }
        var w = s.clone()._ishlnsubmul(u, 1, l);
        w.negative === 0 && (s = w, n && (n.words[l] = 1));
        for (var g = l - 1;g >= 0; g--) {
          var _2 = (s.words[u.length + g] | 0) * 67108864 + (s.words[u.length + g - 1] | 0);
          for (_2 = Math.min(_2 / c | 0, 67108863), s._ishlnsubmul(u, _2, g);s.negative !== 0; )
            _2--, s.negative = 0, s._ishlnsubmul(u, 1, g), s.isZero() || (s.negative ^= 1);
          n && (n.words[g] = _2);
        }
        return n && n.strip(), s.strip(), a !== "div" && h !== 0 && s.iushrn(h), { div: n || null, mod: s };
      }, f2.prototype.divmod = function(i, a, h) {
        if (r(!i.isZero()), this.isZero())
          return { div: new f2(0), mod: new f2(0) };
        var s, u, c;
        return this.negative !== 0 && i.negative === 0 ? (c = this.neg().divmod(i, a), a !== "mod" && (s = c.div.neg()), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.iadd(i)), { div: s, mod: u }) : this.negative === 0 && i.negative !== 0 ? (c = this.divmod(i.neg(), a), a !== "mod" && (s = c.div.neg()), { div: s, mod: c.mod }) : (this.negative & i.negative) !== 0 ? (c = this.neg().divmod(i.neg(), a), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.isub(i)), { div: c.div, mod: u }) : i.length > this.length || this.cmp(i) < 0 ? { div: new f2(0), mod: this } : i.length === 1 ? a === "div" ? { div: this.divn(i.words[0]), mod: null } : a === "mod" ? { div: null, mod: new f2(this.modn(i.words[0])) } : { div: this.divn(i.words[0]), mod: new f2(this.modn(i.words[0])) } : this._wordDiv(i, a);
      }, f2.prototype.div = function(i) {
        return this.divmod(i, "div", false).div;
      }, f2.prototype.mod = function(i) {
        return this.divmod(i, "mod", false).mod;
      }, f2.prototype.umod = function(i) {
        return this.divmod(i, "mod", true).mod;
      }, f2.prototype.divRound = function(i) {
        var a = this.divmod(i);
        if (a.mod.isZero())
          return a.div;
        var h = a.div.negative !== 0 ? a.mod.isub(i) : a.mod, s = i.ushrn(1), u = i.andln(1), c = h.cmp(s);
        return c < 0 || u === 1 && c === 0 ? a.div : a.div.negative !== 0 ? a.div.isubn(1) : a.div.iaddn(1);
      }, f2.prototype.modn = function(i) {
        r(i <= 67108863);
        for (var a = (1 << 26) % i, h = 0, s = this.length - 1;s >= 0; s--)
          h = (a * h + (this.words[s] | 0)) % i;
        return h;
      }, f2.prototype.idivn = function(i) {
        r(i <= 67108863);
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = (this.words[h] | 0) + a * 67108864;
          this.words[h] = s / i | 0, a = s % i;
        }
        return this.strip();
      }, f2.prototype.divn = function(i) {
        return this.clone().idivn(i);
      }, f2.prototype.egcd = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f2(1), u = new f2(0), c = new f2(0), b2 = new f2(1), l = 0;a.isEven() && h.isEven(); )
          a.iushrn(1), h.iushrn(1), ++l;
        for (var n = h.clone(), d = a.clone();!a.isZero(); ) {
          for (var w = 0, g = 1;(a.words[0] & g) === 0 && w < 26; ++w, g <<= 1)
            ;
          if (w > 0)
            for (a.iushrn(w);w-- > 0; )
              (s.isOdd() || u.isOdd()) && (s.iadd(n), u.isub(d)), s.iushrn(1), u.iushrn(1);
          for (var _2 = 0, A = 1;(h.words[0] & A) === 0 && _2 < 26; ++_2, A <<= 1)
            ;
          if (_2 > 0)
            for (h.iushrn(_2);_2-- > 0; )
              (c.isOdd() || b2.isOdd()) && (c.iadd(n), b2.isub(d)), c.iushrn(1), b2.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(c), u.isub(b2)) : (h.isub(a), c.isub(s), b2.isub(u));
        }
        return { a: c, b: b2, gcd: h.iushln(l) };
      }, f2.prototype._invmp = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f2(1), u = new f2(0), c = h.clone();a.cmpn(1) > 0 && h.cmpn(1) > 0; ) {
          for (var b2 = 0, l = 1;(a.words[0] & l) === 0 && b2 < 26; ++b2, l <<= 1)
            ;
          if (b2 > 0)
            for (a.iushrn(b2);b2-- > 0; )
              s.isOdd() && s.iadd(c), s.iushrn(1);
          for (var n = 0, d = 1;(h.words[0] & d) === 0 && n < 26; ++n, d <<= 1)
            ;
          if (n > 0)
            for (h.iushrn(n);n-- > 0; )
              u.isOdd() && u.iadd(c), u.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(u)) : (h.isub(a), u.isub(s));
        }
        var w;
        return a.cmpn(1) === 0 ? w = s : w = u, w.cmpn(0) < 0 && w.iadd(i), w;
      }, f2.prototype.gcd = function(i) {
        if (this.isZero())
          return i.abs();
        if (i.isZero())
          return this.abs();
        var a = this.clone(), h = i.clone();
        a.negative = 0, h.negative = 0;
        for (var s = 0;a.isEven() && h.isEven(); s++)
          a.iushrn(1), h.iushrn(1);
        do {
          for (;a.isEven(); )
            a.iushrn(1);
          for (;h.isEven(); )
            h.iushrn(1);
          var u = a.cmp(h);
          if (u < 0) {
            var c = a;
            a = h, h = c;
          } else if (u === 0 || h.cmpn(1) === 0)
            break;
          a.isub(h);
        } while (true);
        return h.iushln(s);
      }, f2.prototype.invm = function(i) {
        return this.egcd(i).a.umod(i);
      }, f2.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, f2.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, f2.prototype.andln = function(i) {
        return this.words[0] & i;
      }, f2.prototype.bincn = function(i) {
        r(typeof i == "number");
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return this._expand(h + 1), this.words[h] |= s, this;
        for (var u = s, c = h;u !== 0 && c < this.length; c++) {
          var b2 = this.words[c] | 0;
          b2 += u, u = b2 >>> 26, b2 &= 67108863, this.words[c] = b2;
        }
        return u !== 0 && (this.words[c] = u, this.length++), this;
      }, f2.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, f2.prototype.cmpn = function(i) {
        var a = i < 0;
        if (this.negative !== 0 && !a)
          return -1;
        if (this.negative === 0 && a)
          return 1;
        this.strip();
        var h;
        if (this.length > 1)
          h = 1;
        else {
          a && (i = -i), r(i <= 67108863, "Number is too big");
          var s = this.words[0] | 0;
          h = s === i ? 0 : s < i ? -1 : 1;
        }
        return this.negative !== 0 ? -h | 0 : h;
      }, f2.prototype.cmp = function(i) {
        if (this.negative !== 0 && i.negative === 0)
          return -1;
        if (this.negative === 0 && i.negative !== 0)
          return 1;
        var a = this.ucmp(i);
        return this.negative !== 0 ? -a | 0 : a;
      }, f2.prototype.ucmp = function(i) {
        if (this.length > i.length)
          return 1;
        if (this.length < i.length)
          return -1;
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = this.words[h] | 0, u = i.words[h] | 0;
          if (s !== u) {
            s < u ? a = -1 : s > u && (a = 1);
            break;
          }
        }
        return a;
      }, f2.prototype.gtn = function(i) {
        return this.cmpn(i) === 1;
      }, f2.prototype.gt = function(i) {
        return this.cmp(i) === 1;
      }, f2.prototype.gten = function(i) {
        return this.cmpn(i) >= 0;
      }, f2.prototype.gte = function(i) {
        return this.cmp(i) >= 0;
      }, f2.prototype.ltn = function(i) {
        return this.cmpn(i) === -1;
      }, f2.prototype.lt = function(i) {
        return this.cmp(i) === -1;
      }, f2.prototype.lten = function(i) {
        return this.cmpn(i) <= 0;
      }, f2.prototype.lte = function(i) {
        return this.cmp(i) <= 0;
      }, f2.prototype.eqn = function(i) {
        return this.cmpn(i) === 0;
      }, f2.prototype.eq = function(i) {
        return this.cmp(i) === 0;
      }, f2.red = function(i) {
        return new D2(i);
      }, f2.prototype.toRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), i.convertTo(this)._forceRed(i);
      }, f2.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, f2.prototype._forceRed = function(i) {
        return this.red = i, this;
      }, f2.prototype.forceRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(i);
      }, f2.prototype.redAdd = function(i) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, i);
      }, f2.prototype.redIAdd = function(i) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, i);
      }, f2.prototype.redSub = function(i) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, i);
      }, f2.prototype.redISub = function(i) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, i);
      }, f2.prototype.redShl = function(i) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, i);
      }, f2.prototype.redMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.mul(this, i);
      }, f2.prototype.redIMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.imul(this, i);
      }, f2.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, f2.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, f2.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, f2.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, f2.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, f2.prototype.redPow = function(i) {
        return r(this.red && !i.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, i);
      };
      var Me = { k256: null, p224: null, p192: null, p25519: null };
      function me(v2, i) {
        this.name = v2, this.p = new f2(i, 16), this.n = this.p.bitLength(), this.k = new f2(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      me.prototype._tmp = function() {
        var i = new f2(null);
        return i.words = new Array(Math.ceil(this.n / 13)), i;
      }, me.prototype.ireduce = function(i) {
        var a = i, h;
        do
          this.split(a, this.tmp), a = this.imulK(a), a = a.iadd(this.tmp), h = a.bitLength();
        while (h > this.n);
        var s = h < this.n ? -1 : a.ucmp(this.p);
        return s === 0 ? (a.words[0] = 0, a.length = 1) : s > 0 ? a.isub(this.p) : a.strip !== undefined ? a.strip() : a._strip(), a;
      }, me.prototype.split = function(i, a) {
        i.iushrn(this.n, 0, a);
      }, me.prototype.imulK = function(i) {
        return i.imul(this.k);
      };
      function xe() {
        me.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      o(xe, me), xe.prototype.split = function(i, a) {
        for (var h = 4194303, s = Math.min(i.length, 9), u = 0;u < s; u++)
          a.words[u] = i.words[u];
        if (a.length = s, i.length <= 9) {
          i.words[0] = 0, i.length = 1;
          return;
        }
        var c = i.words[9];
        for (a.words[a.length++] = c & h, u = 10;u < i.length; u++) {
          var b2 = i.words[u] | 0;
          i.words[u - 10] = (b2 & h) << 4 | c >>> 22, c = b2;
        }
        c >>>= 22, i.words[u - 10] = c, c === 0 && i.length > 10 ? i.length -= 10 : i.length -= 9;
      }, xe.prototype.imulK = function(i) {
        i.words[i.length] = 0, i.words[i.length + 1] = 0, i.length += 2;
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = i.words[h] | 0;
          a += s * 977, i.words[h] = a & 67108863, a = s * 64 + (a / 67108864 | 0);
        }
        return i.words[i.length - 1] === 0 && (i.length--, i.words[i.length - 1] === 0 && i.length--), i;
      };
      function Ae() {
        me.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      o(Ae, me);
      function Ee() {
        me.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      o(Ee, me);
      function Re() {
        me.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      o(Re, me), Re.prototype.imulK = function(i) {
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = (i.words[h] | 0) * 19 + a, u = s & 67108863;
          s >>>= 26, i.words[h] = u, a = s;
        }
        return a !== 0 && (i.words[i.length++] = a), i;
      }, f2._prime = function(i) {
        if (Me[i])
          return Me[i];
        var a;
        if (i === "k256")
          a = new xe;
        else if (i === "p224")
          a = new Ae;
        else if (i === "p192")
          a = new Ee;
        else if (i === "p25519")
          a = new Re;
        else
          throw new Error("Unknown prime " + i);
        return Me[i] = a, a;
      };
      function D2(v2) {
        if (typeof v2 == "string") {
          var i = f2._prime(v2);
          this.m = i.p, this.prime = i;
        } else
          r(v2.gtn(1), "modulus must be greater than 1"), this.m = v2, this.prime = null;
      }
      D2.prototype._verify1 = function(i) {
        r(i.negative === 0, "red works only with positives"), r(i.red, "red works only with red numbers");
      }, D2.prototype._verify2 = function(i, a) {
        r((i.negative | a.negative) === 0, "red works only with positives"), r(i.red && i.red === a.red, "red works only with red numbers");
      }, D2.prototype.imod = function(i) {
        return this.prime ? this.prime.ireduce(i)._forceRed(this) : i.umod(this.m)._forceRed(this);
      }, D2.prototype.neg = function(i) {
        return i.isZero() ? i.clone() : this.m.sub(i)._forceRed(this);
      }, D2.prototype.add = function(i, a) {
        this._verify2(i, a);
        var h = i.add(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h._forceRed(this);
      }, D2.prototype.iadd = function(i, a) {
        this._verify2(i, a);
        var h = i.iadd(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h;
      }, D2.prototype.sub = function(i, a) {
        this._verify2(i, a);
        var h = i.sub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h._forceRed(this);
      }, D2.prototype.isub = function(i, a) {
        this._verify2(i, a);
        var h = i.isub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h;
      }, D2.prototype.shl = function(i, a) {
        return this._verify1(i), this.imod(i.ushln(a));
      }, D2.prototype.imul = function(i, a) {
        return this._verify2(i, a), this.imod(i.imul(a));
      }, D2.prototype.mul = function(i, a) {
        return this._verify2(i, a), this.imod(i.mul(a));
      }, D2.prototype.isqr = function(i) {
        return this.imul(i, i.clone());
      }, D2.prototype.sqr = function(i) {
        return this.mul(i, i);
      }, D2.prototype.sqrt = function(i) {
        if (i.isZero())
          return i.clone();
        var a = this.m.andln(3);
        if (r(a % 2 === 1), a === 3) {
          var h = this.m.add(new f2(1)).iushrn(2);
          return this.pow(i, h);
        }
        for (var s = this.m.subn(1), u = 0;!s.isZero() && s.andln(1) === 0; )
          u++, s.iushrn(1);
        r(!s.isZero());
        var c = new f2(1).toRed(this), b2 = c.redNeg(), l = this.m.subn(1).iushrn(1), n = this.m.bitLength();
        for (n = new f2(2 * n * n).toRed(this);this.pow(n, l).cmp(b2) !== 0; )
          n.redIAdd(b2);
        for (var d = this.pow(n, s), w = this.pow(i, s.addn(1).iushrn(1)), g = this.pow(i, s), _2 = u;g.cmp(c) !== 0; ) {
          for (var A = g, B = 0;A.cmp(c) !== 0; B++)
            A = A.redSqr();
          r(B < _2);
          var I = this.pow(d, new f2(1).iushln(_2 - B - 1));
          w = w.redMul(I), d = I.redSqr(), g = g.redMul(d), _2 = B;
        }
        return w;
      }, D2.prototype.invm = function(i) {
        var a = i._invmp(this.m);
        return a.negative !== 0 ? (a.negative = 0, this.imod(a).redNeg()) : this.imod(a);
      }, D2.prototype.pow = function(i, a) {
        if (a.isZero())
          return new f2(1).toRed(this);
        if (a.cmpn(1) === 0)
          return i.clone();
        var h = 4, s = new Array(1 << h);
        s[0] = new f2(1).toRed(this), s[1] = i;
        for (var u = 2;u < s.length; u++)
          s[u] = this.mul(s[u - 1], i);
        var c = s[0], b2 = 0, l = 0, n = a.bitLength() % 26;
        for (n === 0 && (n = 26), u = a.length - 1;u >= 0; u--) {
          for (var d = a.words[u], w = n - 1;w >= 0; w--) {
            var g = d >> w & 1;
            if (c !== s[0] && (c = this.sqr(c)), g === 0 && b2 === 0) {
              l = 0;
              continue;
            }
            b2 <<= 1, b2 |= g, l++, !(l !== h && (u !== 0 || w !== 0)) && (c = this.mul(c, s[b2]), l = 0, b2 = 0);
          }
          n = 26;
        }
        return c;
      }, D2.prototype.convertTo = function(i) {
        var a = i.umod(this.m);
        return a === i ? a.clone() : a;
      }, D2.prototype.convertFrom = function(i) {
        var a = i.clone();
        return a.red = null, a;
      }, f2.mont = function(i) {
        return new Se(i);
      };
      function Se(v2) {
        D2.call(this, v2), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f2(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o(Se, D2), Se.prototype.convertTo = function(i) {
        return this.imod(i.ushln(this.shift));
      }, Se.prototype.convertFrom = function(i) {
        var a = this.imod(i.mul(this.rinv));
        return a.red = null, a;
      }, Se.prototype.imul = function(i, a) {
        if (i.isZero() || a.isZero())
          return i.words[0] = 0, i.length = 1, i;
        var h = i.imul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se.prototype.mul = function(i, a) {
        if (i.isZero() || a.isZero())
          return new f2(0)._forceRed(this);
        var h = i.mul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se.prototype.invm = function(i) {
        var a = this.imod(i._invmp(this.m).mul(this.r2));
        return a._forceRed(this);
      };
    })(typeof Dd > "u" || Dd, a3);
  });
  h3 = k((dN, s3) => {
    var sI = d0(), hI = o3();
    s3.exports = function(e) {
      return new Xn(e);
    };
    var hr = { secp256k1: { name: "secp256k1", byteLength: 32 }, secp224r1: { name: "p224", byteLength: 28 }, prime256v1: { name: "p256", byteLength: 32 }, prime192v1: { name: "p192", byteLength: 24 }, ed25519: { name: "ed25519", byteLength: 32 }, secp384r1: { name: "p384", byteLength: 48 }, secp521r1: { name: "p521", byteLength: 66 } };
    hr.p224 = hr.secp224r1;
    hr.p256 = hr.secp256r1 = hr.prime256v1;
    hr.p192 = hr.secp192r1 = hr.prime192v1;
    hr.p384 = hr.secp384r1;
    hr.p521 = hr.secp521r1;
    function Xn(t) {
      this.curveType = hr[t], this.curveType || (this.curveType = { name: t }), this.curve = new sI.ec(this.curveType.name), this.keys = undefined;
    }
    Xn.prototype.generateKeys = function(t, e) {
      return this.keys = this.curve.genKeyPair(), this.getPublicKey(t, e);
    };
    Xn.prototype.computeSecret = function(t, e, r) {
      e = e || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e));
      var o = this.curve.keyFromPublic(t).getPublic(), f2 = o.mul(this.keys.getPrivate()).getX();
      return Cd(f2, r, this.curveType.byteLength);
    };
    Xn.prototype.getPublicKey = function(t, e) {
      var r = this.keys.getPublic(e === "compressed", true);
      return e === "hybrid" && (r[r.length - 1] % 2 ? r[0] = 7 : r[0] = 6), Cd(r, t);
    };
    Xn.prototype.getPrivateKey = function(t) {
      return Cd(this.keys.getPrivate(), t);
    };
    Xn.prototype.setPublicKey = function(t, e) {
      return e = e || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e)), this.keys._importPublic(t), this;
    };
    Xn.prototype.setPrivateKey = function(t, e) {
      e = e || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e));
      var r = new hI(t);
      return r = r.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(r), this;
    };
    function Cd(t, e, r) {
      Array.isArray(t) || (t = t.toArray());
      var o = new Buffer(t);
      if (r && o.length < r) {
        var f2 = new Buffer(r - o.length);
        f2.fill(0), o = Buffer.concat([f2, o]);
      }
      return e ? o.toString(e) : o;
    }
  });
  Fd = k((cN, u3) => {
    var uI = yf(), Od = Te().Buffer;
    u3.exports = function(t, e) {
      for (var r = Od.alloc(0), o = 0, f2;r.length < e; )
        f2 = lI(o++), r = Od.concat([r, uI("sha1").update(t).update(f2).digest()]);
      return r.slice(0, e);
    };
    function lI(t) {
      var e = Od.allocUnsafe(4);
      return e.writeUInt32BE(t, 0), e;
    }
  });
  Ud = k((pN, l3) => {
    l3.exports = function(e, r) {
      for (var o = e.length, f2 = -1;++f2 < o; )
        e[f2] ^= r[f2];
      return e;
    };
  });
  E0 = k((d3, zd) => {
    (function(t, e) {
      function r(v2, i) {
        if (!v2)
          throw new Error(i || "Assertion failed");
      }
      function o(v2, i) {
        v2.super_ = i;
        var a = function() {
        };
        a.prototype = i.prototype, v2.prototype = new a, v2.prototype.constructor = v2;
      }
      function f2(v2, i, a) {
        if (f2.isBN(v2))
          return v2;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, v2 !== null && ((i === "le" || i === "be") && (a = i, i = 10), this._init(v2 || 0, i || 10, a || "be"));
      }
      typeof t == "object" ? t.exports = f2 : e.BN = f2, f2.BN = f2, f2.wordSize = 26;
      var p;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? p = window.Buffer : p = Vi().Buffer;
      } catch {
      }
      f2.isBN = function(i) {
        return i instanceof f2 ? true : i !== null && typeof i == "object" && i.constructor.wordSize === f2.wordSize && Array.isArray(i.words);
      }, f2.max = function(i, a) {
        return i.cmp(a) > 0 ? i : a;
      }, f2.min = function(i, a) {
        return i.cmp(a) < 0 ? i : a;
      }, f2.prototype._init = function(i, a, h) {
        if (typeof i == "number")
          return this._initNumber(i, a, h);
        if (typeof i == "object")
          return this._initArray(i, a, h);
        a === "hex" && (a = 16), r(a === (a | 0) && a >= 2 && a <= 36), i = i.toString().replace(/\s+/g, "");
        var s = 0;
        i[0] === "-" && (s++, this.negative = 1), s < i.length && (a === 16 ? this._parseHex(i, s, h) : (this._parseBase(i, a, s), h === "le" && this._initArray(this.toArray(), a, h)));
      }, f2.prototype._initNumber = function(i, a, h) {
        i < 0 && (this.negative = 1, i = -i), i < 67108864 ? (this.words = [i & 67108863], this.length = 1) : i < 4503599627370496 ? (this.words = [i & 67108863, i / 67108864 & 67108863], this.length = 2) : (r(i < 9007199254740992), this.words = [i & 67108863, i / 67108864 & 67108863, 1], this.length = 3), h === "le" && this._initArray(this.toArray(), a, h);
      }, f2.prototype._initArray = function(i, a, h) {
        if (r(typeof i.length == "number"), i.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(i.length / 3), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u, c, b2 = 0;
        if (h === "be")
          for (s = i.length - 1, u = 0;s >= 0; s -= 3)
            c = i[s] | i[s - 1] << 8 | i[s - 2] << 16, this.words[u] |= c << b2 & 67108863, this.words[u + 1] = c >>> 26 - b2 & 67108863, b2 += 24, b2 >= 26 && (b2 -= 26, u++);
        else if (h === "le")
          for (s = 0, u = 0;s < i.length; s += 3)
            c = i[s] | i[s + 1] << 8 | i[s + 2] << 16, this.words[u] |= c << b2 & 67108863, this.words[u + 1] = c >>> 26 - b2 & 67108863, b2 += 24, b2 >= 26 && (b2 -= 26, u++);
        return this.strip();
      };
      function m(v2, i) {
        var a = v2.charCodeAt(i);
        return a >= 65 && a <= 70 ? a - 55 : a >= 97 && a <= 102 ? a - 87 : a - 48 & 15;
      }
      function y(v2, i, a) {
        var h = m(v2, a);
        return a - 1 >= i && (h |= m(v2, a - 1) << 4), h;
      }
      f2.prototype._parseHex = function(i, a, h) {
        this.length = Math.ceil((i.length - a) / 6), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u = 0, c = 0, b2;
        if (h === "be")
          for (s = i.length - 1;s >= a; s -= 2)
            b2 = y(i, a, s) << u, this.words[c] |= b2 & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b2 >>> 26) : u += 8;
        else {
          var l = i.length - a;
          for (s = l % 2 === 0 ? a + 1 : a;s < i.length; s += 2)
            b2 = y(i, a, s) << u, this.words[c] |= b2 & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b2 >>> 26) : u += 8;
        }
        this.strip();
      };
      function M(v2, i, a, h) {
        for (var s = 0, u = Math.min(v2.length, a), c = i;c < u; c++) {
          var b2 = v2.charCodeAt(c) - 48;
          s *= h, b2 >= 49 ? s += b2 - 49 + 10 : b2 >= 17 ? s += b2 - 17 + 10 : s += b2;
        }
        return s;
      }
      f2.prototype._parseBase = function(i, a, h) {
        this.words = [0], this.length = 1;
        for (var s = 0, u = 1;u <= 67108863; u *= a)
          s++;
        s--, u = u / a | 0;
        for (var c = i.length - h, b2 = c % s, l = Math.min(c, c - b2) + h, n = 0, d = h;d < l; d += s)
          n = M(i, d, d + s, a), this.imuln(u), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        if (b2 !== 0) {
          var w = 1;
          for (n = M(i, d, i.length, a), d = 0;d < b2; d++)
            w *= a;
          this.imuln(w), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        }
        this.strip();
      }, f2.prototype.copy = function(i) {
        i.words = new Array(this.length);
        for (var a = 0;a < this.length; a++)
          i.words[a] = this.words[a];
        i.length = this.length, i.negative = this.negative, i.red = this.red;
      }, f2.prototype.clone = function() {
        var i = new f2(null);
        return this.copy(i), i;
      }, f2.prototype._expand = function(i) {
        for (;this.length < i; )
          this.words[this.length++] = 0;
        return this;
      }, f2.prototype.strip = function() {
        for (;this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, f2.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, f2.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var x = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], S2 = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], E = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      f2.prototype.toString = function(i, a) {
        i = i || 10, a = a | 0 || 1;
        var h;
        if (i === 16 || i === "hex") {
          h = "";
          for (var s = 0, u = 0, c = 0;c < this.length; c++) {
            var b2 = this.words[c], l = ((b2 << s | u) & 16777215).toString(16);
            u = b2 >>> 24 - s & 16777215, u !== 0 || c !== this.length - 1 ? h = x[6 - l.length] + l + h : h = l + h, s += 2, s >= 26 && (s -= 26, c--);
          }
          for (u !== 0 && (h = u.toString(16) + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        if (i === (i | 0) && i >= 2 && i <= 36) {
          var n = S2[i], d = E[i];
          h = "";
          var w = this.clone();
          for (w.negative = 0;!w.isZero(); ) {
            var g = w.modn(d).toString(i);
            w = w.idivn(d), w.isZero() ? h = g + h : h = x[n - g.length] + g + h;
          }
          for (this.isZero() && (h = "0" + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        r(false, "Base should be between 2 and 36");
      }, f2.prototype.toNumber = function() {
        var i = this.words[0];
        return this.length === 2 ? i += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? i += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -i : i;
      }, f2.prototype.toJSON = function() {
        return this.toString(16);
      }, f2.prototype.toBuffer = function(i, a) {
        return r(typeof p < "u"), this.toArrayLike(p, i, a);
      }, f2.prototype.toArray = function(i, a) {
        return this.toArrayLike(Array, i, a);
      }, f2.prototype.toArrayLike = function(i, a, h) {
        var s = this.byteLength(), u = h || Math.max(1, s);
        r(s <= u, "byte array longer than desired length"), r(u > 0, "Requested array length <= 0"), this.strip();
        var c = a === "le", b2 = new i(u), l, n, d = this.clone();
        if (c) {
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b2[n] = l;
          for (;n < u; n++)
            b2[n] = 0;
        } else {
          for (n = 0;n < u - s; n++)
            b2[n] = 0;
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b2[u - n - 1] = l;
        }
        return b2;
      }, Math.clz32 ? f2.prototype._countBits = function(i) {
        return 32 - Math.clz32(i);
      } : f2.prototype._countBits = function(i) {
        var a = i, h = 0;
        return a >= 4096 && (h += 13, a >>>= 13), a >= 64 && (h += 7, a >>>= 7), a >= 8 && (h += 4, a >>>= 4), a >= 2 && (h += 2, a >>>= 2), h + a;
      }, f2.prototype._zeroBits = function(i) {
        if (i === 0)
          return 26;
        var a = i, h = 0;
        return (a & 8191) === 0 && (h += 13, a >>>= 13), (a & 127) === 0 && (h += 7, a >>>= 7), (a & 15) === 0 && (h += 4, a >>>= 4), (a & 3) === 0 && (h += 2, a >>>= 2), (a & 1) === 0 && h++, h;
      }, f2.prototype.bitLength = function() {
        var i = this.words[this.length - 1], a = this._countBits(i);
        return (this.length - 1) * 26 + a;
      };
      function R(v2) {
        for (var i = new Array(v2.bitLength()), a = 0;a < i.length; a++) {
          var h = a / 26 | 0, s = a % 26;
          i[a] = (v2.words[h] & 1 << s) >>> s;
        }
        return i;
      }
      f2.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var i = 0, a = 0;a < this.length; a++) {
          var h = this._zeroBits(this.words[a]);
          if (i += h, h !== 26)
            break;
        }
        return i;
      }, f2.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, f2.prototype.toTwos = function(i) {
        return this.negative !== 0 ? this.abs().inotn(i).iaddn(1) : this.clone();
      }, f2.prototype.fromTwos = function(i) {
        return this.testn(i - 1) ? this.notn(i).iaddn(1).ineg() : this.clone();
      }, f2.prototype.isNeg = function() {
        return this.negative !== 0;
      }, f2.prototype.neg = function() {
        return this.clone().ineg();
      }, f2.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, f2.prototype.iuor = function(i) {
        for (;this.length < i.length; )
          this.words[this.length++] = 0;
        for (var a = 0;a < i.length; a++)
          this.words[a] = this.words[a] | i.words[a];
        return this.strip();
      }, f2.prototype.ior = function(i) {
        return r((this.negative | i.negative) === 0), this.iuor(i);
      }, f2.prototype.or = function(i) {
        return this.length > i.length ? this.clone().ior(i) : i.clone().ior(this);
      }, f2.prototype.uor = function(i) {
        return this.length > i.length ? this.clone().iuor(i) : i.clone().iuor(this);
      }, f2.prototype.iuand = function(i) {
        var a;
        this.length > i.length ? a = i : a = this;
        for (var h = 0;h < a.length; h++)
          this.words[h] = this.words[h] & i.words[h];
        return this.length = a.length, this.strip();
      }, f2.prototype.iand = function(i) {
        return r((this.negative | i.negative) === 0), this.iuand(i);
      }, f2.prototype.and = function(i) {
        return this.length > i.length ? this.clone().iand(i) : i.clone().iand(this);
      }, f2.prototype.uand = function(i) {
        return this.length > i.length ? this.clone().iuand(i) : i.clone().iuand(this);
      }, f2.prototype.iuxor = function(i) {
        var a, h;
        this.length > i.length ? (a = this, h = i) : (a = i, h = this);
        for (var s = 0;s < h.length; s++)
          this.words[s] = a.words[s] ^ h.words[s];
        if (this !== a)
          for (;s < a.length; s++)
            this.words[s] = a.words[s];
        return this.length = a.length, this.strip();
      }, f2.prototype.ixor = function(i) {
        return r((this.negative | i.negative) === 0), this.iuxor(i);
      }, f2.prototype.xor = function(i) {
        return this.length > i.length ? this.clone().ixor(i) : i.clone().ixor(this);
      }, f2.prototype.uxor = function(i) {
        return this.length > i.length ? this.clone().iuxor(i) : i.clone().iuxor(this);
      }, f2.prototype.inotn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = Math.ceil(i / 26) | 0, h = i % 26;
        this._expand(a), h > 0 && a--;
        for (var s = 0;s < a; s++)
          this.words[s] = ~this.words[s] & 67108863;
        return h > 0 && (this.words[s] = ~this.words[s] & 67108863 >> 26 - h), this.strip();
      }, f2.prototype.notn = function(i) {
        return this.clone().inotn(i);
      }, f2.prototype.setn = function(i, a) {
        r(typeof i == "number" && i >= 0);
        var h = i / 26 | 0, s = i % 26;
        return this._expand(h + 1), a ? this.words[h] = this.words[h] | 1 << s : this.words[h] = this.words[h] & ~(1 << s), this.strip();
      }, f2.prototype.iadd = function(i) {
        var a;
        if (this.negative !== 0 && i.negative === 0)
          return this.negative = 0, a = this.isub(i), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && i.negative !== 0)
          return i.negative = 0, a = this.isub(i), i.negative = 1, a._normSign();
        var h, s;
        this.length > i.length ? (h = this, s = i) : (h = i, s = this);
        for (var u = 0, c = 0;c < s.length; c++)
          a = (h.words[c] | 0) + (s.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        for (;u !== 0 && c < h.length; c++)
          a = (h.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        if (this.length = h.length, u !== 0)
          this.words[this.length] = u, this.length++;
        else if (h !== this)
          for (;c < h.length; c++)
            this.words[c] = h.words[c];
        return this;
      }, f2.prototype.add = function(i) {
        var a;
        return i.negative !== 0 && this.negative === 0 ? (i.negative = 0, a = this.sub(i), i.negative ^= 1, a) : i.negative === 0 && this.negative !== 0 ? (this.negative = 0, a = i.sub(this), this.negative = 1, a) : this.length > i.length ? this.clone().iadd(i) : i.clone().iadd(this);
      }, f2.prototype.isub = function(i) {
        if (i.negative !== 0) {
          i.negative = 0;
          var a = this.iadd(i);
          return i.negative = 1, a._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(i), this.negative = 1, this._normSign();
        var h = this.cmp(i);
        if (h === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var s, u;
        h > 0 ? (s = this, u = i) : (s = i, u = this);
        for (var c = 0, b2 = 0;b2 < u.length; b2++)
          a = (s.words[b2] | 0) - (u.words[b2] | 0) + c, c = a >> 26, this.words[b2] = a & 67108863;
        for (;c !== 0 && b2 < s.length; b2++)
          a = (s.words[b2] | 0) + c, c = a >> 26, this.words[b2] = a & 67108863;
        if (c === 0 && b2 < s.length && s !== this)
          for (;b2 < s.length; b2++)
            this.words[b2] = s.words[b2];
        return this.length = Math.max(this.length, b2), s !== this && (this.negative = 1), this.strip();
      }, f2.prototype.sub = function(i) {
        return this.clone().isub(i);
      };
      function q(v2, i, a) {
        a.negative = i.negative ^ v2.negative;
        var h = v2.length + i.length | 0;
        a.length = h, h = h - 1 | 0;
        var s = v2.words[0] | 0, u = i.words[0] | 0, c = s * u, b2 = c & 67108863, l = c / 67108864 | 0;
        a.words[0] = b2;
        for (var n = 1;n < h; n++) {
          for (var d = l >>> 26, w = l & 67108863, g = Math.min(n, i.length - 1), _2 = Math.max(0, n - v2.length + 1);_2 <= g; _2++) {
            var A = n - _2 | 0;
            s = v2.words[A] | 0, u = i.words[_2] | 0, c = s * u + w, d += c / 67108864 | 0, w = c & 67108863;
          }
          a.words[n] = w | 0, l = d | 0;
        }
        return l !== 0 ? a.words[n] = l | 0 : a.length--, a.strip();
      }
      var T = function(i, a, h) {
        var s = i.words, u = a.words, c = h.words, b2 = 0, l, n, d, w = s[0] | 0, g = w & 8191, _2 = w >>> 13, A = s[1] | 0, B = A & 8191, I = A >>> 13, we = s[2] | 0, L = we & 8191, N = we >>> 13, nt = s[3] | 0, C = nt & 8191, O = nt >>> 13, vt = s[4] | 0, F = vt & 8191, U = vt >>> 13, bt = s[5] | 0, z2 = bt & 8191, H = bt >>> 13, mt = s[6] | 0, W = mt & 8191, K = mt >>> 13, gt = s[7] | 0, j = gt & 8191, Z = gt >>> 13, yt = s[8] | 0, V = yt & 8191, $2 = yt >>> 13, wt = s[9] | 0, G = wt & 8191, Y = wt >>> 13, Mt = u[0] | 0, X = Mt & 8191, J2 = Mt >>> 13, _t = u[1] | 0, Q2 = _t & 8191, ee = _t >>> 13, xt = u[2] | 0, te = xt & 8191, re = xt >>> 13, St = u[3] | 0, ie = St & 8191, ne = St >>> 13, Et = u[4] | 0, fe = Et & 8191, ae = Et >>> 13, At = u[5] | 0, oe = At & 8191, se = At >>> 13, Rt = u[6] | 0, he = Rt & 8191, ue = Rt >>> 13, Bt = u[7] | 0, le = Bt & 8191, de = Bt >>> 13, qt = u[8] | 0, ce = qt & 8191, pe = qt >>> 13, It = u[9] | 0, ve = It & 8191, be = It >>> 13;
        h.negative = i.negative ^ a.negative, h.length = 19, l = Math.imul(g, X), n = Math.imul(g, J2), n = n + Math.imul(_2, X) | 0, d = Math.imul(_2, J2);
        var ft = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, l = Math.imul(B, X), n = Math.imul(B, J2), n = n + Math.imul(I, X) | 0, d = Math.imul(I, J2), l = l + Math.imul(g, Q2) | 0, n = n + Math.imul(g, ee) | 0, n = n + Math.imul(_2, Q2) | 0, d = d + Math.imul(_2, ee) | 0;
        var Be = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, l = Math.imul(L, X), n = Math.imul(L, J2), n = n + Math.imul(N, X) | 0, d = Math.imul(N, J2), l = l + Math.imul(B, Q2) | 0, n = n + Math.imul(B, ee) | 0, n = n + Math.imul(I, Q2) | 0, d = d + Math.imul(I, ee) | 0, l = l + Math.imul(g, te) | 0, n = n + Math.imul(g, re) | 0, n = n + Math.imul(_2, te) | 0, d = d + Math.imul(_2, re) | 0;
        var qe = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (qe >>> 26) | 0, qe &= 67108863, l = Math.imul(C, X), n = Math.imul(C, J2), n = n + Math.imul(O, X) | 0, d = Math.imul(O, J2), l = l + Math.imul(L, Q2) | 0, n = n + Math.imul(L, ee) | 0, n = n + Math.imul(N, Q2) | 0, d = d + Math.imul(N, ee) | 0, l = l + Math.imul(B, te) | 0, n = n + Math.imul(B, re) | 0, n = n + Math.imul(I, te) | 0, d = d + Math.imul(I, re) | 0, l = l + Math.imul(g, ie) | 0, n = n + Math.imul(g, ne) | 0, n = n + Math.imul(_2, ie) | 0, d = d + Math.imul(_2, ne) | 0;
        var ze = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, l = Math.imul(F, X), n = Math.imul(F, J2), n = n + Math.imul(U, X) | 0, d = Math.imul(U, J2), l = l + Math.imul(C, Q2) | 0, n = n + Math.imul(C, ee) | 0, n = n + Math.imul(O, Q2) | 0, d = d + Math.imul(O, ee) | 0, l = l + Math.imul(L, te) | 0, n = n + Math.imul(L, re) | 0, n = n + Math.imul(N, te) | 0, d = d + Math.imul(N, re) | 0, l = l + Math.imul(B, ie) | 0, n = n + Math.imul(B, ne) | 0, n = n + Math.imul(I, ie) | 0, d = d + Math.imul(I, ne) | 0, l = l + Math.imul(g, fe) | 0, n = n + Math.imul(g, ae) | 0, n = n + Math.imul(_2, fe) | 0, d = d + Math.imul(_2, ae) | 0;
        var He = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, l = Math.imul(z2, X), n = Math.imul(z2, J2), n = n + Math.imul(H, X) | 0, d = Math.imul(H, J2), l = l + Math.imul(F, Q2) | 0, n = n + Math.imul(F, ee) | 0, n = n + Math.imul(U, Q2) | 0, d = d + Math.imul(U, ee) | 0, l = l + Math.imul(C, te) | 0, n = n + Math.imul(C, re) | 0, n = n + Math.imul(O, te) | 0, d = d + Math.imul(O, re) | 0, l = l + Math.imul(L, ie) | 0, n = n + Math.imul(L, ne) | 0, n = n + Math.imul(N, ie) | 0, d = d + Math.imul(N, ne) | 0, l = l + Math.imul(B, fe) | 0, n = n + Math.imul(B, ae) | 0, n = n + Math.imul(I, fe) | 0, d = d + Math.imul(I, ae) | 0, l = l + Math.imul(g, oe) | 0, n = n + Math.imul(g, se) | 0, n = n + Math.imul(_2, oe) | 0, d = d + Math.imul(_2, se) | 0;
        var We = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (We >>> 26) | 0, We &= 67108863, l = Math.imul(W, X), n = Math.imul(W, J2), n = n + Math.imul(K, X) | 0, d = Math.imul(K, J2), l = l + Math.imul(z2, Q2) | 0, n = n + Math.imul(z2, ee) | 0, n = n + Math.imul(H, Q2) | 0, d = d + Math.imul(H, ee) | 0, l = l + Math.imul(F, te) | 0, n = n + Math.imul(F, re) | 0, n = n + Math.imul(U, te) | 0, d = d + Math.imul(U, re) | 0, l = l + Math.imul(C, ie) | 0, n = n + Math.imul(C, ne) | 0, n = n + Math.imul(O, ie) | 0, d = d + Math.imul(O, ne) | 0, l = l + Math.imul(L, fe) | 0, n = n + Math.imul(L, ae) | 0, n = n + Math.imul(N, fe) | 0, d = d + Math.imul(N, ae) | 0, l = l + Math.imul(B, oe) | 0, n = n + Math.imul(B, se) | 0, n = n + Math.imul(I, oe) | 0, d = d + Math.imul(I, se) | 0, l = l + Math.imul(g, he) | 0, n = n + Math.imul(g, ue) | 0, n = n + Math.imul(_2, he) | 0, d = d + Math.imul(_2, ue) | 0;
        var Ke = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, l = Math.imul(j, X), n = Math.imul(j, J2), n = n + Math.imul(Z, X) | 0, d = Math.imul(Z, J2), l = l + Math.imul(W, Q2) | 0, n = n + Math.imul(W, ee) | 0, n = n + Math.imul(K, Q2) | 0, d = d + Math.imul(K, ee) | 0, l = l + Math.imul(z2, te) | 0, n = n + Math.imul(z2, re) | 0, n = n + Math.imul(H, te) | 0, d = d + Math.imul(H, re) | 0, l = l + Math.imul(F, ie) | 0, n = n + Math.imul(F, ne) | 0, n = n + Math.imul(U, ie) | 0, d = d + Math.imul(U, ne) | 0, l = l + Math.imul(C, fe) | 0, n = n + Math.imul(C, ae) | 0, n = n + Math.imul(O, fe) | 0, d = d + Math.imul(O, ae) | 0, l = l + Math.imul(L, oe) | 0, n = n + Math.imul(L, se) | 0, n = n + Math.imul(N, oe) | 0, d = d + Math.imul(N, se) | 0, l = l + Math.imul(B, he) | 0, n = n + Math.imul(B, ue) | 0, n = n + Math.imul(I, he) | 0, d = d + Math.imul(I, ue) | 0, l = l + Math.imul(g, le) | 0, n = n + Math.imul(g, de) | 0, n = n + Math.imul(_2, le) | 0, d = d + Math.imul(_2, de) | 0;
        var je = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, l = Math.imul(V, X), n = Math.imul(V, J2), n = n + Math.imul($2, X) | 0, d = Math.imul($2, J2), l = l + Math.imul(j, Q2) | 0, n = n + Math.imul(j, ee) | 0, n = n + Math.imul(Z, Q2) | 0, d = d + Math.imul(Z, ee) | 0, l = l + Math.imul(W, te) | 0, n = n + Math.imul(W, re) | 0, n = n + Math.imul(K, te) | 0, d = d + Math.imul(K, re) | 0, l = l + Math.imul(z2, ie) | 0, n = n + Math.imul(z2, ne) | 0, n = n + Math.imul(H, ie) | 0, d = d + Math.imul(H, ne) | 0, l = l + Math.imul(F, fe) | 0, n = n + Math.imul(F, ae) | 0, n = n + Math.imul(U, fe) | 0, d = d + Math.imul(U, ae) | 0, l = l + Math.imul(C, oe) | 0, n = n + Math.imul(C, se) | 0, n = n + Math.imul(O, oe) | 0, d = d + Math.imul(O, se) | 0, l = l + Math.imul(L, he) | 0, n = n + Math.imul(L, ue) | 0, n = n + Math.imul(N, he) | 0, d = d + Math.imul(N, ue) | 0, l = l + Math.imul(B, le) | 0, n = n + Math.imul(B, de) | 0, n = n + Math.imul(I, le) | 0, d = d + Math.imul(I, de) | 0, l = l + Math.imul(g, ce) | 0, n = n + Math.imul(g, pe) | 0, n = n + Math.imul(_2, ce) | 0, d = d + Math.imul(_2, pe) | 0;
        var Ze = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, l = Math.imul(G, X), n = Math.imul(G, J2), n = n + Math.imul(Y, X) | 0, d = Math.imul(Y, J2), l = l + Math.imul(V, Q2) | 0, n = n + Math.imul(V, ee) | 0, n = n + Math.imul($2, Q2) | 0, d = d + Math.imul($2, ee) | 0, l = l + Math.imul(j, te) | 0, n = n + Math.imul(j, re) | 0, n = n + Math.imul(Z, te) | 0, d = d + Math.imul(Z, re) | 0, l = l + Math.imul(W, ie) | 0, n = n + Math.imul(W, ne) | 0, n = n + Math.imul(K, ie) | 0, d = d + Math.imul(K, ne) | 0, l = l + Math.imul(z2, fe) | 0, n = n + Math.imul(z2, ae) | 0, n = n + Math.imul(H, fe) | 0, d = d + Math.imul(H, ae) | 0, l = l + Math.imul(F, oe) | 0, n = n + Math.imul(F, se) | 0, n = n + Math.imul(U, oe) | 0, d = d + Math.imul(U, se) | 0, l = l + Math.imul(C, he) | 0, n = n + Math.imul(C, ue) | 0, n = n + Math.imul(O, he) | 0, d = d + Math.imul(O, ue) | 0, l = l + Math.imul(L, le) | 0, n = n + Math.imul(L, de) | 0, n = n + Math.imul(N, le) | 0, d = d + Math.imul(N, de) | 0, l = l + Math.imul(B, ce) | 0, n = n + Math.imul(B, pe) | 0, n = n + Math.imul(I, ce) | 0, d = d + Math.imul(I, pe) | 0, l = l + Math.imul(g, ve) | 0, n = n + Math.imul(g, be) | 0, n = n + Math.imul(_2, ve) | 0, d = d + Math.imul(_2, be) | 0;
        var Ve = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, l = Math.imul(G, Q2), n = Math.imul(G, ee), n = n + Math.imul(Y, Q2) | 0, d = Math.imul(Y, ee), l = l + Math.imul(V, te) | 0, n = n + Math.imul(V, re) | 0, n = n + Math.imul($2, te) | 0, d = d + Math.imul($2, re) | 0, l = l + Math.imul(j, ie) | 0, n = n + Math.imul(j, ne) | 0, n = n + Math.imul(Z, ie) | 0, d = d + Math.imul(Z, ne) | 0, l = l + Math.imul(W, fe) | 0, n = n + Math.imul(W, ae) | 0, n = n + Math.imul(K, fe) | 0, d = d + Math.imul(K, ae) | 0, l = l + Math.imul(z2, oe) | 0, n = n + Math.imul(z2, se) | 0, n = n + Math.imul(H, oe) | 0, d = d + Math.imul(H, se) | 0, l = l + Math.imul(F, he) | 0, n = n + Math.imul(F, ue) | 0, n = n + Math.imul(U, he) | 0, d = d + Math.imul(U, ue) | 0, l = l + Math.imul(C, le) | 0, n = n + Math.imul(C, de) | 0, n = n + Math.imul(O, le) | 0, d = d + Math.imul(O, de) | 0, l = l + Math.imul(L, ce) | 0, n = n + Math.imul(L, pe) | 0, n = n + Math.imul(N, ce) | 0, d = d + Math.imul(N, pe) | 0, l = l + Math.imul(B, ve) | 0, n = n + Math.imul(B, be) | 0, n = n + Math.imul(I, ve) | 0, d = d + Math.imul(I, be) | 0;
        var $e = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + ($e >>> 26) | 0, $e &= 67108863, l = Math.imul(G, te), n = Math.imul(G, re), n = n + Math.imul(Y, te) | 0, d = Math.imul(Y, re), l = l + Math.imul(V, ie) | 0, n = n + Math.imul(V, ne) | 0, n = n + Math.imul($2, ie) | 0, d = d + Math.imul($2, ne) | 0, l = l + Math.imul(j, fe) | 0, n = n + Math.imul(j, ae) | 0, n = n + Math.imul(Z, fe) | 0, d = d + Math.imul(Z, ae) | 0, l = l + Math.imul(W, oe) | 0, n = n + Math.imul(W, se) | 0, n = n + Math.imul(K, oe) | 0, d = d + Math.imul(K, se) | 0, l = l + Math.imul(z2, he) | 0, n = n + Math.imul(z2, ue) | 0, n = n + Math.imul(H, he) | 0, d = d + Math.imul(H, ue) | 0, l = l + Math.imul(F, le) | 0, n = n + Math.imul(F, de) | 0, n = n + Math.imul(U, le) | 0, d = d + Math.imul(U, de) | 0, l = l + Math.imul(C, ce) | 0, n = n + Math.imul(C, pe) | 0, n = n + Math.imul(O, ce) | 0, d = d + Math.imul(O, pe) | 0, l = l + Math.imul(L, ve) | 0, n = n + Math.imul(L, be) | 0, n = n + Math.imul(N, ve) | 0, d = d + Math.imul(N, be) | 0;
        var Ge = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, l = Math.imul(G, ie), n = Math.imul(G, ne), n = n + Math.imul(Y, ie) | 0, d = Math.imul(Y, ne), l = l + Math.imul(V, fe) | 0, n = n + Math.imul(V, ae) | 0, n = n + Math.imul($2, fe) | 0, d = d + Math.imul($2, ae) | 0, l = l + Math.imul(j, oe) | 0, n = n + Math.imul(j, se) | 0, n = n + Math.imul(Z, oe) | 0, d = d + Math.imul(Z, se) | 0, l = l + Math.imul(W, he) | 0, n = n + Math.imul(W, ue) | 0, n = n + Math.imul(K, he) | 0, d = d + Math.imul(K, ue) | 0, l = l + Math.imul(z2, le) | 0, n = n + Math.imul(z2, de) | 0, n = n + Math.imul(H, le) | 0, d = d + Math.imul(H, de) | 0, l = l + Math.imul(F, ce) | 0, n = n + Math.imul(F, pe) | 0, n = n + Math.imul(U, ce) | 0, d = d + Math.imul(U, pe) | 0, l = l + Math.imul(C, ve) | 0, n = n + Math.imul(C, be) | 0, n = n + Math.imul(O, ve) | 0, d = d + Math.imul(O, be) | 0;
        var Ye = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, l = Math.imul(G, fe), n = Math.imul(G, ae), n = n + Math.imul(Y, fe) | 0, d = Math.imul(Y, ae), l = l + Math.imul(V, oe) | 0, n = n + Math.imul(V, se) | 0, n = n + Math.imul($2, oe) | 0, d = d + Math.imul($2, se) | 0, l = l + Math.imul(j, he) | 0, n = n + Math.imul(j, ue) | 0, n = n + Math.imul(Z, he) | 0, d = d + Math.imul(Z, ue) | 0, l = l + Math.imul(W, le) | 0, n = n + Math.imul(W, de) | 0, n = n + Math.imul(K, le) | 0, d = d + Math.imul(K, de) | 0, l = l + Math.imul(z2, ce) | 0, n = n + Math.imul(z2, pe) | 0, n = n + Math.imul(H, ce) | 0, d = d + Math.imul(H, pe) | 0, l = l + Math.imul(F, ve) | 0, n = n + Math.imul(F, be) | 0, n = n + Math.imul(U, ve) | 0, d = d + Math.imul(U, be) | 0;
        var Xe = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, l = Math.imul(G, oe), n = Math.imul(G, se), n = n + Math.imul(Y, oe) | 0, d = Math.imul(Y, se), l = l + Math.imul(V, he) | 0, n = n + Math.imul(V, ue) | 0, n = n + Math.imul($2, he) | 0, d = d + Math.imul($2, ue) | 0, l = l + Math.imul(j, le) | 0, n = n + Math.imul(j, de) | 0, n = n + Math.imul(Z, le) | 0, d = d + Math.imul(Z, de) | 0, l = l + Math.imul(W, ce) | 0, n = n + Math.imul(W, pe) | 0, n = n + Math.imul(K, ce) | 0, d = d + Math.imul(K, pe) | 0, l = l + Math.imul(z2, ve) | 0, n = n + Math.imul(z2, be) | 0, n = n + Math.imul(H, ve) | 0, d = d + Math.imul(H, be) | 0;
        var Je = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, l = Math.imul(G, he), n = Math.imul(G, ue), n = n + Math.imul(Y, he) | 0, d = Math.imul(Y, ue), l = l + Math.imul(V, le) | 0, n = n + Math.imul(V, de) | 0, n = n + Math.imul($2, le) | 0, d = d + Math.imul($2, de) | 0, l = l + Math.imul(j, ce) | 0, n = n + Math.imul(j, pe) | 0, n = n + Math.imul(Z, ce) | 0, d = d + Math.imul(Z, pe) | 0, l = l + Math.imul(W, ve) | 0, n = n + Math.imul(W, be) | 0, n = n + Math.imul(K, ve) | 0, d = d + Math.imul(K, be) | 0;
        var Qe = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, l = Math.imul(G, le), n = Math.imul(G, de), n = n + Math.imul(Y, le) | 0, d = Math.imul(Y, de), l = l + Math.imul(V, ce) | 0, n = n + Math.imul(V, pe) | 0, n = n + Math.imul($2, ce) | 0, d = d + Math.imul($2, pe) | 0, l = l + Math.imul(j, ve) | 0, n = n + Math.imul(j, be) | 0, n = n + Math.imul(Z, ve) | 0, d = d + Math.imul(Z, be) | 0;
        var et = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, l = Math.imul(G, ce), n = Math.imul(G, pe), n = n + Math.imul(Y, ce) | 0, d = Math.imul(Y, pe), l = l + Math.imul(V, ve) | 0, n = n + Math.imul(V, be) | 0, n = n + Math.imul($2, ve) | 0, d = d + Math.imul($2, be) | 0;
        var tt = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, l = Math.imul(G, ve), n = Math.imul(G, be), n = n + Math.imul(Y, ve) | 0, d = Math.imul(Y, be);
        var rt = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        return b2 = (d + (n >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, c[0] = ft, c[1] = Be, c[2] = qe, c[3] = ze, c[4] = He, c[5] = We, c[6] = Ke, c[7] = je, c[8] = Ze, c[9] = Ve, c[10] = $e, c[11] = Ge, c[12] = Ye, c[13] = Xe, c[14] = Je, c[15] = Qe, c[16] = et, c[17] = tt, c[18] = rt, b2 !== 0 && (c[19] = b2, h.length++), h;
      };
      Math.imul || (T = q);
      function ye(v2, i, a) {
        a.negative = i.negative ^ v2.negative, a.length = v2.length + i.length;
        for (var h = 0, s = 0, u = 0;u < a.length - 1; u++) {
          var c = s;
          s = 0;
          for (var b2 = h & 67108863, l = Math.min(u, i.length - 1), n = Math.max(0, u - v2.length + 1);n <= l; n++) {
            var d = u - n, w = v2.words[d] | 0, g = i.words[n] | 0, _2 = w * g, A = _2 & 67108863;
            c = c + (_2 / 67108864 | 0) | 0, A = A + b2 | 0, b2 = A & 67108863, c = c + (A >>> 26) | 0, s += c >>> 26, c &= 67108863;
          }
          a.words[u] = b2, h = c, c = s;
        }
        return h !== 0 ? a.words[u] = h : a.length--, a.strip();
      }
      function _e(v2, i, a) {
        var h = new P;
        return h.mulp(v2, i, a);
      }
      f2.prototype.mulTo = function(i, a) {
        var h, s = this.length + i.length;
        return this.length === 10 && i.length === 10 ? h = T(this, i, a) : s < 63 ? h = q(this, i, a) : s < 1024 ? h = ye(this, i, a) : h = _e(this, i, a), h;
      };
      function P(v2, i) {
        this.x = v2, this.y = i;
      }
      P.prototype.makeRBT = function(i) {
        for (var a = new Array(i), h = f2.prototype._countBits(i) - 1, s = 0;s < i; s++)
          a[s] = this.revBin(s, h, i);
        return a;
      }, P.prototype.revBin = function(i, a, h) {
        if (i === 0 || i === h - 1)
          return i;
        for (var s = 0, u = 0;u < a; u++)
          s |= (i & 1) << a - u - 1, i >>= 1;
        return s;
      }, P.prototype.permute = function(i, a, h, s, u, c) {
        for (var b2 = 0;b2 < c; b2++)
          s[b2] = a[i[b2]], u[b2] = h[i[b2]];
      }, P.prototype.transform = function(i, a, h, s, u, c) {
        this.permute(c, i, a, h, s, u);
        for (var b2 = 1;b2 < u; b2 <<= 1)
          for (var l = b2 << 1, n = Math.cos(2 * Math.PI / l), d = Math.sin(2 * Math.PI / l), w = 0;w < u; w += l)
            for (var g = n, _2 = d, A = 0;A < b2; A++) {
              var B = h[w + A], I = s[w + A], we = h[w + A + b2], L = s[w + A + b2], N = g * we - _2 * L;
              L = g * L + _2 * we, we = N, h[w + A] = B + we, s[w + A] = I + L, h[w + A + b2] = B - we, s[w + A + b2] = I - L, A !== l && (N = n * g - d * _2, _2 = n * _2 + d * g, g = N);
            }
      }, P.prototype.guessLen13b = function(i, a) {
        var h = Math.max(a, i) | 1, s = h & 1, u = 0;
        for (h = h / 2 | 0;h; h = h >>> 1)
          u++;
        return 1 << u + 1 + s;
      }, P.prototype.conjugate = function(i, a, h) {
        if (!(h <= 1))
          for (var s = 0;s < h / 2; s++) {
            var u = i[s];
            i[s] = i[h - s - 1], i[h - s - 1] = u, u = a[s], a[s] = -a[h - s - 1], a[h - s - 1] = -u;
          }
      }, P.prototype.normalize13b = function(i, a) {
        for (var h = 0, s = 0;s < a / 2; s++) {
          var u = Math.round(i[2 * s + 1] / a) * 8192 + Math.round(i[2 * s] / a) + h;
          i[s] = u & 67108863, u < 67108864 ? h = 0 : h = u / 67108864 | 0;
        }
        return i;
      }, P.prototype.convert13b = function(i, a, h, s) {
        for (var u = 0, c = 0;c < a; c++)
          u = u + (i[c] | 0), h[2 * c] = u & 8191, u = u >>> 13, h[2 * c + 1] = u & 8191, u = u >>> 13;
        for (c = 2 * a;c < s; ++c)
          h[c] = 0;
        r(u === 0), r((u & -8192) === 0);
      }, P.prototype.stub = function(i) {
        for (var a = new Array(i), h = 0;h < i; h++)
          a[h] = 0;
        return a;
      }, P.prototype.mulp = function(i, a, h) {
        var s = 2 * this.guessLen13b(i.length, a.length), u = this.makeRBT(s), c = this.stub(s), b2 = new Array(s), l = new Array(s), n = new Array(s), d = new Array(s), w = new Array(s), g = new Array(s), _2 = h.words;
        _2.length = s, this.convert13b(i.words, i.length, b2, s), this.convert13b(a.words, a.length, d, s), this.transform(b2, c, l, n, s, u), this.transform(d, c, w, g, s, u);
        for (var A = 0;A < s; A++) {
          var B = l[A] * w[A] - n[A] * g[A];
          n[A] = l[A] * g[A] + n[A] * w[A], l[A] = B;
        }
        return this.conjugate(l, n, s), this.transform(l, n, _2, c, s, u), this.conjugate(_2, c, s), this.normalize13b(_2, s), h.negative = i.negative ^ a.negative, h.length = i.length + a.length, h.strip();
      }, f2.prototype.mul = function(i) {
        var a = new f2(null);
        return a.words = new Array(this.length + i.length), this.mulTo(i, a);
      }, f2.prototype.mulf = function(i) {
        var a = new f2(null);
        return a.words = new Array(this.length + i.length), _e(this, i, a);
      }, f2.prototype.imul = function(i) {
        return this.clone().mulTo(i, this);
      }, f2.prototype.imuln = function(i) {
        r(typeof i == "number"), r(i < 67108864);
        for (var a = 0, h = 0;h < this.length; h++) {
          var s = (this.words[h] | 0) * i, u = (s & 67108863) + (a & 67108863);
          a >>= 26, a += s / 67108864 | 0, a += u >>> 26, this.words[h] = u & 67108863;
        }
        return a !== 0 && (this.words[h] = a, this.length++), this;
      }, f2.prototype.muln = function(i) {
        return this.clone().imuln(i);
      }, f2.prototype.sqr = function() {
        return this.mul(this);
      }, f2.prototype.isqr = function() {
        return this.imul(this.clone());
      }, f2.prototype.pow = function(i) {
        var a = R(i);
        if (a.length === 0)
          return new f2(1);
        for (var h = this, s = 0;s < a.length && a[s] === 0; s++, h = h.sqr())
          ;
        if (++s < a.length)
          for (var u = h.sqr();s < a.length; s++, u = u.sqr())
            a[s] !== 0 && (h = h.mul(u));
        return h;
      }, f2.prototype.iushln = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 67108863 >>> 26 - a << 26 - a, u;
        if (a !== 0) {
          var c = 0;
          for (u = 0;u < this.length; u++) {
            var b2 = this.words[u] & s, l = (this.words[u] | 0) - b2 << a;
            this.words[u] = l | c, c = b2 >>> 26 - a;
          }
          c && (this.words[u] = c, this.length++);
        }
        if (h !== 0) {
          for (u = this.length - 1;u >= 0; u--)
            this.words[u + h] = this.words[u];
          for (u = 0;u < h; u++)
            this.words[u] = 0;
          this.length += h;
        }
        return this.strip();
      }, f2.prototype.ishln = function(i) {
        return r(this.negative === 0), this.iushln(i);
      }, f2.prototype.iushrn = function(i, a, h) {
        r(typeof i == "number" && i >= 0);
        var s;
        a ? s = (a - a % 26) / 26 : s = 0;
        var u = i % 26, c = Math.min((i - u) / 26, this.length), b2 = 67108863 ^ 67108863 >>> u << u, l = h;
        if (s -= c, s = Math.max(0, s), l) {
          for (var n = 0;n < c; n++)
            l.words[n] = this.words[n];
          l.length = c;
        }
        if (c !== 0)
          if (this.length > c)
            for (this.length -= c, n = 0;n < this.length; n++)
              this.words[n] = this.words[n + c];
          else
            this.words[0] = 0, this.length = 1;
        var d = 0;
        for (n = this.length - 1;n >= 0 && (d !== 0 || n >= s); n--) {
          var w = this.words[n] | 0;
          this.words[n] = d << 26 - u | w >>> u, d = w & b2;
        }
        return l && d !== 0 && (l.words[l.length++] = d), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, f2.prototype.ishrn = function(i, a, h) {
        return r(this.negative === 0), this.iushrn(i, a, h);
      }, f2.prototype.shln = function(i) {
        return this.clone().ishln(i);
      }, f2.prototype.ushln = function(i) {
        return this.clone().iushln(i);
      }, f2.prototype.shrn = function(i) {
        return this.clone().ishrn(i);
      }, f2.prototype.ushrn = function(i) {
        return this.clone().iushrn(i);
      }, f2.prototype.testn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return false;
        var u = this.words[h];
        return !!(u & s);
      }, f2.prototype.imaskn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= h)
          return this;
        if (a !== 0 && h++, this.length = Math.min(h, this.length), a !== 0) {
          var s = 67108863 ^ 67108863 >>> a << a;
          this.words[this.length - 1] &= s;
        }
        return this.strip();
      }, f2.prototype.maskn = function(i) {
        return this.clone().imaskn(i);
      }, f2.prototype.iaddn = function(i) {
        return r(typeof i == "number"), r(i < 67108864), i < 0 ? this.isubn(-i) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < i ? (this.words[0] = i - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(i), this.negative = 1, this) : this._iaddn(i);
      }, f2.prototype._iaddn = function(i) {
        this.words[0] += i;
        for (var a = 0;a < this.length && this.words[a] >= 67108864; a++)
          this.words[a] -= 67108864, a === this.length - 1 ? this.words[a + 1] = 1 : this.words[a + 1]++;
        return this.length = Math.max(this.length, a + 1), this;
      }, f2.prototype.isubn = function(i) {
        if (r(typeof i == "number"), r(i < 67108864), i < 0)
          return this.iaddn(-i);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(i), this.negative = 1, this;
        if (this.words[0] -= i, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var a = 0;a < this.length && this.words[a] < 0; a++)
            this.words[a] += 67108864, this.words[a + 1] -= 1;
        return this.strip();
      }, f2.prototype.addn = function(i) {
        return this.clone().iaddn(i);
      }, f2.prototype.subn = function(i) {
        return this.clone().isubn(i);
      }, f2.prototype.iabs = function() {
        return this.negative = 0, this;
      }, f2.prototype.abs = function() {
        return this.clone().iabs();
      }, f2.prototype._ishlnsubmul = function(i, a, h) {
        var s = i.length + h, u;
        this._expand(s);
        var c, b2 = 0;
        for (u = 0;u < i.length; u++) {
          c = (this.words[u + h] | 0) + b2;
          var l = (i.words[u] | 0) * a;
          c -= l & 67108863, b2 = (c >> 26) - (l / 67108864 | 0), this.words[u + h] = c & 67108863;
        }
        for (;u < this.length - h; u++)
          c = (this.words[u + h] | 0) + b2, b2 = c >> 26, this.words[u + h] = c & 67108863;
        if (b2 === 0)
          return this.strip();
        for (r(b2 === -1), b2 = 0, u = 0;u < this.length; u++)
          c = -(this.words[u] | 0) + b2, b2 = c >> 26, this.words[u] = c & 67108863;
        return this.negative = 1, this.strip();
      }, f2.prototype._wordDiv = function(i, a) {
        var h = this.length - i.length, s = this.clone(), u = i, c = u.words[u.length - 1] | 0, b2 = this._countBits(c);
        h = 26 - b2, h !== 0 && (u = u.ushln(h), s.iushln(h), c = u.words[u.length - 1] | 0);
        var l = s.length - u.length, n;
        if (a !== "mod") {
          n = new f2(null), n.length = l + 1, n.words = new Array(n.length);
          for (var d = 0;d < n.length; d++)
            n.words[d] = 0;
        }
        var w = s.clone()._ishlnsubmul(u, 1, l);
        w.negative === 0 && (s = w, n && (n.words[l] = 1));
        for (var g = l - 1;g >= 0; g--) {
          var _2 = (s.words[u.length + g] | 0) * 67108864 + (s.words[u.length + g - 1] | 0);
          for (_2 = Math.min(_2 / c | 0, 67108863), s._ishlnsubmul(u, _2, g);s.negative !== 0; )
            _2--, s.negative = 0, s._ishlnsubmul(u, 1, g), s.isZero() || (s.negative ^= 1);
          n && (n.words[g] = _2);
        }
        return n && n.strip(), s.strip(), a !== "div" && h !== 0 && s.iushrn(h), { div: n || null, mod: s };
      }, f2.prototype.divmod = function(i, a, h) {
        if (r(!i.isZero()), this.isZero())
          return { div: new f2(0), mod: new f2(0) };
        var s, u, c;
        return this.negative !== 0 && i.negative === 0 ? (c = this.neg().divmod(i, a), a !== "mod" && (s = c.div.neg()), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.iadd(i)), { div: s, mod: u }) : this.negative === 0 && i.negative !== 0 ? (c = this.divmod(i.neg(), a), a !== "mod" && (s = c.div.neg()), { div: s, mod: c.mod }) : (this.negative & i.negative) !== 0 ? (c = this.neg().divmod(i.neg(), a), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.isub(i)), { div: c.div, mod: u }) : i.length > this.length || this.cmp(i) < 0 ? { div: new f2(0), mod: this } : i.length === 1 ? a === "div" ? { div: this.divn(i.words[0]), mod: null } : a === "mod" ? { div: null, mod: new f2(this.modn(i.words[0])) } : { div: this.divn(i.words[0]), mod: new f2(this.modn(i.words[0])) } : this._wordDiv(i, a);
      }, f2.prototype.div = function(i) {
        return this.divmod(i, "div", false).div;
      }, f2.prototype.mod = function(i) {
        return this.divmod(i, "mod", false).mod;
      }, f2.prototype.umod = function(i) {
        return this.divmod(i, "mod", true).mod;
      }, f2.prototype.divRound = function(i) {
        var a = this.divmod(i);
        if (a.mod.isZero())
          return a.div;
        var h = a.div.negative !== 0 ? a.mod.isub(i) : a.mod, s = i.ushrn(1), u = i.andln(1), c = h.cmp(s);
        return c < 0 || u === 1 && c === 0 ? a.div : a.div.negative !== 0 ? a.div.isubn(1) : a.div.iaddn(1);
      }, f2.prototype.modn = function(i) {
        r(i <= 67108863);
        for (var a = (1 << 26) % i, h = 0, s = this.length - 1;s >= 0; s--)
          h = (a * h + (this.words[s] | 0)) % i;
        return h;
      }, f2.prototype.idivn = function(i) {
        r(i <= 67108863);
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = (this.words[h] | 0) + a * 67108864;
          this.words[h] = s / i | 0, a = s % i;
        }
        return this.strip();
      }, f2.prototype.divn = function(i) {
        return this.clone().idivn(i);
      }, f2.prototype.egcd = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f2(1), u = new f2(0), c = new f2(0), b2 = new f2(1), l = 0;a.isEven() && h.isEven(); )
          a.iushrn(1), h.iushrn(1), ++l;
        for (var n = h.clone(), d = a.clone();!a.isZero(); ) {
          for (var w = 0, g = 1;(a.words[0] & g) === 0 && w < 26; ++w, g <<= 1)
            ;
          if (w > 0)
            for (a.iushrn(w);w-- > 0; )
              (s.isOdd() || u.isOdd()) && (s.iadd(n), u.isub(d)), s.iushrn(1), u.iushrn(1);
          for (var _2 = 0, A = 1;(h.words[0] & A) === 0 && _2 < 26; ++_2, A <<= 1)
            ;
          if (_2 > 0)
            for (h.iushrn(_2);_2-- > 0; )
              (c.isOdd() || b2.isOdd()) && (c.iadd(n), b2.isub(d)), c.iushrn(1), b2.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(c), u.isub(b2)) : (h.isub(a), c.isub(s), b2.isub(u));
        }
        return { a: c, b: b2, gcd: h.iushln(l) };
      }, f2.prototype._invmp = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f2(1), u = new f2(0), c = h.clone();a.cmpn(1) > 0 && h.cmpn(1) > 0; ) {
          for (var b2 = 0, l = 1;(a.words[0] & l) === 0 && b2 < 26; ++b2, l <<= 1)
            ;
          if (b2 > 0)
            for (a.iushrn(b2);b2-- > 0; )
              s.isOdd() && s.iadd(c), s.iushrn(1);
          for (var n = 0, d = 1;(h.words[0] & d) === 0 && n < 26; ++n, d <<= 1)
            ;
          if (n > 0)
            for (h.iushrn(n);n-- > 0; )
              u.isOdd() && u.iadd(c), u.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(u)) : (h.isub(a), u.isub(s));
        }
        var w;
        return a.cmpn(1) === 0 ? w = s : w = u, w.cmpn(0) < 0 && w.iadd(i), w;
      }, f2.prototype.gcd = function(i) {
        if (this.isZero())
          return i.abs();
        if (i.isZero())
          return this.abs();
        var a = this.clone(), h = i.clone();
        a.negative = 0, h.negative = 0;
        for (var s = 0;a.isEven() && h.isEven(); s++)
          a.iushrn(1), h.iushrn(1);
        do {
          for (;a.isEven(); )
            a.iushrn(1);
          for (;h.isEven(); )
            h.iushrn(1);
          var u = a.cmp(h);
          if (u < 0) {
            var c = a;
            a = h, h = c;
          } else if (u === 0 || h.cmpn(1) === 0)
            break;
          a.isub(h);
        } while (true);
        return h.iushln(s);
      }, f2.prototype.invm = function(i) {
        return this.egcd(i).a.umod(i);
      }, f2.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, f2.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, f2.prototype.andln = function(i) {
        return this.words[0] & i;
      }, f2.prototype.bincn = function(i) {
        r(typeof i == "number");
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return this._expand(h + 1), this.words[h] |= s, this;
        for (var u = s, c = h;u !== 0 && c < this.length; c++) {
          var b2 = this.words[c] | 0;
          b2 += u, u = b2 >>> 26, b2 &= 67108863, this.words[c] = b2;
        }
        return u !== 0 && (this.words[c] = u, this.length++), this;
      }, f2.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, f2.prototype.cmpn = function(i) {
        var a = i < 0;
        if (this.negative !== 0 && !a)
          return -1;
        if (this.negative === 0 && a)
          return 1;
        this.strip();
        var h;
        if (this.length > 1)
          h = 1;
        else {
          a && (i = -i), r(i <= 67108863, "Number is too big");
          var s = this.words[0] | 0;
          h = s === i ? 0 : s < i ? -1 : 1;
        }
        return this.negative !== 0 ? -h | 0 : h;
      }, f2.prototype.cmp = function(i) {
        if (this.negative !== 0 && i.negative === 0)
          return -1;
        if (this.negative === 0 && i.negative !== 0)
          return 1;
        var a = this.ucmp(i);
        return this.negative !== 0 ? -a | 0 : a;
      }, f2.prototype.ucmp = function(i) {
        if (this.length > i.length)
          return 1;
        if (this.length < i.length)
          return -1;
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = this.words[h] | 0, u = i.words[h] | 0;
          if (s !== u) {
            s < u ? a = -1 : s > u && (a = 1);
            break;
          }
        }
        return a;
      }, f2.prototype.gtn = function(i) {
        return this.cmpn(i) === 1;
      }, f2.prototype.gt = function(i) {
        return this.cmp(i) === 1;
      }, f2.prototype.gten = function(i) {
        return this.cmpn(i) >= 0;
      }, f2.prototype.gte = function(i) {
        return this.cmp(i) >= 0;
      }, f2.prototype.ltn = function(i) {
        return this.cmpn(i) === -1;
      }, f2.prototype.lt = function(i) {
        return this.cmp(i) === -1;
      }, f2.prototype.lten = function(i) {
        return this.cmpn(i) <= 0;
      }, f2.prototype.lte = function(i) {
        return this.cmp(i) <= 0;
      }, f2.prototype.eqn = function(i) {
        return this.cmpn(i) === 0;
      }, f2.prototype.eq = function(i) {
        return this.cmp(i) === 0;
      }, f2.red = function(i) {
        return new D2(i);
      }, f2.prototype.toRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), i.convertTo(this)._forceRed(i);
      }, f2.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, f2.prototype._forceRed = function(i) {
        return this.red = i, this;
      }, f2.prototype.forceRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(i);
      }, f2.prototype.redAdd = function(i) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, i);
      }, f2.prototype.redIAdd = function(i) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, i);
      }, f2.prototype.redSub = function(i) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, i);
      }, f2.prototype.redISub = function(i) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, i);
      }, f2.prototype.redShl = function(i) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, i);
      }, f2.prototype.redMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.mul(this, i);
      }, f2.prototype.redIMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.imul(this, i);
      }, f2.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, f2.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, f2.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, f2.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, f2.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, f2.prototype.redPow = function(i) {
        return r(this.red && !i.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, i);
      };
      var Me = { k256: null, p224: null, p192: null, p25519: null };
      function me(v2, i) {
        this.name = v2, this.p = new f2(i, 16), this.n = this.p.bitLength(), this.k = new f2(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      me.prototype._tmp = function() {
        var i = new f2(null);
        return i.words = new Array(Math.ceil(this.n / 13)), i;
      }, me.prototype.ireduce = function(i) {
        var a = i, h;
        do
          this.split(a, this.tmp), a = this.imulK(a), a = a.iadd(this.tmp), h = a.bitLength();
        while (h > this.n);
        var s = h < this.n ? -1 : a.ucmp(this.p);
        return s === 0 ? (a.words[0] = 0, a.length = 1) : s > 0 ? a.isub(this.p) : a.strip !== undefined ? a.strip() : a._strip(), a;
      }, me.prototype.split = function(i, a) {
        i.iushrn(this.n, 0, a);
      }, me.prototype.imulK = function(i) {
        return i.imul(this.k);
      };
      function xe() {
        me.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      o(xe, me), xe.prototype.split = function(i, a) {
        for (var h = 4194303, s = Math.min(i.length, 9), u = 0;u < s; u++)
          a.words[u] = i.words[u];
        if (a.length = s, i.length <= 9) {
          i.words[0] = 0, i.length = 1;
          return;
        }
        var c = i.words[9];
        for (a.words[a.length++] = c & h, u = 10;u < i.length; u++) {
          var b2 = i.words[u] | 0;
          i.words[u - 10] = (b2 & h) << 4 | c >>> 22, c = b2;
        }
        c >>>= 22, i.words[u - 10] = c, c === 0 && i.length > 10 ? i.length -= 10 : i.length -= 9;
      }, xe.prototype.imulK = function(i) {
        i.words[i.length] = 0, i.words[i.length + 1] = 0, i.length += 2;
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = i.words[h] | 0;
          a += s * 977, i.words[h] = a & 67108863, a = s * 64 + (a / 67108864 | 0);
        }
        return i.words[i.length - 1] === 0 && (i.length--, i.words[i.length - 1] === 0 && i.length--), i;
      };
      function Ae() {
        me.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      o(Ae, me);
      function Ee() {
        me.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      o(Ee, me);
      function Re() {
        me.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      o(Re, me), Re.prototype.imulK = function(i) {
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = (i.words[h] | 0) * 19 + a, u = s & 67108863;
          s >>>= 26, i.words[h] = u, a = s;
        }
        return a !== 0 && (i.words[i.length++] = a), i;
      }, f2._prime = function(i) {
        if (Me[i])
          return Me[i];
        var a;
        if (i === "k256")
          a = new xe;
        else if (i === "p224")
          a = new Ae;
        else if (i === "p192")
          a = new Ee;
        else if (i === "p25519")
          a = new Re;
        else
          throw new Error("Unknown prime " + i);
        return Me[i] = a, a;
      };
      function D2(v2) {
        if (typeof v2 == "string") {
          var i = f2._prime(v2);
          this.m = i.p, this.prime = i;
        } else
          r(v2.gtn(1), "modulus must be greater than 1"), this.m = v2, this.prime = null;
      }
      D2.prototype._verify1 = function(i) {
        r(i.negative === 0, "red works only with positives"), r(i.red, "red works only with red numbers");
      }, D2.prototype._verify2 = function(i, a) {
        r((i.negative | a.negative) === 0, "red works only with positives"), r(i.red && i.red === a.red, "red works only with red numbers");
      }, D2.prototype.imod = function(i) {
        return this.prime ? this.prime.ireduce(i)._forceRed(this) : i.umod(this.m)._forceRed(this);
      }, D2.prototype.neg = function(i) {
        return i.isZero() ? i.clone() : this.m.sub(i)._forceRed(this);
      }, D2.prototype.add = function(i, a) {
        this._verify2(i, a);
        var h = i.add(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h._forceRed(this);
      }, D2.prototype.iadd = function(i, a) {
        this._verify2(i, a);
        var h = i.iadd(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h;
      }, D2.prototype.sub = function(i, a) {
        this._verify2(i, a);
        var h = i.sub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h._forceRed(this);
      }, D2.prototype.isub = function(i, a) {
        this._verify2(i, a);
        var h = i.isub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h;
      }, D2.prototype.shl = function(i, a) {
        return this._verify1(i), this.imod(i.ushln(a));
      }, D2.prototype.imul = function(i, a) {
        return this._verify2(i, a), this.imod(i.imul(a));
      }, D2.prototype.mul = function(i, a) {
        return this._verify2(i, a), this.imod(i.mul(a));
      }, D2.prototype.isqr = function(i) {
        return this.imul(i, i.clone());
      }, D2.prototype.sqr = function(i) {
        return this.mul(i, i);
      }, D2.prototype.sqrt = function(i) {
        if (i.isZero())
          return i.clone();
        var a = this.m.andln(3);
        if (r(a % 2 === 1), a === 3) {
          var h = this.m.add(new f2(1)).iushrn(2);
          return this.pow(i, h);
        }
        for (var s = this.m.subn(1), u = 0;!s.isZero() && s.andln(1) === 0; )
          u++, s.iushrn(1);
        r(!s.isZero());
        var c = new f2(1).toRed(this), b2 = c.redNeg(), l = this.m.subn(1).iushrn(1), n = this.m.bitLength();
        for (n = new f2(2 * n * n).toRed(this);this.pow(n, l).cmp(b2) !== 0; )
          n.redIAdd(b2);
        for (var d = this.pow(n, s), w = this.pow(i, s.addn(1).iushrn(1)), g = this.pow(i, s), _2 = u;g.cmp(c) !== 0; ) {
          for (var A = g, B = 0;A.cmp(c) !== 0; B++)
            A = A.redSqr();
          r(B < _2);
          var I = this.pow(d, new f2(1).iushln(_2 - B - 1));
          w = w.redMul(I), d = I.redSqr(), g = g.redMul(d), _2 = B;
        }
        return w;
      }, D2.prototype.invm = function(i) {
        var a = i._invmp(this.m);
        return a.negative !== 0 ? (a.negative = 0, this.imod(a).redNeg()) : this.imod(a);
      }, D2.prototype.pow = function(i, a) {
        if (a.isZero())
          return new f2(1).toRed(this);
        if (a.cmpn(1) === 0)
          return i.clone();
        var h = 4, s = new Array(1 << h);
        s[0] = new f2(1).toRed(this), s[1] = i;
        for (var u = 2;u < s.length; u++)
          s[u] = this.mul(s[u - 1], i);
        var c = s[0], b2 = 0, l = 0, n = a.bitLength() % 26;
        for (n === 0 && (n = 26), u = a.length - 1;u >= 0; u--) {
          for (var d = a.words[u], w = n - 1;w >= 0; w--) {
            var g = d >> w & 1;
            if (c !== s[0] && (c = this.sqr(c)), g === 0 && b2 === 0) {
              l = 0;
              continue;
            }
            b2 <<= 1, b2 |= g, l++, !(l !== h && (u !== 0 || w !== 0)) && (c = this.mul(c, s[b2]), l = 0, b2 = 0);
          }
          n = 26;
        }
        return c;
      }, D2.prototype.convertTo = function(i) {
        var a = i.umod(this.m);
        return a === i ? a.clone() : a;
      }, D2.prototype.convertFrom = function(i) {
        var a = i.clone();
        return a.red = null, a;
      }, f2.mont = function(i) {
        return new Se(i);
      };
      function Se(v2) {
        D2.call(this, v2), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f2(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o(Se, D2), Se.prototype.convertTo = function(i) {
        return this.imod(i.ushln(this.shift));
      }, Se.prototype.convertFrom = function(i) {
        var a = this.imod(i.mul(this.rinv));
        return a.red = null, a;
      }, Se.prototype.imul = function(i, a) {
        if (i.isZero() || a.isZero())
          return i.words[0] = 0, i.length = 1, i;
        var h = i.imul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se.prototype.mul = function(i, a) {
        if (i.isZero() || a.isZero())
          return new f2(0)._forceRed(this);
        var h = i.mul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se.prototype.invm = function(i) {
        var a = this.imod(i._invmp(this.m).mul(this.r2));
        return a._forceRed(this);
      };
    })(typeof zd > "u" || zd, d3);
  });
  Hd = k((vN, p3) => {
    var c3 = E0(), dI = Te().Buffer;
    function cI(t, e) {
      return dI.from(t.toRed(c3.mont(e.modulus)).redPow(new c3(e.publicExponent)).fromRed().toArray());
    }
    p3.exports = cI;
  });
  g3 = k((bN, m3) => {
    var pI = Va(), Wd = hn(), vI = yf(), v3 = Fd(), b3 = Ud(), Kd = E0(), bI = Hd(), mI = Gs(), Kr2 = Te().Buffer;
    m3.exports = function(e, r, o) {
      var f2;
      e.padding ? f2 = e.padding : o ? f2 = 1 : f2 = 4;
      var p = pI(e), m;
      if (f2 === 4)
        m = gI(p, r);
      else if (f2 === 1)
        m = yI(p, r, o);
      else if (f2 === 3) {
        if (m = new Kd(r), m.cmp(p.modulus) >= 0)
          throw new Error("data too long for modulus");
      } else
        throw new Error("unknown padding");
      return o ? mI(m, p) : bI(m, p);
    };
    function gI(t, e) {
      var r = t.modulus.byteLength(), o = e.length, f2 = vI("sha1").update(Kr2.alloc(0)).digest(), p = f2.length, m = 2 * p;
      if (o > r - m - 2)
        throw new Error("message too long");
      var y = Kr2.alloc(r - o - m - 2), M = r - p - 1, x = Wd(p), S2 = b3(Kr2.concat([f2, y, Kr2.alloc(1, 1), e], M), v3(x, M)), E = b3(x, v3(S2, p));
      return new Kd(Kr2.concat([Kr2.alloc(1), E, S2], r));
    }
    function yI(t, e, r) {
      var o = e.length, f2 = t.modulus.byteLength();
      if (o > f2 - 11)
        throw new Error("message too long");
      var p;
      return r ? p = Kr2.alloc(f2 - o - 3, 255) : p = wI(f2 - o - 3), new Kd(Kr2.concat([Kr2.from([0, r ? 1 : 2]), p, Kr2.alloc(1), e], f2));
    }
    function wI(t) {
      for (var e = Kr2.allocUnsafe(t), r = 0, o = Wd(t * 2), f2 = 0, p;r < t; )
        f2 === o.length && (o = Wd(t * 2), f2 = 0), p = o[f2++], p && (e[r++] = p);
      return e;
    }
  });
  x3 = k((mN, _3) => {
    var MI = Va(), y3 = Fd(), w3 = Ud(), M3 = E0(), _I = Gs(), xI = yf(), SI = Hd(), Xa = Te().Buffer;
    _3.exports = function(e, r, o) {
      var f2;
      e.padding ? f2 = e.padding : o ? f2 = 1 : f2 = 4;
      var p = MI(e), m = p.modulus.byteLength();
      if (r.length > m || new M3(r).cmp(p.modulus) >= 0)
        throw new Error("decryption error");
      var y;
      o ? y = SI(new M3(r), p) : y = _I(r, p);
      var M = Xa.alloc(m - y.length);
      if (y = Xa.concat([M, y], m), f2 === 4)
        return EI(p, y);
      if (f2 === 1)
        return AI(p, y, o);
      if (f2 === 3)
        return y;
      throw new Error("unknown padding");
    };
    function EI(t, e) {
      var r = t.modulus.byteLength(), o = xI("sha1").update(Xa.alloc(0)).digest(), f2 = o.length;
      if (e[0] !== 0)
        throw new Error("decryption error");
      var p = e.slice(1, f2 + 1), m = e.slice(f2 + 1), y = w3(p, y3(m, f2)), M = w3(m, y3(y, r - f2 - 1));
      if (RI(o, M.slice(0, f2)))
        throw new Error("decryption error");
      for (var x = f2;M[x] === 0; )
        x++;
      if (M[x++] !== 1)
        throw new Error("decryption error");
      return M.slice(x);
    }
    function AI(t, e, r) {
      for (var o = e.slice(0, 2), f2 = 2, p = 0;e[f2++] !== 0; )
        if (f2 >= e.length) {
          p++;
          break;
        }
      var m = e.slice(2, f2 - 1);
      if ((o.toString("hex") !== "0002" && !r || o.toString("hex") !== "0001" && r) && p++, m.length < 8 && p++, p)
        throw new Error("decryption error");
      return e.slice(f2);
    }
    function RI(t, e) {
      t = Xa.from(t), e = Xa.from(e);
      var r = 0, o = t.length;
      t.length !== e.length && (r++, o = Math.min(t.length, e.length));
      for (var f2 = -1;++f2 < o; )
        r += t[f2] ^ e[f2];
      return r;
    }
  });
  S3 = k((Jn) => {
    Jn.publicEncrypt = g3();
    Jn.privateDecrypt = x3();
    Jn.privateEncrypt = function(e, r) {
      return Jn.publicEncrypt(e, r, true);
    };
    Jn.publicDecrypt = function(e, r) {
      return Jn.privateDecrypt(e, r, true);
    };
  });
  N3 = k((Ja) => {
    function E3() {
      throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
    }
    var R3 = Te(), A3 = hn(), B3 = R3.Buffer, q3 = R3.kMaxLength, jd = global.crypto || global.msCrypto, I3 = Math.pow(2, 32) - 1;
    function T3(t, e) {
      if (typeof t != "number" || t !== t)
        throw new TypeError("offset must be a number");
      if (t > I3 || t < 0)
        throw new TypeError("offset must be a uint32");
      if (t > q3 || t > e)
        throw new RangeError("offset out of range");
    }
    function k3(t, e, r) {
      if (typeof t != "number" || t !== t)
        throw new TypeError("size must be a number");
      if (t > I3 || t < 0)
        throw new TypeError("size must be a uint32");
      if (t + e > r || t > q3)
        throw new RangeError("buffer too small");
    }
    jd && jd.getRandomValues ? (Ja.randomFill = BI, Ja.randomFillSync = qI) : (Ja.randomFill = E3, Ja.randomFillSync = E3);
    function BI(t, e, r, o) {
      if (!B3.isBuffer(t) && !(t instanceof global.Uint8Array))
        throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
      if (typeof e == "function")
        o = e, e = 0, r = t.length;
      else if (typeof r == "function")
        o = r, r = t.length - e;
      else if (typeof o != "function")
        throw new TypeError('"cb" argument must be a function');
      return T3(e, t.length), k3(r, e, t.length), L3(t, e, r, o);
    }
    function L3(t, e, r, o) {
      if (true) {
        var f2 = t.buffer, p = new Uint8Array(f2, e, r);
        if (jd.getRandomValues(p), o) {
          process.nextTick(function() {
            o(null, t);
          });
          return;
        }
        return t;
      }
      if (o) {
        A3(r, function(y, M) {
          if (y)
            return o(y);
          M.copy(t, e), o(null, t);
        });
        return;
      }
      var m = A3(r);
      return m.copy(t, e), t;
    }
    function qI(t, e, r) {
      if (typeof e > "u" && (e = 0), !B3.isBuffer(t) && !(t instanceof global.Uint8Array))
        throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
      return T3(e, t.length), r === undefined && (r = t.length - e), k3(r, e, t.length), L3(t, e, r);
    }
  });
  Zd = k((ke) => {
    ke.randomBytes = ke.rng = ke.pseudoRandomBytes = ke.prng = hn();
    ke.createHash = ke.Hash = yf();
    ke.createHmac = ke.Hmac = Cu();
    var II = Yb(), TI = Object.keys(II), kI = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(TI);
    ke.getHashes = function() {
      return kI;
    };
    var P3 = Vu();
    ke.pbkdf2 = P3.pbkdf2;
    ke.pbkdf2Sync = P3.pbkdf2Sync;
    var ci = gg();
    ke.Cipher = ci.Cipher;
    ke.createCipher = ci.createCipher;
    ke.Cipheriv = ci.Cipheriv;
    ke.createCipheriv = ci.createCipheriv;
    ke.Decipher = ci.Decipher;
    ke.createDecipher = ci.createDecipher;
    ke.Decipheriv = ci.Decipheriv;
    ke.createDecipheriv = ci.createDecipheriv;
    ke.getCiphers = ci.getCiphers;
    ke.listCiphers = ci.listCiphers;
    var Qa = Ng();
    ke.DiffieHellmanGroup = Qa.DiffieHellmanGroup;
    ke.createDiffieHellmanGroup = Qa.createDiffieHellmanGroup;
    ke.getDiffieHellman = Qa.getDiffieHellman;
    ke.createDiffieHellman = Qa.createDiffieHellman;
    ke.DiffieHellman = Qa.DiffieHellman;
    var A0 = f3();
    ke.createSign = A0.createSign;
    ke.Sign = A0.Sign;
    ke.createVerify = A0.createVerify;
    ke.Verify = A0.Verify;
    ke.createECDH = h3();
    var R0 = S3();
    ke.publicEncrypt = R0.publicEncrypt;
    ke.privateEncrypt = R0.privateEncrypt;
    ke.publicDecrypt = R0.publicDecrypt;
    ke.privateDecrypt = R0.privateDecrypt;
    var D3 = N3();
    ke.randomFill = D3.randomFill;
    ke.randomFillSync = D3.randomFillSync;
    ke.createCredentials = function() {
      throw new Error(["sorry, createCredentials is not implemented yet", "we accept pull requests", "https://github.com/crypto-browserify/crypto-browserify"].join(`
`));
    };
    ke.constants = { DH_CHECK_P_NOT_SAFE_PRIME: 2, DH_CHECK_P_NOT_PRIME: 1, DH_UNABLE_TO_CHECK_GENERATOR: 4, DH_NOT_SUITABLE_GENERATOR: 8, NPN_ENABLED: 1, ALPN_ENABLED: 1, RSA_PKCS1_PADDING: 1, RSA_SSLV23_PADDING: 2, RSA_NO_PADDING: 3, RSA_PKCS1_OAEP_PADDING: 4, RSA_X931_PADDING: 5, RSA_PKCS1_PSS_PADDING: 6, POINT_CONVERSION_COMPRESSED: 2, POINT_CONVERSION_UNCOMPRESSED: 4, POINT_CONVERSION_HYBRID: 6 };
  });
  Xt = {};
  io(Xt, { DEFAULT_ENCODING: () => eo, default: () => PI, getCurves: () => F3, getRandomValues: () => C3, randomUUID: () => O3, scrypt: () => $d, scryptSync: () => Vd, timingSafeEqual: () => B0, webcrypto: () => U3 });
  ot(Xt, fn(Zd()));
  LI = fn(Zd());
  eo = "buffer";
  C3 = (t) => crypto.getRandomValues(t);
  O3 = () => crypto.randomUUID();
  NI = ["p192", "p224", "p256", "p384", "p521", "curve25519", "ed25519", "secp256k1", "secp224r1", "prime256v1", "prime192v1", "ed25519", "secp384r1", "secp521r1"];
  B0 = ("timingSafeEqual" in crypto) ? (t, e) => {
    let { byteLength: r } = t, { byteLength: o } = e;
    if (typeof r != "number" || typeof o != "number")
      throw new TypeError("Input must be an array buffer view");
    if (r !== o)
      throw new RangeError("Input buffers must have the same length");
    return crypto.timingSafeEqual(t, e);
  } : undefined;
  Vd = ("scryptSync" in crypto) ? (t, e, r, o) => {
    let f2 = crypto.scryptSync(t, e, r, o);
    return eo !== "buffer" ? new Buffer(f2).toString(eo) : new Buffer(f2);
  } : undefined;
  $d = ("scryptSync" in crypto) ? function(t, e, r, o, f2) {
    if (typeof o == "function" && (f2 = o, o = undefined), typeof f2 != "function") {
      var p = new TypeError("callback must be a function");
      throw p.code = "ERR_INVALID_CALLBACK", p;
    }
    try {
      let m = crypto.scryptSync(t, e, r, o);
      process.nextTick(f2, null, eo !== "buffer" ? new Buffer(m).toString(eo) : new Buffer(m));
    } catch (m) {
      throw m;
    }
  } : undefined;
  B0 && (Object.defineProperty(B0, "name", { value: "::bunternal::" }), Object.defineProperty($d, "name", { value: "::bunternal::" }), Object.defineProperty(Vd, "name", { value: "::bunternal::" }));
  U3 = crypto;
  PI = { ...LI, getRandomValues: C3, randomUUID: O3, timingSafeEqual: B0, scryptSync: Vd, scrypt: $d, webcrypto: U3, getCurves: F3 };
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
});

// node_modules/brorand/index.js
var require_brorand = __commonJS((exports, module) => {
  var Rand = function(rand) {
    this.rand = rand;
  };
  var r;
  module.exports = function rand(len) {
    if (!r)
      r = new Rand(null);
    return r.generate(len);
  };
  module.exports.Rand = Rand;
  Rand.prototype.generate = function generate(len) {
    return this._rand(len);
  };
  Rand.prototype._rand = function _rand(n) {
    if (this.rand.getBytes)
      return this.rand.getBytes(n);
    var res = new Uint8Array(n);
    for (var i = 0;i < res.length; i++)
      res[i] = this.rand.getByte();
    return res;
  };
  if (typeof self === "object") {
    if (self.crypto && self.crypto.getRandomValues) {
      Rand.prototype._rand = function _rand(n) {
        var arr = new Uint8Array(n);
        self.crypto.getRandomValues(arr);
        return arr;
      };
    } else if (self.msCrypto && self.msCrypto.getRandomValues) {
      Rand.prototype._rand = function _rand(n) {
        var arr = new Uint8Array(n);
        self.msCrypto.getRandomValues(arr);
        return arr;
      };
    } else if (typeof window === "object") {
      Rand.prototype._rand = function() {
        throw new Error("Not implemented yet");
      };
    }
  } else {
    try {
      crypto15 = (init_crypto(), __toCommonJS(exports_crypto));
      if (typeof crypto15.randomBytes !== "function")
        throw new Error("Not supported");
      Rand.prototype._rand = function _rand(n) {
        return crypto15.randomBytes(n);
      };
    } catch (e) {
    }
  }
  var crypto15;
});

// node_modules/elliptic/lib/elliptic/curve/base.js
var require_base = __commonJS((exports, module) => {
  var BaseCurve = function(type4, conf) {
    this.type = type4;
    this.p = new BN2(conf.p, 16);
    this.red = conf.prime ? BN2.red(conf.prime) : BN2.mont(this.p);
    this.zero = new BN2(0).toRed(this.red);
    this.one = new BN2(1).toRed(this.red);
    this.two = new BN2(2).toRed(this.red);
    this.n = conf.n && new BN2(conf.n, 16);
    this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
    this._wnafT1 = new Array(4);
    this._wnafT2 = new Array(4);
    this._wnafT3 = new Array(4);
    this._wnafT4 = new Array(4);
    this._bitLength = this.n ? this.n.bitLength() : 0;
    var adjustCount = this.n && this.p.div(this.n);
    if (!adjustCount || adjustCount.cmpn(100) > 0) {
      this.redN = null;
    } else {
      this._maxwellTrick = true;
      this.redN = this.n.toRed(this.red);
    }
  };
  var BasePoint = function(curve, type4) {
    this.curve = curve;
    this.type = type4;
    this.precomputed = null;
  };
  var BN2 = require_bn2();
  var utils41 = require_utils2();
  var getNAF = utils41.getNAF;
  var getJSF = utils41.getJSF;
  var assert4 = utils41.assert;
  module.exports = BaseCurve;
  BaseCurve.prototype.point = function point() {
    throw new Error("Not implemented");
  };
  BaseCurve.prototype.validate = function validate() {
    throw new Error("Not implemented");
  };
  BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k2) {
    assert4(p.precomputed);
    var doubles = p._getDoubles();
    var naf = getNAF(k2, 1, this._bitLength);
    var I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
    I /= 3;
    var repr = [];
    var j;
    var nafW;
    for (j = 0;j < naf.length; j += doubles.step) {
      nafW = 0;
      for (var l = j + doubles.step - 1;l >= j; l--)
        nafW = (nafW << 1) + naf[l];
      repr.push(nafW);
    }
    var a = this.jpoint(null, null, null);
    var b2 = this.jpoint(null, null, null);
    for (var i = I;i > 0; i--) {
      for (j = 0;j < repr.length; j++) {
        nafW = repr[j];
        if (nafW === i)
          b2 = b2.mixedAdd(doubles.points[j]);
        else if (nafW === -i)
          b2 = b2.mixedAdd(doubles.points[j].neg());
      }
      a = a.add(b2);
    }
    return a.toP();
  };
  BaseCurve.prototype._wnafMul = function _wnafMul(p, k2) {
    var w = 4;
    var nafPoints = p._getNAFPoints(w);
    w = nafPoints.wnd;
    var wnd = nafPoints.points;
    var naf = getNAF(k2, w, this._bitLength);
    var acc = this.jpoint(null, null, null);
    for (var i = naf.length - 1;i >= 0; i--) {
      for (var l = 0;i >= 0 && naf[i] === 0; i--)
        l++;
      if (i >= 0)
        l++;
      acc = acc.dblp(l);
      if (i < 0)
        break;
      var z2 = naf[i];
      assert4(z2 !== 0);
      if (p.type === "affine") {
        if (z2 > 0)
          acc = acc.mixedAdd(wnd[z2 - 1 >> 1]);
        else
          acc = acc.mixedAdd(wnd[-z2 - 1 >> 1].neg());
      } else {
        if (z2 > 0)
          acc = acc.add(wnd[z2 - 1 >> 1]);
        else
          acc = acc.add(wnd[-z2 - 1 >> 1].neg());
      }
    }
    return p.type === "affine" ? acc.toP() : acc;
  };
  BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
    var wndWidth = this._wnafT1;
    var wnd = this._wnafT2;
    var naf = this._wnafT3;
    var max2 = 0;
    var i;
    var j;
    var p;
    for (i = 0;i < len; i++) {
      p = points[i];
      var nafPoints = p._getNAFPoints(defW);
      wndWidth[i] = nafPoints.wnd;
      wnd[i] = nafPoints.points;
    }
    for (i = len - 1;i >= 1; i -= 2) {
      var a = i - 1;
      var b2 = i;
      if (wndWidth[a] !== 1 || wndWidth[b2] !== 1) {
        naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
        naf[b2] = getNAF(coeffs[b2], wndWidth[b2], this._bitLength);
        max2 = Math.max(naf[a].length, max2);
        max2 = Math.max(naf[b2].length, max2);
        continue;
      }
      var comb = [
        points[a],
        null,
        null,
        points[b2]
      ];
      if (points[a].y.cmp(points[b2].y) === 0) {
        comb[1] = points[a].add(points[b2]);
        comb[2] = points[a].toJ().mixedAdd(points[b2].neg());
      } else if (points[a].y.cmp(points[b2].y.redNeg()) === 0) {
        comb[1] = points[a].toJ().mixedAdd(points[b2]);
        comb[2] = points[a].add(points[b2].neg());
      } else {
        comb[1] = points[a].toJ().mixedAdd(points[b2]);
        comb[2] = points[a].toJ().mixedAdd(points[b2].neg());
      }
      var index = [
        -3,
        -1,
        -5,
        -7,
        0,
        7,
        5,
        1,
        3
      ];
      var jsf = getJSF(coeffs[a], coeffs[b2]);
      max2 = Math.max(jsf[0].length, max2);
      naf[a] = new Array(max2);
      naf[b2] = new Array(max2);
      for (j = 0;j < max2; j++) {
        var ja = jsf[0][j] | 0;
        var jb2 = jsf[1][j] | 0;
        naf[a][j] = index[(ja + 1) * 3 + (jb2 + 1)];
        naf[b2][j] = 0;
        wnd[a] = comb;
      }
    }
    var acc = this.jpoint(null, null, null);
    var tmp = this._wnafT4;
    for (i = max2;i >= 0; i--) {
      var k2 = 0;
      while (i >= 0) {
        var zero = true;
        for (j = 0;j < len; j++) {
          tmp[j] = naf[j][i] | 0;
          if (tmp[j] !== 0)
            zero = false;
        }
        if (!zero)
          break;
        k2++;
        i--;
      }
      if (i >= 0)
        k2++;
      acc = acc.dblp(k2);
      if (i < 0)
        break;
      for (j = 0;j < len; j++) {
        var z2 = tmp[j];
        if (z2 === 0)
          continue;
        else if (z2 > 0)
          p = wnd[j][z2 - 1 >> 1];
        else if (z2 < 0)
          p = wnd[j][-z2 - 1 >> 1].neg();
        if (p.type === "affine")
          acc = acc.mixedAdd(p);
        else
          acc = acc.add(p);
      }
    }
    for (i = 0;i < len; i++)
      wnd[i] = null;
    if (jacobianResult)
      return acc;
    else
      return acc.toP();
  };
  BaseCurve.BasePoint = BasePoint;
  BasePoint.prototype.eq = function eq() {
    throw new Error("Not implemented");
  };
  BasePoint.prototype.validate = function validate() {
    return this.curve.validate(this);
  };
  BaseCurve.prototype.decodePoint = function decodePoint(bytes3, enc) {
    bytes3 = utils41.toArray(bytes3, enc);
    var len = this.p.byteLength();
    if ((bytes3[0] === 4 || bytes3[0] === 6 || bytes3[0] === 7) && bytes3.length - 1 === 2 * len) {
      if (bytes3[0] === 6)
        assert4(bytes3[bytes3.length - 1] % 2 === 0);
      else if (bytes3[0] === 7)
        assert4(bytes3[bytes3.length - 1] % 2 === 1);
      var res = this.point(bytes3.slice(1, 1 + len), bytes3.slice(1 + len, 1 + 2 * len));
      return res;
    } else if ((bytes3[0] === 2 || bytes3[0] === 3) && bytes3.length - 1 === len) {
      return this.pointFromX(bytes3.slice(1, 1 + len), bytes3[0] === 3);
    }
    throw new Error("Unknown point format");
  };
  BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
    return this.encode(enc, true);
  };
  BasePoint.prototype._encode = function _encode(compact) {
    var len = this.curve.p.byteLength();
    var x = this.getX().toArray("be", len);
    if (compact)
      return [this.getY().isEven() ? 2 : 3].concat(x);
    return [4].concat(x, this.getY().toArray("be", len));
  };
  BasePoint.prototype.encode = function encode(enc, compact) {
    return utils41.encode(this._encode(compact), enc);
  };
  BasePoint.prototype.precompute = function precompute(power) {
    if (this.precomputed)
      return this;
    var precomputed = {
      doubles: null,
      naf: null,
      beta: null
    };
    precomputed.naf = this._getNAFPoints(8);
    precomputed.doubles = this._getDoubles(4, power);
    precomputed.beta = this._getBeta();
    this.precomputed = precomputed;
    return this;
  };
  BasePoint.prototype._hasDoubles = function _hasDoubles(k2) {
    if (!this.precomputed)
      return false;
    var doubles = this.precomputed.doubles;
    if (!doubles)
      return false;
    return doubles.points.length >= Math.ceil((k2.bitLength() + 1) / doubles.step);
  };
  BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
    if (this.precomputed && this.precomputed.doubles)
      return this.precomputed.doubles;
    var doubles = [this];
    var acc = this;
    for (var i = 0;i < power; i += step) {
      for (var j = 0;j < step; j++)
        acc = acc.dbl();
      doubles.push(acc);
    }
    return {
      step,
      points: doubles
    };
  };
  BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
    if (this.precomputed && this.precomputed.naf)
      return this.precomputed.naf;
    var res = [this];
    var max2 = (1 << wnd) - 1;
    var dbl = max2 === 1 ? null : this.dbl();
    for (var i = 1;i < max2; i++)
      res[i] = res[i - 1].add(dbl);
    return {
      wnd,
      points: res
    };
  };
  BasePoint.prototype._getBeta = function _getBeta() {
    return null;
  };
  BasePoint.prototype.dblp = function dblp(k2) {
    var r = this;
    for (var i = 0;i < k2; i++)
      r = r.dbl();
    return r;
  };
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS((exports, module) => {
  if (typeof Object.create === "function") {
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor;
        ctor.prototype.constructor = ctor;
      }
    };
  }
});

// node_modules/elliptic/lib/elliptic/curve/short.js
var require_short = __commonJS((exports, module) => {
  var ShortCurve = function(conf) {
    Base.call(this, "short", conf);
    this.a = new BN2(conf.a, 16).toRed(this.red);
    this.b = new BN2(conf.b, 16).toRed(this.red);
    this.tinv = this.two.redInvm();
    this.zeroA = this.a.fromRed().cmpn(0) === 0;
    this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
    this.endo = this._getEndomorphism(conf);
    this._endoWnafT1 = new Array(4);
    this._endoWnafT2 = new Array(4);
  };
  var Point = function(curve, x, y, isRed) {
    Base.BasePoint.call(this, curve, "affine");
    if (x === null && y === null) {
      this.x = null;
      this.y = null;
      this.inf = true;
    } else {
      this.x = new BN2(x, 16);
      this.y = new BN2(y, 16);
      if (isRed) {
        this.x.forceRed(this.curve.red);
        this.y.forceRed(this.curve.red);
      }
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      this.inf = false;
    }
  };
  var JPoint = function(curve, x, y, z2) {
    Base.BasePoint.call(this, curve, "jacobian");
    if (x === null && y === null && z2 === null) {
      this.x = this.curve.one;
      this.y = this.curve.one;
      this.z = new BN2(0);
    } else {
      this.x = new BN2(x, 16);
      this.y = new BN2(y, 16);
      this.z = new BN2(z2, 16);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;
  };
  var utils41 = require_utils2();
  var BN2 = require_bn2();
  var inherits = require_inherits_browser();
  var Base = require_base();
  var assert4 = utils41.assert;
  inherits(ShortCurve, Base);
  module.exports = ShortCurve;
  ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
    if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
      return;
    var beta;
    var lambda;
    if (conf.beta) {
      beta = new BN2(conf.beta, 16).toRed(this.red);
    } else {
      var betas = this._getEndoRoots(this.p);
      beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
      beta = beta.toRed(this.red);
    }
    if (conf.lambda) {
      lambda = new BN2(conf.lambda, 16);
    } else {
      var lambdas = this._getEndoRoots(this.n);
      if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
        lambda = lambdas[0];
      } else {
        lambda = lambdas[1];
        assert4(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
      }
    }
    var basis;
    if (conf.basis) {
      basis = conf.basis.map(function(vec) {
        return {
          a: new BN2(vec.a, 16),
          b: new BN2(vec.b, 16)
        };
      });
    } else {
      basis = this._getEndoBasis(lambda);
    }
    return {
      beta,
      lambda,
      basis
    };
  };
  ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
    var red = num === this.p ? this.red : BN2.mont(num);
    var tinv = new BN2(2).toRed(red).redInvm();
    var ntinv = tinv.redNeg();
    var s = new BN2(3).toRed(red).redNeg().redSqrt().redMul(tinv);
    var l1 = ntinv.redAdd(s).fromRed();
    var l2 = ntinv.redSub(s).fromRed();
    return [l1, l2];
  };
  ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
    var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
    var u = lambda;
    var v2 = this.n.clone();
    var x1 = new BN2(1);
    var y1 = new BN2(0);
    var x22 = new BN2(0);
    var y2 = new BN2(1);
    var a02;
    var b0;
    var a1;
    var b1;
    var a22;
    var b2;
    var prevR;
    var i = 0;
    var r;
    var x;
    while (u.cmpn(0) !== 0) {
      var q = v2.div(u);
      r = v2.sub(q.mul(u));
      x = x22.sub(q.mul(x1));
      var y = y2.sub(q.mul(y1));
      if (!a1 && r.cmp(aprxSqrt) < 0) {
        a02 = prevR.neg();
        b0 = x1;
        a1 = r.neg();
        b1 = x;
      } else if (a1 && ++i === 2) {
        break;
      }
      prevR = r;
      v2 = u;
      u = r;
      x22 = x1;
      x1 = x;
      y2 = y1;
      y1 = y;
    }
    a22 = r.neg();
    b2 = x;
    var len1 = a1.sqr().add(b1.sqr());
    var len2 = a22.sqr().add(b2.sqr());
    if (len2.cmp(len1) >= 0) {
      a22 = a02;
      b2 = b0;
    }
    if (a1.negative) {
      a1 = a1.neg();
      b1 = b1.neg();
    }
    if (a22.negative) {
      a22 = a22.neg();
      b2 = b2.neg();
    }
    return [
      { a: a1, b: b1 },
      { a: a22, b: b2 }
    ];
  };
  ShortCurve.prototype._endoSplit = function _endoSplit(k2) {
    var basis = this.endo.basis;
    var v1 = basis[0];
    var v2 = basis[1];
    var c1 = v2.b.mul(k2).divRound(this.n);
    var c2 = v1.b.neg().mul(k2).divRound(this.n);
    var p1 = c1.mul(v1.a);
    var p2 = c2.mul(v2.a);
    var q1 = c1.mul(v1.b);
    var q2 = c2.mul(v2.b);
    var k1 = k2.sub(p1).sub(p2);
    var k22 = q1.add(q2).neg();
    return { k1, k2: k22 };
  };
  ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
    x = new BN2(x, 16);
    if (!x.red)
      x = x.toRed(this.red);
    var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
    var y = y2.redSqrt();
    if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var isOdd = y.fromRed().isOdd();
    if (odd && !isOdd || !odd && isOdd)
      y = y.redNeg();
    return this.point(x, y);
  };
  ShortCurve.prototype.validate = function validate(point) {
    if (point.inf)
      return true;
    var x = point.x;
    var y = point.y;
    var ax = this.a.redMul(x);
    var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
    return y.redSqr().redISub(rhs).cmpn(0) === 0;
  };
  ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
    var npoints = this._endoWnafT1;
    var ncoeffs = this._endoWnafT2;
    for (var i = 0;i < points.length; i++) {
      var split3 = this._endoSplit(coeffs[i]);
      var p = points[i];
      var beta = p._getBeta();
      if (split3.k1.negative) {
        split3.k1.ineg();
        p = p.neg(true);
      }
      if (split3.k2.negative) {
        split3.k2.ineg();
        beta = beta.neg(true);
      }
      npoints[i * 2] = p;
      npoints[i * 2 + 1] = beta;
      ncoeffs[i * 2] = split3.k1;
      ncoeffs[i * 2 + 1] = split3.k2;
    }
    var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);
    for (var j = 0;j < i * 2; j++) {
      npoints[j] = null;
      ncoeffs[j] = null;
    }
    return res;
  };
  inherits(Point, Base.BasePoint);
  ShortCurve.prototype.point = function point(x, y, isRed) {
    return new Point(this, x, y, isRed);
  };
  ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
    return Point.fromJSON(this, obj, red);
  };
  Point.prototype._getBeta = function _getBeta() {
    if (!this.curve.endo)
      return;
    var pre = this.precomputed;
    if (pre && pre.beta)
      return pre.beta;
    var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (pre) {
      var curve = this.curve;
      var endoMul = function(p) {
        return curve.point(p.x.redMul(curve.endo.beta), p.y);
      };
      pre.beta = beta;
      beta.precomputed = {
        beta: null,
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: pre.naf.points.map(endoMul)
        },
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: pre.doubles.points.map(endoMul)
        }
      };
    }
    return beta;
  };
  Point.prototype.toJSON = function toJSON() {
    if (!this.precomputed)
      return [this.x, this.y];
    return [this.x, this.y, this.precomputed && {
      doubles: this.precomputed.doubles && {
        step: this.precomputed.doubles.step,
        points: this.precomputed.doubles.points.slice(1)
      },
      naf: this.precomputed.naf && {
        wnd: this.precomputed.naf.wnd,
        points: this.precomputed.naf.points.slice(1)
      }
    }];
  };
  Point.fromJSON = function fromJSON(curve, obj, red) {
    if (typeof obj === "string")
      obj = JSON.parse(obj);
    var res = curve.point(obj[0], obj[1], red);
    if (!obj[2])
      return res;
    function obj2point(obj2) {
      return curve.point(obj2[0], obj2[1], red);
    }
    var pre = obj[2];
    res.precomputed = {
      beta: null,
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: [res].concat(pre.doubles.points.map(obj2point))
      },
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: [res].concat(pre.naf.points.map(obj2point))
      }
    };
    return res;
  };
  Point.prototype.inspect = function inspect() {
    if (this.isInfinity())
      return "<EC Point Infinity>";
    return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
  };
  Point.prototype.isInfinity = function isInfinity() {
    return this.inf;
  };
  Point.prototype.add = function add(p) {
    if (this.inf)
      return p;
    if (p.inf)
      return this;
    if (this.eq(p))
      return this.dbl();
    if (this.neg().eq(p))
      return this.curve.point(null, null);
    if (this.x.cmp(p.x) === 0)
      return this.curve.point(null, null);
    var c = this.y.redSub(p.y);
    if (c.cmpn(0) !== 0)
      c = c.redMul(this.x.redSub(p.x).redInvm());
    var nx = c.redSqr().redISub(this.x).redISub(p.x);
    var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
    return this.curve.point(nx, ny);
  };
  Point.prototype.dbl = function dbl() {
    if (this.inf)
      return this;
    var ys1 = this.y.redAdd(this.y);
    if (ys1.cmpn(0) === 0)
      return this.curve.point(null, null);
    var a = this.curve.a;
    var x22 = this.x.redSqr();
    var dyinv = ys1.redInvm();
    var c = x22.redAdd(x22).redIAdd(x22).redIAdd(a).redMul(dyinv);
    var nx = c.redSqr().redISub(this.x.redAdd(this.x));
    var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
    return this.curve.point(nx, ny);
  };
  Point.prototype.getX = function getX() {
    return this.x.fromRed();
  };
  Point.prototype.getY = function getY() {
    return this.y.fromRed();
  };
  Point.prototype.mul = function mul(k2) {
    k2 = new BN2(k2, 16);
    if (this.isInfinity())
      return this;
    else if (this._hasDoubles(k2))
      return this.curve._fixedNafMul(this, k2);
    else if (this.curve.endo)
      return this.curve._endoWnafMulAdd([this], [k2]);
    else
      return this.curve._wnafMul(this, k2);
  };
  Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
    var points = [this, p2];
    var coeffs = [k1, k2];
    if (this.curve.endo)
      return this.curve._endoWnafMulAdd(points, coeffs);
    else
      return this.curve._wnafMulAdd(1, points, coeffs, 2);
  };
  Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
    var points = [this, p2];
    var coeffs = [k1, k2];
    if (this.curve.endo)
      return this.curve._endoWnafMulAdd(points, coeffs, true);
    else
      return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
  };
  Point.prototype.eq = function eq(p) {
    return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
  };
  Point.prototype.neg = function neg(_precompute) {
    if (this.inf)
      return this;
    var res = this.curve.point(this.x, this.y.redNeg());
    if (_precompute && this.precomputed) {
      var pre = this.precomputed;
      var negate = function(p) {
        return p.neg();
      };
      res.precomputed = {
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: pre.naf.points.map(negate)
        },
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: pre.doubles.points.map(negate)
        }
      };
    }
    return res;
  };
  Point.prototype.toJ = function toJ() {
    if (this.inf)
      return this.curve.jpoint(null, null, null);
    var res = this.curve.jpoint(this.x, this.y, this.curve.one);
    return res;
  };
  inherits(JPoint, Base.BasePoint);
  ShortCurve.prototype.jpoint = function jpoint(x, y, z2) {
    return new JPoint(this, x, y, z2);
  };
  JPoint.prototype.toP = function toP() {
    if (this.isInfinity())
      return this.curve.point(null, null);
    var zinv = this.z.redInvm();
    var zinv2 = zinv.redSqr();
    var ax = this.x.redMul(zinv2);
    var ay = this.y.redMul(zinv2).redMul(zinv);
    return this.curve.point(ax, ay);
  };
  JPoint.prototype.neg = function neg() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
  };
  JPoint.prototype.add = function add(p) {
    if (this.isInfinity())
      return p;
    if (p.isInfinity())
      return this;
    var pz2 = p.z.redSqr();
    var z2 = this.z.redSqr();
    var u1 = this.x.redMul(pz2);
    var u2 = p.x.redMul(z2);
    var s1 = this.y.redMul(pz2.redMul(p.z));
    var s22 = p.y.redMul(z2.redMul(this.z));
    var h = u1.redSub(u2);
    var r = s1.redSub(s22);
    if (h.cmpn(0) === 0) {
      if (r.cmpn(0) !== 0)
        return this.curve.jpoint(null, null, null);
      else
        return this.dbl();
    }
    var h2 = h.redSqr();
    var h32 = h2.redMul(h);
    var v2 = u1.redMul(h2);
    var nx = r.redSqr().redIAdd(h32).redISub(v2).redISub(v2);
    var ny = r.redMul(v2.redISub(nx)).redISub(s1.redMul(h32));
    var nz = this.z.redMul(p.z).redMul(h);
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype.mixedAdd = function mixedAdd(p) {
    if (this.isInfinity())
      return p.toJ();
    if (p.isInfinity())
      return this;
    var z2 = this.z.redSqr();
    var u1 = this.x;
    var u2 = p.x.redMul(z2);
    var s1 = this.y;
    var s22 = p.y.redMul(z2).redMul(this.z);
    var h = u1.redSub(u2);
    var r = s1.redSub(s22);
    if (h.cmpn(0) === 0) {
      if (r.cmpn(0) !== 0)
        return this.curve.jpoint(null, null, null);
      else
        return this.dbl();
    }
    var h2 = h.redSqr();
    var h32 = h2.redMul(h);
    var v2 = u1.redMul(h2);
    var nx = r.redSqr().redIAdd(h32).redISub(v2).redISub(v2);
    var ny = r.redMul(v2.redISub(nx)).redISub(s1.redMul(h32));
    var nz = this.z.redMul(h);
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype.dblp = function dblp(pow) {
    if (pow === 0)
      return this;
    if (this.isInfinity())
      return this;
    if (!pow)
      return this.dbl();
    var i;
    if (this.curve.zeroA || this.curve.threeA) {
      var r = this;
      for (i = 0;i < pow; i++)
        r = r.dbl();
      return r;
    }
    var a = this.curve.a;
    var tinv = this.curve.tinv;
    var jx = this.x;
    var jy = this.y;
    var jz = this.z;
    var jz4 = jz.redSqr().redSqr();
    var jyd = jy.redAdd(jy);
    for (i = 0;i < pow; i++) {
      var jx2 = jx.redSqr();
      var jyd2 = jyd.redSqr();
      var jyd4 = jyd2.redSqr();
      var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
      var t1 = jx.redMul(jyd2);
      var nx = c.redSqr().redISub(t1.redAdd(t1));
      var t2 = t1.redISub(nx);
      var dny = c.redMul(t2);
      dny = dny.redIAdd(dny).redISub(jyd4);
      var nz = jyd.redMul(jz);
      if (i + 1 < pow)
        jz4 = jz4.redMul(jyd4);
      jx = nx;
      jz = nz;
      jyd = dny;
    }
    return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
  };
  JPoint.prototype.dbl = function dbl() {
    if (this.isInfinity())
      return this;
    if (this.curve.zeroA)
      return this._zeroDbl();
    else if (this.curve.threeA)
      return this._threeDbl();
    else
      return this._dbl();
  };
  JPoint.prototype._zeroDbl = function _zeroDbl() {
    var nx;
    var ny;
    var nz;
    if (this.zOne) {
      var xx = this.x.redSqr();
      var yy2 = this.y.redSqr();
      var yyyy = yy2.redSqr();
      var s = this.x.redAdd(yy2).redSqr().redISub(xx).redISub(yyyy);
      s = s.redIAdd(s);
      var m = xx.redAdd(xx).redIAdd(xx);
      var t = m.redSqr().redISub(s).redISub(s);
      var yyyy8 = yyyy.redIAdd(yyyy);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      nx = t;
      ny = m.redMul(s.redISub(t)).redISub(yyyy8);
      nz = this.y.redAdd(this.y);
    } else {
      var a = this.x.redSqr();
      var b2 = this.y.redSqr();
      var c = b2.redSqr();
      var d = this.x.redAdd(b2).redSqr().redISub(a).redISub(c);
      d = d.redIAdd(d);
      var e = a.redAdd(a).redIAdd(a);
      var f2 = e.redSqr();
      var c8 = c.redIAdd(c);
      c8 = c8.redIAdd(c8);
      c8 = c8.redIAdd(c8);
      nx = f2.redISub(d).redISub(d);
      ny = e.redMul(d.redISub(nx)).redISub(c8);
      nz = this.y.redMul(this.z);
      nz = nz.redIAdd(nz);
    }
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype._threeDbl = function _threeDbl() {
    var nx;
    var ny;
    var nz;
    if (this.zOne) {
      var xx = this.x.redSqr();
      var yy2 = this.y.redSqr();
      var yyyy = yy2.redSqr();
      var s = this.x.redAdd(yy2).redSqr().redISub(xx).redISub(yyyy);
      s = s.redIAdd(s);
      var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
      var t = m.redSqr().redISub(s).redISub(s);
      nx = t;
      var yyyy8 = yyyy.redIAdd(yyyy);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      ny = m.redMul(s.redISub(t)).redISub(yyyy8);
      nz = this.y.redAdd(this.y);
    } else {
      var delta = this.z.redSqr();
      var gamma = this.y.redSqr();
      var beta = this.x.redMul(gamma);
      var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
      alpha = alpha.redAdd(alpha).redIAdd(alpha);
      var beta4 = beta.redIAdd(beta);
      beta4 = beta4.redIAdd(beta4);
      var beta8 = beta4.redAdd(beta4);
      nx = alpha.redSqr().redISub(beta8);
      nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
      var ggamma8 = gamma.redSqr();
      ggamma8 = ggamma8.redIAdd(ggamma8);
      ggamma8 = ggamma8.redIAdd(ggamma8);
      ggamma8 = ggamma8.redIAdd(ggamma8);
      ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
    }
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype._dbl = function _dbl() {
    var a = this.curve.a;
    var jx = this.x;
    var jy = this.y;
    var jz = this.z;
    var jz4 = jz.redSqr().redSqr();
    var jx2 = jx.redSqr();
    var jy2 = jy.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
    var jxd4 = jx.redAdd(jx);
    jxd4 = jxd4.redIAdd(jxd4);
    var t1 = jxd4.redMul(jy2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var jyd8 = jy2.redSqr();
    jyd8 = jyd8.redIAdd(jyd8);
    jyd8 = jyd8.redIAdd(jyd8);
    jyd8 = jyd8.redIAdd(jyd8);
    var ny = c.redMul(t2).redISub(jyd8);
    var nz = jy.redAdd(jy).redMul(jz);
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype.trpl = function trpl() {
    if (!this.curve.zeroA)
      return this.dbl().add(this);
    var xx = this.x.redSqr();
    var yy2 = this.y.redSqr();
    var zz = this.z.redSqr();
    var yyyy = yy2.redSqr();
    var m = xx.redAdd(xx).redIAdd(xx);
    var mm = m.redSqr();
    var e = this.x.redAdd(yy2).redSqr().redISub(xx).redISub(yyyy);
    e = e.redIAdd(e);
    e = e.redAdd(e).redIAdd(e);
    e = e.redISub(mm);
    var ee = e.redSqr();
    var t = yyyy.redIAdd(yyyy);
    t = t.redIAdd(t);
    t = t.redIAdd(t);
    t = t.redIAdd(t);
    var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
    var yyu4 = yy2.redMul(u);
    yyu4 = yyu4.redIAdd(yyu4);
    yyu4 = yyu4.redIAdd(yyu4);
    var nx = this.x.redMul(ee).redISub(yyu4);
    nx = nx.redIAdd(nx);
    nx = nx.redIAdd(nx);
    var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
    ny = ny.redIAdd(ny);
    ny = ny.redIAdd(ny);
    ny = ny.redIAdd(ny);
    var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype.mul = function mul(k2, kbase) {
    k2 = new BN2(k2, kbase);
    return this.curve._wnafMul(this, k2);
  };
  JPoint.prototype.eq = function eq(p) {
    if (p.type === "affine")
      return this.eq(p.toJ());
    if (this === p)
      return true;
    var z2 = this.z.redSqr();
    var pz2 = p.z.redSqr();
    if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
      return false;
    var z32 = z2.redMul(this.z);
    var pz3 = pz2.redMul(p.z);
    return this.y.redMul(pz3).redISub(p.y.redMul(z32)).cmpn(0) === 0;
  };
  JPoint.prototype.eqXToP = function eqXToP(x) {
    var zs = this.z.redSqr();
    var rx = x.toRed(this.curve.red).redMul(zs);
    if (this.x.cmp(rx) === 0)
      return true;
    var xc = x.clone();
    var t = this.curve.redN.redMul(zs);
    for (;; ) {
      xc.iadd(this.curve.n);
      if (xc.cmp(this.curve.p) >= 0)
        return false;
      rx.redIAdd(t);
      if (this.x.cmp(rx) === 0)
        return true;
    }
  };
  JPoint.prototype.inspect = function inspect() {
    if (this.isInfinity())
      return "<EC JPoint Infinity>";
    return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
  };
  JPoint.prototype.isInfinity = function isInfinity() {
    return this.z.cmpn(0) === 0;
  };
});

// node_modules/elliptic/lib/elliptic/curve/mont.js
var require_mont = __commonJS((exports, module) => {
  var MontCurve = function(conf) {
    Base.call(this, "mont", conf);
    this.a = new BN2(conf.a, 16).toRed(this.red);
    this.b = new BN2(conf.b, 16).toRed(this.red);
    this.i4 = new BN2(4).toRed(this.red).redInvm();
    this.two = new BN2(2).toRed(this.red);
    this.a24 = this.i4.redMul(this.a.redAdd(this.two));
  };
  var Point = function(curve, x, z2) {
    Base.BasePoint.call(this, curve, "projective");
    if (x === null && z2 === null) {
      this.x = this.curve.one;
      this.z = this.curve.zero;
    } else {
      this.x = new BN2(x, 16);
      this.z = new BN2(z2, 16);
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
    }
  };
  var BN2 = require_bn2();
  var inherits = require_inherits_browser();
  var Base = require_base();
  var utils41 = require_utils2();
  inherits(MontCurve, Base);
  module.exports = MontCurve;
  MontCurve.prototype.validate = function validate(point) {
    var x = point.normalize().x;
    var x22 = x.redSqr();
    var rhs = x22.redMul(x).redAdd(x22.redMul(this.a)).redAdd(x);
    var y = rhs.redSqrt();
    return y.redSqr().cmp(rhs) === 0;
  };
  inherits(Point, Base.BasePoint);
  MontCurve.prototype.decodePoint = function decodePoint(bytes3, enc) {
    return this.point(utils41.toArray(bytes3, enc), 1);
  };
  MontCurve.prototype.point = function point(x, z2) {
    return new Point(this, x, z2);
  };
  MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
    return Point.fromJSON(this, obj);
  };
  Point.prototype.precompute = function precompute() {
  };
  Point.prototype._encode = function _encode() {
    return this.getX().toArray("be", this.curve.p.byteLength());
  };
  Point.fromJSON = function fromJSON(curve, obj) {
    return new Point(curve, obj[0], obj[1] || curve.one);
  };
  Point.prototype.inspect = function inspect() {
    if (this.isInfinity())
      return "<EC Point Infinity>";
    return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  };
  Point.prototype.isInfinity = function isInfinity() {
    return this.z.cmpn(0) === 0;
  };
  Point.prototype.dbl = function dbl() {
    var a = this.x.redAdd(this.z);
    var aa = a.redSqr();
    var b2 = this.x.redSub(this.z);
    var bb = b2.redSqr();
    var c = aa.redSub(bb);
    var nx = aa.redMul(bb);
    var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
    return this.curve.point(nx, nz);
  };
  Point.prototype.add = function add() {
    throw new Error("Not supported on Montgomery curve");
  };
  Point.prototype.diffAdd = function diffAdd(p, diff) {
    var a = this.x.redAdd(this.z);
    var b2 = this.x.redSub(this.z);
    var c = p.x.redAdd(p.z);
    var d = p.x.redSub(p.z);
    var da = d.redMul(a);
    var cb = c.redMul(b2);
    var nx = diff.z.redMul(da.redAdd(cb).redSqr());
    var nz = diff.x.redMul(da.redISub(cb).redSqr());
    return this.curve.point(nx, nz);
  };
  Point.prototype.mul = function mul(k2) {
    var t = k2.clone();
    var a = this;
    var b2 = this.curve.point(null, null);
    var c = this;
    for (var bits = [];t.cmpn(0) !== 0; t.iushrn(1))
      bits.push(t.andln(1));
    for (var i = bits.length - 1;i >= 0; i--) {
      if (bits[i] === 0) {
        a = a.diffAdd(b2, c);
        b2 = b2.dbl();
      } else {
        b2 = a.diffAdd(b2, c);
        a = a.dbl();
      }
    }
    return b2;
  };
  Point.prototype.mulAdd = function mulAdd() {
    throw new Error("Not supported on Montgomery curve");
  };
  Point.prototype.jumlAdd = function jumlAdd() {
    throw new Error("Not supported on Montgomery curve");
  };
  Point.prototype.eq = function eq(other) {
    return this.getX().cmp(other.getX()) === 0;
  };
  Point.prototype.normalize = function normalize() {
    this.x = this.x.redMul(this.z.redInvm());
    this.z = this.curve.one;
    return this;
  };
  Point.prototype.getX = function getX() {
    this.normalize();
    return this.x.fromRed();
  };
});

// node_modules/elliptic/lib/elliptic/curve/edwards.js
var require_edwards = __commonJS((exports, module) => {
  var EdwardsCurve = function(conf) {
    this.twisted = (conf.a | 0) !== 1;
    this.mOneA = this.twisted && (conf.a | 0) === -1;
    this.extended = this.mOneA;
    Base.call(this, "edwards", conf);
    this.a = new BN2(conf.a, 16).umod(this.red.m);
    this.a = this.a.toRed(this.red);
    this.c = new BN2(conf.c, 16).toRed(this.red);
    this.c2 = this.c.redSqr();
    this.d = new BN2(conf.d, 16).toRed(this.red);
    this.dd = this.d.redAdd(this.d);
    assert4(!this.twisted || this.c.fromRed().cmpn(1) === 0);
    this.oneC = (conf.c | 0) === 1;
  };
  var Point = function(curve, x, y, z2, t) {
    Base.BasePoint.call(this, curve, "projective");
    if (x === null && y === null && z2 === null) {
      this.x = this.curve.zero;
      this.y = this.curve.one;
      this.z = this.curve.one;
      this.t = this.curve.zero;
      this.zOne = true;
    } else {
      this.x = new BN2(x, 16);
      this.y = new BN2(y, 16);
      this.z = z2 ? new BN2(z2, 16) : this.curve.one;
      this.t = t && new BN2(t, 16);
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
      if (this.t && !this.t.red)
        this.t = this.t.toRed(this.curve.red);
      this.zOne = this.z === this.curve.one;
      if (this.curve.extended && !this.t) {
        this.t = this.x.redMul(this.y);
        if (!this.zOne)
          this.t = this.t.redMul(this.z.redInvm());
      }
    }
  };
  var utils41 = require_utils2();
  var BN2 = require_bn2();
  var inherits = require_inherits_browser();
  var Base = require_base();
  var assert4 = utils41.assert;
  inherits(EdwardsCurve, Base);
  module.exports = EdwardsCurve;
  EdwardsCurve.prototype._mulA = function _mulA(num) {
    if (this.mOneA)
      return num.redNeg();
    else
      return this.a.redMul(num);
  };
  EdwardsCurve.prototype._mulC = function _mulC(num) {
    if (this.oneC)
      return num;
    else
      return this.c.redMul(num);
  };
  EdwardsCurve.prototype.jpoint = function jpoint(x, y, z2, t) {
    return this.point(x, y, z2, t);
  };
  EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
    x = new BN2(x, 16);
    if (!x.red)
      x = x.toRed(this.red);
    var x22 = x.redSqr();
    var rhs = this.c2.redSub(this.a.redMul(x22));
    var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x22));
    var y2 = rhs.redMul(lhs.redInvm());
    var y = y2.redSqrt();
    if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var isOdd = y.fromRed().isOdd();
    if (odd && !isOdd || !odd && isOdd)
      y = y.redNeg();
    return this.point(x, y);
  };
  EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
    y = new BN2(y, 16);
    if (!y.red)
      y = y.toRed(this.red);
    var y2 = y.redSqr();
    var lhs = y2.redSub(this.c2);
    var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
    var x22 = lhs.redMul(rhs.redInvm());
    if (x22.cmp(this.zero) === 0) {
      if (odd)
        throw new Error("invalid point");
      else
        return this.point(this.zero, y);
    }
    var x = x22.redSqrt();
    if (x.redSqr().redSub(x22).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    if (x.fromRed().isOdd() !== odd)
      x = x.redNeg();
    return this.point(x, y);
  };
  EdwardsCurve.prototype.validate = function validate(point) {
    if (point.isInfinity())
      return true;
    point.normalize();
    var x22 = point.x.redSqr();
    var y2 = point.y.redSqr();
    var lhs = x22.redMul(this.a).redAdd(y2);
    var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x22).redMul(y2)));
    return lhs.cmp(rhs) === 0;
  };
  inherits(Point, Base.BasePoint);
  EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
    return Point.fromJSON(this, obj);
  };
  EdwardsCurve.prototype.point = function point(x, y, z2, t) {
    return new Point(this, x, y, z2, t);
  };
  Point.fromJSON = function fromJSON(curve, obj) {
    return new Point(curve, obj[0], obj[1], obj[2]);
  };
  Point.prototype.inspect = function inspect() {
    if (this.isInfinity())
      return "<EC Point Infinity>";
    return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  };
  Point.prototype.isInfinity = function isInfinity() {
    return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
  };
  Point.prototype._extDbl = function _extDbl() {
    var a = this.x.redSqr();
    var b2 = this.y.redSqr();
    var c = this.z.redSqr();
    c = c.redIAdd(c);
    var d = this.curve._mulA(a);
    var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b2);
    var g = d.redAdd(b2);
    var f2 = g.redSub(c);
    var h = d.redSub(b2);
    var nx = e.redMul(f2);
    var ny = g.redMul(h);
    var nt = e.redMul(h);
    var nz = f2.redMul(g);
    return this.curve.point(nx, ny, nz, nt);
  };
  Point.prototype._projDbl = function _projDbl() {
    var b2 = this.x.redAdd(this.y).redSqr();
    var c = this.x.redSqr();
    var d = this.y.redSqr();
    var nx;
    var ny;
    var nz;
    var e;
    var h;
    var j;
    if (this.curve.twisted) {
      e = this.curve._mulA(c);
      var f2 = e.redAdd(d);
      if (this.zOne) {
        nx = b2.redSub(c).redSub(d).redMul(f2.redSub(this.curve.two));
        ny = f2.redMul(e.redSub(d));
        nz = f2.redSqr().redSub(f2).redSub(f2);
      } else {
        h = this.z.redSqr();
        j = f2.redSub(h).redISub(h);
        nx = b2.redSub(c).redISub(d).redMul(j);
        ny = f2.redMul(e.redSub(d));
        nz = f2.redMul(j);
      }
    } else {
      e = c.redAdd(d);
      h = this.curve._mulC(this.z).redSqr();
      j = e.redSub(h).redSub(h);
      nx = this.curve._mulC(b2.redISub(e)).redMul(j);
      ny = this.curve._mulC(e).redMul(c.redISub(d));
      nz = e.redMul(j);
    }
    return this.curve.point(nx, ny, nz);
  };
  Point.prototype.dbl = function dbl() {
    if (this.isInfinity())
      return this;
    if (this.curve.extended)
      return this._extDbl();
    else
      return this._projDbl();
  };
  Point.prototype._extAdd = function _extAdd(p) {
    var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
    var b2 = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
    var c = this.t.redMul(this.curve.dd).redMul(p.t);
    var d = this.z.redMul(p.z.redAdd(p.z));
    var e = b2.redSub(a);
    var f2 = d.redSub(c);
    var g = d.redAdd(c);
    var h = b2.redAdd(a);
    var nx = e.redMul(f2);
    var ny = g.redMul(h);
    var nt = e.redMul(h);
    var nz = f2.redMul(g);
    return this.curve.point(nx, ny, nz, nt);
  };
  Point.prototype._projAdd = function _projAdd(p) {
    var a = this.z.redMul(p.z);
    var b2 = a.redSqr();
    var c = this.x.redMul(p.x);
    var d = this.y.redMul(p.y);
    var e = this.curve.d.redMul(c).redMul(d);
    var f2 = b2.redSub(e);
    var g = b2.redAdd(e);
    var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
    var nx = a.redMul(f2).redMul(tmp);
    var ny;
    var nz;
    if (this.curve.twisted) {
      ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
      nz = f2.redMul(g);
    } else {
      ny = a.redMul(g).redMul(d.redSub(c));
      nz = this.curve._mulC(f2).redMul(g);
    }
    return this.curve.point(nx, ny, nz);
  };
  Point.prototype.add = function add(p) {
    if (this.isInfinity())
      return p;
    if (p.isInfinity())
      return this;
    if (this.curve.extended)
      return this._extAdd(p);
    else
      return this._projAdd(p);
  };
  Point.prototype.mul = function mul(k2) {
    if (this._hasDoubles(k2))
      return this.curve._fixedNafMul(this, k2);
    else
      return this.curve._wnafMul(this, k2);
  };
  Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
    return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, false);
  };
  Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
    return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, true);
  };
  Point.prototype.normalize = function normalize() {
    if (this.zOne)
      return this;
    var zi = this.z.redInvm();
    this.x = this.x.redMul(zi);
    this.y = this.y.redMul(zi);
    if (this.t)
      this.t = this.t.redMul(zi);
    this.z = this.curve.one;
    this.zOne = true;
    return this;
  };
  Point.prototype.neg = function neg() {
    return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
  };
  Point.prototype.getX = function getX() {
    this.normalize();
    return this.x.fromRed();
  };
  Point.prototype.getY = function getY() {
    this.normalize();
    return this.y.fromRed();
  };
  Point.prototype.eq = function eq(other) {
    return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
  };
  Point.prototype.eqXToP = function eqXToP(x) {
    var rx = x.toRed(this.curve.red).redMul(this.z);
    if (this.x.cmp(rx) === 0)
      return true;
    var xc = x.clone();
    var t = this.curve.redN.redMul(this.z);
    for (;; ) {
      xc.iadd(this.curve.n);
      if (xc.cmp(this.curve.p) >= 0)
        return false;
      rx.redIAdd(t);
      if (this.x.cmp(rx) === 0)
        return true;
    }
  };
  Point.prototype.toP = Point.prototype.normalize;
  Point.prototype.mixedAdd = Point.prototype.add;
});

// node_modules/elliptic/lib/elliptic/curve/index.js
var require_curve = __commonJS((exports) => {
  var curve = exports;
  curve.base = require_base();
  curve.short = require_short();
  curve.mont = require_mont();
  curve.edwards = require_edwards();
});

// node_modules/hash.js/lib/hash/utils.js
var require_utils3 = __commonJS((exports) => {
  var isSurrogatePair = function(msg, i) {
    if ((msg.charCodeAt(i) & 64512) !== 55296) {
      return false;
    }
    if (i < 0 || i + 1 >= msg.length) {
      return false;
    }
    return (msg.charCodeAt(i + 1) & 64512) === 56320;
  };
  var toArray = function(msg, enc) {
    if (Array.isArray(msg))
      return msg.slice();
    if (!msg)
      return [];
    var res = [];
    if (typeof msg === "string") {
      if (!enc) {
        var p = 0;
        for (var i = 0;i < msg.length; i++) {
          var c = msg.charCodeAt(i);
          if (c < 128) {
            res[p++] = c;
          } else if (c < 2048) {
            res[p++] = c >> 6 | 192;
            res[p++] = c & 63 | 128;
          } else if (isSurrogatePair(msg, i)) {
            c = 65536 + ((c & 1023) << 10) + (msg.charCodeAt(++i) & 1023);
            res[p++] = c >> 18 | 240;
            res[p++] = c >> 12 & 63 | 128;
            res[p++] = c >> 6 & 63 | 128;
            res[p++] = c & 63 | 128;
          } else {
            res[p++] = c >> 12 | 224;
            res[p++] = c >> 6 & 63 | 128;
            res[p++] = c & 63 | 128;
          }
        }
      } else if (enc === "hex") {
        msg = msg.replace(/[^a-z0-9]+/ig, "");
        if (msg.length % 2 !== 0)
          msg = "0" + msg;
        for (i = 0;i < msg.length; i += 2)
          res.push(parseInt(msg[i] + msg[i + 1], 16));
      }
    } else {
      for (i = 0;i < msg.length; i++)
        res[i] = msg[i] | 0;
    }
    return res;
  };
  var toHex2 = function(msg) {
    var res = "";
    for (var i = 0;i < msg.length; i++)
      res += zero2(msg[i].toString(16));
    return res;
  };
  var htonl = function(w) {
    var res = w >>> 24 | w >>> 8 & 65280 | w << 8 & 16711680 | (w & 255) << 24;
    return res >>> 0;
  };
  var toHex32 = function(msg, endian) {
    var res = "";
    for (var i = 0;i < msg.length; i++) {
      var w = msg[i];
      if (endian === "little")
        w = htonl(w);
      res += zero8(w.toString(16));
    }
    return res;
  };
  var zero2 = function(word) {
    if (word.length === 1)
      return "0" + word;
    else
      return word;
  };
  var zero8 = function(word) {
    if (word.length === 7)
      return "0" + word;
    else if (word.length === 6)
      return "00" + word;
    else if (word.length === 5)
      return "000" + word;
    else if (word.length === 4)
      return "0000" + word;
    else if (word.length === 3)
      return "00000" + word;
    else if (word.length === 2)
      return "000000" + word;
    else if (word.length === 1)
      return "0000000" + word;
    else
      return word;
  };
  var join32 = function(msg, start, end, endian) {
    var len = end - start;
    assert4(len % 4 === 0);
    var res = new Array(len / 4);
    for (var i = 0, k2 = start;i < res.length; i++, k2 += 4) {
      var w;
      if (endian === "big")
        w = msg[k2] << 24 | msg[k2 + 1] << 16 | msg[k2 + 2] << 8 | msg[k2 + 3];
      else
        w = msg[k2 + 3] << 24 | msg[k2 + 2] << 16 | msg[k2 + 1] << 8 | msg[k2];
      res[i] = w >>> 0;
    }
    return res;
  };
  var split32 = function(msg, endian) {
    var res = new Array(msg.length * 4);
    for (var i = 0, k2 = 0;i < msg.length; i++, k2 += 4) {
      var m = msg[i];
      if (endian === "big") {
        res[k2] = m >>> 24;
        res[k2 + 1] = m >>> 16 & 255;
        res[k2 + 2] = m >>> 8 & 255;
        res[k2 + 3] = m & 255;
      } else {
        res[k2 + 3] = m >>> 24;
        res[k2 + 2] = m >>> 16 & 255;
        res[k2 + 1] = m >>> 8 & 255;
        res[k2] = m & 255;
      }
    }
    return res;
  };
  var rotr32 = function(w, b2) {
    return w >>> b2 | w << 32 - b2;
  };
  var rotl32 = function(w, b2) {
    return w << b2 | w >>> 32 - b2;
  };
  var sum32 = function(a, b2) {
    return a + b2 >>> 0;
  };
  var sum32_3 = function(a, b2, c) {
    return a + b2 + c >>> 0;
  };
  var sum32_4 = function(a, b2, c, d) {
    return a + b2 + c + d >>> 0;
  };
  var sum32_5 = function(a, b2, c, d, e) {
    return a + b2 + c + d + e >>> 0;
  };
  var sum64 = function(buf, pos, ah2, al2) {
    var bh = buf[pos];
    var bl = buf[pos + 1];
    var lo = al2 + bl >>> 0;
    var hi = (lo < al2 ? 1 : 0) + ah2 + bh;
    buf[pos] = hi >>> 0;
    buf[pos + 1] = lo;
  };
  var sum64_hi = function(ah2, al2, bh, bl) {
    var lo = al2 + bl >>> 0;
    var hi = (lo < al2 ? 1 : 0) + ah2 + bh;
    return hi >>> 0;
  };
  var sum64_lo = function(ah2, al2, bh, bl) {
    var lo = al2 + bl;
    return lo >>> 0;
  };
  var sum64_4_hi = function(ah2, al2, bh, bl, ch, cl2, dh, dl) {
    var carry = 0;
    var lo = al2;
    lo = lo + bl >>> 0;
    carry += lo < al2 ? 1 : 0;
    lo = lo + cl2 >>> 0;
    carry += lo < cl2 ? 1 : 0;
    lo = lo + dl >>> 0;
    carry += lo < dl ? 1 : 0;
    var hi = ah2 + bh + ch + dh + carry;
    return hi >>> 0;
  };
  var sum64_4_lo = function(ah2, al2, bh, bl, ch, cl2, dh, dl) {
    var lo = al2 + bl + cl2 + dl;
    return lo >>> 0;
  };
  var sum64_5_hi = function(ah2, al2, bh, bl, ch, cl2, dh, dl, eh2, el) {
    var carry = 0;
    var lo = al2;
    lo = lo + bl >>> 0;
    carry += lo < al2 ? 1 : 0;
    lo = lo + cl2 >>> 0;
    carry += lo < cl2 ? 1 : 0;
    lo = lo + dl >>> 0;
    carry += lo < dl ? 1 : 0;
    lo = lo + el >>> 0;
    carry += lo < el ? 1 : 0;
    var hi = ah2 + bh + ch + dh + eh2 + carry;
    return hi >>> 0;
  };
  var sum64_5_lo = function(ah2, al2, bh, bl, ch, cl2, dh, dl, eh2, el) {
    var lo = al2 + bl + cl2 + dl + el;
    return lo >>> 0;
  };
  var rotr64_hi = function(ah2, al2, num) {
    var r = al2 << 32 - num | ah2 >>> num;
    return r >>> 0;
  };
  var rotr64_lo = function(ah2, al2, num) {
    var r = ah2 << 32 - num | al2 >>> num;
    return r >>> 0;
  };
  var shr64_hi = function(ah2, al2, num) {
    return ah2 >>> num;
  };
  var shr64_lo = function(ah2, al2, num) {
    var r = ah2 << 32 - num | al2 >>> num;
    return r >>> 0;
  };
  var assert4 = require_minimalistic_assert();
  var inherits = require_inherits_browser();
  exports.inherits = inherits;
  exports.toArray = toArray;
  exports.toHex = toHex2;
  exports.htonl = htonl;
  exports.toHex32 = toHex32;
  exports.zero2 = zero2;
  exports.zero8 = zero8;
  exports.join32 = join32;
  exports.split32 = split32;
  exports.rotr32 = rotr32;
  exports.rotl32 = rotl32;
  exports.sum32 = sum32;
  exports.sum32_3 = sum32_3;
  exports.sum32_4 = sum32_4;
  exports.sum32_5 = sum32_5;
  exports.sum64 = sum64;
  exports.sum64_hi = sum64_hi;
  exports.sum64_lo = sum64_lo;
  exports.sum64_4_hi = sum64_4_hi;
  exports.sum64_4_lo = sum64_4_lo;
  exports.sum64_5_hi = sum64_5_hi;
  exports.sum64_5_lo = sum64_5_lo;
  exports.rotr64_hi = rotr64_hi;
  exports.rotr64_lo = rotr64_lo;
  exports.shr64_hi = shr64_hi;
  exports.shr64_lo = shr64_lo;
});

// node_modules/hash.js/lib/hash/common.js
var require_common = __commonJS((exports) => {
  var BlockHash = function() {
    this.pending = null;
    this.pendingTotal = 0;
    this.blockSize = this.constructor.blockSize;
    this.outSize = this.constructor.outSize;
    this.hmacStrength = this.constructor.hmacStrength;
    this.padLength = this.constructor.padLength / 8;
    this.endian = "big";
    this._delta8 = this.blockSize / 8;
    this._delta32 = this.blockSize / 32;
  };
  var utils41 = require_utils3();
  var assert4 = require_minimalistic_assert();
  exports.BlockHash = BlockHash;
  BlockHash.prototype.update = function update(msg, enc) {
    msg = utils41.toArray(msg, enc);
    if (!this.pending)
      this.pending = msg;
    else
      this.pending = this.pending.concat(msg);
    this.pendingTotal += msg.length;
    if (this.pending.length >= this._delta8) {
      msg = this.pending;
      var r = msg.length % this._delta8;
      this.pending = msg.slice(msg.length - r, msg.length);
      if (this.pending.length === 0)
        this.pending = null;
      msg = utils41.join32(msg, 0, msg.length - r, this.endian);
      for (var i = 0;i < msg.length; i += this._delta32)
        this._update(msg, i, i + this._delta32);
    }
    return this;
  };
  BlockHash.prototype.digest = function digest(enc) {
    this.update(this._pad());
    assert4(this.pending === null);
    return this._digest(enc);
  };
  BlockHash.prototype._pad = function pad() {
    var len = this.pendingTotal;
    var bytes3 = this._delta8;
    var k2 = bytes3 - (len + this.padLength) % bytes3;
    var res = new Array(k2 + this.padLength);
    res[0] = 128;
    for (var i = 1;i < k2; i++)
      res[i] = 0;
    len <<= 3;
    if (this.endian === "big") {
      for (var t = 8;t < this.padLength; t++)
        res[i++] = 0;
      res[i++] = 0;
      res[i++] = 0;
      res[i++] = 0;
      res[i++] = 0;
      res[i++] = len >>> 24 & 255;
      res[i++] = len >>> 16 & 255;
      res[i++] = len >>> 8 & 255;
      res[i++] = len & 255;
    } else {
      res[i++] = len & 255;
      res[i++] = len >>> 8 & 255;
      res[i++] = len >>> 16 & 255;
      res[i++] = len >>> 24 & 255;
      res[i++] = 0;
      res[i++] = 0;
      res[i++] = 0;
      res[i++] = 0;
      for (t = 8;t < this.padLength; t++)
        res[i++] = 0;
    }
    return res;
  };
});

// node_modules/hash.js/lib/hash/sha/common.js
var require_common2 = __commonJS((exports) => {
  var ft_1 = function(s, x, y, z2) {
    if (s === 0)
      return ch32(x, y, z2);
    if (s === 1 || s === 3)
      return p32(x, y, z2);
    if (s === 2)
      return maj32(x, y, z2);
  };
  var ch32 = function(x, y, z2) {
    return x & y ^ ~x & z2;
  };
  var maj32 = function(x, y, z2) {
    return x & y ^ x & z2 ^ y & z2;
  };
  var p32 = function(x, y, z2) {
    return x ^ y ^ z2;
  };
  var s0_256 = function(x) {
    return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
  };
  var s1_256 = function(x) {
    return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
  };
  var g0_256 = function(x) {
    return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;
  };
  var g1_256 = function(x) {
    return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;
  };
  var utils41 = require_utils3();
  var rotr32 = utils41.rotr32;
  exports.ft_1 = ft_1;
  exports.ch32 = ch32;
  exports.maj32 = maj32;
  exports.p32 = p32;
  exports.s0_256 = s0_256;
  exports.s1_256 = s1_256;
  exports.g0_256 = g0_256;
  exports.g1_256 = g1_256;
});

// node_modules/hash.js/lib/hash/sha/1.js
var require_1 = __commonJS((exports, module) => {
  var SHA1 = function() {
    if (!(this instanceof SHA1))
      return new SHA1;
    BlockHash.call(this);
    this.h = [
      1732584193,
      4023233417,
      2562383102,
      271733878,
      3285377520
    ];
    this.W = new Array(80);
  };
  var utils41 = require_utils3();
  var common = require_common();
  var shaCommon = require_common2();
  var rotl32 = utils41.rotl32;
  var sum32 = utils41.sum32;
  var sum32_5 = utils41.sum32_5;
  var ft_1 = shaCommon.ft_1;
  var BlockHash = common.BlockHash;
  var sha1_K = [
    1518500249,
    1859775393,
    2400959708,
    3395469782
  ];
  utils41.inherits(SHA1, BlockHash);
  module.exports = SHA1;
  SHA1.blockSize = 512;
  SHA1.outSize = 160;
  SHA1.hmacStrength = 80;
  SHA1.padLength = 64;
  SHA1.prototype._update = function _update(msg, start) {
    var W = this.W;
    for (var i = 0;i < 16; i++)
      W[i] = msg[start + i];
    for (;i < W.length; i++)
      W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
    var a = this.h[0];
    var b2 = this.h[1];
    var c = this.h[2];
    var d = this.h[3];
    var e = this.h[4];
    for (i = 0;i < W.length; i++) {
      var s = ~~(i / 20);
      var t = sum32_5(rotl32(a, 5), ft_1(s, b2, c, d), e, W[i], sha1_K[s]);
      e = d;
      d = c;
      c = rotl32(b2, 30);
      b2 = a;
      a = t;
    }
    this.h[0] = sum32(this.h[0], a);
    this.h[1] = sum32(this.h[1], b2);
    this.h[2] = sum32(this.h[2], c);
    this.h[3] = sum32(this.h[3], d);
    this.h[4] = sum32(this.h[4], e);
  };
  SHA1.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils41.toHex32(this.h, "big");
    else
      return utils41.split32(this.h, "big");
  };
});

// node_modules/hash.js/lib/hash/sha/256.js
var require_256 = __commonJS((exports, module) => {
  var SHA2563 = function() {
    if (!(this instanceof SHA2563))
      return new SHA2563;
    BlockHash.call(this);
    this.h = [
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ];
    this.k = sha256_K;
    this.W = new Array(64);
  };
  var utils41 = require_utils3();
  var common = require_common();
  var shaCommon = require_common2();
  var assert4 = require_minimalistic_assert();
  var sum32 = utils41.sum32;
  var sum32_4 = utils41.sum32_4;
  var sum32_5 = utils41.sum32_5;
  var ch32 = shaCommon.ch32;
  var maj32 = shaCommon.maj32;
  var s0_256 = shaCommon.s0_256;
  var s1_256 = shaCommon.s1_256;
  var g0_256 = shaCommon.g0_256;
  var g1_256 = shaCommon.g1_256;
  var BlockHash = common.BlockHash;
  var sha256_K = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ];
  utils41.inherits(SHA2563, BlockHash);
  module.exports = SHA2563;
  SHA2563.blockSize = 512;
  SHA2563.outSize = 256;
  SHA2563.hmacStrength = 192;
  SHA2563.padLength = 64;
  SHA2563.prototype._update = function _update(msg, start) {
    var W = this.W;
    for (var i = 0;i < 16; i++)
      W[i] = msg[start + i];
    for (;i < W.length; i++)
      W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);
    var a = this.h[0];
    var b2 = this.h[1];
    var c = this.h[2];
    var d = this.h[3];
    var e = this.h[4];
    var f2 = this.h[5];
    var g = this.h[6];
    var h = this.h[7];
    assert4(this.k.length === W.length);
    for (i = 0;i < W.length; i++) {
      var T1 = sum32_5(h, s1_256(e), ch32(e, f2, g), this.k[i], W[i]);
      var T2 = sum32(s0_256(a), maj32(a, b2, c));
      h = g;
      g = f2;
      f2 = e;
      e = sum32(d, T1);
      d = c;
      c = b2;
      b2 = a;
      a = sum32(T1, T2);
    }
    this.h[0] = sum32(this.h[0], a);
    this.h[1] = sum32(this.h[1], b2);
    this.h[2] = sum32(this.h[2], c);
    this.h[3] = sum32(this.h[3], d);
    this.h[4] = sum32(this.h[4], e);
    this.h[5] = sum32(this.h[5], f2);
    this.h[6] = sum32(this.h[6], g);
    this.h[7] = sum32(this.h[7], h);
  };
  SHA2563.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils41.toHex32(this.h, "big");
    else
      return utils41.split32(this.h, "big");
  };
});

// node_modules/hash.js/lib/hash/sha/224.js
var require_224 = __commonJS((exports, module) => {
  var SHA2242 = function() {
    if (!(this instanceof SHA2242))
      return new SHA2242;
    SHA2563.call(this);
    this.h = [
      3238371032,
      914150663,
      812702999,
      4144912697,
      4290775857,
      1750603025,
      1694076839,
      3204075428
    ];
  };
  var utils41 = require_utils3();
  var SHA2563 = require_256();
  utils41.inherits(SHA2242, SHA2563);
  module.exports = SHA2242;
  SHA2242.blockSize = 512;
  SHA2242.outSize = 224;
  SHA2242.hmacStrength = 192;
  SHA2242.padLength = 64;
  SHA2242.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils41.toHex32(this.h.slice(0, 7), "big");
    else
      return utils41.split32(this.h.slice(0, 7), "big");
  };
});

// node_modules/hash.js/lib/hash/sha/512.js
var require_512 = __commonJS((exports, module) => {
  var SHA5122 = function() {
    if (!(this instanceof SHA5122))
      return new SHA5122;
    BlockHash.call(this);
    this.h = [
      1779033703,
      4089235720,
      3144134277,
      2227873595,
      1013904242,
      4271175723,
      2773480762,
      1595750129,
      1359893119,
      2917565137,
      2600822924,
      725511199,
      528734635,
      4215389547,
      1541459225,
      327033209
    ];
    this.k = sha512_K;
    this.W = new Array(160);
  };
  var ch64_hi = function(xh2, xl, yh2, yl, zh) {
    var r = xh2 & yh2 ^ ~xh2 & zh;
    if (r < 0)
      r += 4294967296;
    return r;
  };
  var ch64_lo = function(xh2, xl, yh2, yl, zh, zl) {
    var r = xl & yl ^ ~xl & zl;
    if (r < 0)
      r += 4294967296;
    return r;
  };
  var maj64_hi = function(xh2, xl, yh2, yl, zh) {
    var r = xh2 & yh2 ^ xh2 & zh ^ yh2 & zh;
    if (r < 0)
      r += 4294967296;
    return r;
  };
  var maj64_lo = function(xh2, xl, yh2, yl, zh, zl) {
    var r = xl & yl ^ xl & zl ^ yl & zl;
    if (r < 0)
      r += 4294967296;
    return r;
  };
  var s0_512_hi = function(xh2, xl) {
    var c0_hi = rotr64_hi(xh2, xl, 28);
    var c1_hi = rotr64_hi(xl, xh2, 2);
    var c2_hi = rotr64_hi(xl, xh2, 7);
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0)
      r += 4294967296;
    return r;
  };
  var s0_512_lo = function(xh2, xl) {
    var c0_lo = rotr64_lo(xh2, xl, 28);
    var c1_lo = rotr64_lo(xl, xh2, 2);
    var c2_lo = rotr64_lo(xl, xh2, 7);
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0)
      r += 4294967296;
    return r;
  };
  var s1_512_hi = function(xh2, xl) {
    var c0_hi = rotr64_hi(xh2, xl, 14);
    var c1_hi = rotr64_hi(xh2, xl, 18);
    var c2_hi = rotr64_hi(xl, xh2, 9);
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0)
      r += 4294967296;
    return r;
  };
  var s1_512_lo = function(xh2, xl) {
    var c0_lo = rotr64_lo(xh2, xl, 14);
    var c1_lo = rotr64_lo(xh2, xl, 18);
    var c2_lo = rotr64_lo(xl, xh2, 9);
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0)
      r += 4294967296;
    return r;
  };
  var g0_512_hi = function(xh2, xl) {
    var c0_hi = rotr64_hi(xh2, xl, 1);
    var c1_hi = rotr64_hi(xh2, xl, 8);
    var c2_hi = shr64_hi(xh2, xl, 7);
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0)
      r += 4294967296;
    return r;
  };
  var g0_512_lo = function(xh2, xl) {
    var c0_lo = rotr64_lo(xh2, xl, 1);
    var c1_lo = rotr64_lo(xh2, xl, 8);
    var c2_lo = shr64_lo(xh2, xl, 7);
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0)
      r += 4294967296;
    return r;
  };
  var g1_512_hi = function(xh2, xl) {
    var c0_hi = rotr64_hi(xh2, xl, 19);
    var c1_hi = rotr64_hi(xl, xh2, 29);
    var c2_hi = shr64_hi(xh2, xl, 6);
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0)
      r += 4294967296;
    return r;
  };
  var g1_512_lo = function(xh2, xl) {
    var c0_lo = rotr64_lo(xh2, xl, 19);
    var c1_lo = rotr64_lo(xl, xh2, 29);
    var c2_lo = shr64_lo(xh2, xl, 6);
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0)
      r += 4294967296;
    return r;
  };
  var utils41 = require_utils3();
  var common = require_common();
  var assert4 = require_minimalistic_assert();
  var rotr64_hi = utils41.rotr64_hi;
  var rotr64_lo = utils41.rotr64_lo;
  var shr64_hi = utils41.shr64_hi;
  var shr64_lo = utils41.shr64_lo;
  var sum64 = utils41.sum64;
  var sum64_hi = utils41.sum64_hi;
  var sum64_lo = utils41.sum64_lo;
  var sum64_4_hi = utils41.sum64_4_hi;
  var sum64_4_lo = utils41.sum64_4_lo;
  var sum64_5_hi = utils41.sum64_5_hi;
  var sum64_5_lo = utils41.sum64_5_lo;
  var BlockHash = common.BlockHash;
  var sha512_K = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ];
  utils41.inherits(SHA5122, BlockHash);
  module.exports = SHA5122;
  SHA5122.blockSize = 1024;
  SHA5122.outSize = 512;
  SHA5122.hmacStrength = 192;
  SHA5122.padLength = 128;
  SHA5122.prototype._prepareBlock = function _prepareBlock(msg, start) {
    var W = this.W;
    for (var i = 0;i < 32; i++)
      W[i] = msg[start + i];
    for (;i < W.length; i += 2) {
      var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);
      var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
      var c1_hi = W[i - 14];
      var c1_lo = W[i - 13];
      var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);
      var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
      var c3_hi = W[i - 32];
      var c3_lo = W[i - 31];
      W[i] = sum64_4_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
      W[i + 1] = sum64_4_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
    }
  };
  SHA5122.prototype._update = function _update(msg, start) {
    this._prepareBlock(msg, start);
    var W = this.W;
    var ah2 = this.h[0];
    var al2 = this.h[1];
    var bh = this.h[2];
    var bl = this.h[3];
    var ch = this.h[4];
    var cl2 = this.h[5];
    var dh = this.h[6];
    var dl = this.h[7];
    var eh2 = this.h[8];
    var el = this.h[9];
    var fh = this.h[10];
    var fl = this.h[11];
    var gh = this.h[12];
    var gl2 = this.h[13];
    var hh = this.h[14];
    var hl = this.h[15];
    assert4(this.k.length === W.length);
    for (var i = 0;i < W.length; i += 2) {
      var c0_hi = hh;
      var c0_lo = hl;
      var c1_hi = s1_512_hi(eh2, el);
      var c1_lo = s1_512_lo(eh2, el);
      var c2_hi = ch64_hi(eh2, el, fh, fl, gh, gl2);
      var c2_lo = ch64_lo(eh2, el, fh, fl, gh, gl2);
      var c3_hi = this.k[i];
      var c3_lo = this.k[i + 1];
      var c4_hi = W[i];
      var c4_lo = W[i + 1];
      var T1_hi = sum64_5_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
      var T1_lo = sum64_5_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
      c0_hi = s0_512_hi(ah2, al2);
      c0_lo = s0_512_lo(ah2, al2);
      c1_hi = maj64_hi(ah2, al2, bh, bl, ch, cl2);
      c1_lo = maj64_lo(ah2, al2, bh, bl, ch, cl2);
      var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
      var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
      hh = gh;
      hl = gl2;
      gh = fh;
      gl2 = fl;
      fh = eh2;
      fl = el;
      eh2 = sum64_hi(dh, dl, T1_hi, T1_lo);
      el = sum64_lo(dl, dl, T1_hi, T1_lo);
      dh = ch;
      dl = cl2;
      ch = bh;
      cl2 = bl;
      bh = ah2;
      bl = al2;
      ah2 = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
      al2 = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
    }
    sum64(this.h, 0, ah2, al2);
    sum64(this.h, 2, bh, bl);
    sum64(this.h, 4, ch, cl2);
    sum64(this.h, 6, dh, dl);
    sum64(this.h, 8, eh2, el);
    sum64(this.h, 10, fh, fl);
    sum64(this.h, 12, gh, gl2);
    sum64(this.h, 14, hh, hl);
  };
  SHA5122.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils41.toHex32(this.h, "big");
    else
      return utils41.split32(this.h, "big");
  };
});

// node_modules/hash.js/lib/hash/sha/384.js
var require_384 = __commonJS((exports, module) => {
  var SHA384 = function() {
    if (!(this instanceof SHA384))
      return new SHA384;
    SHA5122.call(this);
    this.h = [
      3418070365,
      3238371032,
      1654270250,
      914150663,
      2438529370,
      812702999,
      355462360,
      4144912697,
      1731405415,
      4290775857,
      2394180231,
      1750603025,
      3675008525,
      1694076839,
      1203062813,
      3204075428
    ];
  };
  var utils41 = require_utils3();
  var SHA5122 = require_512();
  utils41.inherits(SHA384, SHA5122);
  module.exports = SHA384;
  SHA384.blockSize = 1024;
  SHA384.outSize = 384;
  SHA384.hmacStrength = 192;
  SHA384.padLength = 128;
  SHA384.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils41.toHex32(this.h.slice(0, 12), "big");
    else
      return utils41.split32(this.h.slice(0, 12), "big");
  };
});

// node_modules/hash.js/lib/hash/sha.js
var require_sha = __commonJS((exports) => {
  exports.sha1 = require_1();
  exports.sha224 = require_224();
  exports.sha256 = require_256();
  exports.sha384 = require_384();
  exports.sha512 = require_512();
});

// node_modules/hash.js/lib/hash/ripemd.js
var require_ripemd = __commonJS((exports) => {
  var RIPEMD1602 = function() {
    if (!(this instanceof RIPEMD1602))
      return new RIPEMD1602;
    BlockHash.call(this);
    this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    this.endian = "little";
  };
  var f2 = function(j, x, y, z2) {
    if (j <= 15)
      return x ^ y ^ z2;
    else if (j <= 31)
      return x & y | ~x & z2;
    else if (j <= 47)
      return (x | ~y) ^ z2;
    else if (j <= 63)
      return x & z2 | y & ~z2;
    else
      return x ^ (y | ~z2);
  };
  var K = function(j) {
    if (j <= 15)
      return 0;
    else if (j <= 31)
      return 1518500249;
    else if (j <= 47)
      return 1859775393;
    else if (j <= 63)
      return 2400959708;
    else
      return 2840853838;
  };
  var Kh = function(j) {
    if (j <= 15)
      return 1352829926;
    else if (j <= 31)
      return 1548603684;
    else if (j <= 47)
      return 1836072691;
    else if (j <= 63)
      return 2053994217;
    else
      return 0;
  };
  var utils41 = require_utils3();
  var common = require_common();
  var rotl32 = utils41.rotl32;
  var sum32 = utils41.sum32;
  var sum32_3 = utils41.sum32_3;
  var sum32_4 = utils41.sum32_4;
  var BlockHash = common.BlockHash;
  utils41.inherits(RIPEMD1602, BlockHash);
  exports.ripemd160 = RIPEMD1602;
  RIPEMD1602.blockSize = 512;
  RIPEMD1602.outSize = 160;
  RIPEMD1602.hmacStrength = 192;
  RIPEMD1602.padLength = 64;
  RIPEMD1602.prototype._update = function update(msg, start) {
    var A = this.h[0];
    var B = this.h[1];
    var C = this.h[2];
    var D2 = this.h[3];
    var E = this.h[4];
    var Ah = A;
    var Bh = B;
    var Ch = C;
    var Dh = D2;
    var Eh = E;
    for (var j = 0;j < 80; j++) {
      var T = sum32(rotl32(sum32_4(A, f2(j, B, C, D2), msg[r[j] + start], K(j)), s[j]), E);
      A = E;
      E = D2;
      D2 = rotl32(C, 10);
      C = B;
      B = T;
      T = sum32(rotl32(sum32_4(Ah, f2(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)), sh[j]), Eh);
      Ah = Eh;
      Eh = Dh;
      Dh = rotl32(Ch, 10);
      Ch = Bh;
      Bh = T;
    }
    T = sum32_3(this.h[1], C, Dh);
    this.h[1] = sum32_3(this.h[2], D2, Eh);
    this.h[2] = sum32_3(this.h[3], E, Ah);
    this.h[3] = sum32_3(this.h[4], A, Bh);
    this.h[4] = sum32_3(this.h[0], B, Ch);
    this.h[0] = T;
  };
  RIPEMD1602.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils41.toHex32(this.h, "little");
    else
      return utils41.split32(this.h, "little");
  };
  var r = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ];
  var rh = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ];
  var s = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ];
  var sh = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ];
});

// node_modules/hash.js/lib/hash/hmac.js
var require_hmac = __commonJS((exports, module) => {
  var Hmac = function(hash5, key, enc) {
    if (!(this instanceof Hmac))
      return new Hmac(hash5, key, enc);
    this.Hash = hash5;
    this.blockSize = hash5.blockSize / 8;
    this.outSize = hash5.outSize / 8;
    this.inner = null;
    this.outer = null;
    this._init(utils41.toArray(key, enc));
  };
  var utils41 = require_utils3();
  var assert4 = require_minimalistic_assert();
  module.exports = Hmac;
  Hmac.prototype._init = function init(key) {
    if (key.length > this.blockSize)
      key = new this.Hash().update(key).digest();
    assert4(key.length <= this.blockSize);
    for (var i = key.length;i < this.blockSize; i++)
      key.push(0);
    for (i = 0;i < key.length; i++)
      key[i] ^= 54;
    this.inner = new this.Hash().update(key);
    for (i = 0;i < key.length; i++)
      key[i] ^= 106;
    this.outer = new this.Hash().update(key);
  };
  Hmac.prototype.update = function update(msg, enc) {
    this.inner.update(msg, enc);
    return this;
  };
  Hmac.prototype.digest = function digest(enc) {
    this.outer.update(this.inner.digest());
    return this.outer.digest(enc);
  };
});

// node_modules/hash.js/lib/hash.js
var require_hash = __commonJS((exports) => {
  var hash5 = exports;
  hash5.utils = require_utils3();
  hash5.common = require_common();
  hash5.sha = require_sha();
  hash5.ripemd = require_ripemd();
  hash5.hmac = require_hmac();
  hash5.sha1 = hash5.sha.sha1;
  hash5.sha256 = hash5.sha.sha256;
  hash5.sha224 = hash5.sha.sha224;
  hash5.sha384 = hash5.sha.sha384;
  hash5.sha512 = hash5.sha.sha512;
  hash5.ripemd160 = hash5.ripemd.ripemd160;
});

// node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js
var require_secp256k1 = __commonJS((exports, module) => {
  module.exports = {
    doubles: {
      step: 4,
      points: [
        [
          "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
          "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
        ],
        [
          "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
          "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
        ],
        [
          "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
          "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
        ],
        [
          "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
          "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
        ],
        [
          "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
          "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
        ],
        [
          "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
          "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
        ],
        [
          "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
          "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
        ],
        [
          "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
          "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
        ],
        [
          "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
          "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
        ],
        [
          "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
          "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
        ],
        [
          "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
          "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
        ],
        [
          "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
          "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
        ],
        [
          "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
          "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
        ],
        [
          "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
          "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
        ],
        [
          "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
          "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
        ],
        [
          "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
          "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
        ],
        [
          "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
          "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
        ],
        [
          "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
          "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
        ],
        [
          "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
          "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
        ],
        [
          "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
          "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
        ],
        [
          "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
          "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
        ],
        [
          "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
          "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
        ],
        [
          "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
          "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
        ],
        [
          "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
          "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
        ],
        [
          "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
          "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
        ],
        [
          "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
          "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
        ],
        [
          "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
          "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
        ],
        [
          "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
          "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
        ],
        [
          "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
          "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
        ],
        [
          "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
          "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
        ],
        [
          "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
          "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
        ],
        [
          "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
          "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
        ],
        [
          "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
          "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
        ],
        [
          "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
          "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
        ],
        [
          "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
          "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
        ],
        [
          "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
          "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
        ],
        [
          "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
          "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
        ],
        [
          "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
          "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
        ],
        [
          "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
          "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
        ],
        [
          "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
          "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
        ],
        [
          "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
          "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
        ],
        [
          "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
          "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
        ],
        [
          "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
          "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
        ],
        [
          "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
          "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
        ],
        [
          "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
          "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
        ],
        [
          "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
          "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
        ],
        [
          "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
          "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
        ],
        [
          "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
          "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
        ],
        [
          "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
          "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
        ],
        [
          "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
          "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
        ],
        [
          "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
          "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
        ],
        [
          "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
          "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
        ],
        [
          "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
          "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
        ],
        [
          "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
          "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
        ],
        [
          "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
          "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
        ],
        [
          "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
          "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
        ],
        [
          "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
          "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
        ],
        [
          "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
          "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
        ],
        [
          "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
          "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
        ],
        [
          "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
          "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
        ],
        [
          "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
          "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
        ],
        [
          "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
          "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
        ],
        [
          "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
          "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
        ],
        [
          "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
          "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
        ],
        [
          "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
          "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
        ]
      ]
    },
    naf: {
      wnd: 7,
      points: [
        [
          "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
          "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
        ],
        [
          "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
          "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
        ],
        [
          "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
          "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
        ],
        [
          "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
          "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
        ],
        [
          "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
          "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
        ],
        [
          "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
          "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
        ],
        [
          "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
          "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
        ],
        [
          "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
          "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
        ],
        [
          "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
          "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
        ],
        [
          "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
          "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
        ],
        [
          "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
          "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
        ],
        [
          "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
          "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
        ],
        [
          "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
          "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
        ],
        [
          "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
          "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
        ],
        [
          "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
          "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
        ],
        [
          "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
          "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
        ],
        [
          "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
          "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
        ],
        [
          "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
          "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
        ],
        [
          "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
          "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
        ],
        [
          "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
          "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
        ],
        [
          "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
          "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
        ],
        [
          "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
          "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
        ],
        [
          "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
          "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
        ],
        [
          "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
          "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
        ],
        [
          "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
          "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
        ],
        [
          "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
          "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
        ],
        [
          "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
          "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
        ],
        [
          "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
          "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
        ],
        [
          "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
          "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
        ],
        [
          "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
          "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
        ],
        [
          "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
          "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
        ],
        [
          "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
          "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
        ],
        [
          "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
          "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
        ],
        [
          "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
          "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
        ],
        [
          "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
          "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
        ],
        [
          "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
          "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
        ],
        [
          "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
          "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
        ],
        [
          "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
          "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
        ],
        [
          "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
          "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
        ],
        [
          "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
          "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
        ],
        [
          "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
          "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
        ],
        [
          "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
          "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
        ],
        [
          "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
          "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
        ],
        [
          "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
          "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
        ],
        [
          "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
          "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
        ],
        [
          "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
          "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
        ],
        [
          "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
          "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
        ],
        [
          "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
          "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
        ],
        [
          "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
          "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
        ],
        [
          "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
          "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
        ],
        [
          "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
          "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
        ],
        [
          "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
          "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
        ],
        [
          "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
          "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
        ],
        [
          "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
          "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
        ],
        [
          "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
          "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
        ],
        [
          "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
          "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
        ],
        [
          "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
          "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
        ],
        [
          "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
          "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
        ],
        [
          "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
          "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
        ],
        [
          "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
          "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
        ],
        [
          "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
          "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
        ],
        [
          "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
          "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
        ],
        [
          "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
          "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
        ],
        [
          "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
          "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
        ],
        [
          "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
          "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
        ],
        [
          "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
          "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
        ],
        [
          "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
          "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
        ],
        [
          "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
          "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
        ],
        [
          "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
          "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
        ],
        [
          "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
          "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
        ],
        [
          "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
          "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
        ],
        [
          "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
          "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
        ],
        [
          "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
          "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
        ],
        [
          "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
          "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
        ],
        [
          "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
          "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
        ],
        [
          "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
          "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
        ],
        [
          "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
          "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
        ],
        [
          "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
          "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
        ],
        [
          "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
          "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
        ],
        [
          "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
          "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
        ],
        [
          "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
          "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
        ],
        [
          "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
          "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
        ],
        [
          "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
          "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
        ],
        [
          "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
          "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
        ],
        [
          "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
          "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
        ],
        [
          "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
          "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
        ],
        [
          "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
          "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
        ],
        [
          "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
          "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
        ],
        [
          "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
          "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
        ],
        [
          "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
          "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
        ],
        [
          "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
          "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
        ],
        [
          "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
          "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
        ],
        [
          "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
          "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
        ],
        [
          "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
          "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
        ],
        [
          "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
          "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
        ],
        [
          "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
          "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
        ],
        [
          "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
          "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
        ],
        [
          "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
          "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
        ],
        [
          "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
          "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
        ],
        [
          "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
          "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
        ],
        [
          "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
          "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
        ],
        [
          "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
          "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
        ],
        [
          "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
          "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
        ],
        [
          "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
          "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
        ],
        [
          "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
          "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
        ],
        [
          "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
          "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
        ],
        [
          "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
          "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
        ],
        [
          "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
          "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
        ],
        [
          "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
          "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
        ],
        [
          "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
          "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
        ],
        [
          "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
          "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
        ],
        [
          "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
          "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
        ],
        [
          "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
          "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
        ],
        [
          "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
          "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
        ],
        [
          "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
          "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
        ],
        [
          "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
          "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
        ],
        [
          "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
          "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
        ],
        [
          "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
          "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
        ],
        [
          "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
          "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
        ],
        [
          "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
          "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
        ],
        [
          "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
          "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
        ],
        [
          "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
          "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
        ],
        [
          "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
          "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
        ],
        [
          "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
          "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
        ],
        [
          "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
          "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
        ],
        [
          "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
          "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
        ],
        [
          "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
          "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
        ]
      ]
    }
  };
});

// node_modules/elliptic/lib/elliptic/curves.js
var require_curves = __commonJS((exports) => {
  var PresetCurve = function(options) {
    if (options.type === "short")
      this.curve = new curve.short(options);
    else if (options.type === "edwards")
      this.curve = new curve.edwards(options);
    else
      this.curve = new curve.mont(options);
    this.g = this.curve.g;
    this.n = this.curve.n;
    this.hash = options.hash;
    assert4(this.g.validate(), "Invalid curve");
    assert4(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  };
  var defineCurve = function(name, options) {
    Object.defineProperty(curves, name, {
      configurable: true,
      enumerable: true,
      get: function() {
        var curve2 = new PresetCurve(options);
        Object.defineProperty(curves, name, {
          configurable: true,
          enumerable: true,
          value: curve2
        });
        return curve2;
      }
    });
  };
  var curves = exports;
  var hash5 = require_hash();
  var curve = require_curve();
  var utils41 = require_utils2();
  var assert4 = utils41.assert;
  curves.PresetCurve = PresetCurve;
  defineCurve("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: hash5.sha256,
    gRed: false,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  });
  defineCurve("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: hash5.sha256,
    gRed: false,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  });
  defineCurve("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: hash5.sha256,
    gRed: false,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  });
  defineCurve("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: hash5.sha384,
    gRed: false,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  });
  defineCurve("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: hash5.sha512,
    gRed: false,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  });
  defineCurve("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash5.sha256,
    gRed: false,
    g: [
      "9"
    ]
  });
  defineCurve("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash5.sha256,
    gRed: false,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var pre;
  try {
    pre = require_secp256k1();
  } catch (e) {
    pre = undefined;
  }
  defineCurve("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: hash5.sha256,
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: false,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      pre
    ]
  });
});

// node_modules/hmac-drbg/lib/hmac-drbg.js
var require_hmac_drbg = __commonJS((exports, module) => {
  var HmacDRBG = function(options) {
    if (!(this instanceof HmacDRBG))
      return new HmacDRBG(options);
    this.hash = options.hash;
    this.predResist = !!options.predResist;
    this.outLen = this.hash.outSize;
    this.minEntropy = options.minEntropy || this.hash.hmacStrength;
    this._reseed = null;
    this.reseedInterval = null;
    this.K = null;
    this.V = null;
    var entropy = utils41.toArray(options.entropy, options.entropyEnc || "hex");
    var nonce = utils41.toArray(options.nonce, options.nonceEnc || "hex");
    var pers = utils41.toArray(options.pers, options.persEnc || "hex");
    assert4(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
    this._init(entropy, nonce, pers);
  };
  var hash5 = require_hash();
  var utils41 = require_utils();
  var assert4 = require_minimalistic_assert();
  module.exports = HmacDRBG;
  HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
    var seed = entropy.concat(nonce).concat(pers);
    this.K = new Array(this.outLen / 8);
    this.V = new Array(this.outLen / 8);
    for (var i = 0;i < this.V.length; i++) {
      this.K[i] = 0;
      this.V[i] = 1;
    }
    this._update(seed);
    this._reseed = 1;
    this.reseedInterval = 281474976710656;
  };
  HmacDRBG.prototype._hmac = function hmac() {
    return new hash5.hmac(this.hash, this.K);
  };
  HmacDRBG.prototype._update = function update(seed) {
    var kmac = this._hmac().update(this.V).update([0]);
    if (seed)
      kmac = kmac.update(seed);
    this.K = kmac.digest();
    this.V = this._hmac().update(this.V).digest();
    if (!seed)
      return;
    this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
    this.V = this._hmac().update(this.V).digest();
  };
  HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add3, addEnc) {
    if (typeof entropyEnc !== "string") {
      addEnc = add3;
      add3 = entropyEnc;
      entropyEnc = null;
    }
    entropy = utils41.toArray(entropy, entropyEnc);
    add3 = utils41.toArray(add3, addEnc);
    assert4(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
    this._update(entropy.concat(add3 || []));
    this._reseed = 1;
  };
  HmacDRBG.prototype.generate = function generate(len, enc, add3, addEnc) {
    if (this._reseed > this.reseedInterval)
      throw new Error("Reseed is required");
    if (typeof enc !== "string") {
      addEnc = add3;
      add3 = enc;
      enc = null;
    }
    if (add3) {
      add3 = utils41.toArray(add3, addEnc || "hex");
      this._update(add3);
    }
    var temp = [];
    while (temp.length < len) {
      this.V = this._hmac().update(this.V).digest();
      temp = temp.concat(this.V);
    }
    var res = temp.slice(0, len);
    this._update(add3);
    this._reseed++;
    return utils41.encode(res, enc);
  };
});

// node_modules/elliptic/lib/elliptic/ec/key.js
var require_key = __commonJS((exports, module) => {
  var KeyPair = function(ec, options) {
    this.ec = ec;
    this.priv = null;
    this.pub = null;
    if (options.priv)
      this._importPrivate(options.priv, options.privEnc);
    if (options.pub)
      this._importPublic(options.pub, options.pubEnc);
  };
  var BN2 = require_bn2();
  var utils41 = require_utils2();
  var assert4 = utils41.assert;
  module.exports = KeyPair;
  KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
    if (pub instanceof KeyPair)
      return pub;
    return new KeyPair(ec, {
      pub,
      pubEnc: enc
    });
  };
  KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
    if (priv instanceof KeyPair)
      return priv;
    return new KeyPair(ec, {
      priv,
      privEnc: enc
    });
  };
  KeyPair.prototype.validate = function validate() {
    var pub = this.getPublic();
    if (pub.isInfinity())
      return { result: false, reason: "Invalid public key" };
    if (!pub.validate())
      return { result: false, reason: "Public key is not a point" };
    if (!pub.mul(this.ec.curve.n).isInfinity())
      return { result: false, reason: "Public key * N != O" };
    return { result: true, reason: null };
  };
  KeyPair.prototype.getPublic = function getPublic(compact, enc) {
    if (typeof compact === "string") {
      enc = compact;
      compact = null;
    }
    if (!this.pub)
      this.pub = this.ec.g.mul(this.priv);
    if (!enc)
      return this.pub;
    return this.pub.encode(enc, compact);
  };
  KeyPair.prototype.getPrivate = function getPrivate(enc) {
    if (enc === "hex")
      return this.priv.toString(16, 2);
    else
      return this.priv;
  };
  KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
    this.priv = new BN2(key, enc || 16);
    this.priv = this.priv.umod(this.ec.curve.n);
  };
  KeyPair.prototype._importPublic = function _importPublic(key, enc) {
    if (key.x || key.y) {
      if (this.ec.curve.type === "mont") {
        assert4(key.x, "Need x coordinate");
      } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
        assert4(key.x && key.y, "Need both x and y coordinate");
      }
      this.pub = this.ec.curve.point(key.x, key.y);
      return;
    }
    this.pub = this.ec.curve.decodePoint(key, enc);
  };
  KeyPair.prototype.derive = function derive(pub) {
    if (!pub.validate()) {
      assert4(pub.validate(), "public point not validated");
    }
    return pub.mul(this.priv).getX();
  };
  KeyPair.prototype.sign = function sign(msg, enc, options) {
    return this.ec.sign(msg, this, enc, options);
  };
  KeyPair.prototype.verify = function verify(msg, signature) {
    return this.ec.verify(msg, signature, this);
  };
  KeyPair.prototype.inspect = function inspect() {
    return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
  };
});

// node_modules/elliptic/lib/elliptic/ec/signature.js
var require_signature = __commonJS((exports, module) => {
  var Signature2 = function(options, enc) {
    if (options instanceof Signature2)
      return options;
    if (this._importDER(options, enc))
      return;
    assert4(options.r && options.s, "Signature without r or s");
    this.r = new BN2(options.r, 16);
    this.s = new BN2(options.s, 16);
    if (options.recoveryParam === undefined)
      this.recoveryParam = null;
    else
      this.recoveryParam = options.recoveryParam;
  };
  var Position = function() {
    this.place = 0;
  };
  var getLength = function(buf, p) {
    var initial = buf[p.place++];
    if (!(initial & 128)) {
      return initial;
    }
    var octetLen = initial & 15;
    if (octetLen === 0 || octetLen > 4) {
      return false;
    }
    var val = 0;
    for (var i = 0, off = p.place;i < octetLen; i++, off++) {
      val <<= 8;
      val |= buf[off];
      val >>>= 0;
    }
    if (val <= 127) {
      return false;
    }
    p.place = off;
    return val;
  };
  var rmPadding = function(buf) {
    var i = 0;
    var len = buf.length - 1;
    while (!buf[i] && !(buf[i + 1] & 128) && i < len) {
      i++;
    }
    if (i === 0) {
      return buf;
    }
    return buf.slice(i);
  };
  var constructLength = function(arr, len) {
    if (len < 128) {
      arr.push(len);
      return;
    }
    var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
    arr.push(octets | 128);
    while (--octets) {
      arr.push(len >>> (octets << 3) & 255);
    }
    arr.push(len);
  };
  var BN2 = require_bn2();
  var utils41 = require_utils2();
  var assert4 = utils41.assert;
  module.exports = Signature2;
  Signature2.prototype._importDER = function _importDER(data3, enc) {
    data3 = utils41.toArray(data3, enc);
    var p = new Position;
    if (data3[p.place++] !== 48) {
      return false;
    }
    var len = getLength(data3, p);
    if (len === false) {
      return false;
    }
    if (len + p.place !== data3.length) {
      return false;
    }
    if (data3[p.place++] !== 2) {
      return false;
    }
    var rlen = getLength(data3, p);
    if (rlen === false) {
      return false;
    }
    var r = data3.slice(p.place, rlen + p.place);
    p.place += rlen;
    if (data3[p.place++] !== 2) {
      return false;
    }
    var slen = getLength(data3, p);
    if (slen === false) {
      return false;
    }
    if (data3.length !== slen + p.place) {
      return false;
    }
    var s = data3.slice(p.place, slen + p.place);
    if (r[0] === 0) {
      if (r[1] & 128) {
        r = r.slice(1);
      } else {
        return false;
      }
    }
    if (s[0] === 0) {
      if (s[1] & 128) {
        s = s.slice(1);
      } else {
        return false;
      }
    }
    this.r = new BN2(r);
    this.s = new BN2(s);
    this.recoveryParam = null;
    return true;
  };
  Signature2.prototype.toDER = function toDER(enc) {
    var r = this.r.toArray();
    var s = this.s.toArray();
    if (r[0] & 128)
      r = [0].concat(r);
    if (s[0] & 128)
      s = [0].concat(s);
    r = rmPadding(r);
    s = rmPadding(s);
    while (!s[0] && !(s[1] & 128)) {
      s = s.slice(1);
    }
    var arr = [2];
    constructLength(arr, r.length);
    arr = arr.concat(r);
    arr.push(2);
    constructLength(arr, s.length);
    var backHalf = arr.concat(s);
    var res = [48];
    constructLength(res, backHalf.length);
    res = res.concat(backHalf);
    return utils41.encode(res, enc);
  };
});

// node_modules/elliptic/lib/elliptic/ec/index.js
var require_ec = __commonJS((exports, module) => {
  var EC = function(options) {
    if (!(this instanceof EC))
      return new EC(options);
    if (typeof options === "string") {
      assert4(Object.prototype.hasOwnProperty.call(curves, options), "Unknown curve " + options);
      options = curves[options];
    }
    if (options instanceof curves.PresetCurve)
      options = { curve: options };
    this.curve = options.curve.curve;
    this.n = this.curve.n;
    this.nh = this.n.ushrn(1);
    this.g = this.curve.g;
    this.g = options.curve.g;
    this.g.precompute(options.curve.n.bitLength() + 1);
    this.hash = options.hash || options.curve.hash;
  };
  var BN2 = require_bn2();
  var HmacDRBG = require_hmac_drbg();
  var utils41 = require_utils2();
  var curves = require_curves();
  var rand = require_brorand();
  var assert4 = utils41.assert;
  var KeyPair = require_key();
  var Signature2 = require_signature();
  module.exports = EC;
  EC.prototype.keyPair = function keyPair(options) {
    return new KeyPair(this, options);
  };
  EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
    return KeyPair.fromPrivate(this, priv, enc);
  };
  EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
    return KeyPair.fromPublic(this, pub, enc);
  };
  EC.prototype.genKeyPair = function genKeyPair(options) {
    if (!options)
      options = {};
    var drbg = new HmacDRBG({
      hash: this.hash,
      pers: options.pers,
      persEnc: options.persEnc || "utf8",
      entropy: options.entropy || rand(this.hash.hmacStrength),
      entropyEnc: options.entropy && options.entropyEnc || "utf8",
      nonce: this.n.toArray()
    });
    var bytes3 = this.n.byteLength();
    var ns2 = this.n.sub(new BN2(2));
    for (;; ) {
      var priv = new BN2(drbg.generate(bytes3));
      if (priv.cmp(ns2) > 0)
        continue;
      priv.iaddn(1);
      return this.keyFromPrivate(priv);
    }
  };
  EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
    var delta = msg.byteLength() * 8 - this.n.bitLength();
    if (delta > 0)
      msg = msg.ushrn(delta);
    if (!truncOnly && msg.cmp(this.n) >= 0)
      return msg.sub(this.n);
    else
      return msg;
  };
  EC.prototype.sign = function sign(msg, key, enc, options) {
    if (typeof enc === "object") {
      options = enc;
      enc = null;
    }
    if (!options)
      options = {};
    key = this.keyFromPrivate(key, enc);
    msg = this._truncateToN(new BN2(msg, 16));
    var bytes3 = this.n.byteLength();
    var bkey = key.getPrivate().toArray("be", bytes3);
    var nonce = msg.toArray("be", bytes3);
    var drbg = new HmacDRBG({
      hash: this.hash,
      entropy: bkey,
      nonce,
      pers: options.pers,
      persEnc: options.persEnc || "utf8"
    });
    var ns1 = this.n.sub(new BN2(1));
    for (var iter = 0;; iter++) {
      var k2 = options.k ? options.k(iter) : new BN2(drbg.generate(this.n.byteLength()));
      k2 = this._truncateToN(k2, true);
      if (k2.cmpn(1) <= 0 || k2.cmp(ns1) >= 0)
        continue;
      var kp = this.g.mul(k2);
      if (kp.isInfinity())
        continue;
      var kpX = kp.getX();
      var r = kpX.umod(this.n);
      if (r.cmpn(0) === 0)
        continue;
      var s = k2.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
      s = s.umod(this.n);
      if (s.cmpn(0) === 0)
        continue;
      var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0);
      if (options.canonical && s.cmp(this.nh) > 0) {
        s = this.n.sub(s);
        recoveryParam ^= 1;
      }
      return new Signature2({ r, s, recoveryParam });
    }
  };
  EC.prototype.verify = function verify(msg, signature, key, enc) {
    msg = this._truncateToN(new BN2(msg, 16));
    key = this.keyFromPublic(key, enc);
    signature = new Signature2(signature, "hex");
    var r = signature.r;
    var s = signature.s;
    if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
      return false;
    if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
      return false;
    var sinv = s.invm(this.n);
    var u1 = sinv.mul(msg).umod(this.n);
    var u2 = sinv.mul(r).umod(this.n);
    var p;
    if (!this.curve._maxwellTrick) {
      p = this.g.mulAdd(u1, key.getPublic(), u2);
      if (p.isInfinity())
        return false;
      return p.getX().umod(this.n).cmp(r) === 0;
    }
    p = this.g.jmulAdd(u1, key.getPublic(), u2);
    if (p.isInfinity())
      return false;
    return p.eqXToP(r);
  };
  EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
    assert4((3 & j) === j, "The recovery param is more than two bits");
    signature = new Signature2(signature, enc);
    var n = this.n;
    var e = new BN2(msg);
    var r = signature.r;
    var s = signature.s;
    var isYOdd = j & 1;
    var isSecondKey = j >> 1;
    if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
      throw new Error("Unable to find sencond key candinate");
    if (isSecondKey)
      r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
    else
      r = this.curve.pointFromX(r, isYOdd);
    var rInv = signature.r.invm(n);
    var s1 = n.sub(e).mul(rInv).umod(n);
    var s22 = s.mul(rInv).umod(n);
    return this.g.mulAdd(s1, r, s22);
  };
  EC.prototype.getKeyRecoveryParam = function(e, signature, Q2, enc) {
    signature = new Signature2(signature, enc);
    if (signature.recoveryParam !== null)
      return signature.recoveryParam;
    for (var i = 0;i < 4; i++) {
      var Qprime;
      try {
        Qprime = this.recoverPubKey(e, signature, i);
      } catch (e2) {
        continue;
      }
      if (Qprime.eq(Q2))
        return i;
    }
    throw new Error("Unable to find valid recovery factor");
  };
});

// node_modules/elliptic/lib/elliptic/eddsa/key.js
var require_key2 = __commonJS((exports, module) => {
  var KeyPair = function(eddsa, params) {
    this.eddsa = eddsa;
    this._secret = parseBytes(params.secret);
    if (eddsa.isPoint(params.pub))
      this._pub = params.pub;
    else
      this._pubBytes = parseBytes(params.pub);
  };
  var utils41 = require_utils2();
  var assert4 = utils41.assert;
  var parseBytes = utils41.parseBytes;
  var cachedProperty = utils41.cachedProperty;
  KeyPair.fromPublic = function fromPublic(eddsa, pub) {
    if (pub instanceof KeyPair)
      return pub;
    return new KeyPair(eddsa, { pub });
  };
  KeyPair.fromSecret = function fromSecret(eddsa, secret) {
    if (secret instanceof KeyPair)
      return secret;
    return new KeyPair(eddsa, { secret });
  };
  KeyPair.prototype.secret = function secret() {
    return this._secret;
  };
  cachedProperty(KeyPair, "pubBytes", function pubBytes() {
    return this.eddsa.encodePoint(this.pub());
  });
  cachedProperty(KeyPair, "pub", function pub() {
    if (this._pubBytes)
      return this.eddsa.decodePoint(this._pubBytes);
    return this.eddsa.g.mul(this.priv());
  });
  cachedProperty(KeyPair, "privBytes", function privBytes() {
    var eddsa = this.eddsa;
    var hash5 = this.hash();
    var lastIx = eddsa.encodingLength - 1;
    var a = hash5.slice(0, eddsa.encodingLength);
    a[0] &= 248;
    a[lastIx] &= 127;
    a[lastIx] |= 64;
    return a;
  });
  cachedProperty(KeyPair, "priv", function priv() {
    return this.eddsa.decodeInt(this.privBytes());
  });
  cachedProperty(KeyPair, "hash", function hash() {
    return this.eddsa.hash().update(this.secret()).digest();
  });
  cachedProperty(KeyPair, "messagePrefix", function messagePrefix() {
    return this.hash().slice(this.eddsa.encodingLength);
  });
  KeyPair.prototype.sign = function sign(message) {
    assert4(this._secret, "KeyPair can only verify");
    return this.eddsa.sign(message, this);
  };
  KeyPair.prototype.verify = function verify(message, sig) {
    return this.eddsa.verify(message, sig, this);
  };
  KeyPair.prototype.getSecret = function getSecret(enc) {
    assert4(this._secret, "KeyPair is public only");
    return utils41.encode(this.secret(), enc);
  };
  KeyPair.prototype.getPublic = function getPublic(enc) {
    return utils41.encode(this.pubBytes(), enc);
  };
  module.exports = KeyPair;
});

// node_modules/elliptic/lib/elliptic/eddsa/signature.js
var require_signature2 = __commonJS((exports, module) => {
  var Signature2 = function(eddsa, sig) {
    this.eddsa = eddsa;
    if (typeof sig !== "object")
      sig = parseBytes(sig);
    if (Array.isArray(sig)) {
      sig = {
        R: sig.slice(0, eddsa.encodingLength),
        S: sig.slice(eddsa.encodingLength)
      };
    }
    assert4(sig.R && sig.S, "Signature without R or S");
    if (eddsa.isPoint(sig.R))
      this._R = sig.R;
    if (sig.S instanceof BN2)
      this._S = sig.S;
    this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
    this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
  };
  var BN2 = require_bn2();
  var utils41 = require_utils2();
  var assert4 = utils41.assert;
  var cachedProperty = utils41.cachedProperty;
  var parseBytes = utils41.parseBytes;
  cachedProperty(Signature2, "S", function S() {
    return this.eddsa.decodeInt(this.Sencoded());
  });
  cachedProperty(Signature2, "R", function R() {
    return this.eddsa.decodePoint(this.Rencoded());
  });
  cachedProperty(Signature2, "Rencoded", function Rencoded() {
    return this.eddsa.encodePoint(this.R());
  });
  cachedProperty(Signature2, "Sencoded", function Sencoded() {
    return this.eddsa.encodeInt(this.S());
  });
  Signature2.prototype.toBytes = function toBytes() {
    return this.Rencoded().concat(this.Sencoded());
  };
  Signature2.prototype.toHex = function toHex() {
    return utils41.encode(this.toBytes(), "hex").toUpperCase();
  };
  module.exports = Signature2;
});

// node_modules/elliptic/lib/elliptic/eddsa/index.js
var require_eddsa = __commonJS((exports, module) => {
  var EDDSA = function(curve) {
    assert4(curve === "ed25519", "only tested with ed25519 so far");
    if (!(this instanceof EDDSA))
      return new EDDSA(curve);
    curve = curves[curve].curve;
    this.curve = curve;
    this.g = curve.g;
    this.g.precompute(curve.n.bitLength() + 1);
    this.pointClass = curve.point().constructor;
    this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
    this.hash = hash5.sha512;
  };
  var hash5 = require_hash();
  var curves = require_curves();
  var utils41 = require_utils2();
  var assert4 = utils41.assert;
  var parseBytes = utils41.parseBytes;
  var KeyPair = require_key2();
  var Signature2 = require_signature2();
  module.exports = EDDSA;
  EDDSA.prototype.sign = function sign(message, secret) {
    message = parseBytes(message);
    var key = this.keyFromSecret(secret);
    var r = this.hashInt(key.messagePrefix(), message);
    var R = this.g.mul(r);
    var Rencoded = this.encodePoint(R);
    var s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv());
    var S2 = r.add(s_).umod(this.curve.n);
    return this.makeSignature({ R, S: S2, Rencoded });
  };
  EDDSA.prototype.verify = function verify(message, sig, pub) {
    message = parseBytes(message);
    sig = this.makeSignature(sig);
    var key = this.keyFromPublic(pub);
    var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
    var SG = this.g.mul(sig.S());
    var RplusAh = sig.R().add(key.pub().mul(h));
    return RplusAh.eq(SG);
  };
  EDDSA.prototype.hashInt = function hashInt() {
    var hash6 = this.hash();
    for (var i = 0;i < arguments.length; i++)
      hash6.update(arguments[i]);
    return utils41.intFromLE(hash6.digest()).umod(this.curve.n);
  };
  EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
    return KeyPair.fromPublic(this, pub);
  };
  EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
    return KeyPair.fromSecret(this, secret);
  };
  EDDSA.prototype.makeSignature = function makeSignature(sig) {
    if (sig instanceof Signature2)
      return sig;
    return new Signature2(this, sig);
  };
  EDDSA.prototype.encodePoint = function encodePoint(point) {
    var enc = point.getY().toArray("le", this.encodingLength);
    enc[this.encodingLength - 1] |= point.getX().isOdd() ? 128 : 0;
    return enc;
  };
  EDDSA.prototype.decodePoint = function decodePoint(bytes3) {
    bytes3 = utils41.parseBytes(bytes3);
    var lastIx = bytes3.length - 1;
    var normed = bytes3.slice(0, lastIx).concat(bytes3[lastIx] & ~128);
    var xIsOdd = (bytes3[lastIx] & 128) !== 0;
    var y = utils41.intFromLE(normed);
    return this.curve.pointFromY(y, xIsOdd);
  };
  EDDSA.prototype.encodeInt = function encodeInt(num) {
    return num.toArray("le", this.encodingLength);
  };
  EDDSA.prototype.decodeInt = function decodeInt(bytes3) {
    return utils41.intFromLE(bytes3);
  };
  EDDSA.prototype.isPoint = function isPoint(val) {
    return val instanceof this.pointClass;
  };
});

// node_modules/elliptic/lib/elliptic.js
var require_elliptic = __commonJS((exports) => {
  var elliptic = exports;
  elliptic.version = require_package().version;
  elliptic.utils = require_utils2();
  elliptic.rand = require_brorand();
  elliptic.curve = require_curve();
  elliptic.curves = require_curves();
  elliptic.ec = require_ec();
  elliptic.eddsa = require_eddsa();
});

// src/out/debug/fuel.bin
var require_fuel = __commonJS((exports, module) => {
  module.exports = "fuel-b182f427512d6909.bin";
});

// node_modules/ethers/lib.esm/_version.js
var version = "6.8.1";

// node_modules/ethers/lib.esm/utils/properties.js
var checkType = function(value, type, name) {
  const types = type.split("|").map((t) => t.trim());
  for (let i = 0;i < types.length; i++) {
    switch (type) {
      case "any":
        return;
      case "bigint":
      case "boolean":
      case "number":
      case "string":
        if (typeof value === type) {
          return;
        }
    }
  }
  const error = new Error(`invalid value for type ${type}`);
  error.code = "INVALID_ARGUMENT";
  error.argument = `value.${name}`;
  error.value = value;
  throw error;
};
function defineProperties(target, values, types) {
  for (let key in values) {
    let value = values[key];
    const type = types ? types[key] : null;
    if (type) {
      checkType(value, type, key);
    }
    Object.defineProperty(target, key, { enumerable: true, value, writable: false });
  }
}

// node_modules/ethers/lib.esm/utils/errors.js
var stringify = function(value) {
  if (value == null) {
    return "null";
  }
  if (Array.isArray(value)) {
    return "[ " + value.map(stringify).join(", ") + " ]";
  }
  if (value instanceof Uint8Array) {
    const HEX = "0123456789abcdef";
    let result = "0x";
    for (let i = 0;i < value.length; i++) {
      result += HEX[value[i] >> 4];
      result += HEX[value[i] & 15];
    }
    return result;
  }
  if (typeof value === "object" && typeof value.toJSON === "function") {
    return stringify(value.toJSON());
  }
  switch (typeof value) {
    case "boolean":
    case "symbol":
      return value.toString();
    case "bigint":
      return BigInt(value).toString();
    case "number":
      return value.toString();
    case "string":
      return JSON.stringify(value);
    case "object": {
      const keys = Object.keys(value);
      keys.sort();
      return "{ " + keys.map((k) => `${stringify(k)}: ${stringify(value[k])}`).join(", ") + " }";
    }
  }
  return `[ COULD NOT SERIALIZE ]`;
};
function makeError(message, code, info) {
  let shortMessage = message;
  {
    const details = [];
    if (info) {
      if (("message" in info) || ("code" in info) || ("name" in info)) {
        throw new Error(`value will overwrite populated values: ${stringify(info)}`);
      }
      for (const key in info) {
        if (key === "shortMessage") {
          continue;
        }
        const value = info[key];
        details.push(key + "=" + stringify(value));
      }
    }
    details.push(`code=${code}`);
    details.push(`version=${version}`);
    if (details.length) {
      message += " (" + details.join(", ") + ")";
    }
  }
  let error;
  switch (code) {
    case "INVALID_ARGUMENT":
      error = new TypeError(message);
      break;
    case "NUMERIC_FAULT":
    case "BUFFER_OVERRUN":
      error = new RangeError(message);
      break;
    default:
      error = new Error(message);
  }
  defineProperties(error, { code });
  if (info) {
    Object.assign(error, info);
  }
  if (error.shortMessage == null) {
    defineProperties(error, { shortMessage });
  }
  return error;
}
function assert(check, message, code, info) {
  if (!check) {
    throw makeError(message, code, info);
  }
}
function assertArgument(check, message, name, value) {
  assert(check, message, "INVALID_ARGUMENT", { argument: name, value });
}
function assertNormalize(form) {
  assert(_normalizeForms.indexOf(form) >= 0, "platform missing String.prototype.normalize", "UNSUPPORTED_OPERATION", {
    operation: "String.prototype.normalize",
    info: { form }
  });
}
var _normalizeForms = ["NFD", "NFC", "NFKD", "NFKC"].reduce((accum, form) => {
  try {
    if ("test".normalize(form) !== "test") {
      throw new Error("bad");
    }
    if (form === "NFD") {
      const check = String.fromCharCode(233).normalize("NFD");
      const expected = String.fromCharCode(101, 769);
      if (check !== expected) {
        throw new Error("broken");
      }
    }
    accum.push(form);
  } catch (error) {
  }
  return accum;
}, []);

// node_modules/ethers/lib.esm/utils/data.js
var _getBytes = function(value, name, copy) {
  if (value instanceof Uint8Array) {
    if (copy) {
      return new Uint8Array(value);
    }
    return value;
  }
  if (typeof value === "string" && value.match(/^0x([0-9a-f][0-9a-f])*$/i)) {
    const result = new Uint8Array((value.length - 2) / 2);
    let offset = 2;
    for (let i = 0;i < result.length; i++) {
      result[i] = parseInt(value.substring(offset, offset + 2), 16);
      offset += 2;
    }
    return result;
  }
  assertArgument(false, "invalid BytesLike value", name || "value", value);
};
function getBytes(value, name) {
  return _getBytes(value, name, false);
}
function getBytesCopy(value, name) {
  return _getBytes(value, name, true);
}
function isHexString(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (typeof length === "number" && value.length !== 2 + 2 * length) {
    return false;
  }
  if (length === true && value.length % 2 !== 0) {
    return false;
  }
  return true;
}
function hexlify(data) {
  const bytes = getBytes(data);
  let result = "0x";
  for (let i = 0;i < bytes.length; i++) {
    const v = bytes[i];
    result += HexCharacters[(v & 240) >> 4] + HexCharacters[v & 15];
  }
  return result;
}
function concat(datas) {
  return "0x" + datas.map((d) => hexlify(d).substring(2)).join("");
}
function dataSlice(data, start, end) {
  const bytes = getBytes(data);
  if (end != null && end > bytes.length) {
    assert(false, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
      buffer: bytes,
      length: bytes.length,
      offset: end
    });
  }
  return hexlify(bytes.slice(start == null ? 0 : start, end == null ? bytes.length : end));
}
var HexCharacters = "0123456789abcdef";

// node_modules/ethers/lib.esm/utils/maths.js
function getBigInt(value, name) {
  switch (typeof value) {
    case "bigint":
      return value;
    case "number":
      assertArgument(Number.isInteger(value), "underflow", name || "value", value);
      assertArgument(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
      return BigInt(value);
    case "string":
      try {
        if (value === "") {
          throw new Error("empty string");
        }
        if (value[0] === "-" && value[1] !== "-") {
          return -BigInt(value.substring(1));
        }
        return BigInt(value);
      } catch (e) {
        assertArgument(false, `invalid BigNumberish string: ${e.message}`, name || "value", value);
      }
  }
  assertArgument(false, "invalid BigNumberish value", name || "value", value);
}
function getUint(value, name) {
  const result = getBigInt(value, name);
  assert(result >= BN_0, "unsigned value cannot be negative", "NUMERIC_FAULT", {
    fault: "overflow",
    operation: "getUint",
    value
  });
  return result;
}
function toBigInt(value) {
  if (value instanceof Uint8Array) {
    let result = "0x0";
    for (const v of value) {
      result += Nibbles[v >> 4];
      result += Nibbles[v & 15];
    }
    return BigInt(result);
  }
  return getBigInt(value);
}
function getNumber(value, name) {
  switch (typeof value) {
    case "bigint":
      assertArgument(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
      return Number(value);
    case "number":
      assertArgument(Number.isInteger(value), "underflow", name || "value", value);
      assertArgument(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
      return value;
    case "string":
      try {
        if (value === "") {
          throw new Error("empty string");
        }
        return getNumber(BigInt(value), name);
      } catch (e) {
        assertArgument(false, `invalid numeric string: ${e.message}`, name || "value", value);
      }
  }
  assertArgument(false, "invalid numeric value", name || "value", value);
}
function toBeHex(_value, _width) {
  const value = getUint(_value, "value");
  let result = value.toString(16);
  if (_width == null) {
    if (result.length % 2) {
      result = "0" + result;
    }
  } else {
    const width = getNumber(_width, "width");
    assert(width * 2 >= result.length, `value exceeds width (${width} bytes)`, "NUMERIC_FAULT", {
      operation: "toBeHex",
      fault: "overflow",
      value: _value
    });
    while (result.length < width * 2) {
      result = "0" + result;
    }
  }
  return "0x" + result;
}
var BN_0 = BigInt(0);
var BN_1 = BigInt(1);
var maxValue = 9007199254740991;
var Nibbles = "0123456789abcdef";

// node_modules/ethers/lib.esm/utils/base58.js
var getAlpha = function(letter) {
  if (Lookup == null) {
    Lookup = {};
    for (let i = 0;i < Alphabet.length; i++) {
      Lookup[Alphabet[i]] = BigInt(i);
    }
  }
  const result = Lookup[letter];
  assertArgument(result != null, `invalid base58 value`, "letter", letter);
  return result;
};
function encodeBase58(_value) {
  let value = toBigInt(getBytes(_value));
  let result = "";
  while (value) {
    result = Alphabet[Number(value % BN_58)] + result;
    value /= BN_58;
  }
  return result;
}
function decodeBase58(value) {
  let result = BN_02;
  for (let i = 0;i < value.length; i++) {
    result *= BN_58;
    result += getAlpha(value[i]);
  }
  return result;
}
var Alphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var Lookup = null;
var BN_02 = BigInt(0);
var BN_58 = BigInt(58);
// node_modules/ethers/lib.esm/utils/utf8.js
var errorFunc = function(reason, offset, bytes, output, badCodepoint) {
  assertArgument(false, `invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes);
};
var ignoreFunc = function(reason, offset, bytes, output, badCodepoint) {
  if (reason === "BAD_PREFIX" || reason === "UNEXPECTED_CONTINUE") {
    let i = 0;
    for (let o = offset + 1;o < bytes.length; o++) {
      if (bytes[o] >> 6 !== 2) {
        break;
      }
      i++;
    }
    return i;
  }
  if (reason === "OVERRUN") {
    return bytes.length - offset - 1;
  }
  return 0;
};
var replaceFunc = function(reason, offset, bytes, output, badCodepoint) {
  if (reason === "OVERLONG") {
    assertArgument(typeof badCodepoint === "number", "invalid bad code point for replacement", "badCodepoint", badCodepoint);
    output.push(badCodepoint);
    return 0;
  }
  output.push(65533);
  return ignoreFunc(reason, offset, bytes, output, badCodepoint);
};
var getUtf8CodePoints = function(_bytes, onError) {
  if (onError == null) {
    onError = Utf8ErrorFuncs.error;
  }
  const bytes = getBytes(_bytes, "bytes");
  const result = [];
  let i = 0;
  while (i < bytes.length) {
    const c = bytes[i++];
    if (c >> 7 === 0) {
      result.push(c);
      continue;
    }
    let extraLength = null;
    let overlongMask = null;
    if ((c & 224) === 192) {
      extraLength = 1;
      overlongMask = 127;
    } else if ((c & 240) === 224) {
      extraLength = 2;
      overlongMask = 2047;
    } else if ((c & 248) === 240) {
      extraLength = 3;
      overlongMask = 65535;
    } else {
      if ((c & 192) === 128) {
        i += onError("UNEXPECTED_CONTINUE", i - 1, bytes, result);
      } else {
        i += onError("BAD_PREFIX", i - 1, bytes, result);
      }
      continue;
    }
    if (i - 1 + extraLength >= bytes.length) {
      i += onError("OVERRUN", i - 1, bytes, result);
      continue;
    }
    let res = c & (1 << 8 - extraLength - 1) - 1;
    for (let j = 0;j < extraLength; j++) {
      let nextChar = bytes[i];
      if ((nextChar & 192) != 128) {
        i += onError("MISSING_CONTINUE", i, bytes, result);
        res = null;
        break;
      }
      res = res << 6 | nextChar & 63;
      i++;
    }
    if (res === null) {
      continue;
    }
    if (res > 1114111) {
      i += onError("OUT_OF_RANGE", i - 1 - extraLength, bytes, result, res);
      continue;
    }
    if (res >= 55296 && res <= 57343) {
      i += onError("UTF16_SURROGATE", i - 1 - extraLength, bytes, result, res);
      continue;
    }
    if (res <= overlongMask) {
      i += onError("OVERLONG", i - 1 - extraLength, bytes, result, res);
      continue;
    }
    result.push(res);
  }
  return result;
};
function toUtf8Bytes(str, form) {
  if (form != null) {
    assertNormalize(form);
    str = str.normalize(form);
  }
  let result = [];
  for (let i = 0;i < str.length; i++) {
    const c = str.charCodeAt(i);
    if (c < 128) {
      result.push(c);
    } else if (c < 2048) {
      result.push(c >> 6 | 192);
      result.push(c & 63 | 128);
    } else if ((c & 64512) == 55296) {
      i++;
      const c2 = str.charCodeAt(i);
      assertArgument(i < str.length && (c2 & 64512) === 56320, "invalid surrogate pair", "str", str);
      const pair = 65536 + ((c & 1023) << 10) + (c2 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c >> 12 | 224);
      result.push(c >> 6 & 63 | 128);
      result.push(c & 63 | 128);
    }
  }
  return new Uint8Array(result);
}
var _toUtf8String = function(codePoints) {
  return codePoints.map((codePoint) => {
    if (codePoint <= 65535) {
      return String.fromCharCode(codePoint);
    }
    codePoint -= 65536;
    return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
  }).join("");
};
function toUtf8String(bytes, onError) {
  return _toUtf8String(getUtf8CodePoints(bytes, onError));
}
var Utf8ErrorFuncs = Object.freeze({
  error: errorFunc,
  ignore: ignoreFunc,
  replace: replaceFunc
});
// node_modules/@noble/hashes/esm/_assert.js
var number = function(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error(`Wrong positive integer: ${n}`);
};
var bytes = function(b, ...lengths) {
  if (!(b instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
};
var hash = function(hash2) {
  if (typeof hash2 !== "function" || typeof hash2.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(hash2.outputLen);
  number(hash2.blockLen);
};
var exists = function(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
};
var output = function(out, instance) {
  bytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
};

// node_modules/@noble/hashes/esm/utils.js
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes(data3) {
  if (typeof data3 === "string")
    data3 = utf8ToBytes(data3);
  if (!u8a(data3))
    throw new Error(`expected Uint8Array, got ${typeof data3}`);
  return data3;
}
function checkOpts(defaults, opts) {
  if (opts !== undefined && toStr.call(opts) !== "[object Object]")
    throw new Error("Options should be object or undefined");
  const merged = Object.assign(defaults, opts);
  return merged;
}
function wrapConstructor(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function wrapXOFConstructorWithOpts(hashCons) {
  const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
  const tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  return hashC;
}
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var u8a = (a) => a instanceof Uint8Array;
var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var rotr = (word, shift) => word << 32 - shift | word >>> shift;
var isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE)
  throw new Error("Non little-endian hardware is not supported");
class Hash {
  clone() {
    return this._cloneInto();
  }
}
var toStr = {}.toString;

// node_modules/@noble/hashes/esm/hmac.js
class HMAC extends Hash {
  constructor(hash2, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    hash(hash2);
    const key = toBytes(_key);
    this.iHash = hash2.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
    for (let i = 0;i < pad.length; i++)
      pad[i] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash2.create();
    for (let i = 0;i < pad.length; i++)
      pad[i] ^= 54 ^ 92;
    this.oHash.update(pad);
    pad.fill(0);
  }
  update(buf) {
    exists(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    exists(this);
    bytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
}
var hmac = (hash2, key, message) => new HMAC(hash2, key).update(message).digest();
hmac.create = (hash2, key) => new HMAC(hash2, key);

// node_modules/@noble/hashes/esm/pbkdf2.js
var pbkdf2Init = function(hash2, _password, _salt, _opts) {
  hash(hash2);
  const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);
  const { c, dkLen, asyncTick } = opts;
  number(c);
  number(dkLen);
  number(asyncTick);
  if (c < 1)
    throw new Error("PBKDF2: iterations (c) should be >= 1");
  const password = toBytes(_password);
  const salt = toBytes(_salt);
  const DK = new Uint8Array(dkLen);
  const PRF = hmac.create(hash2, password);
  const PRFSalt = PRF._cloneInto().update(salt);
  return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
};
var pbkdf2Output = function(PRF, PRFSalt, DK, prfW, u) {
  PRF.destroy();
  PRFSalt.destroy();
  if (prfW)
    prfW.destroy();
  u.fill(0);
  return DK;
};
function pbkdf2(hash2, password, salt, opts) {
  const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash2, password, salt, opts);
  let prfW;
  const arr = new Uint8Array(4);
  const view = createView(arr);
  const u = new Uint8Array(PRF.outputLen);
  for (let ti = 1, pos = 0;pos < dkLen; ti++, pos += PRF.outputLen) {
    const Ti = DK.subarray(pos, pos + PRF.outputLen);
    view.setInt32(0, ti, false);
    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
    Ti.set(u.subarray(0, Ti.length));
    for (let ui = 1;ui < c; ui++) {
      PRF._cloneInto(prfW).update(u).digestInto(u);
      for (let i = 0;i < Ti.length; i++)
        Ti[i] ^= u[i];
    }
  }
  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
}

// node_modules/@noble/hashes/esm/_sha2.js
var setBigUint64 = function(view, byteOffset, value, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE2);
  const _32n = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE2 ? 4 : 0;
  const l = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE2);
  view.setUint32(byteOffset + l, wl, isLE2);
};

class SHA2 extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE2) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE2;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data3) {
    exists(this);
    const { view, buffer, blockLen } = this;
    data3 = toBytes(data3);
    const len = data3.length;
    for (let pos = 0;pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data3);
        for (;blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data3.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data3.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    exists(this);
    output(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE: isLE2 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos;i < blockLen; i++)
      buffer[i] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0;i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE2);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor);
    to.set(...this.get());
    const { blockLen, buffer, length, finished, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer);
    return to;
  }
}

// node_modules/@noble/hashes/esm/sha256.js
var Chi = (a, b, c) => a & b ^ ~a & c;
var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
var SHA256_K = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var IV = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA256_W = new Uint32Array(64);

class SHA256 extends SHA2 {
  constructor() {
    super(64, 32, 8, false);
    this.A = IV[0] | 0;
    this.B = IV[1] | 0;
    this.C = IV[2] | 0;
    this.D = IV[3] | 0;
    this.E = IV[4] | 0;
    this.F = IV[5] | 0;
    this.G = IV[6] | 0;
    this.H = IV[7] | 0;
  }
  get() {
    const { A, B, C, D, E, F, G, H } = this;
    return [A, B, C, D, E, F, G, H];
  }
  set(A, B, C, D, E, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i = 0;i < 16; i++, offset += 4)
      SHA256_W[i] = view.getUint32(offset, false);
    for (let i = 16;i < 64; i++) {
      const W15 = SHA256_W[i - 15];
      const W2 = SHA256_W[i - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
    }
    let { A, B, C, D, E, F, G, H } = this;
    for (let i = 0;i < 64; i++) {
      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
      const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
      const T2 = sigma0 + Maj(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T1 | 0;
      D = C;
      C = B;
      B = A;
      A = T1 + T2 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G, H);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
}
var sha256 = wrapConstructor(() => new SHA256);

// node_modules/@noble/hashes/esm/_u64.js
var fromBig = function(n, le = false) {
  if (le)
    return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
  return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
};
var split = function(lst, le = false) {
  let Ah = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i = 0;i < lst.length; i++) {
    const { h, l } = fromBig(lst[i], le);
    [Ah[i], Al[i]] = [h, l];
  }
  return [Ah, Al];
};
var add = function(Ah, Al, Bh, Bl) {
  const l = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
};
var U32_MASK64 = BigInt(2 ** 32 - 1);
var _32n = BigInt(32);
var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
var shrSH = (h, _l, s) => h >>> s;
var shrSL = (h, l, s) => h << 32 - s | l >>> s;
var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
var rotr32H = (_h, l) => l;
var rotr32L = (h, _l) => h;
var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
var u64 = {
  fromBig,
  split,
  toBig,
  shrSH,
  shrSL,
  rotrSH,
  rotrSL,
  rotrBH,
  rotrBL,
  rotr32H,
  rotr32L,
  rotlSH,
  rotlSL,
  rotlBH,
  rotlBL,
  add,
  add3L,
  add3H,
  add4L,
  add4H,
  add5H,
  add5L
};
var _u64_default = u64;

// node_modules/@noble/hashes/esm/sha512.js
var [SHA512_Kh, SHA512_Kl] = (() => _u64_default.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n) => BigInt(n))))();
var SHA512_W_H = new Uint32Array(80);
var SHA512_W_L = new Uint32Array(80);

class SHA512 extends SHA2 {
  constructor() {
    super(128, 64, 16, false);
    this.Ah = 1779033703 | 0;
    this.Al = 4089235720 | 0;
    this.Bh = 3144134277 | 0;
    this.Bl = 2227873595 | 0;
    this.Ch = 1013904242 | 0;
    this.Cl = 4271175723 | 0;
    this.Dh = 2773480762 | 0;
    this.Dl = 1595750129 | 0;
    this.Eh = 1359893119 | 0;
    this.El = 2917565137 | 0;
    this.Fh = 2600822924 | 0;
    this.Fl = 725511199 | 0;
    this.Gh = 528734635 | 0;
    this.Gl = 4215389547 | 0;
    this.Hh = 1541459225 | 0;
    this.Hl = 327033209 | 0;
  }
  get() {
    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
  }
  set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
    this.Ah = Ah | 0;
    this.Al = Al | 0;
    this.Bh = Bh | 0;
    this.Bl = Bl | 0;
    this.Ch = Ch | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh | 0;
    this.El = El | 0;
    this.Fh = Fh | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh | 0;
    this.Hl = Hl | 0;
  }
  process(view, offset) {
    for (let i = 0;i < 16; i++, offset += 4) {
      SHA512_W_H[i] = view.getUint32(offset);
      SHA512_W_L[i] = view.getUint32(offset += 4);
    }
    for (let i = 16;i < 80; i++) {
      const W15h = SHA512_W_H[i - 15] | 0;
      const W15l = SHA512_W_L[i - 15] | 0;
      const s0h = _u64_default.rotrSH(W15h, W15l, 1) ^ _u64_default.rotrSH(W15h, W15l, 8) ^ _u64_default.shrSH(W15h, W15l, 7);
      const s0l = _u64_default.rotrSL(W15h, W15l, 1) ^ _u64_default.rotrSL(W15h, W15l, 8) ^ _u64_default.shrSL(W15h, W15l, 7);
      const W2h = SHA512_W_H[i - 2] | 0;
      const W2l = SHA512_W_L[i - 2] | 0;
      const s1h = _u64_default.rotrSH(W2h, W2l, 19) ^ _u64_default.rotrBH(W2h, W2l, 61) ^ _u64_default.shrSH(W2h, W2l, 6);
      const s1l = _u64_default.rotrSL(W2h, W2l, 19) ^ _u64_default.rotrBL(W2h, W2l, 61) ^ _u64_default.shrSL(W2h, W2l, 6);
      const SUMl = _u64_default.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
      const SUMh = _u64_default.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
      SHA512_W_H[i] = SUMh | 0;
      SHA512_W_L[i] = SUMl | 0;
    }
    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    for (let i = 0;i < 80; i++) {
      const sigma1h = _u64_default.rotrSH(Eh, El, 14) ^ _u64_default.rotrSH(Eh, El, 18) ^ _u64_default.rotrBH(Eh, El, 41);
      const sigma1l = _u64_default.rotrSL(Eh, El, 14) ^ _u64_default.rotrSL(Eh, El, 18) ^ _u64_default.rotrBL(Eh, El, 41);
      const CHIh = Eh & Fh ^ ~Eh & Gh;
      const CHIl = El & Fl ^ ~El & Gl;
      const T1ll = _u64_default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
      const T1h = _u64_default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
      const T1l = T1ll | 0;
      const sigma0h = _u64_default.rotrSH(Ah, Al, 28) ^ _u64_default.rotrBH(Ah, Al, 34) ^ _u64_default.rotrBH(Ah, Al, 39);
      const sigma0l = _u64_default.rotrSL(Ah, Al, 28) ^ _u64_default.rotrBL(Ah, Al, 34) ^ _u64_default.rotrBL(Ah, Al, 39);
      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
      const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
      Hh = Gh | 0;
      Hl = Gl | 0;
      Gh = Fh | 0;
      Gl = Fl | 0;
      Fh = Eh | 0;
      Fl = El | 0;
      ({ h: Eh, l: El } = _u64_default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
      Dh = Ch | 0;
      Dl = Cl | 0;
      Ch = Bh | 0;
      Cl = Bl | 0;
      Bh = Ah | 0;
      Bl = Al | 0;
      const All = _u64_default.add3L(T1l, sigma0l, MAJl);
      Ah = _u64_default.add3H(All, T1h, sigma0h, MAJh);
      Al = All | 0;
    }
    ({ h: Ah, l: Al } = _u64_default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
    ({ h: Bh, l: Bl } = _u64_default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
    ({ h: Ch, l: Cl } = _u64_default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
    ({ h: Dh, l: Dl } = _u64_default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
    ({ h: Eh, l: El } = _u64_default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
    ({ h: Fh, l: Fl } = _u64_default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
    ({ h: Gh, l: Gl } = _u64_default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
    ({ h: Hh, l: Hl } = _u64_default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
  }
  roundClean() {
    SHA512_W_H.fill(0);
    SHA512_W_L.fill(0);
  }
  destroy() {
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
var sha512 = wrapConstructor(() => new SHA512);

// node_modules/ethers/lib.esm/crypto/crypto-browser.js
var getGlobal = function() {
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw new Error("unable to locate global object");
};
function createHash(algo) {
  switch (algo) {
    case "sha256":
      return sha256.create();
    case "sha512":
      return sha512.create();
  }
  assertArgument(false, "invalid hashing algorithm name", "algorithm", algo);
}
function createHmac(_algo, key) {
  const algo = { sha256, sha512 }[_algo];
  assertArgument(algo != null, "invalid hmac algorithm", "algorithm", _algo);
  return hmac.create(algo, key);
}
function pbkdf2Sync(password, salt, iterations, keylen, _algo) {
  const algo = { sha256, sha512 }[_algo];
  assertArgument(algo != null, "invalid pbkdf2 algorithm", "algorithm", _algo);
  return pbkdf2(algo, password, salt, { c: iterations, dkLen: keylen });
}
var anyGlobal = getGlobal();
var crypto2 = anyGlobal.crypto || anyGlobal.msCrypto;

// node_modules/ethers/lib.esm/crypto/hmac.js
function computeHmac(algorithm, _key, _data) {
  const key = getBytes(_key, "key");
  const data3 = getBytes(_data, "data");
  return hexlify(__computeHmac(algorithm, key, data3));
}
var locked = false;
var _computeHmac = function(algorithm, key, data3) {
  return createHmac(algorithm, key).update(data3).digest();
};
var __computeHmac = _computeHmac;
computeHmac._ = _computeHmac;
computeHmac.lock = function() {
  locked = true;
};
computeHmac.register = function(func) {
  if (locked) {
    throw new Error("computeHmac is locked");
  }
  __computeHmac = func;
};
Object.freeze(computeHmac);

// node_modules/@noble/hashes/esm/sha3.js
function keccakP(s, rounds = 24) {
  const B = new Uint32Array(5 * 2);
  for (let round = 24 - rounds;round < 24; round++) {
    for (let x = 0;x < 10; x++)
      B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
    for (let x = 0;x < 10; x += 2) {
      const idx1 = (x + 8) % 10;
      const idx0 = (x + 2) % 10;
      const B0 = B[idx0];
      const B1 = B[idx0 + 1];
      const Th = rotlH(B0, B1, 1) ^ B[idx1];
      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
      for (let y = 0;y < 50; y += 10) {
        s[x + y] ^= Th;
        s[x + y + 1] ^= Tl;
      }
    }
    let curH = s[2];
    let curL = s[3];
    for (let t = 0;t < 24; t++) {
      const shift = SHA3_ROTL[t];
      const Th = rotlH(curH, curL, shift);
      const Tl = rotlL(curH, curL, shift);
      const PI = SHA3_PI[t];
      curH = s[PI];
      curL = s[PI + 1];
      s[PI] = Th;
      s[PI + 1] = Tl;
    }
    for (let y = 0;y < 50; y += 10) {
      for (let x = 0;x < 10; x++)
        B[x] = s[y + x];
      for (let x = 0;x < 10; x++)
        s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
    }
    s[0] ^= SHA3_IOTA_H[round];
    s[1] ^= SHA3_IOTA_L[round];
  }
  B.fill(0);
}
var [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
var _7n = BigInt(7);
var _256n = BigInt(256);
var _0x71n = BigInt(113);
for (let round = 0, R = _1n, x = 1, y = 0;round < 24; round++) {
  [x, y] = [y, (2 * x + 3 * y) % 5];
  SHA3_PI.push(2 * (5 * y + x));
  SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
  let t = _0n;
  for (let j = 0;j < 7; j++) {
    R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
    if (R & _2n)
      t ^= _1n << (_1n << BigInt(j)) - _1n;
  }
  _SHA3_IOTA.push(t);
}
var [SHA3_IOTA_H, SHA3_IOTA_L] = split(_SHA3_IOTA, true);
var rotlH = (h, l, s) => s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s);
var rotlL = (h, l, s) => s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s);

class Keccak extends Hash {
  constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
    super();
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    this.pos = 0;
    this.posOut = 0;
    this.finished = false;
    this.destroyed = false;
    number(outputLen);
    if (0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200);
    this.state32 = u32(this.state);
  }
  keccak() {
    keccakP(this.state32, this.rounds);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data3) {
    exists(this);
    const { blockLen, state } = this;
    data3 = toBytes(data3);
    const len = data3.length;
    for (let pos = 0;pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      for (let i = 0;i < take; i++)
        state[this.pos++] ^= data3[pos++];
      if (this.pos === blockLen)
        this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state, suffix, pos, blockLen } = this;
    state[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1)
      this.keccak();
    state[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    exists(this, false);
    bytes(out);
    this.finish();
    const bufferOut = this.state;
    const { blockLen } = this;
    for (let pos = 0, len = out.length;pos < len; ) {
      if (this.posOut >= blockLen)
        this.keccak();
      const take = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes2) {
    number(bytes2);
    return this.xofInto(new Uint8Array(bytes2));
  }
  digestInto(out) {
    output(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    this.state.fill(0);
  }
  _cloneInto(to) {
    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
    to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
    to.state32.set(this.state32);
    to.pos = this.pos;
    to.posOut = this.posOut;
    to.finished = this.finished;
    to.rounds = rounds;
    to.suffix = suffix;
    to.outputLen = outputLen;
    to.enableXOF = enableXOF;
    to.destroyed = this.destroyed;
    return to;
  }
}
var gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
var sha3_224 = gen(6, 144, 224 / 8);
var sha3_256 = gen(6, 136, 256 / 8);
var sha3_384 = gen(6, 104, 384 / 8);
var sha3_512 = gen(6, 72, 512 / 8);
var keccak_224 = gen(1, 144, 224 / 8);
var keccak_256 = gen(1, 136, 256 / 8);
var keccak_384 = gen(1, 104, 384 / 8);
var keccak_512 = gen(1, 72, 512 / 8);
var genShake = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));
var shake128 = genShake(31, 168, 128 / 8);
var shake256 = genShake(31, 136, 256 / 8);

// node_modules/ethers/lib.esm/crypto/keccak.js
function keccak256(_data) {
  const data3 = getBytes(_data, "data");
  return hexlify(__keccak256(data3));
}
var locked2 = false;
var _keccak256 = function(data3) {
  return keccak_256(data3);
};
var __keccak256 = _keccak256;
keccak256._ = _keccak256;
keccak256.lock = function() {
  locked2 = true;
};
keccak256.register = function(func) {
  if (locked2) {
    throw new TypeError("keccak256 is locked");
  }
  __keccak256 = func;
};
Object.freeze(keccak256);

// node_modules/@noble/hashes/esm/ripemd160.js
var f = function(group, x, y, z) {
  if (group === 0)
    return x ^ y ^ z;
  else if (group === 1)
    return x & y | ~x & z;
  else if (group === 2)
    return (x | ~y) ^ z;
  else if (group === 3)
    return x & z | y & ~z;
  else
    return x ^ (y | ~z);
};
var Rho = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
var Id = Uint8Array.from({ length: 16 }, (_, i) => i);
var Pi = Id.map((i) => (9 * i + 5) % 16);
var idxL = [Id];
var idxR = [Pi];
for (let i = 0;i < 4; i++)
  for (let j of [idxL, idxR])
    j.push(j[i].map((k) => Rho[k]));
var shifts = [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((i) => new Uint8Array(i));
var shiftsL = idxL.map((idx, i) => idx.map((j) => shifts[i][j]));
var shiftsR = idxR.map((idx, i) => idx.map((j) => shifts[i][j]));
var Kl = new Uint32Array([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]);
var Kr = new Uint32Array([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
var rotl = (word, shift) => word << shift | word >>> 32 - shift;
var BUF = new Uint32Array(16);

class RIPEMD160 extends SHA2 {
  constructor() {
    super(64, 20, 8, true);
    this.h0 = 1732584193 | 0;
    this.h1 = 4023233417 | 0;
    this.h2 = 2562383102 | 0;
    this.h3 = 271733878 | 0;
    this.h4 = 3285377520 | 0;
  }
  get() {
    const { h0, h1, h2, h3, h4 } = this;
    return [h0, h1, h2, h3, h4];
  }
  set(h0, h1, h2, h3, h4) {
    this.h0 = h0 | 0;
    this.h1 = h1 | 0;
    this.h2 = h2 | 0;
    this.h3 = h3 | 0;
    this.h4 = h4 | 0;
  }
  process(view, offset) {
    for (let i = 0;i < 16; i++, offset += 4)
      BUF[i] = view.getUint32(offset, true);
    let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
    for (let group = 0;group < 5; group++) {
      const rGroup = 4 - group;
      const hbl = Kl[group], hbr = Kr[group];
      const rl = idxL[group], rr = idxR[group];
      const sl = shiftsL[group], sr = shiftsR[group];
      for (let i = 0;i < 16; i++) {
        const tl = rotl(al + f(group, bl, cl, dl) + BUF[rl[i]] + hbl, sl[i]) + el | 0;
        al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl;
      }
      for (let i = 0;i < 16; i++) {
        const tr = rotl(ar + f(rGroup, br, cr, dr) + BUF[rr[i]] + hbr, sr[i]) + er | 0;
        ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr;
      }
    }
    this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
  }
  roundClean() {
    BUF.fill(0);
  }
  destroy() {
    this.destroyed = true;
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0);
  }
}
var ripemd160 = wrapConstructor(() => new RIPEMD160);

// node_modules/ethers/lib.esm/crypto/ripemd160.js
function ripemd1603(_data) {
  const data3 = getBytes(_data, "data");
  return hexlify(__ripemd160(data3));
}
var locked3 = false;
var _ripemd160 = function(data3) {
  return ripemd160(data3);
};
var __ripemd160 = _ripemd160;
ripemd1603._ = _ripemd160;
ripemd1603.lock = function() {
  locked3 = true;
};
ripemd1603.register = function(func) {
  if (locked3) {
    throw new TypeError("ripemd160 is locked");
  }
  __ripemd160 = func;
};
Object.freeze(ripemd1603);

// node_modules/ethers/lib.esm/crypto/pbkdf2.js
function pbkdf23(_password, _salt, iterations, keylen, algo) {
  const password = getBytes(_password, "password");
  const salt = getBytes(_salt, "salt");
  return hexlify(__pbkdf2(password, salt, iterations, keylen, algo));
}
var locked4 = false;
var _pbkdf2 = function(password, salt, iterations, keylen, algo) {
  return pbkdf2Sync(password, salt, iterations, keylen, algo);
};
var __pbkdf2 = _pbkdf2;
pbkdf23._ = _pbkdf2;
pbkdf23.lock = function() {
  locked4 = true;
};
pbkdf23.register = function(func) {
  if (locked4) {
    throw new Error("pbkdf2 is locked");
  }
  __pbkdf2 = func;
};
Object.freeze(pbkdf23);

// node_modules/ethers/lib.esm/crypto/sha2.js
function sha2563(_data) {
  const data3 = getBytes(_data, "data");
  return hexlify(__sha256(data3));
}
function sha5123(_data) {
  const data3 = getBytes(_data, "data");
  return hexlify(__sha512(data3));
}
var _sha256 = function(data3) {
  return createHash("sha256").update(data3).digest();
};
var _sha512 = function(data3) {
  return createHash("sha512").update(data3).digest();
};
var __sha256 = _sha256;
var __sha512 = _sha512;
var locked256 = false;
var locked512 = false;
sha2563._ = _sha256;
sha2563.lock = function() {
  locked256 = true;
};
sha2563.register = function(func) {
  if (locked256) {
    throw new Error("sha256 is locked");
  }
  __sha256 = func;
};
Object.freeze(sha2563);
sha5123._ = _sha512;
sha5123.lock = function() {
  locked512 = true;
};
sha5123.register = function(func) {
  if (locked512) {
    throw new Error("sha512 is locked");
  }
  __sha512 = func;
};
Object.freeze(sha2563);

// node_modules/ethers/lib.esm/address/address.js
var getChecksumAddress = function(address) {
  address = address.toLowerCase();
  const chars = address.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i = 0;i < 40; i++) {
    expanded[i] = chars[i].charCodeAt(0);
  }
  const hashed = getBytes(keccak256(expanded));
  for (let i = 0;i < 40; i += 2) {
    if (hashed[i >> 1] >> 4 >= 8) {
      chars[i] = chars[i].toUpperCase();
    }
    if ((hashed[i >> 1] & 15) >= 8) {
      chars[i + 1] = chars[i + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
};
var ibanChecksum = function(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  let expanded = address.split("").map((c) => {
    return ibanLookup[c];
  }).join("");
  while (expanded.length >= safeDigits) {
    let block = expanded.substring(0, safeDigits);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }
  let checksum = String(98 - parseInt(expanded, 10) % 97);
  while (checksum.length < 2) {
    checksum = "0" + checksum;
  }
  return checksum;
};
var fromBase36 = function(value) {
  value = value.toLowerCase();
  let result = BN_03;
  for (let i = 0;i < value.length; i++) {
    result = result * BN_36 + Base36[value[i]];
  }
  return result;
};
function getAddress(address) {
  assertArgument(typeof address === "string", "invalid address", "address", address);
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    if (!address.startsWith("0x")) {
      address = "0x" + address;
    }
    const result = getChecksumAddress(address);
    assertArgument(!address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || result === address, "bad address checksum", "address", address);
    return result;
  }
  if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    assertArgument(address.substring(2, 4) === ibanChecksum(address), "bad icap checksum", "address", address);
    let result = fromBase36(address.substring(4)).toString(16);
    while (result.length < 40) {
      result = "0" + result;
    }
    return getChecksumAddress("0x" + result);
  }
  assertArgument(false, "invalid address", "address", address);
}
var BN_03 = BigInt(0);
var BN_36 = BigInt(36);
var ibanLookup = {};
for (let i = 0;i < 10; i++) {
  ibanLookup[String(i)] = String(i);
}
for (let i = 0;i < 26; i++) {
  ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);
}
var safeDigits = 15;
var Base36 = function() {
  const result = {};
  for (let i = 0;i < 36; i++) {
    const key = "0123456789abcdefghijklmnopqrstuvwxyz"[i];
    result[key] = BigInt(i);
  }
  return result;
}();
// node_modules/ethers/lib.esm/transaction/accesslist.js
var accessSetify = function(addr, storageKeys) {
  return {
    address: getAddress(addr),
    storageKeys: storageKeys.map((storageKey, index) => {
      assertArgument(isHexString(storageKey, 32), "invalid slot", `storageKeys[${index}]`, storageKey);
      return storageKey.toLowerCase();
    })
  };
};
function accessListify(value) {
  if (Array.isArray(value)) {
    return value.map((set, index) => {
      if (Array.isArray(set)) {
        assertArgument(set.length === 2, "invalid slot set", `value[${index}]`, set);
        return accessSetify(set[0], set[1]);
      }
      assertArgument(set != null && typeof set === "object", "invalid address-slot set", "value", value);
      return accessSetify(set.address, set.storageKeys);
    });
  }
  assertArgument(value != null && typeof value === "object", "invalid access list", "value", value);
  const result = Object.keys(value).map((addr) => {
    const storageKeys = value[addr].reduce((accum, storageKey) => {
      accum[storageKey] = true;
      return accum;
    }, {});
    return accessSetify(addr, Object.keys(storageKeys).sort());
  });
  result.sort((a, b) => a.address.localeCompare(b.address));
  return result;
}
// node_modules/ethers/lib.esm/providers/plugins-network.js
var EnsAddress = "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e";

class NetworkPlugin {
  name;
  constructor(name) {
    defineProperties(this, { name });
  }
  clone() {
    return new NetworkPlugin(this.name);
  }
}

class GasCostPlugin extends NetworkPlugin {
  effectiveBlock;
  txBase;
  txCreate;
  txDataZero;
  txDataNonzero;
  txAccessListStorageKey;
  txAccessListAddress;
  constructor(effectiveBlock, costs) {
    if (effectiveBlock == null) {
      effectiveBlock = 0;
    }
    super(`org.ethers.network.plugins.GasCost#${effectiveBlock || 0}`);
    const props = { effectiveBlock };
    function set(name, nullish) {
      let value = (costs || {})[name];
      if (value == null) {
        value = nullish;
      }
      assertArgument(typeof value === "number", `invalud value for ${name}`, "costs", costs);
      props[name] = value;
    }
    set("txBase", 21000);
    set("txCreate", 32000);
    set("txDataZero", 4);
    set("txDataNonzero", 16);
    set("txAccessListStorageKey", 1900);
    set("txAccessListAddress", 2400);
    defineProperties(this, props);
  }
  clone() {
    return new GasCostPlugin(this.effectiveBlock, this);
  }
}

class EnsPlugin extends NetworkPlugin {
  address;
  targetNetwork;
  constructor(address2, targetNetwork) {
    super("org.ethers.plugins.network.Ens");
    defineProperties(this, {
      address: address2 || EnsAddress,
      targetNetwork: targetNetwork == null ? 1 : targetNetwork
    });
  }
  clone() {
    return new EnsPlugin(this.address, this.targetNetwork);
  }
}

class FeeDataNetworkPlugin extends NetworkPlugin {
  #feeDataFunc;
  get feeDataFunc() {
    return this.#feeDataFunc;
  }
  constructor(feeDataFunc) {
    super("org.ethers.plugins.network.FeeData");
    this.#feeDataFunc = feeDataFunc;
  }
  async getFeeData(provider) {
    return await this.#feeDataFunc(provider);
  }
  clone() {
    return new FeeDataNetworkPlugin(this.#feeDataFunc);
  }
}

class FetchUrlFeeDataNetworkPlugin extends NetworkPlugin {
  #url;
  #processFunc;
  get url() {
    return this.#url;
  }
  get processFunc() {
    return this.#processFunc;
  }
  constructor(url, processFunc) {
    super("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
    this.#url = url;
    this.#processFunc = processFunc;
  }
  clone() {
    return this;
  }
}

// node_modules/ethers/lib.esm/providers/network.js
var parseUnits = function(_value, decimals) {
  const value = String(_value);
  if (!value.match(/^[0-9.]+$/)) {
    throw new Error(`invalid gwei value: ${_value}`);
  }
  const comps = value.split(".");
  if (comps.length === 1) {
    comps.push("");
  }
  if (comps.length !== 2) {
    throw new Error(`invalid gwei value: ${_value}`);
  }
  while (comps[1].length < decimals) {
    comps[1] += "0";
  }
  if (comps[1].length > 9) {
    let frac = BigInt(comps[1].substring(0, 9));
    if (!comps[1].substring(9).match(/^0+$/)) {
      frac++;
    }
    comps[1] = frac.toString();
  }
  return BigInt(comps[0] + comps[1]);
};
var getGasStationPlugin = function(url) {
  return new FetchUrlFeeDataNetworkPlugin(url, async (fetchFeeData, provider, request) => {
    request.setHeader("User-Agent", "ethers");
    let response;
    try {
      const [_response, _feeData] = await Promise.all([
        request.send(),
        fetchFeeData()
      ]);
      response = _response;
      const payload = response.bodyJson.standard;
      const feeData = {
        gasPrice: _feeData.gasPrice,
        maxFeePerGas: parseUnits(payload.maxFee, 9),
        maxPriorityFeePerGas: parseUnits(payload.maxPriorityFee, 9)
      };
      return feeData;
    } catch (error) {
      assert(false, `error encountered with polygon gas station (${JSON.stringify(request.url)})`, "SERVER_ERROR", { request, response, error });
    }
  });
};
var getPriorityFeePlugin = function(maxPriorityFeePerGas) {
  return new FetchUrlFeeDataNetworkPlugin("data:", async (fetchFeeData, provider, request) => {
    const feeData = await fetchFeeData();
    if (feeData.maxFeePerGas == null || feeData.maxPriorityFeePerGas == null) {
      return feeData;
    }
    const baseFee = feeData.maxFeePerGas - feeData.maxPriorityFeePerGas;
    return {
      gasPrice: feeData.gasPrice,
      maxFeePerGas: baseFee + maxPriorityFeePerGas,
      maxPriorityFeePerGas
    };
  });
};
var injectCommonNetworks = function() {
  if (injected) {
    return;
  }
  injected = true;
  function registerEth(name, chainId, options) {
    const func = function() {
      const network = new Network(name, chainId);
      if (options.ensNetwork != null) {
        network.attachPlugin(new EnsPlugin(null, options.ensNetwork));
      }
      network.attachPlugin(new GasCostPlugin);
      (options.plugins || []).forEach((plugin) => {
        network.attachPlugin(plugin);
      });
      return network;
    };
    Network.register(name, func);
    Network.register(chainId, func);
    if (options.altNames) {
      options.altNames.forEach((name2) => {
        Network.register(name2, func);
      });
    }
  }
  registerEth("mainnet", 1, { ensNetwork: 1, altNames: ["homestead"] });
  registerEth("ropsten", 3, { ensNetwork: 3 });
  registerEth("rinkeby", 4, { ensNetwork: 4 });
  registerEth("goerli", 5, { ensNetwork: 5 });
  registerEth("kovan", 42, { ensNetwork: 42 });
  registerEth("sepolia", 11155111, { ensNetwork: 11155111 });
  registerEth("classic", 61, {});
  registerEth("classicKotti", 6, {});
  registerEth("arbitrum", 42161, {
    ensNetwork: 1
  });
  registerEth("arbitrum-goerli", 421613, {});
  registerEth("bnb", 56, { ensNetwork: 1 });
  registerEth("bnbt", 97, {});
  registerEth("linea", 59144, { ensNetwork: 1 });
  registerEth("linea-goerli", 59140, {});
  registerEth("matic", 137, {
    ensNetwork: 1,
    plugins: [
      getGasStationPlugin("https://gasstation.polygon.technology/v2")
    ]
  });
  registerEth("matic-mumbai", 80001, {
    altNames: ["maticMumbai", "maticmum"],
    plugins: [
      getGasStationPlugin("https://gasstation-testnet.polygon.technology/v2")
    ]
  });
  registerEth("optimism", 10, {
    ensNetwork: 1,
    plugins: [
      getPriorityFeePlugin(BigInt("1000000"))
    ]
  });
  registerEth("optimism-goerli", 420, {});
  registerEth("xdai", 100, { ensNetwork: 1 });
};
var Networks = new Map;

class Network {
  #name;
  #chainId;
  #plugins;
  constructor(name, chainId) {
    this.#name = name;
    this.#chainId = getBigInt(chainId);
    this.#plugins = new Map;
  }
  toJSON() {
    return { name: this.name, chainId: String(this.chainId) };
  }
  get name() {
    return this.#name;
  }
  set name(value) {
    this.#name = value;
  }
  get chainId() {
    return this.#chainId;
  }
  set chainId(value) {
    this.#chainId = getBigInt(value, "chainId");
  }
  matches(other) {
    if (other == null) {
      return false;
    }
    if (typeof other === "string") {
      try {
        return this.chainId === getBigInt(other);
      } catch (error) {
      }
      return this.name === other;
    }
    if (typeof other === "number" || typeof other === "bigint") {
      try {
        return this.chainId === getBigInt(other);
      } catch (error) {
      }
      return false;
    }
    if (typeof other === "object") {
      if (other.chainId != null) {
        try {
          return this.chainId === getBigInt(other.chainId);
        } catch (error) {
        }
        return false;
      }
      if (other.name != null) {
        return this.name === other.name;
      }
      return false;
    }
    return false;
  }
  get plugins() {
    return Array.from(this.#plugins.values());
  }
  attachPlugin(plugin) {
    if (this.#plugins.get(plugin.name)) {
      throw new Error(`cannot replace existing plugin: ${plugin.name} `);
    }
    this.#plugins.set(plugin.name, plugin.clone());
    return this;
  }
  getPlugin(name) {
    return this.#plugins.get(name) || null;
  }
  getPlugins(basename) {
    return this.plugins.filter((p) => p.name.split("#")[0] === basename);
  }
  clone() {
    const clone = new Network(this.name, this.chainId);
    this.plugins.forEach((plugin) => {
      clone.attachPlugin(plugin.clone());
    });
    return clone;
  }
  computeIntrinsicGas(tx) {
    const costs = this.getPlugin("org.ethers.plugins.network.GasCost") || new GasCostPlugin;
    let gas = costs.txBase;
    if (tx.to == null) {
      gas += costs.txCreate;
    }
    if (tx.data) {
      for (let i = 2;i < tx.data.length; i += 2) {
        if (tx.data.substring(i, i + 2) === "00") {
          gas += costs.txDataZero;
        } else {
          gas += costs.txDataNonzero;
        }
      }
    }
    if (tx.accessList) {
      const accessList = accessListify(tx.accessList);
      for (const addr in accessList) {
        gas += costs.txAccessListAddress + costs.txAccessListStorageKey * accessList[addr].storageKeys.length;
      }
    }
    return gas;
  }
  static from(network) {
    injectCommonNetworks();
    if (network == null) {
      return Network.from("mainnet");
    }
    if (typeof network === "number") {
      network = BigInt(network);
    }
    if (typeof network === "string" || typeof network === "bigint") {
      const networkFunc = Networks.get(network);
      if (networkFunc) {
        return networkFunc();
      }
      if (typeof network === "bigint") {
        return new Network("unknown", network);
      }
      assertArgument(false, "unknown network", "network", network);
    }
    if (typeof network.clone === "function") {
      const clone = network.clone();
      return clone;
    }
    if (typeof network === "object") {
      assertArgument(typeof network.name === "string" && typeof network.chainId === "number", "invalid network object name or chainId", "network", network);
      const custom = new Network(network.name, network.chainId);
      if (network.ensAddress || network.ensNetwork != null) {
        custom.attachPlugin(new EnsPlugin(network.ensAddress, network.ensNetwork));
      }
      return custom;
    }
    assertArgument(false, "invalid network", "network", network);
  }
  static register(nameOrChainId, networkFunc) {
    if (typeof nameOrChainId === "number") {
      nameOrChainId = BigInt(nameOrChainId);
    }
    const existing = Networks.get(nameOrChainId);
    if (existing) {
      assertArgument(false, `conflicting network for ${JSON.stringify(existing.name)}`, "nameOrChainId", nameOrChainId);
    }
    Networks.set(nameOrChainId, networkFunc);
  }
}
var injected = false;
// node_modules/@fuel-ts/versions/dist/index.mjs
var import_semver = __toESM(require_semver2(), 1);
var getBuiltinVersions = function() {
  return {
    FORC: "0.46.1",
    FUEL_CORE: "0.20.8",
    FUELS: "0.67.0"
  };
};
var checkFuelCoreVersionCompatibility = function(networkVersion) {
  const { FUEL_CORE: supportedVersion } = getBuiltinVersions();
  const networkMajor = import_semver.default.major(networkVersion);
  const networkMinor = import_semver.default.minor(networkVersion);
  const networkPatch = import_semver.default.patch(networkVersion);
  const supportedMajor = import_semver.default.major(supportedVersion);
  const supportedMinor = import_semver.default.minor(supportedVersion);
  const supportedPatch = import_semver.default.patch(supportedVersion);
  return {
    supportedVersion,
    isMajorSupported: networkMajor === supportedMajor,
    isMinorSupported: networkMinor === supportedMinor,
    isPatchSupported: networkPatch === supportedPatch
  };
};
var versions = getBuiltinVersions();

// node_modules/@fuel-ts/errors/dist/index.mjs
var __defProp2 = Object.defineProperty;
var __defNormalProp = (obj, key, value) => (key in obj) ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var ErrorCode = ((ErrorCode2) => {
  ErrorCode2["ABI_TYPES_AND_VALUES_MISMATCH"] = "abi-types-and-values-mismatch";
  ErrorCode2["ABI_MAIN_METHOD_MISSING"] = "abi-main-method-missing";
  ErrorCode2["INVALID_COMPONENT"] = "invalid-component";
  ErrorCode2["FRAGMENT_NOT_FOUND"] = "fragment-not-found";
  ErrorCode2["CONFIGURABLE_NOT_FOUND"] = "configurable-not-found";
  ErrorCode2["TYPE_NOT_FOUND"] = "type-not-found";
  ErrorCode2["TYPE_NOT_SUPPORTED"] = "type-not-supported";
  ErrorCode2["INVALID_DECODE_VALUE"] = "invalid-decode-value";
  ErrorCode2["JSON_ABI_ERROR"] = "json-abi-error";
  ErrorCode2["TYPE_ID_NOT_FOUND"] = "type-id-not-found";
  ErrorCode2["BIN_FILE_NOT_FOUND"] = "bin-file-not-found";
  ErrorCode2["CODER_NOT_FOUND"] = "coder-not-found";
  ErrorCode2["INVALID_DATA"] = "invalid-data";
  ErrorCode2["FUNCTION_NOT_FOUND"] = "function-not-found";
  ErrorCode2["INVALID_BECH32_ADDRESS"] = "invalid-bech32-address";
  ErrorCode2["INVALID_EVM_ADDRESS"] = "invalid-evm-address";
  ErrorCode2["INVALID_URL"] = "invalid-url";
  ErrorCode2["CHAIN_INFO_CACHE_EMPTY"] = "chain-info-cache-empty";
  ErrorCode2["NODE_INFO_CACHE_EMPTY"] = "node-info-cache-empty";
  ErrorCode2["MISSING_PROVIDER"] = "missing-provider";
  ErrorCode2["INSUFFICIENT_BALANCE"] = "insufficient-balance";
  ErrorCode2["WALLET_MANAGER_ERROR"] = "wallet-manager-error";
  ErrorCode2["HD_WALLET_ERROR"] = "hd-wallet-error";
  ErrorCode2["PARSE_FAILED"] = "parse-failed";
  ErrorCode2["ENCODE_ERROR"] = "encode-error";
  ErrorCode2["DECODE_ERROR"] = "decode-error";
  ErrorCode2["INVALID_CREDENTIALS"] = "invalid-credentials";
  ErrorCode2["ENV_DEPENDENCY_MISSING"] = "env-dependency-missing";
  ErrorCode2["INVALID_TTL"] = "invalid-ttl";
  ErrorCode2["INVALID_INPUT_PARAMETERS"] = "invalid-input-parameters";
  ErrorCode2["NOT_IMPLEMENTED"] = "not-implemented";
  ErrorCode2["NOT_SUPPORTED"] = "not-supported";
  ErrorCode2["CONVERTING_FAILED"] = "converting-error";
  ErrorCode2["ELEMENT_NOT_FOUND"] = "element-not-found";
  ErrorCode2["MISSING_REQUIRED_PARAMETER"] = "missing-required-parameter";
  ErrorCode2["GAS_PRICE_TOO_LOW"] = "gas-price-too-low";
  ErrorCode2["GAS_LIMIT_TOO_LOW"] = "gas-limit-too-low";
  ErrorCode2["TRANSACTION_NOT_FOUND"] = "transaction-not-found";
  ErrorCode2["TRANSACTION_FAILED"] = "transaction-failed";
  ErrorCode2["INVALID_CONFIGURABLE_CONSTANTS"] = "invalid-configurable-constants";
  ErrorCode2["INVALID_TRANSACTION_INPUT"] = "invalid-transaction-input";
  ErrorCode2["INVALID_TRANSACTION_OUTPUT"] = "invalid-transaction-output";
  ErrorCode2["INVALID_TRANSACTION_STATUS"] = "invalid-transaction-status";
  ErrorCode2["INVALID_TRANSACTION_TYPE"] = "invalid-transaction-type";
  ErrorCode2["TRANSACTION_ERROR"] = "transaction-error";
  ErrorCode2["INVALID_RECEIPT_TYPE"] = "invalid-receipt-type";
  ErrorCode2["INVALID_WORD_LIST"] = "invalid-word-list";
  ErrorCode2["INVALID_MNEMONIC"] = "invalid-mnemonic";
  ErrorCode2["INVALID_ENTROPY"] = "invalid-entropy";
  ErrorCode2["INVALID_SEED"] = "invalid-seed";
  ErrorCode2["INVALID_CHECKSUM"] = "invalid-checksum";
  ErrorCode2["INVALID_PASSWORD"] = "invalid-password";
  ErrorCode2["ACCOUNT_REQUIRED"] = "account-required";
  ErrorCode2["LATEST_BLOCK_UNAVAILABLE"] = "latest-block-unavailable";
  ErrorCode2["ERROR_BUILDING_BLOCK_EXPLORER_URL"] = "error-building-block-explorer-url";
  ErrorCode2["UNSUPPORTED_FUEL_CLIENT_VERSION"] = "unsupported-fuel-client-version";
  ErrorCode2["VITEPRESS_PLUGIN_ERROR"] = "vitepress-plugin-error";
  ErrorCode2["INVALID_MULTICALL"] = "invalid-multicall";
  ErrorCode2["SCRIPT_REVERTED"] = "script-reverted";
  ErrorCode2["SCRIPT_RETURN_INVALID_TYPE"] = "script-return-invalid-type";
  return ErrorCode2;
})(ErrorCode || {});
var _FuelError = class extends Error {
  VERSIONS = versions;
  static parse(e) {
    const error = e;
    if (error.code === undefined) {
      throw new _FuelError("parse-failed", "Failed to parse the error object. The required 'code' property is missing.");
    }
    const enumValues = Object.values(ErrorCode);
    const codeIsKnown = enumValues.includes(error.code);
    if (!codeIsKnown) {
      throw new _FuelError("parse-failed", `Unknown error code: ${error.code}. Accepted codes: ${enumValues.join(", ")}.`);
    }
    return new _FuelError(error.code, error.message);
  }
  code;
  constructor(code, message) {
    super(message);
    this.code = code;
    this.name = "FuelError";
  }
  toObject() {
    const { code, name, message, VERSIONS } = this;
    return { code, name, message, VERSIONS };
  }
};
var FuelError = _FuelError;
__publicField(FuelError, "CODES", ErrorCode);

// node_modules/@fuel-ts/utils/dist/index.mjs
var getBuiltinVersions2 = function() {
  return {
    FORC: "0.46.1",
    FUEL_CORE: "0.20.8",
    FUELS: "0.67.0"
  };
};
var __create2 = Object.create;
var __defProp3 = Object.defineProperty;
var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames2 = Object.getOwnPropertyNames;
var __getProtoOf2 = Object.getPrototypeOf;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __commonJS2 = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames2(from))
      if (!__hasOwnProp2.call(to, key) && key !== except)
        __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp3(target, "default", { value: mod, enumerable: true }) : target, mod));
var require_constants2 = __commonJS2({
  "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/internal/constants.js"(exports, module) {
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    module.exports = {
      SEMVER_SPEC_VERSION,
      MAX_LENGTH,
      MAX_SAFE_INTEGER,
      MAX_SAFE_COMPONENT_LENGTH
    };
  }
});
var require_debug2 = __commonJS2({
  "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/internal/debug.js"(exports, module) {
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module.exports = debug;
  }
});
var require_re2 = __commonJS2({
  "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/internal/re.js"(exports, module) {
    var { MAX_SAFE_COMPONENT_LENGTH } = require_constants2();
    var debug = require_debug2();
    exports = module.exports = {};
    var re = exports.re = [];
    var src = exports.src = [];
    var t = exports.t = {};
    var R = 0;
    var createToken = (name, value, isGlobal) => {
      const index = R++;
      debug(name, index, value);
      t[name] = index;
      src[index] = value;
      re[index] = new RegExp(value, isGlobal ? "g" : undefined);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "[0-9]+");
    createToken("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*");
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", "[0-9A-Za-z-]+");
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}\$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}\$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}\$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}\$`);
    createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}\$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}\$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}\$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}\$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})\$|^\$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})\$|^\$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*\$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*\$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});
var require_parse_options2 = __commonJS2({
  "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/internal/parse-options.js"(exports, module) {
    var opts = ["includePrerelease", "loose", "rtl"];
    var parseOptions = (options) => !options ? {} : typeof options !== "object" ? { loose: true } : opts.filter((k) => options[k]).reduce((o, k) => {
      o[k] = true;
      return o;
    }, {});
    module.exports = parseOptions;
  }
});
var require_identifiers2 = __commonJS2({
  "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/internal/identifiers.js"(exports, module) {
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});
var require_semver3 = __commonJS2({
  "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/classes/semver.js"(exports, module) {
    var debug = require_debug2();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants2();
    var { re, t } = require_re2();
    var parseOptions = require_parse_options2();
    var { compareIdentifiers } = require_identifiers2();
    var SemVer = class {
      constructor(version2, options) {
        options = parseOptions(options);
        if (version2 instanceof SemVer) {
          if (version2.loose === !!options.loose && version2.includePrerelease === !!options.includePrerelease) {
            return version2;
          } else {
            version2 = version2.version;
          }
        } else if (typeof version2 !== "string") {
          throw new TypeError(`Invalid Version: ${version2}`);
        }
        if (version2.length > MAX_LENGTH) {
          throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
        }
        debug("SemVer", version2, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m = version2.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version2}`);
        }
        this.raw = version2;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug("prerelease compare", i, a, b);
          if (a === undefined && b === undefined) {
            return 0;
          } else if (b === undefined) {
            return 1;
          } else if (a === undefined) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug("prerelease compare", i, a, b);
          if (a === undefined && b === undefined) {
            return 0;
          } else if (b === undefined) {
            return 1;
          } else if (a === undefined) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      inc(release, identifier) {
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier);
            this.inc("pre", identifier);
            break;
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier);
            }
            this.inc("pre", identifier);
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          case "pre":
            if (this.prerelease.length === 0) {
              this.prerelease = [0];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                this.prerelease.push(0);
              }
            }
            if (identifier) {
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = [identifier, 0];
                }
              } else {
                this.prerelease = [identifier, 0];
              }
            }
            break;
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.format();
        this.raw = this.version;
        return this;
      }
    };
    module.exports = SemVer;
  }
});
var require_parse2 = __commonJS2({
  "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/parse.js"(exports, module) {
    var { MAX_LENGTH } = require_constants2();
    var { re, t } = require_re2();
    var SemVer = require_semver3();
    var parseOptions = require_parse_options2();
    var parse = (version2, options) => {
      options = parseOptions(options);
      if (version2 instanceof SemVer) {
        return version2;
      }
      if (typeof version2 !== "string") {
        return null;
      }
      if (version2.length > MAX_LENGTH) {
        return null;
      }
      const r = options.loose ? re[t.LOOSE] : re[t.FULL];
      if (!r.test(version2)) {
        return null;
      }
      try {
        return new SemVer(version2, options);
      } catch (er) {
        return null;
      }
    };
    module.exports = parse;
  }
});
var require_valid3 = __commonJS2({
  "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/valid.js"(exports, module) {
    var parse = require_parse2();
    var valid = (version2, options) => {
      const v = parse(version2, options);
      return v ? v.version : null;
    };
    module.exports = valid;
  }
});
var require_clean2 = __commonJS2({
  "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/clean.js"(exports, module) {
    var parse = require_parse2();
    var clean = (version2, options) => {
      const s = parse(version2.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    };
    module.exports = clean;
  }
});
var require_inc2 = __commonJS2({
  "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/inc.js"(exports, module) {
    var SemVer = require_semver3();
    var inc = (version2, release, options, identifier) => {
      if (typeof options === "string") {
        identifier = options;
        options = undefined;
      }
      try {
        return new SemVer(version2 instanceof SemVer ? version2.version : version2, options).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    };
    module.exports = inc;
  }
});
var require_compare2 = __commonJS2({
  "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/compare.js"(exports, module) {
    var SemVer = require_semver3();
    var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module.exports = compare;
  }
});
var require_eq2 = __commonJS2({
  "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/eq.js"(exports, module) {
    var compare = require_compare2();
    var eq = (a, b, loose) => compare(a, b, loose) === 0;
    module.exports = eq;
  }
});
var require_diff2 = __commonJS2({
  "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/diff.js"(exports, module) {
    var parse = require_parse2();
    var eq = require_eq2();
    var diff = (version1, version2) => {
      if (eq(version1, version2)) {
        return null;
      } else {
        const v1 = parse(version1);
        const v2 = parse(version2);
        const hasPre = v1.prerelease.length || v2.prerelease.length;
        const prefix = hasPre ? "pre" : "";
        const defaultResult = hasPre ? "prerelease" : "";
        for (const key in v1) {
          if (key === "major" || key === "minor" || key === "patch") {
            if (v1[key] !== v2[key]) {
              return prefix + key;
            }
          }
        }
        return defaultResult;
      }
    };
    module.exports = diff;
  }
});
var require_major2 = __commonJS2({
  "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/major.js"(exports, module) {
    var SemVer = require_semver3();
    var major = (a, loose) => new SemVer(a, loose).major;
    module.exports = major;
  }
});
var require_minor2 = __commonJS2({
  "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/minor.js"(exports, module) {
    var SemVer = require_semver3();
    var minor = (a, loose) => new SemVer(a, loose).minor;
    module.exports = minor;
  }
});
var require_patch2 = __commonJS2({
  "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/patch.js"(exports, module) {
    var SemVer = require_semver3();
    var patch = (a, loose) => new SemVer(a, loose).patch;
    module.exports = patch;
  }
});
var require_prerelease2 = __commonJS2({
  "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/prerelease.js"(exports, module) {
    var parse = require_parse2();
    var prerelease = (version2, options) => {
      const parsed = parse(version2, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module.exports = prerelease;
  }
});
var require_rcompare2 = __commonJS2({
  "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/rcompare.js"(exports, module) {
    var compare = require_compare2();
    var rcompare = (a, b, loose) => compare(b, a, loose);
    module.exports = rcompare;
  }
});
var require_compare_loose2 = __commonJS2({
  "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/compare-loose.js"(exports, module) {
    var compare = require_compare2();
    var compareLoose = (a, b) => compare(a, b, true);
    module.exports = compareLoose;
  }
});
var require_compare_build2 = __commonJS2({
  "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/compare-build.js"(exports, module) {
    var SemVer = require_semver3();
    var compareBuild = (a, b, loose) => {
      const versionA = new SemVer(a, loose);
      const versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module.exports = compareBuild;
  }
});
var require_sort2 = __commonJS2({
  "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/sort.js"(exports, module) {
    var compareBuild = require_compare_build2();
    var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
    module.exports = sort;
  }
});
var require_rsort2 = __commonJS2({
  "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/rsort.js"(exports, module) {
    var compareBuild = require_compare_build2();
    var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
    module.exports = rsort;
  }
});
var require_gt2 = __commonJS2({
  "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/gt.js"(exports, module) {
    var compare = require_compare2();
    var gt = (a, b, loose) => compare(a, b, loose) > 0;
    module.exports = gt;
  }
});
var require_lt2 = __commonJS2({
  "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/lt.js"(exports, module) {
    var compare = require_compare2();
    var lt = (a, b, loose) => compare(a, b, loose) < 0;
    module.exports = lt;
  }
});
var require_neq2 = __commonJS2({
  "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/neq.js"(exports, module) {
    var compare = require_compare2();
    var neq = (a, b, loose) => compare(a, b, loose) !== 0;
    module.exports = neq;
  }
});
var require_gte2 = __commonJS2({
  "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/gte.js"(exports, module) {
    var compare = require_compare2();
    var gte = (a, b, loose) => compare(a, b, loose) >= 0;
    module.exports = gte;
  }
});
var require_lte2 = __commonJS2({
  "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/lte.js"(exports, module) {
    var compare = require_compare2();
    var lte = (a, b, loose) => compare(a, b, loose) <= 0;
    module.exports = lte;
  }
});
var require_cmp2 = __commonJS2({
  "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/cmp.js"(exports, module) {
    var eq = require_eq2();
    var neq = require_neq2();
    var gt = require_gt2();
    var gte = require_gte2();
    var lt = require_lt2();
    var lte = require_lte2();
    var cmp = (a, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a === b;
        case "!==":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module.exports = cmp;
  }
});
var require_coerce2 = __commonJS2({
  "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/coerce.js"(exports, module) {
    var SemVer = require_semver3();
    var parse = require_parse2();
    var { re, t } = require_re2();
    var coerce = (version2, options) => {
      if (version2 instanceof SemVer) {
        return version2;
      }
      if (typeof version2 === "number") {
        version2 = String(version2);
      }
      if (typeof version2 !== "string") {
        return null;
      }
      options = options || {};
      let match = null;
      if (!options.rtl) {
        match = version2.match(re[t.COERCE]);
      } else {
        let next;
        while ((next = re[t.COERCERTL].exec(version2)) && (!match || match.index + match[0].length !== version2.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
        }
        re[t.COERCERTL].lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      return parse(`${match[2]}.${match[3] || "0"}.${match[4] || "0"}`, options);
    };
    module.exports = coerce;
  }
});
var require_iterator2 = __commonJS2({
  "../../node_modules/.pnpm/yallist@4.0.0/node_modules/yallist/iterator.js"(exports, module) {
    module.exports = function(Yallist) {
      Yallist.prototype[Symbol.iterator] = function* () {
        for (let walker = this.head;walker; walker = walker.next) {
          yield walker.value;
        }
      };
    };
  }
});
var require_yallist2 = __commonJS2({
  "../../node_modules/.pnpm/yallist@4.0.0/node_modules/yallist/yallist.js"(exports, module) {
    module.exports = Yallist;
    Yallist.Node = Node;
    Yallist.create = Yallist;
    function Yallist(list) {
      var self2 = this;
      if (!(self2 instanceof Yallist)) {
        self2 = new Yallist;
      }
      self2.tail = null;
      self2.head = null;
      self2.length = 0;
      if (list && typeof list.forEach === "function") {
        list.forEach(function(item) {
          self2.push(item);
        });
      } else if (arguments.length > 0) {
        for (var i = 0, l = arguments.length;i < l; i++) {
          self2.push(arguments[i]);
        }
      }
      return self2;
    }
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      var next = node.next;
      var prev = node.prev;
      if (next) {
        next.prev = prev;
      }
      if (prev) {
        prev.next = next;
      }
      if (node === this.head) {
        this.head = next;
      }
      if (node === this.tail) {
        this.tail = prev;
      }
      node.list.length--;
      node.next = null;
      node.prev = null;
      node.list = null;
      return next;
    };
    Yallist.prototype.unshiftNode = function(node) {
      if (node === this.head) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var head = this.head;
      node.list = this;
      node.next = head;
      if (head) {
        head.prev = node;
      }
      this.head = node;
      if (!this.tail) {
        this.tail = node;
      }
      this.length++;
    };
    Yallist.prototype.pushNode = function(node) {
      if (node === this.tail) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var tail = this.tail;
      node.list = this;
      node.prev = tail;
      if (tail) {
        tail.next = node;
      }
      this.tail = node;
      if (!this.head) {
        this.head = node;
      }
      this.length++;
    };
    Yallist.prototype.push = function() {
      for (var i = 0, l = arguments.length;i < l; i++) {
        push(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i = 0, l = arguments.length;i < l; i++) {
        unshift(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (!this.tail) {
        return;
      }
      var res = this.tail.value;
      this.tail = this.tail.prev;
      if (this.tail) {
        this.tail.next = null;
      } else {
        this.head = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.shift = function() {
      if (!this.head) {
        return;
      }
      var res = this.head.value;
      this.head = this.head.next;
      if (this.head) {
        this.head.prev = null;
      } else {
        this.tail = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i = 0;walker !== null; i++) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.next;
      }
    };
    Yallist.prototype.forEachReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i = this.length - 1;walker !== null; i--) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.prev;
      }
    };
    Yallist.prototype.get = function(n) {
      for (var i = 0, walker = this.head;walker !== null && i < n; i++) {
        walker = walker.next;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.getReverse = function(n) {
      for (var i = 0, walker = this.tail;walker !== null && i < n; i++) {
        walker = walker.prev;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.map = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist;
      for (var walker = this.head;walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
      }
      return res;
    };
    Yallist.prototype.mapReverse = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist;
      for (var walker = this.tail;walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
      }
      return res;
    };
    Yallist.prototype.reduce = function(fn, initial) {
      var acc;
      var walker = this.head;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = 0;walker !== null; i++) {
        acc = fn(acc, walker.value, i);
        walker = walker.next;
      }
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn, initial) {
      var acc;
      var walker = this.tail;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = this.length - 1;walker !== null; i--) {
        acc = fn(acc, walker.value, i);
        walker = walker.prev;
      }
      return acc;
    };
    Yallist.prototype.toArray = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.head;walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.next;
      }
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.tail;walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.prev;
      }
      return arr;
    };
    Yallist.prototype.slice = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist;
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = 0, walker = this.head;walker !== null && i < from; i++) {
        walker = walker.next;
      }
      for (;walker !== null && i < to; i++, walker = walker.next) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.sliceReverse = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist;
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = this.length, walker = this.tail;walker !== null && i > to; i--) {
        walker = walker.prev;
      }
      for (;walker !== null && i > from; i--, walker = walker.prev) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
      if (start > this.length) {
        start = this.length - 1;
      }
      if (start < 0) {
        start = this.length + start;
      }
      for (var i = 0, walker = this.head;walker !== null && i < start; i++) {
        walker = walker.next;
      }
      var ret = [];
      for (var i = 0;walker && i < deleteCount; i++) {
        ret.push(walker.value);
        walker = this.removeNode(walker);
      }
      if (walker === null) {
        walker = this.tail;
      }
      if (walker !== this.head && walker !== this.tail) {
        walker = walker.prev;
      }
      for (var i = 0;i < nodes.length; i++) {
        walker = insert(this, walker, nodes[i]);
      }
      return ret;
    };
    Yallist.prototype.reverse = function() {
      var head = this.head;
      var tail = this.tail;
      for (var walker = head;walker !== null; walker = walker.prev) {
        var p = walker.prev;
        walker.prev = walker.next;
        walker.next = p;
      }
      this.head = tail;
      this.tail = head;
      return this;
    };
    function insert(self2, node, value) {
      var inserted = node === self2.head ? new Node(value, null, node, self2) : new Node(value, node, node.next, self2);
      if (inserted.next === null) {
        self2.tail = inserted;
      }
      if (inserted.prev === null) {
        self2.head = inserted;
      }
      self2.length++;
      return inserted;
    }
    function push(self2, item) {
      self2.tail = new Node(item, self2.tail, null, self2);
      if (!self2.head) {
        self2.head = self2.tail;
      }
      self2.length++;
    }
    function unshift(self2, item) {
      self2.head = new Node(item, null, self2.head, self2);
      if (!self2.tail) {
        self2.tail = self2.head;
      }
      self2.length++;
    }
    function Node(value, prev, next, list) {
      if (!(this instanceof Node)) {
        return new Node(value, prev, next, list);
      }
      this.list = list;
      this.value = value;
      if (prev) {
        prev.next = this;
        this.prev = prev;
      } else {
        this.prev = null;
      }
      if (next) {
        next.prev = this;
        this.next = next;
      } else {
        this.next = null;
      }
    }
    try {
      require_iterator2()(Yallist);
    } catch (er) {
    }
  }
});
var require_lru_cache2 = __commonJS2({
  "../../node_modules/.pnpm/lru-cache@6.0.0/node_modules/lru-cache/index.js"(exports, module) {
    var Yallist = require_yallist2();
    var MAX = Symbol("max");
    var LENGTH = Symbol("length");
    var LENGTH_CALCULATOR = Symbol("lengthCalculator");
    var ALLOW_STALE = Symbol("allowStale");
    var MAX_AGE = Symbol("maxAge");
    var DISPOSE = Symbol("dispose");
    var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
    var LRU_LIST = Symbol("lruList");
    var CACHE = Symbol("cache");
    var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
    var naiveLength = () => 1;
    var LRUCache = class {
      constructor(options) {
        if (typeof options === "number")
          options = { max: options };
        if (!options)
          options = {};
        if (options.max && (typeof options.max !== "number" || options.max < 0))
          throw new TypeError("max must be a non-negative number");
        const max = this[MAX] = options.max || Infinity;
        const lc = options.length || naiveLength;
        this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
        this[ALLOW_STALE] = options.stale || false;
        if (options.maxAge && typeof options.maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        this[MAX_AGE] = options.maxAge || 0;
        this[DISPOSE] = options.dispose;
        this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
        this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
        this.reset();
      }
      set max(mL) {
        if (typeof mL !== "number" || mL < 0)
          throw new TypeError("max must be a non-negative number");
        this[MAX] = mL || Infinity;
        trim(this);
      }
      get max() {
        return this[MAX];
      }
      set allowStale(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
      }
      get allowStale() {
        return this[ALLOW_STALE];
      }
      set maxAge(mA) {
        if (typeof mA !== "number")
          throw new TypeError("maxAge must be a non-negative number");
        this[MAX_AGE] = mA;
        trim(this);
      }
      get maxAge() {
        return this[MAX_AGE];
      }
      set lengthCalculator(lC) {
        if (typeof lC !== "function")
          lC = naiveLength;
        if (lC !== this[LENGTH_CALCULATOR]) {
          this[LENGTH_CALCULATOR] = lC;
          this[LENGTH] = 0;
          this[LRU_LIST].forEach((hit) => {
            hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
            this[LENGTH] += hit.length;
          });
        }
        trim(this);
      }
      get lengthCalculator() {
        return this[LENGTH_CALCULATOR];
      }
      get length() {
        return this[LENGTH];
      }
      get itemCount() {
        return this[LRU_LIST].length;
      }
      rforEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].tail;walker !== null; ) {
          const prev = walker.prev;
          forEachStep(this, fn, walker, thisp);
          walker = prev;
        }
      }
      forEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].head;walker !== null; ) {
          const next = walker.next;
          forEachStep(this, fn, walker, thisp);
          walker = next;
        }
      }
      keys() {
        return this[LRU_LIST].toArray().map((k) => k.key);
      }
      values() {
        return this[LRU_LIST].toArray().map((k) => k.value);
      }
      reset() {
        if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
          this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
        }
        this[CACHE] = new Map;
        this[LRU_LIST] = new Yallist;
        this[LENGTH] = 0;
      }
      dump() {
        return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
          k: hit.key,
          v: hit.value,
          e: hit.now + (hit.maxAge || 0)
        }).toArray().filter((h) => h);
      }
      dumpLru() {
        return this[LRU_LIST];
      }
      set(key, value, maxAge) {
        maxAge = maxAge || this[MAX_AGE];
        if (maxAge && typeof maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        const now = maxAge ? Date.now() : 0;
        const len = this[LENGTH_CALCULATOR](value, key);
        if (this[CACHE].has(key)) {
          if (len > this[MAX]) {
            del(this, this[CACHE].get(key));
            return false;
          }
          const node = this[CACHE].get(key);
          const item = node.value;
          if (this[DISPOSE]) {
            if (!this[NO_DISPOSE_ON_SET])
              this[DISPOSE](key, item.value);
          }
          item.now = now;
          item.maxAge = maxAge;
          item.value = value;
          this[LENGTH] += len - item.length;
          item.length = len;
          this.get(key);
          trim(this);
          return true;
        }
        const hit = new Entry(key, value, len, now, maxAge);
        if (hit.length > this[MAX]) {
          if (this[DISPOSE])
            this[DISPOSE](key, value);
          return false;
        }
        this[LENGTH] += hit.length;
        this[LRU_LIST].unshift(hit);
        this[CACHE].set(key, this[LRU_LIST].head);
        trim(this);
        return true;
      }
      has(key) {
        if (!this[CACHE].has(key))
          return false;
        const hit = this[CACHE].get(key).value;
        return !isStale(this, hit);
      }
      get(key) {
        return get(this, key, true);
      }
      peek(key) {
        return get(this, key, false);
      }
      pop() {
        const node = this[LRU_LIST].tail;
        if (!node)
          return null;
        del(this, node);
        return node.value;
      }
      del(key) {
        del(this, this[CACHE].get(key));
      }
      load(arr) {
        this.reset();
        const now = Date.now();
        for (let l = arr.length - 1;l >= 0; l--) {
          const hit = arr[l];
          const expiresAt = hit.e || 0;
          if (expiresAt === 0)
            this.set(hit.k, hit.v);
          else {
            const maxAge = expiresAt - now;
            if (maxAge > 0) {
              this.set(hit.k, hit.v, maxAge);
            }
          }
        }
      }
      prune() {
        this[CACHE].forEach((value, key) => get(this, key, false));
      }
    };
    var get = (self2, key, doUse) => {
      const node = self2[CACHE].get(key);
      if (node) {
        const hit = node.value;
        if (isStale(self2, hit)) {
          del(self2, node);
          if (!self2[ALLOW_STALE])
            return;
        } else {
          if (doUse) {
            if (self2[UPDATE_AGE_ON_GET])
              node.value.now = Date.now();
            self2[LRU_LIST].unshiftNode(node);
          }
        }
        return hit.value;
      }
    };
    var isStale = (self2, hit) => {
      if (!hit || !hit.maxAge && !self2[MAX_AGE])
        return false;
      const diff = Date.now() - hit.now;
      return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
    };
    var trim = (self2) => {
      if (self2[LENGTH] > self2[MAX]) {
        for (let walker = self2[LRU_LIST].tail;self2[LENGTH] > self2[MAX] && walker !== null; ) {
          const prev = walker.prev;
          del(self2, walker);
          walker = prev;
        }
      }
    };
    var del = (self2, node) => {
      if (node) {
        const hit = node.value;
        if (self2[DISPOSE])
          self2[DISPOSE](hit.key, hit.value);
        self2[LENGTH] -= hit.length;
        self2[CACHE].delete(hit.key);
        self2[LRU_LIST].removeNode(node);
      }
    };
    var Entry = class {
      constructor(key, value, length, now, maxAge) {
        this.key = key;
        this.value = value;
        this.length = length;
        this.now = now;
        this.maxAge = maxAge || 0;
      }
    };
    var forEachStep = (self2, fn, node, thisp) => {
      let hit = node.value;
      if (isStale(self2, hit)) {
        del(self2, node);
        if (!self2[ALLOW_STALE])
          hit = undefined;
      }
      if (hit)
        fn.call(thisp, hit.value, hit.key, self2);
    };
    module.exports = LRUCache;
  }
});
var require_range2 = __commonJS2({
  "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/classes/range.js"(exports, module) {
    var Range = class {
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof Range) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new Range(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.format();
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range;
        this.set = range.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${range}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.format();
      }
      format() {
        this.range = this.set.map((comps) => {
          return comps.join(" ").trim();
        }).join("||").trim();
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        range = range.trim();
        const memoOpts = Object.keys(this.options).join(",");
        const memoKey = `parseRange:${memoOpts}:${range}`;
        const cached = cache.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range);
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range);
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        range = range.split(/\s+/).join(" ");
        let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug("loose invalid filter", comp, this.options);
            return !!comp.match(re[t.COMPARATORLOOSE]);
          });
        }
        debug("range list", rangeList);
        const rangeMap = new Map;
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      test(version2) {
        if (!version2) {
          return false;
        }
        if (typeof version2 === "string") {
          try {
            version2 = new SemVer(version2, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0;i < this.set.length; i++) {
          if (testSet(this.set[i], version2, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module.exports = Range;
    var LRU = require_lru_cache2();
    var cache = new LRU({ max: 1000 });
    var parseOptions = require_parse_options2();
    var Comparator = require_comparator2();
    var debug = require_debug2();
    var SemVer = require_semver3();
    var {
      re,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re2();
    var isNullSet = (c) => c.value === "<0.0.0-0";
    var isAny = (c) => c.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => comp.trim().split(/\s+/).map((c) => {
      return replaceTilde(c, options);
    }).join(" ");
    var replaceTilde = (comp, options) => {
      const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => comp.trim().split(/\s+/).map((c) => {
      return replaceCaret(c, options);
    }).join(" ");
    var replaceCaret = (comp, options) => {
      debug("caret", comp, options);
      const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z = options.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c) => {
        return replaceXRange(c, options);
      }).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[t.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set, version2, options) => {
      for (let i = 0;i < set.length; i++) {
        if (!set[i].test(version2)) {
          return false;
        }
      }
      if (version2.prerelease.length && !options.includePrerelease) {
        for (let i = 0;i < set.length; i++) {
          debug(set[i].semver);
          if (set[i].semver === Comparator.ANY) {
            continue;
          }
          if (set[i].semver.prerelease.length > 0) {
            const allowed = set[i].semver;
            if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});
var require_comparator2 = __commonJS2({
  "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/classes/comparator.js"(exports, module) {
    var ANY = Symbol("SemVer ANY");
    var Comparator = class {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== undefined ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version2) {
        debug("Comparator.test", version2, this.options.loose);
        if (this.semver === ANY || version2 === ANY) {
          return true;
        }
        if (typeof version2 === "string") {
          try {
            version2 = new SemVer(version2, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version2, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (!options || typeof options !== "object") {
          options = {
            loose: !!options,
            includePrerelease: false
          };
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        const sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
        const sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
        const sameSemVer = this.semver.version === comp.semver.version;
        const differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
        const oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && (this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<");
        const oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && (this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">");
        return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
      }
    };
    module.exports = Comparator;
    var parseOptions = require_parse_options2();
    var { re, t } = require_re2();
    var cmp = require_cmp2();
    var debug = require_debug2();
    var SemVer = require_semver3();
    var Range = require_range2();
  }
});
var require_satisfies2 = __commonJS2({
  "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/satisfies.js"(exports, module) {
    var Range = require_range2();
    var satisfies = (version2, range, options) => {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version2);
    };
    module.exports = satisfies;
  }
});
var require_to_comparators2 = __commonJS2({
  "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/ranges/to-comparators.js"(exports, module) {
    var Range = require_range2();
    var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
    module.exports = toComparators;
  }
});
var require_max_satisfying2 = __commonJS2({
  "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/ranges/max-satisfying.js"(exports, module) {
    var SemVer = require_semver3();
    var Range = require_range2();
    var maxSatisfying = (versions22, range, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions22.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    };
    module.exports = maxSatisfying;
  }
});
var require_min_satisfying2 = __commonJS2({
  "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/ranges/min-satisfying.js"(exports, module) {
    var SemVer = require_semver3();
    var Range = require_range2();
    var minSatisfying = (versions22, range, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions22.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    };
    module.exports = minSatisfying;
  }
});
var require_min_version2 = __commonJS2({
  "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/ranges/min-version.js"(exports, module) {
    var SemVer = require_semver3();
    var Range = require_range2();
    var gt = require_gt2();
    var minVersion = (range, loose) => {
      range = new Range(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i = 0;i < range.set.length; ++i) {
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    };
    module.exports = minVersion;
  }
});
var require_valid22 = __commonJS2({
  "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/ranges/valid.js"(exports, module) {
    var Range = require_range2();
    var validRange = (range, options) => {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    };
    module.exports = validRange;
  }
});
var require_outside2 = __commonJS2({
  "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/ranges/outside.js"(exports, module) {
    var SemVer = require_semver3();
    var Comparator = require_comparator2();
    var { ANY } = Comparator;
    var Range = require_range2();
    var satisfies = require_satisfies2();
    var gt = require_gt2();
    var lt = require_lt2();
    var lte = require_lte2();
    var gte = require_gte2();
    var outside = (version2, range, hilo, options) => {
      version2 = new SemVer(version2, options);
      range = new Range(range, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version2, range, options)) {
        return false;
      }
      for (let i = 0;i < range.set.length; ++i) {
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module.exports = outside;
  }
});
var require_gtr2 = __commonJS2({
  "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/ranges/gtr.js"(exports, module) {
    var outside = require_outside2();
    var gtr = (version2, range, options) => outside(version2, range, ">", options);
    module.exports = gtr;
  }
});
var require_ltr2 = __commonJS2({
  "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/ranges/ltr.js"(exports, module) {
    var outside = require_outside2();
    var ltr = (version2, range, options) => outside(version2, range, "<", options);
    module.exports = ltr;
  }
});
var require_intersects2 = __commonJS2({
  "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/ranges/intersects.js"(exports, module) {
    var Range = require_range2();
    var intersects = (r1, r2, options) => {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2);
    };
    module.exports = intersects;
  }
});
var require_simplify2 = __commonJS2({
  "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/ranges/simplify.js"(exports, module) {
    var satisfies = require_satisfies2();
    var compare = require_compare2();
    module.exports = (versions22, range, options) => {
      const set = [];
      let first = null;
      let prev = null;
      const v = versions22.sort((a, b) => compare(a, b, options));
      for (const version2 of v) {
        const included = satisfies(version2, range, options);
        if (included) {
          prev = version2;
          if (!first) {
            first = version2;
          }
        } else {
          if (prev) {
            set.push([first, prev]);
          }
          prev = null;
          first = null;
        }
      }
      if (first) {
        set.push([first, null]);
      }
      const ranges = [];
      for (const [min, max] of set) {
        if (min === max) {
          ranges.push(min);
        } else if (!max && min === v[0]) {
          ranges.push("*");
        } else if (!max) {
          ranges.push(`>=${min}`);
        } else if (min === v[0]) {
          ranges.push(`<=${max}`);
        } else {
          ranges.push(`${min} - ${max}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  }
});
var require_subset2 = __commonJS2({
  "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/ranges/subset.js"(exports, module) {
    var Range = require_range2();
    var Comparator = require_comparator2();
    var { ANY } = Comparator;
    var satisfies = require_satisfies2();
    var compare = require_compare2();
    var subset = (sub, dom, options = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range(sub, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER:
        for (const simpleSub of sub.set) {
          for (const simpleDom of dom.set) {
            const isSub = simpleSubset(simpleSub, simpleDom, options);
            sawNonNull = sawNonNull || isSub !== null;
            if (isSub) {
              continue OUTER;
            }
          }
          if (sawNonNull) {
            return false;
          }
        }
      return true;
    };
    var simpleSubset = (sub, dom, options) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options.includePrerelease) {
          sub = [new Comparator(">=0.0.0-0")];
        } else {
          sub = [new Comparator(">=0.0.0")];
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
          return true;
        } else {
          dom = [new Comparator(">=0.0.0")];
        }
      }
      const eqSet = new Set;
      let gt, lt;
      for (const c of sub) {
        if (c.operator === ">" || c.operator === ">=") {
          gt = higherGT(gt, c, options);
        } else if (c.operator === "<" || c.operator === "<=") {
          lt = lowerLT(lt, c, options);
        } else {
          eqSet.add(c.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
          return null;
        }
      }
      for (const eq of eqSet) {
        if (gt && !satisfies(eq, String(gt), options)) {
          return null;
        }
        if (lt && !satisfies(eq, String(lt), options)) {
          return null;
        }
        for (const c of dom) {
          if (!satisfies(eq, String(c), options)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c.operator === ">" || c.operator === ">=") {
            higher = higherGT(gt, c, options);
            if (higher === c && higher !== gt) {
              return false;
            }
          } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options)) {
            return false;
          }
        }
        if (lt) {
          if (needDomLTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c.operator === "<" || c.operator === "<=") {
            lower = lowerLT(lt, c, options);
            if (lower === c && lower !== lt) {
              return false;
            }
          } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options)) {
            return false;
          }
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false;
      }
      if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    };
    var higherGT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
    };
    var lowerLT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
    };
    module.exports = subset;
  }
});
var require_semver22 = __commonJS2({
  "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/index.js"(exports, module) {
    var internalRe = require_re2();
    var constants = require_constants2();
    var SemVer = require_semver3();
    var identifiers = require_identifiers2();
    var parse = require_parse2();
    var valid = require_valid3();
    var clean = require_clean2();
    var inc = require_inc2();
    var diff = require_diff2();
    var major = require_major2();
    var minor = require_minor2();
    var patch = require_patch2();
    var prerelease = require_prerelease2();
    var compare = require_compare2();
    var rcompare = require_rcompare2();
    var compareLoose = require_compare_loose2();
    var compareBuild = require_compare_build2();
    var sort = require_sort2();
    var rsort = require_rsort2();
    var gt = require_gt2();
    var lt = require_lt2();
    var eq = require_eq2();
    var neq = require_neq2();
    var gte = require_gte2();
    var lte = require_lte2();
    var cmp = require_cmp2();
    var coerce = require_coerce2();
    var Comparator = require_comparator2();
    var Range = require_range2();
    var satisfies = require_satisfies2();
    var toComparators = require_to_comparators2();
    var maxSatisfying = require_max_satisfying2();
    var minSatisfying = require_min_satisfying2();
    var minVersion = require_min_version2();
    var validRange = require_valid22();
    var outside = require_outside2();
    var gtr = require_gtr2();
    var ltr = require_ltr2();
    var intersects = require_intersects2();
    var simplifyRange = require_simplify2();
    var subset = require_subset2();
    module.exports = {
      parse,
      valid,
      clean,
      inc,
      diff,
      major,
      minor,
      patch,
      prerelease,
      compare,
      rcompare,
      compareLoose,
      compareBuild,
      sort,
      rsort,
      gt,
      lt,
      eq,
      neq,
      gte,
      lte,
      cmp,
      coerce,
      Comparator,
      Range,
      satisfies,
      toComparators,
      maxSatisfying,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers
    };
  }
});
var chunkAndPadBytes = (bytes2, chunkSize) => {
  const chunks = [];
  for (let offset = 0;offset < bytes2.length; offset += chunkSize) {
    const chunk = new Uint8Array(chunkSize);
    chunk.set(bytes2.slice(offset, offset + chunkSize));
    chunks.push(chunk);
  }
  const lastChunk = chunks[chunks.length - 1];
  const remainingBytes = bytes2.length % chunkSize;
  const paddedChunkLength = remainingBytes + (8 - remainingBytes % 8) % 8;
  const newChunk = lastChunk.slice(0, paddedChunkLength);
  chunks[chunks.length - 1] = newChunk;
  return chunks;
};
var concatBytes = (arrays) => {
  const byteArrays = arrays.map((array) => {
    if (array instanceof Uint8Array)
      return array;
    return Uint8Array.from(array);
  });
  const totalSize = byteArrays.reduce((accum, item) => accum + item.length, 0);
  const concatenated = new Uint8Array(totalSize);
  byteArrays.reduce((offset, object) => {
    concatenated.set(object, offset);
    return offset + object.length;
  }, 0);
  return concatenated;
};
var concat2 = (arrays) => {
  const bytes2 = arrays.map((v) => getBytesCopy(v));
  return concatBytes(bytes2);
};
var import_semver2 = __toESM2(require_semver22(), 1);
var versions3 = getBuiltinVersions2();
var __defProp22 = Object.defineProperty;
var __defNormalProp2 = (obj, key, value) => (key in obj) ? __defProp22(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField2 = (obj, key, value) => {
  __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var ErrorCode2 = ((ErrorCode22) => {
  ErrorCode22["ABI_TYPES_AND_VALUES_MISMATCH"] = "abi-types-and-values-mismatch";
  ErrorCode22["ABI_MAIN_METHOD_MISSING"] = "abi-main-method-missing";
  ErrorCode22["INVALID_COMPONENT"] = "invalid-component";
  ErrorCode22["FRAGMENT_NOT_FOUND"] = "fragment-not-found";
  ErrorCode22["CONFIGURABLE_NOT_FOUND"] = "configurable-not-found";
  ErrorCode22["TYPE_NOT_FOUND"] = "type-not-found";
  ErrorCode22["TYPE_NOT_SUPPORTED"] = "type-not-supported";
  ErrorCode22["INVALID_DECODE_VALUE"] = "invalid-decode-value";
  ErrorCode22["JSON_ABI_ERROR"] = "json-abi-error";
  ErrorCode22["TYPE_ID_NOT_FOUND"] = "type-id-not-found";
  ErrorCode22["BIN_FILE_NOT_FOUND"] = "bin-file-not-found";
  ErrorCode22["CODER_NOT_FOUND"] = "coder-not-found";
  ErrorCode22["INVALID_DATA"] = "invalid-data";
  ErrorCode22["FUNCTION_NOT_FOUND"] = "function-not-found";
  ErrorCode22["INVALID_BECH32_ADDRESS"] = "invalid-bech32-address";
  ErrorCode22["INVALID_EVM_ADDRESS"] = "invalid-evm-address";
  ErrorCode22["INVALID_URL"] = "invalid-url";
  ErrorCode22["CHAIN_INFO_CACHE_EMPTY"] = "chain-info-cache-empty";
  ErrorCode22["NODE_INFO_CACHE_EMPTY"] = "node-info-cache-empty";
  ErrorCode22["MISSING_PROVIDER"] = "missing-provider";
  ErrorCode22["INSUFFICIENT_BALANCE"] = "insufficient-balance";
  ErrorCode22["WALLET_MANAGER_ERROR"] = "wallet-manager-error";
  ErrorCode22["HD_WALLET_ERROR"] = "hd-wallet-error";
  ErrorCode22["PARSE_FAILED"] = "parse-failed";
  ErrorCode22["ENCODE_ERROR"] = "encode-error";
  ErrorCode22["DECODE_ERROR"] = "decode-error";
  ErrorCode22["INVALID_CREDENTIALS"] = "invalid-credentials";
  ErrorCode22["ENV_DEPENDENCY_MISSING"] = "env-dependency-missing";
  ErrorCode22["INVALID_TTL"] = "invalid-ttl";
  ErrorCode22["INVALID_INPUT_PARAMETERS"] = "invalid-input-parameters";
  ErrorCode22["NOT_IMPLEMENTED"] = "not-implemented";
  ErrorCode22["NOT_SUPPORTED"] = "not-supported";
  ErrorCode22["CONVERTING_FAILED"] = "converting-error";
  ErrorCode22["ELEMENT_NOT_FOUND"] = "element-not-found";
  ErrorCode22["MISSING_REQUIRED_PARAMETER"] = "missing-required-parameter";
  ErrorCode22["GAS_PRICE_TOO_LOW"] = "gas-price-too-low";
  ErrorCode22["GAS_LIMIT_TOO_LOW"] = "gas-limit-too-low";
  ErrorCode22["TRANSACTION_NOT_FOUND"] = "transaction-not-found";
  ErrorCode22["TRANSACTION_FAILED"] = "transaction-failed";
  ErrorCode22["INVALID_CONFIGURABLE_CONSTANTS"] = "invalid-configurable-constants";
  ErrorCode22["INVALID_TRANSACTION_INPUT"] = "invalid-transaction-input";
  ErrorCode22["INVALID_TRANSACTION_OUTPUT"] = "invalid-transaction-output";
  ErrorCode22["INVALID_TRANSACTION_STATUS"] = "invalid-transaction-status";
  ErrorCode22["INVALID_TRANSACTION_TYPE"] = "invalid-transaction-type";
  ErrorCode22["TRANSACTION_ERROR"] = "transaction-error";
  ErrorCode22["INVALID_RECEIPT_TYPE"] = "invalid-receipt-type";
  ErrorCode22["INVALID_WORD_LIST"] = "invalid-word-list";
  ErrorCode22["INVALID_MNEMONIC"] = "invalid-mnemonic";
  ErrorCode22["INVALID_ENTROPY"] = "invalid-entropy";
  ErrorCode22["INVALID_SEED"] = "invalid-seed";
  ErrorCode22["INVALID_CHECKSUM"] = "invalid-checksum";
  ErrorCode22["INVALID_PASSWORD"] = "invalid-password";
  ErrorCode22["ACCOUNT_REQUIRED"] = "account-required";
  ErrorCode22["LATEST_BLOCK_UNAVAILABLE"] = "latest-block-unavailable";
  ErrorCode22["ERROR_BUILDING_BLOCK_EXPLORER_URL"] = "error-building-block-explorer-url";
  ErrorCode22["UNSUPPORTED_FUEL_CLIENT_VERSION"] = "unsupported-fuel-client-version";
  ErrorCode22["VITEPRESS_PLUGIN_ERROR"] = "vitepress-plugin-error";
  ErrorCode22["INVALID_MULTICALL"] = "invalid-multicall";
  ErrorCode22["SCRIPT_REVERTED"] = "script-reverted";
  ErrorCode22["SCRIPT_RETURN_INVALID_TYPE"] = "script-return-invalid-type";
  return ErrorCode22;
})(ErrorCode2 || {});
var _FuelError2 = class extends Error {
  VERSIONS = versions3;
  static parse(e) {
    const error = e;
    if (error.code === undefined) {
      throw new _FuelError2("parse-failed", "Failed to parse the error object. The required 'code' property is missing.");
    }
    const enumValues = Object.values(ErrorCode2);
    const codeIsKnown = enumValues.includes(error.code);
    if (!codeIsKnown) {
      throw new _FuelError2("parse-failed", `Unknown error code: ${error.code}. Accepted codes: ${enumValues.join(", ")}.`);
    }
    return new _FuelError2(error.code, error.message);
  }
  code;
  constructor(code, message) {
    super(message);
    this.code = code;
    this.name = "FuelError";
  }
  toObject() {
    const { code, name, message, VERSIONS } = this;
    return { code, name, message, VERSIONS };
  }
};
var FuelError2 = _FuelError2;
__publicField2(FuelError2, "CODES", ErrorCode2);

// node_modules/@fuel-ts/math/dist/index.mjs
var import_bn = __toESM(require_bn(), 1);
var toFixed = function(value, options) {
  const { precision = DEFAULT_PRECISION, minPrecision = DEFAULT_MIN_PRECISION } = options || {};
  const [valueUnits = "0", valueDecimals = "0"] = String(value || "0.0").split(".");
  const groupRegex = /(\d)(?=(\d{3})+\b)/g;
  const units = valueUnits.replace(groupRegex, "$1,");
  let decimals = valueDecimals.slice(0, precision);
  if (minPrecision < precision) {
    const trimmedDecimal = decimals.match(/.*[1-9]{1}/);
    const lastNonZeroIndex = trimmedDecimal?.[0].length || 0;
    const keepChars = Math.max(minPrecision, lastNonZeroIndex);
    decimals = decimals.slice(0, keepChars);
  }
  const decimalPortion = decimals ? `.${decimals}` : "";
  return `${units}${decimalPortion}`;
};
var toNumber2 = function(value) {
  return bn(value).toNumber();
};
var toHex = function(value, bytesPadding) {
  return bn(value).toHex(bytesPadding);
};
var toBytes2 = function(value, bytesPadding) {
  return bn(value).toBytes(bytesPadding);
};
var max = function(...numbers) {
  return numbers.reduce((prev, cur) => bn(cur).gt(prev) ? bn(cur) : prev, bn(0));
};
var DEFAULT_PRECISION = 9;
var DEFAULT_MIN_PRECISION = 3;
var DECIMAL_UNITS = 9;
var BN = class extends import_bn.default {
  constructor(value, base, endian) {
    if (BN.isBN(value)) {
      super(value.toArray(), base, endian);
      return;
    }
    if (typeof value === "string" && value.slice(0, 2) === "0x") {
      super(value.substring(2), base || "hex", endian);
      return;
    }
    const defaultValue = value == null ? 0 : value;
    super(defaultValue, base, endian);
  }
  toString(base, length) {
    const output2 = super.toString(base, length);
    if (base === 16 || base === "hex")
      return `0x${output2}`;
    return output2;
  }
  toHex(bytesPadding) {
    const bytes2 = bytesPadding || 0;
    const bytesLength = bytes2 * 2;
    if (this.isNeg()) {
      throw new FuelError(ErrorCode.CONVERTING_FAILED, "Cannot convert negative value to hex.");
    }
    if (bytesPadding && this.byteLength() > bytesPadding) {
      throw new FuelError(ErrorCode.CONVERTING_FAILED, `Provided value ${this} is too large. It should fit within ${bytesPadding} bytes.`);
    }
    return this.toString(16, bytesLength);
  }
  toBytes(bytesPadding) {
    if (this.isNeg()) {
      throw new FuelError(ErrorCode.CONVERTING_FAILED, "Cannot convert negative value to bytes.");
    }
    return Uint8Array.from(this.toArray(undefined, bytesPadding));
  }
  toJSON() {
    return this.toString(16);
  }
  valueOf() {
    return this.toString();
  }
  format(options) {
    const {
      units = DECIMAL_UNITS,
      precision = DEFAULT_PRECISION,
      minPrecision = DEFAULT_MIN_PRECISION
    } = options || {};
    const formattedUnits = this.formatUnits(units);
    const formattedFixed = toFixed(formattedUnits, { precision, minPrecision });
    if (!parseFloat(formattedFixed)) {
      const [, originalDecimals = "0"] = formattedUnits.split(".");
      const firstNonZero = originalDecimals.match(/[1-9]/);
      if (firstNonZero && firstNonZero.index && firstNonZero.index + 1 > precision) {
        const [valueUnits = "0"] = formattedFixed.split(".");
        return `${valueUnits}.${originalDecimals.slice(0, firstNonZero.index + 1)}`;
      }
    }
    return formattedFixed;
  }
  formatUnits(units = DECIMAL_UNITS) {
    const valueUnits = this.toString().slice(0, units * -1);
    const valueDecimals = this.toString().slice(units * -1);
    const length = valueDecimals.length;
    const defaultDecimals = Array.from({ length: units - length }).fill("0").join("");
    const integerPortion = valueUnits ? `${valueUnits}.` : "0.";
    return `${integerPortion}${defaultDecimals}${valueDecimals}`;
  }
  add(v2) {
    return this.caller(v2, "add");
  }
  pow(v2) {
    return this.caller(v2, "pow");
  }
  sub(v2) {
    return this.caller(v2, "sub");
  }
  div(v2) {
    return this.caller(v2, "div");
  }
  mul(v2) {
    return this.caller(v2, "mul");
  }
  mod(v2) {
    return this.caller(v2, "mod");
  }
  divRound(v2) {
    return this.caller(v2, "divRound");
  }
  lt(v2) {
    return this.caller(v2, "lt");
  }
  lte(v2) {
    return this.caller(v2, "lte");
  }
  gt(v2) {
    return this.caller(v2, "gt");
  }
  gte(v2) {
    return this.caller(v2, "gte");
  }
  eq(v2) {
    return this.caller(v2, "eq");
  }
  cmp(v2) {
    return this.caller(v2, "cmp");
  }
  sqr() {
    return new BN(super.sqr().toArray());
  }
  neg() {
    return new BN(super.neg().toArray());
  }
  abs() {
    return new BN(super.abs().toArray());
  }
  toTwos(width) {
    return new BN(super.toTwos(width).toArray());
  }
  fromTwos(width) {
    return new BN(super.fromTwos(width).toArray());
  }
  caller(v2, methodName) {
    const output2 = super[methodName](new BN(v2));
    if (BN.isBN(output2)) {
      return new BN(output2.toArray());
    }
    if (typeof output2 === "boolean") {
      return output2;
    }
    return output2;
  }
  clone() {
    return new BN(this.toArray());
  }
  mulTo(num, out) {
    const output2 = new import_bn.default(this.toArray()).mulTo(num, out);
    return new BN(output2.toArray());
  }
  egcd(p) {
    const { a, b: b2, gcd } = new import_bn.default(this.toArray()).egcd(p);
    return {
      a: new BN(a.toArray()),
      b: new BN(b2.toArray()),
      gcd: new BN(gcd.toArray())
    };
  }
  divmod(num, mode, positive) {
    const { div, mod } = new import_bn.default(this.toArray()).divmod(new BN(num), mode, positive);
    return {
      div: new BN(div?.toArray()),
      mod: new BN(mod?.toArray())
    };
  }
};
var bn = (value, base, endian) => new BN(value, base, endian);
bn.parseUnits = (value, units = DECIMAL_UNITS) => {
  const valueToParse = value === "." ? "0." : value;
  const [valueUnits = "0", valueDecimals = "0"] = valueToParse.split(".");
  const length = valueDecimals.length;
  if (length > units) {
    throw new FuelError(ErrorCode.CONVERTING_FAILED, `Decimal can't have more than ${units} digits.`);
  }
  const decimals = Array.from({ length: units }).fill("0");
  decimals.splice(0, length, valueDecimals);
  const amount = `${valueUnits.replaceAll(",", "")}${decimals.join("")}`;
  return bn(amount);
};

// node_modules/@fuel-ts/abi-coder/dist/index.mjs
var concatWithDynamicData = function(items) {
  const topLevelData = {};
  let totalIndex = 0;
  const objects = items.map((item) => {
    const dynamicData = item.dynamicData;
    if (dynamicData) {
      Object.entries(dynamicData).forEach(([pointerIndex, vData]) => {
        topLevelData[parseInt(pointerIndex, 10) + totalIndex] = vData;
      });
    }
    const byteArray = getBytesCopy(item);
    totalIndex += byteArray.byteLength / WORD_SIZE;
    return byteArray;
  });
  const length = objects.reduce((accum, item) => accum + item.length, 0);
  const result = new Uint8Array(length);
  objects.reduce((offset, object) => {
    result.set(object, offset);
    return offset + object.length;
  }, 0);
  if (Object.keys(topLevelData).length) {
    result.dynamicData = topLevelData;
  }
  return result;
};
var unpackDynamicData = function(results, baseOffset, dataOffset) {
  if (!results.dynamicData) {
    return concat2([results]);
  }
  let cumulativeDynamicByteLength = 0;
  let updatedResults = results;
  Object.entries(results.dynamicData).forEach(([pointerIndex, vData]) => {
    const pointerOffset = parseInt(pointerIndex, 10) * WORD_SIZE;
    const adjustedValue = new U64Coder().encode(dataOffset + baseOffset + cumulativeDynamicByteLength);
    updatedResults.set(adjustedValue, pointerOffset);
    const dataToAppend = vData.dynamicData ? unpackDynamicData(vData, baseOffset, dataOffset + vData.byteLength + cumulativeDynamicByteLength) : vData;
    updatedResults = concat2([updatedResults, dataToAppend]);
    cumulativeDynamicByteLength += dataToAppend.byteLength;
  });
  return updatedResults;
};
var findOrThrow = function(arr, predicate, throwFn = () => {
  throw new FuelError(ErrorCode.ELEMENT_NOT_FOUND, "Element not found in the array.");
}) {
  const found = arr.find(predicate);
  if (found === undefined)
    throwFn();
  return found;
};

// node_modules/ethereum-cryptography/node_modules/@noble/hashes/esm/_assert.js
function number2(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error(`Wrong positive integer: ${n}`);
}
function bool(b2) {
  if (typeof b2 !== "boolean")
    throw new Error(`Expected boolean, not ${b2}`);
}
function bytes2(b2, ...lengths) {
  if (!(b2 instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b2.length))
    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b2.length}`);
}
function hash2(hash3) {
  if (typeof hash3 !== "function" || typeof hash3.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number2(hash3.outputLen);
  number2(hash3.blockLen);
}
function exists2(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output2(out, instance) {
  bytes2(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}
var assert2 = {
  number: number2,
  bool,
  bytes: bytes2,
  hash: hash2,
  exists: exists2,
  output: output2
};
var _assert_default = assert2;

// node_modules/ethereum-cryptography/node_modules/@noble/hashes/esm/crypto.js
var crypto7 = typeof globalThis === "object" && ("crypto" in globalThis) ? globalThis.crypto : undefined;

// node_modules/ethereum-cryptography/node_modules/@noble/hashes/esm/utils.js
function utf8ToBytes2(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes3(data3) {
  if (typeof data3 === "string")
    data3 = utf8ToBytes2(data3);
  if (!u8a2(data3))
    throw new Error(`expected Uint8Array, got ${typeof data3}`);
  return data3;
}
function checkOpts2(defaults, opts) {
  if (opts !== undefined && (typeof opts !== "object" || !isPlainObject(opts)))
    throw new Error("Options should be object or undefined");
  const merged = Object.assign(defaults, opts);
  return merged;
}
function wrapConstructor2(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes3(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function wrapXOFConstructorWithOpts2(hashCons) {
  const hashC = (msg, opts) => hashCons(opts).update(toBytes3(msg)).digest();
  const tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  return hashC;
}
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var u8a2 = (a) => a instanceof Uint8Array;
var u322 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
var createView2 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var rotr2 = (word, shift) => word << 32 - shift | word >>> shift;
var isLE2 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE2)
  throw new Error("Non little-endian hardware is not supported");
var hexes = Array.from({ length: 256 }, (v2, i) => i.toString(16).padStart(2, "0"));
class Hash2 {
  clone() {
    return this._cloneInto();
  }
}
var isPlainObject = (obj) => Object.prototype.toString.call(obj) === "[object Object]" && obj.constructor === Object;

// node_modules/ethereum-cryptography/node_modules/@noble/hashes/esm/_sha2.js
var setBigUint642 = function(view, byteOffset, value, isLE3) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE3);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE3 ? 4 : 0;
  const l = isLE3 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE3);
  view.setUint32(byteOffset + l, wl, isLE3);
};

class SHA22 extends Hash2 {
  constructor(blockLen, outputLen, padOffset, isLE3) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE3;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView2(this.buffer);
  }
  update(data3) {
    _assert_default.exists(this);
    const { view, buffer, blockLen } = this;
    data3 = toBytes3(data3);
    const len = data3.length;
    for (let pos = 0;pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView2(data3);
        for (;blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data3.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data3.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    _assert_default.exists(this);
    _assert_default.output(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE: isLE3 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos;i < blockLen; i++)
      buffer[i] = 0;
    setBigUint642(view, blockLen - 8, BigInt(this.length * 8), isLE3);
    this.process(view, 0);
    const oview = createView2(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0;i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE3);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor);
    to.set(...this.get());
    const { blockLen, buffer, length, finished, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer);
    return to;
  }
}

// node_modules/ethereum-cryptography/node_modules/@noble/hashes/esm/sha256.js
var Chi2 = (a, b2, c) => a & b2 ^ ~a & c;
var Maj2 = (a, b2, c) => a & b2 ^ a & c ^ b2 & c;
var SHA256_K2 = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var IV2 = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA256_W2 = new Uint32Array(64);

class SHA2562 extends SHA22 {
  constructor() {
    super(64, 32, 8, false);
    this.A = IV2[0] | 0;
    this.B = IV2[1] | 0;
    this.C = IV2[2] | 0;
    this.D = IV2[3] | 0;
    this.E = IV2[4] | 0;
    this.F = IV2[5] | 0;
    this.G = IV2[6] | 0;
    this.H = IV2[7] | 0;
  }
  get() {
    const { A, B, C, D: D2, E, F, G, H } = this;
    return [A, B, C, D2, E, F, G, H];
  }
  set(A, B, C, D2, E, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D2 | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i = 0;i < 16; i++, offset += 4)
      SHA256_W2[i] = view.getUint32(offset, false);
    for (let i = 16;i < 64; i++) {
      const W15 = SHA256_W2[i - 15];
      const W2 = SHA256_W2[i - 2];
      const s0 = rotr2(W15, 7) ^ rotr2(W15, 18) ^ W15 >>> 3;
      const s1 = rotr2(W2, 17) ^ rotr2(W2, 19) ^ W2 >>> 10;
      SHA256_W2[i] = s1 + SHA256_W2[i - 7] + s0 + SHA256_W2[i - 16] | 0;
    }
    let { A, B, C, D: D2, E, F, G, H } = this;
    for (let i = 0;i < 64; i++) {
      const sigma1 = rotr2(E, 6) ^ rotr2(E, 11) ^ rotr2(E, 25);
      const T1 = H + sigma1 + Chi2(E, F, G) + SHA256_K2[i] + SHA256_W2[i] | 0;
      const sigma0 = rotr2(A, 2) ^ rotr2(A, 13) ^ rotr2(A, 22);
      const T2 = sigma0 + Maj2(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D2 + T1 | 0;
      D2 = C;
      C = B;
      B = A;
      A = T1 + T2 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D2 = D2 + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D2, E, F, G, H);
  }
  roundClean() {
    SHA256_W2.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
}

class SHA224 extends SHA2562 {
  constructor() {
    super();
    this.A = 3238371032 | 0;
    this.B = 914150663 | 0;
    this.C = 812702999 | 0;
    this.D = 4144912697 | 0;
    this.E = 4290775857 | 0;
    this.F = 1750603025 | 0;
    this.G = 1694076839 | 0;
    this.H = 3204075428 | 0;
    this.outputLen = 28;
  }
}
var sha2564 = wrapConstructor2(() => new SHA2562);
var sha224 = wrapConstructor2(() => new SHA224);

// node_modules/ethereum-cryptography/node_modules/@noble/hashes/esm/hmac.js
class HMAC2 extends Hash2 {
  constructor(hash3, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    _assert_default.hash(hash3);
    const key = toBytes3(_key);
    this.iHash = hash3.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key.length > blockLen ? hash3.create().update(key).digest() : key);
    for (let i = 0;i < pad.length; i++)
      pad[i] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash3.create();
    for (let i = 0;i < pad.length; i++)
      pad[i] ^= 54 ^ 92;
    this.oHash.update(pad);
    pad.fill(0);
  }
  update(buf) {
    _assert_default.exists(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    _assert_default.exists(this);
    _assert_default.bytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
}
var hmac5 = (hash3, key, message) => new HMAC2(hash3, key).update(message).digest();
hmac5.create = (hash3, key) => new HMAC2(hash3, key);

// node_modules/ethereum-cryptography/node_modules/@noble/hashes/esm/pbkdf2.js
var pbkdf2Init2 = function(hash3, _password, _salt, _opts) {
  _assert_default.hash(hash3);
  const opts = checkOpts2({ dkLen: 32, asyncTick: 10 }, _opts);
  const { c, dkLen, asyncTick } = opts;
  _assert_default.number(c);
  _assert_default.number(dkLen);
  _assert_default.number(asyncTick);
  if (c < 1)
    throw new Error("PBKDF2: iterations (c) should be >= 1");
  const password = toBytes3(_password);
  const salt = toBytes3(_salt);
  const DK = new Uint8Array(dkLen);
  const PRF = hmac5.create(hash3, password);
  const PRFSalt = PRF._cloneInto().update(salt);
  return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
};
var pbkdf2Output2 = function(PRF, PRFSalt, DK, prfW, u) {
  PRF.destroy();
  PRFSalt.destroy();
  if (prfW)
    prfW.destroy();
  u.fill(0);
  return DK;
};
function pbkdf25(hash3, password, salt, opts) {
  const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init2(hash3, password, salt, opts);
  let prfW;
  const arr = new Uint8Array(4);
  const view = createView2(arr);
  const u = new Uint8Array(PRF.outputLen);
  for (let ti = 1, pos = 0;pos < dkLen; ti++, pos += PRF.outputLen) {
    const Ti = DK.subarray(pos, pos + PRF.outputLen);
    view.setInt32(0, ti, false);
    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
    Ti.set(u.subarray(0, Ti.length));
    for (let ui = 1;ui < c; ui++) {
      PRF._cloneInto(prfW).update(u).digestInto(u);
      for (let i = 0;i < Ti.length; i++)
        Ti[i] ^= u[i];
    }
  }
  return pbkdf2Output2(PRF, PRFSalt, DK, prfW, u);
}

// node_modules/ethereum-cryptography/node_modules/@noble/hashes/esm/scrypt.js
var XorAndSalsa = function(prev, pi, input, ii, out, oi) {
  let y00 = prev[pi++] ^ input[ii++], y01 = prev[pi++] ^ input[ii++];
  let y02 = prev[pi++] ^ input[ii++], y03 = prev[pi++] ^ input[ii++];
  let y04 = prev[pi++] ^ input[ii++], y05 = prev[pi++] ^ input[ii++];
  let y06 = prev[pi++] ^ input[ii++], y07 = prev[pi++] ^ input[ii++];
  let y08 = prev[pi++] ^ input[ii++], y09 = prev[pi++] ^ input[ii++];
  let y10 = prev[pi++] ^ input[ii++], y11 = prev[pi++] ^ input[ii++];
  let y12 = prev[pi++] ^ input[ii++], y13 = prev[pi++] ^ input[ii++];
  let y14 = prev[pi++] ^ input[ii++], y15 = prev[pi++] ^ input[ii++];
  let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
  for (let i = 0;i < 8; i += 2) {
    x04 ^= rotl2(x00 + x12 | 0, 7);
    x08 ^= rotl2(x04 + x00 | 0, 9);
    x12 ^= rotl2(x08 + x04 | 0, 13);
    x00 ^= rotl2(x12 + x08 | 0, 18);
    x09 ^= rotl2(x05 + x01 | 0, 7);
    x13 ^= rotl2(x09 + x05 | 0, 9);
    x01 ^= rotl2(x13 + x09 | 0, 13);
    x05 ^= rotl2(x01 + x13 | 0, 18);
    x14 ^= rotl2(x10 + x06 | 0, 7);
    x02 ^= rotl2(x14 + x10 | 0, 9);
    x06 ^= rotl2(x02 + x14 | 0, 13);
    x10 ^= rotl2(x06 + x02 | 0, 18);
    x03 ^= rotl2(x15 + x11 | 0, 7);
    x07 ^= rotl2(x03 + x15 | 0, 9);
    x11 ^= rotl2(x07 + x03 | 0, 13);
    x15 ^= rotl2(x11 + x07 | 0, 18);
    x01 ^= rotl2(x00 + x03 | 0, 7);
    x02 ^= rotl2(x01 + x00 | 0, 9);
    x03 ^= rotl2(x02 + x01 | 0, 13);
    x00 ^= rotl2(x03 + x02 | 0, 18);
    x06 ^= rotl2(x05 + x04 | 0, 7);
    x07 ^= rotl2(x06 + x05 | 0, 9);
    x04 ^= rotl2(x07 + x06 | 0, 13);
    x05 ^= rotl2(x04 + x07 | 0, 18);
    x11 ^= rotl2(x10 + x09 | 0, 7);
    x08 ^= rotl2(x11 + x10 | 0, 9);
    x09 ^= rotl2(x08 + x11 | 0, 13);
    x10 ^= rotl2(x09 + x08 | 0, 18);
    x12 ^= rotl2(x15 + x14 | 0, 7);
    x13 ^= rotl2(x12 + x15 | 0, 9);
    x14 ^= rotl2(x13 + x12 | 0, 13);
    x15 ^= rotl2(x14 + x13 | 0, 18);
  }
  out[oi++] = y00 + x00 | 0;
  out[oi++] = y01 + x01 | 0;
  out[oi++] = y02 + x02 | 0;
  out[oi++] = y03 + x03 | 0;
  out[oi++] = y04 + x04 | 0;
  out[oi++] = y05 + x05 | 0;
  out[oi++] = y06 + x06 | 0;
  out[oi++] = y07 + x07 | 0;
  out[oi++] = y08 + x08 | 0;
  out[oi++] = y09 + x09 | 0;
  out[oi++] = y10 + x10 | 0;
  out[oi++] = y11 + x11 | 0;
  out[oi++] = y12 + x12 | 0;
  out[oi++] = y13 + x13 | 0;
  out[oi++] = y14 + x14 | 0;
  out[oi++] = y15 + x15 | 0;
};
var BlockMix = function(input, ii, out, oi, r) {
  let head = oi + 0;
  let tail = oi + 16 * r;
  for (let i = 0;i < 16; i++)
    out[tail + i] = input[ii + (2 * r - 1) * 16 + i];
  for (let i = 0;i < r; i++, head += 16, ii += 16) {
    XorAndSalsa(out, tail, input, ii, out, head);
    if (i > 0)
      tail += 16;
    XorAndSalsa(out, head, input, ii += 16, out, tail);
  }
};
var scryptInit = function(password, salt, _opts) {
  const opts = checkOpts2({
    dkLen: 32,
    asyncTick: 10,
    maxmem: 1024 ** 3 + 1024
  }, _opts);
  const { N, r, p, dkLen, asyncTick, maxmem, onProgress } = opts;
  _assert_default.number(N);
  _assert_default.number(r);
  _assert_default.number(p);
  _assert_default.number(dkLen);
  _assert_default.number(asyncTick);
  _assert_default.number(maxmem);
  if (onProgress !== undefined && typeof onProgress !== "function")
    throw new Error("progressCb should be function");
  const blockSize = 128 * r;
  const blockSize32 = blockSize / 4;
  if (N <= 1 || (N & N - 1) !== 0 || N >= 2 ** (blockSize / 8) || N > 2 ** 32) {
    throw new Error("Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32");
  }
  if (p < 0 || p > (2 ** 32 - 1) * 32 / blockSize) {
    throw new Error("Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)");
  }
  if (dkLen < 0 || dkLen > (2 ** 32 - 1) * 32) {
    throw new Error("Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32");
  }
  const memUsed = blockSize * (N + p);
  if (memUsed > maxmem) {
    throw new Error(`Scrypt: parameters too large, ${memUsed} (128 * r * (N + p)) > ${maxmem} (maxmem)`);
  }
  const B = pbkdf25(sha2564, password, salt, { c: 1, dkLen: blockSize * p });
  const B32 = u322(B);
  const V = u322(new Uint8Array(blockSize * N));
  const tmp = u322(new Uint8Array(blockSize));
  let blockMixCb = () => {
  };
  if (onProgress) {
    const totalBlockMix = 2 * N * p;
    const callbackPer = Math.max(Math.floor(totalBlockMix / 1e4), 1);
    let blockMixCnt = 0;
    blockMixCb = () => {
      blockMixCnt++;
      if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix))
        onProgress(blockMixCnt / totalBlockMix);
    };
  }
  return { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick };
};
var scryptOutput = function(password, dkLen, B, V, tmp) {
  const res = pbkdf25(sha2564, password, B, { c: 1, dkLen });
  B.fill(0);
  V.fill(0);
  tmp.fill(0);
  return res;
};
function scrypt2(password, salt, opts) {
  const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb } = scryptInit(password, salt, opts);
  for (let pi = 0;pi < p; pi++) {
    const Pi2 = blockSize32 * pi;
    for (let i = 0;i < blockSize32; i++)
      V[i] = B32[Pi2 + i];
    for (let i = 0, pos = 0;i < N - 1; i++) {
      BlockMix(V, pos, V, pos += blockSize32, r);
      blockMixCb();
    }
    BlockMix(V, (N - 1) * blockSize32, B32, Pi2, r);
    blockMixCb();
    for (let i = 0;i < N; i++) {
      const j = B32[Pi2 + blockSize32 - 16] % N;
      for (let k = 0;k < blockSize32; k++)
        tmp[k] = B32[Pi2 + k] ^ V[j * blockSize32 + k];
      BlockMix(tmp, 0, B32, Pi2, r);
      blockMixCb();
    }
  }
  return scryptOutput(password, dkLen, B, V, tmp);
}
var rotl2 = (a, b2) => a << b2 | a >>> 32 - b2;
// node_modules/ethereum-cryptography/esm/utils.js
function wrapHash(hash3) {
  return (msg) => {
    _assert_default.bytes(msg);
    return hash3(msg);
  };
}
var assertBool = _assert_default.bool;
var assertBytes = _assert_default.bytes;
var crypto9 = (() => {
  const webCrypto = typeof globalThis === "object" && ("crypto" in globalThis) ? globalThis.crypto : undefined;
  const nodeRequire = typeof module_utils !== "undefined" && typeof module_utils.require === "function" && module_utils.require.bind(module_utils);
  return {
    node: nodeRequire && !webCrypto ? nodeRequire("crypto") : undefined,
    web: webCrypto
  };
})();

// node_modules/ethereum-cryptography/esm/scrypt.js
function scryptSync2(password, salt, n, p, r, dkLen, onProgress) {
  assertBytes(password);
  assertBytes(salt);
  return scrypt2(password, salt, { N: n, r, p, dkLen, onProgress });
}

// node_modules/ethereum-cryptography/node_modules/@noble/hashes/esm/_u64.js
function fromBig2(n, le = false) {
  if (le)
    return { h: Number(n & U32_MASK642), l: Number(n >> _32n2 & U32_MASK642) };
  return { h: Number(n >> _32n2 & U32_MASK642) | 0, l: Number(n & U32_MASK642) | 0 };
}
function split2(lst, le = false) {
  let Ah = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i = 0;i < lst.length; i++) {
    const { h, l } = fromBig2(lst[i], le);
    [Ah[i], Al[i]] = [h, l];
  }
  return [Ah, Al];
}
function add2(Ah, Al, Bh, Bl) {
  const l = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
}
var U32_MASK642 = BigInt(2 ** 32 - 1);
var _32n2 = BigInt(32);
var toBig2 = (h, l) => BigInt(h >>> 0) << _32n2 | BigInt(l >>> 0);
var shrSH2 = (h, l, s) => h >>> s;
var shrSL2 = (h, l, s) => h << 32 - s | l >>> s;
var rotrSH2 = (h, l, s) => h >>> s | l << 32 - s;
var rotrSL2 = (h, l, s) => h << 32 - s | l >>> s;
var rotrBH2 = (h, l, s) => h << 64 - s | l >>> s - 32;
var rotrBL2 = (h, l, s) => h >>> s - 32 | l << 64 - s;
var rotr32H2 = (h, l) => l;
var rotr32L2 = (h, l) => h;
var rotlSH2 = (h, l, s) => h << s | l >>> 32 - s;
var rotlSL2 = (h, l, s) => l << s | h >>> 32 - s;
var rotlBH2 = (h, l, s) => l << s - 32 | h >>> 64 - s;
var rotlBL2 = (h, l, s) => h << s - 32 | l >>> 64 - s;
var add3L2 = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
var add3H2 = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
var add4L2 = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
var add4H2 = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
var add5L2 = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
var add5H2 = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
var u642 = {
  fromBig: fromBig2,
  split: split2,
  toBig: toBig2,
  shrSH: shrSH2,
  shrSL: shrSL2,
  rotrSH: rotrSH2,
  rotrSL: rotrSL2,
  rotrBH: rotrBH2,
  rotrBL: rotrBL2,
  rotr32H: rotr32H2,
  rotr32L: rotr32L2,
  rotlSH: rotlSH2,
  rotlSL: rotlSL2,
  rotlBH: rotlBH2,
  rotlBL: rotlBL2,
  add: add2,
  add3L: add3L2,
  add3H: add3H2,
  add4L: add4L2,
  add4H: add4H2,
  add5H: add5H2,
  add5L: add5L2
};
var _u64_default2 = u642;

// node_modules/ethereum-cryptography/node_modules/@noble/hashes/esm/sha3.js
function keccakP2(s, rounds = 24) {
  const B = new Uint32Array(5 * 2);
  for (let round = 24 - rounds;round < 24; round++) {
    for (let x = 0;x < 10; x++)
      B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
    for (let x = 0;x < 10; x += 2) {
      const idx1 = (x + 8) % 10;
      const idx0 = (x + 2) % 10;
      const B0 = B[idx0];
      const B1 = B[idx0 + 1];
      const Th = rotlH2(B0, B1, 1) ^ B[idx1];
      const Tl = rotlL2(B0, B1, 1) ^ B[idx1 + 1];
      for (let y = 0;y < 50; y += 10) {
        s[x + y] ^= Th;
        s[x + y + 1] ^= Tl;
      }
    }
    let curH = s[2];
    let curL = s[3];
    for (let t = 0;t < 24; t++) {
      const shift = SHA3_ROTL2[t];
      const Th = rotlH2(curH, curL, shift);
      const Tl = rotlL2(curH, curL, shift);
      const PI = SHA3_PI2[t];
      curH = s[PI];
      curL = s[PI + 1];
      s[PI] = Th;
      s[PI + 1] = Tl;
    }
    for (let y = 0;y < 50; y += 10) {
      for (let x = 0;x < 10; x++)
        B[x] = s[y + x];
      for (let x = 0;x < 10; x++)
        s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
    }
    s[0] ^= SHA3_IOTA_H2[round];
    s[1] ^= SHA3_IOTA_L2[round];
  }
  B.fill(0);
}
var [SHA3_PI2, SHA3_ROTL2, _SHA3_IOTA2] = [[], [], []];
var _0n2 = BigInt(0);
var _1n2 = BigInt(1);
var _2n2 = BigInt(2);
var _7n2 = BigInt(7);
var _256n2 = BigInt(256);
var _0x71n2 = BigInt(113);
for (let round = 0, R = _1n2, x = 1, y = 0;round < 24; round++) {
  [x, y] = [y, (2 * x + 3 * y) % 5];
  SHA3_PI2.push(2 * (5 * y + x));
  SHA3_ROTL2.push((round + 1) * (round + 2) / 2 % 64);
  let t = _0n2;
  for (let j = 0;j < 7; j++) {
    R = (R << _1n2 ^ (R >> _7n2) * _0x71n2) % _256n2;
    if (R & _2n2)
      t ^= _1n2 << (_1n2 << BigInt(j)) - _1n2;
  }
  _SHA3_IOTA2.push(t);
}
var [SHA3_IOTA_H2, SHA3_IOTA_L2] = _u64_default2.split(_SHA3_IOTA2, true);
var rotlH2 = (h, l, s) => s > 32 ? _u64_default2.rotlBH(h, l, s) : _u64_default2.rotlSH(h, l, s);
var rotlL2 = (h, l, s) => s > 32 ? _u64_default2.rotlBL(h, l, s) : _u64_default2.rotlSL(h, l, s);

class Keccak2 extends Hash2 {
  constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
    super();
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    this.pos = 0;
    this.posOut = 0;
    this.finished = false;
    this.destroyed = false;
    _assert_default.number(outputLen);
    if (0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200);
    this.state32 = u322(this.state);
  }
  keccak() {
    keccakP2(this.state32, this.rounds);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data3) {
    _assert_default.exists(this);
    const { blockLen, state } = this;
    data3 = toBytes3(data3);
    const len = data3.length;
    for (let pos = 0;pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      for (let i = 0;i < take; i++)
        state[this.pos++] ^= data3[pos++];
      if (this.pos === blockLen)
        this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state, suffix, pos, blockLen } = this;
    state[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1)
      this.keccak();
    state[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    _assert_default.exists(this, false);
    _assert_default.bytes(out);
    this.finish();
    const bufferOut = this.state;
    const { blockLen } = this;
    for (let pos = 0, len = out.length;pos < len; ) {
      if (this.posOut >= blockLen)
        this.keccak();
      const take = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes3) {
    _assert_default.number(bytes3);
    return this.xofInto(new Uint8Array(bytes3));
  }
  digestInto(out) {
    _assert_default.output(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    this.state.fill(0);
  }
  _cloneInto(to) {
    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
    to || (to = new Keccak2(blockLen, suffix, outputLen, enableXOF, rounds));
    to.state32.set(this.state32);
    to.pos = this.pos;
    to.posOut = this.posOut;
    to.finished = this.finished;
    to.rounds = rounds;
    to.suffix = suffix;
    to.outputLen = outputLen;
    to.enableXOF = enableXOF;
    to.destroyed = this.destroyed;
    return to;
  }
}
var gen2 = (suffix, blockLen, outputLen) => wrapConstructor2(() => new Keccak2(blockLen, suffix, outputLen));
var sha3_2242 = gen2(6, 144, 224 / 8);
var sha3_2562 = gen2(6, 136, 256 / 8);
var sha3_3842 = gen2(6, 104, 384 / 8);
var sha3_5122 = gen2(6, 72, 512 / 8);
var keccak_2242 = gen2(1, 144, 224 / 8);
var keccak_2562 = gen2(1, 136, 256 / 8);
var keccak_3842 = gen2(1, 104, 384 / 8);
var keccak_5122 = gen2(1, 72, 512 / 8);
var genShake2 = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts2((opts = {}) => new Keccak2(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));
var shake1282 = genShake2(31, 168, 128 / 8);
var shake2562 = genShake2(31, 136, 256 / 8);

// node_modules/ethereum-cryptography/esm/keccak.js
var keccak224 = wrapHash(keccak_2242);
var keccak2562 = (() => {
  const k = wrapHash(keccak_2562);
  k.create = keccak_2562.create;
  return k;
})();
var keccak384 = wrapHash(keccak_3842);
var keccak512 = wrapHash(keccak_5122);

// node_modules/@fuel-ts/crypto/dist/index.browser.mjs
var scrypt5 = (params) => {
  const { password, salt, n, p, r, dklen } = params;
  const derivedKey = scryptSync2(password, salt, n, r, p, dklen);
  return derivedKey;
};
var keccak2563 = (data3) => keccak2562(data3);
var bufferFromString = (string, encoding = "base64") => {
  switch (encoding) {
    case "utf-8": {
      return new TextEncoder().encode(string);
    }
    case "base64": {
      const binaryString = atob(string);
      const len = binaryString.length;
      const bytes3 = new Uint8Array(len).map((_2, i) => binaryString.charCodeAt(i));
      return bytes3;
    }
    case "hex":
    default: {
      const bufferLength = string.length / 2;
      const buffer = new Uint8Array(bufferLength).map((_2, i) => {
        const startIndex = i * 2;
        const byteValue = parseInt(string.substring(startIndex, startIndex + 2), 16);
        return byteValue;
      });
      return buffer;
    }
  }
};
var { crypto: crypto22, btoa } = globalThis;
if (!crypto22) {
  throw new FuelError(ErrorCode.ENV_DEPENDENCY_MISSING, `Could not find 'crypto' in current browser environment.`);
}
if (!btoa) {
  throw new FuelError(ErrorCode.ENV_DEPENDENCY_MISSING, `Could not find 'btoa' in current browser environment.`);
}
var randomBytes2 = (length) => {
  const randomValues = crypto22.getRandomValues(new Uint8Array(length));
  return randomValues;
};
var stringFromBuffer = (buffer, encoding = "base64") => {
  switch (encoding) {
    case "utf-8": {
      return new TextDecoder().decode(buffer);
    }
    case "base64": {
      const binary = String.fromCharCode.apply(null, new Uint8Array(buffer));
      return btoa(binary);
    }
    case "hex":
    default: {
      let hexString = "";
      for (let i = 0;i < buffer.length; i += 1) {
        const hex = buffer[i].toString(16);
        hexString += hex.length === 1 ? `0${hex}` : hex;
      }
      return hexString;
    }
  }
};
var ALGORITHM = "AES-CTR";
var keyFromPassword = (password, saltBuffer) => {
  const passBuffer = bufferFromString(String(password).normalize("NFKC"), "utf-8");
  const key = pbkdf23(passBuffer, saltBuffer, 1e5, 32, "sha256");
  return getBytesCopy(key);
};
var encrypt = async (password, data3) => {
  const iv = randomBytes2(16);
  const salt = randomBytes2(32);
  const secret = keyFromPassword(password, salt);
  const dataString = JSON.stringify(data3);
  const dataBuffer = bufferFromString(dataString, "utf-8");
  const alg = {
    name: ALGORITHM,
    counter: iv,
    length: 64
  };
  const key = await crypto.subtle.importKey("raw", secret, alg, false, ["encrypt"]);
  const encBuffer = await crypto.subtle.encrypt(alg, key, dataBuffer);
  return {
    data: stringFromBuffer(encBuffer),
    iv: stringFromBuffer(iv),
    salt: stringFromBuffer(salt)
  };
};
var decrypt = async (password, keystore) => {
  const iv = bufferFromString(keystore.iv);
  const salt = bufferFromString(keystore.salt);
  const secret = keyFromPassword(password, salt);
  const encryptedText = bufferFromString(keystore.data);
  const alg = {
    name: ALGORITHM,
    counter: iv,
    length: 64
  };
  const key = await crypto.subtle.importKey("raw", secret, alg, false, ["decrypt"]);
  const ptBuffer = await crypto.subtle.decrypt(alg, key, encryptedText);
  const decryptedData = new TextDecoder().decode(ptBuffer);
  try {
    return JSON.parse(decryptedData);
  } catch {
    throw new FuelError(ErrorCode.INVALID_CREDENTIALS, "Invalid credentials.");
  }
};
var encryptJsonWalletData = async (data3, key, iv) => {
  const subtle = crypto22.subtle;
  const keyBuffer = new Uint8Array(key.subarray(0, 16));
  const ivBuffer = iv;
  const dataBuffer = data3;
  const cryptoKey = await subtle.importKey("raw", keyBuffer, { name: "AES-CTR", length: 128 }, false, ["encrypt", "decrypt"]);
  const encrypted = await subtle.encrypt({ name: "AES-CTR", counter: ivBuffer, length: 128 }, cryptoKey, dataBuffer);
  return new Uint8Array(encrypted);
};
var decryptJsonWalletData = async (data3, key, iv) => {
  const subtle = crypto22.subtle;
  const keyBuffer = new Uint8Array(key.subarray(0, 16)).buffer;
  const ivBuffer = new Uint8Array(iv).buffer;
  const dataBuffer = new Uint8Array(data3).buffer;
  const cryptoKey = await subtle.importKey("raw", keyBuffer, { name: "AES-CTR", length: 128 }, false, ["encrypt", "decrypt"]);
  const decrypted = await subtle.decrypt({ name: "AES-CTR", counter: ivBuffer, length: 128 }, cryptoKey, dataBuffer);
  return new Uint8Array(decrypted);
};
var api = {
  bufferFromString,
  stringFromBuffer,
  decrypt,
  encrypt,
  keyFromPassword,
  randomBytes: randomBytes2,
  scrypt: scrypt5,
  keccak256: keccak2563,
  decryptJsonWalletData,
  encryptJsonWalletData
};
var browser_default = api;
var {
  bufferFromString: bufferFromString2,
  decrypt: decrypt2,
  encrypt: encrypt2,
  keyFromPassword: keyFromPassword2,
  randomBytes: randomBytes22,
  stringFromBuffer: stringFromBuffer2,
  scrypt: scrypt22,
  keccak256: keccak25622,
  decryptJsonWalletData: decryptJsonWalletData2,
  encryptJsonWalletData: encryptJsonWalletData2
} = browser_default;

// node_modules/@fuel-ts/abi-coder/dist/index.mjs
var __defProp4 = Object.defineProperty;
var __defNormalProp3 = (obj, key, value) => (key in obj) ? __defProp4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField3 = (obj, key, value) => {
  __defNormalProp3(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};
var Coder = class {
  name;
  type;
  encodedLength;
  constructor(name, type, encodedLength) {
    this.name = name;
    this.type = type;
    this.encodedLength = encodedLength;
  }
  throwError(errorCode, message) {
    throw new FuelError(errorCode, message);
  }
};
var U64Coder = class extends Coder {
  constructor() {
    super("u64", "u64", 8);
  }
  encode(value) {
    let bytes3;
    try {
      bytes3 = toBytes2(value, 8);
    } catch (error) {
      this.throwError(ErrorCode.ENCODE_ERROR, `Invalid ${this.type}.`);
    }
    return bytes3;
  }
  decode(data3, offset) {
    let bytes3 = data3.slice(offset, offset + 8);
    bytes3 = bytes3.slice(0, 8);
    return [bn(bytes3), offset + 8];
  }
};
var OPTION_CODER_TYPE = "enum Option";
var VEC_CODER_TYPE = "struct Vec";
var BYTES_CODER_TYPE = "struct Bytes";
var STD_STRING_CODER_TYPE = "struct String";
var stringRegEx = /str\[(?<length>[0-9]+)\]/;
var arrayRegEx = /\[(?<item>[\w\s\\[\]]+);\s*(?<length>[0-9]+)\]/;
var structRegEx = /^struct (?<name>\w+)$/;
var enumRegEx = /^enum (?<name>\w+)$/;
var tupleRegEx = /^\((?<items>.*)\)$/;
var genericRegEx = /^generic (?<name>\w+)$/;
var WORD_SIZE = 8;
var BYTES_32 = 32;
var ASSET_ID_LEN = BYTES_32;
var CONTRACT_ID_LEN = BYTES_32;
var ADDRESS_LEN = BYTES_32;
var NONCE_LEN = BYTES_32;
var UTXO_LEN = WORD_SIZE * 5;
var TX_POINTER_LEN = WORD_SIZE * 2;
var calculateVmTxMemory = ({ maxInputs }) => BYTES_32 + WORD_SIZE + maxInputs * (ASSET_ID_LEN + WORD_SIZE);
var SCRIPT_FIXED_SIZE = WORD_SIZE + WORD_SIZE + WORD_SIZE + WORD_SIZE + WORD_SIZE + WORD_SIZE + WORD_SIZE + WORD_SIZE + WORD_SIZE + BYTES_32;
var INPUT_COIN_FIXED_SIZE = WORD_SIZE + UTXO_LEN + ADDRESS_LEN + WORD_SIZE + ASSET_ID_LEN + TX_POINTER_LEN + WORD_SIZE + WORD_SIZE + WORD_SIZE + WORD_SIZE + WORD_SIZE;
var INPUT_MESSAGE_FIXED_SIZE = WORD_SIZE + ADDRESS_LEN + ADDRESS_LEN + WORD_SIZE + NONCE_LEN + WORD_SIZE + WORD_SIZE + WORD_SIZE + WORD_SIZE + WORD_SIZE;
var VEC_PROPERTY_SPACE = 3;
var BASE_VECTOR_OFFSET = VEC_PROPERTY_SPACE * WORD_SIZE;
var RAW_SLICE_PROPERTY_SPACE = 2;
var BASE_RAW_SLICE_OFFSET = RAW_SLICE_PROPERTY_SPACE * WORD_SIZE;
var chunkByLength = (data3, length = WORD_SIZE) => {
  const chunks = [];
  let offset = 0;
  let chunk = data3.slice(offset, offset + length);
  while (chunk.length) {
    chunks.push(chunk);
    offset += length;
    chunk = data3.slice(offset, offset + length);
  }
  return chunks;
};
var isPointerType = (type) => {
  switch (type) {
    case "u8":
    case "u16":
    case "u32":
    case "u64":
    case "bool": {
      return false;
    }
    default: {
      return true;
    }
  }
};
var isHeapType = (type) => type === VEC_CODER_TYPE || type === BYTES_CODER_TYPE || type === STD_STRING_CODER_TYPE;
var ArrayCoder = class extends Coder {
  coder;
  length;
  constructor(coder, length) {
    super("array", `[${coder.type}; ${length}]`, length * coder.encodedLength);
    this.coder = coder;
    this.length = length;
  }
  encode(value) {
    if (!Array.isArray(value)) {
      this.throwError(ErrorCode.ENCODE_ERROR, `Expected array value.`);
    }
    if (this.length !== value.length) {
      this.throwError(ErrorCode.ENCODE_ERROR, `Types/values length mismatch.`);
    }
    return concatWithDynamicData(Array.from(value).map((v2) => this.coder.encode(v2)));
  }
  decode(data3, offset) {
    let newOffset = offset;
    const decodedValue = Array(this.length).fill(0).map(() => {
      let decoded;
      [decoded, newOffset] = this.coder.decode(data3, newOffset);
      return decoded;
    });
    return [decodedValue, newOffset];
  }
};
var B256Coder = class extends Coder {
  constructor() {
    super("b256", "b256", 32);
  }
  encode(value) {
    let encodedValue;
    try {
      encodedValue = getBytesCopy(value);
    } catch (error) {
      this.throwError(ErrorCode.ENCODE_ERROR, `Invalid ${this.type}.`);
    }
    if (encodedValue.length !== 32) {
      this.throwError(ErrorCode.ENCODE_ERROR, `Invalid ${this.type}.`);
    }
    return encodedValue;
  }
  decode(data3, offset) {
    let bytes3 = data3.slice(offset, offset + 32);
    const decoded = bn(bytes3);
    if (decoded.isZero()) {
      bytes3 = new Uint8Array(32);
    }
    if (bytes3.length !== 32) {
      this.throwError(ErrorCode.DECODE_ERROR, `'Invalid size for b256'.`);
    }
    return [toHex(bytes3, 32), offset + 32];
  }
};
var B512Coder = class extends Coder {
  constructor() {
    super("b512", "struct B512", 64);
  }
  encode(value) {
    let encodedValue;
    try {
      encodedValue = getBytesCopy(value);
    } catch (error) {
      this.throwError(ErrorCode.ENCODE_ERROR, `Invalid ${this.type}.`);
    }
    if (encodedValue.length !== 64) {
      this.throwError(ErrorCode.ENCODE_ERROR, `Invalid ${this.type}.`);
    }
    return encodedValue;
  }
  decode(data3, offset) {
    let bytes3 = data3.slice(offset, offset + 64);
    const decoded = bn(bytes3);
    if (decoded.isZero()) {
      bytes3 = new Uint8Array(64);
    }
    if (bytes3.length !== 64) {
      this.throwError(ErrorCode.DECODE_ERROR, `Invalid size for b512.`);
    }
    return [toHex(bytes3, 64), offset + 64];
  }
};
var BooleanCoder = class extends Coder {
  constructor() {
    super("boolean", "boolean", 8);
  }
  encode(value) {
    const isTrueBool = value === true || value === false;
    if (!isTrueBool) {
      this.throwError(ErrorCode.ENCODE_ERROR, `Invalid boolean value.`);
    }
    return toBytes2(value ? 1 : 0, 8);
  }
  decode(data3, offset) {
    const bytes3 = bn(data3.slice(offset, offset + 8));
    if (bytes3.isZero()) {
      return [false, offset + 8];
    }
    if (!bytes3.eq(bn(1))) {
      this.throwError(ErrorCode.DECODE_ERROR, `Invalid boolean value.`);
    }
    return [true, offset + 8];
  }
};
var isFullyNativeEnum = (enumCoders) => Object.values(enumCoders).every(({ type, coders }) => type === "()" && JSON.stringify(coders) === JSON.stringify([]));
var EnumCoder = class extends Coder {
  name;
  coders;
  #caseIndexCoder;
  #encodedValueSize;
  constructor(name, coders) {
    const caseIndexCoder = new U64Coder;
    const encodedValueSize = Object.values(coders).reduce((max2, coder) => Math.max(max2, coder.encodedLength), 0);
    super("enum", `enum ${name}`, caseIndexCoder.encodedLength + encodedValueSize);
    this.name = name;
    this.coders = coders;
    this.#caseIndexCoder = caseIndexCoder;
    this.#encodedValueSize = encodedValueSize;
  }
  #encodeNativeEnum(value) {
    const valueCoder = this.coders[value];
    const encodedValue = valueCoder.encode([]);
    const caseIndex = Object.keys(this.coders).indexOf(value);
    const padding = new Uint8Array(this.#encodedValueSize - valueCoder.encodedLength);
    return concat2([this.#caseIndexCoder.encode(caseIndex), padding, encodedValue]);
  }
  encode(value) {
    if (typeof value === "string" && this.coders[value]) {
      return this.#encodeNativeEnum(value);
    }
    const [caseKey, ...empty] = Object.keys(value);
    if (!caseKey) {
      throw new FuelError(ErrorCode.INVALID_DECODE_VALUE, "A field for the case must be provided.");
    }
    if (empty.length !== 0) {
      throw new FuelError(ErrorCode.INVALID_DECODE_VALUE, "Only one field must be provided.");
    }
    const valueCoder = this.coders[caseKey];
    const caseIndex = Object.keys(this.coders).indexOf(caseKey);
    const encodedValue = valueCoder.encode(value[caseKey]);
    const padding = new Uint8Array(this.#encodedValueSize - valueCoder.encodedLength);
    return concatWithDynamicData([this.#caseIndexCoder.encode(caseIndex), padding, encodedValue]);
  }
  #decodeNativeEnum(caseKey, newOffset) {
    return [caseKey, newOffset];
  }
  decode(data3, offset) {
    let newOffset = offset;
    let decoded;
    [decoded, newOffset] = new U64Coder().decode(data3, newOffset);
    const caseIndex = toNumber2(decoded);
    const caseKey = Object.keys(this.coders)[caseIndex];
    if (!caseKey) {
      throw new FuelError(ErrorCode.INVALID_DECODE_VALUE, `Invalid caseIndex "${caseIndex}". Valid cases: ${Object.keys(this.coders)}.`);
    }
    const valueCoder = this.coders[caseKey];
    const padding = this.#encodedValueSize - valueCoder.encodedLength;
    newOffset += padding;
    [decoded, newOffset] = valueCoder.decode(data3, newOffset);
    if (isFullyNativeEnum(this.coders)) {
      return this.#decodeNativeEnum(caseKey, newOffset);
    }
    return [{ [caseKey]: decoded }, newOffset];
  }
};
var NumberCoder = class extends Coder {
  length;
  baseType;
  constructor(baseType) {
    super("number", baseType, 8);
    this.baseType = baseType;
    switch (baseType) {
      case "u8":
        this.length = 1;
        break;
      case "u16":
        this.length = 2;
        break;
      case "u32":
      default:
        this.length = 4;
        break;
    }
  }
  encode(value) {
    let bytes3;
    try {
      bytes3 = toBytes2(value);
    } catch (error) {
      this.throwError(ErrorCode.ENCODE_ERROR, `Invalid ${this.baseType}.`);
    }
    if (bytes3.length > this.length) {
      this.throwError(ErrorCode.ENCODE_ERROR, `Invalid ${this.baseType}, too many bytes.`);
    }
    return toBytes2(bytes3, 8);
  }
  decode(data3, offset) {
    let bytes3 = data3.slice(offset, offset + 8);
    bytes3 = bytes3.slice(8 - this.length, 8);
    return [toNumber2(bytes3), offset + 8];
  }
};
var StringCoder = class extends Coder {
  length;
  #paddingLength;
  constructor(length) {
    let paddingLength = (8 - length) % 8;
    paddingLength = paddingLength < 0 ? paddingLength + 8 : paddingLength;
    super("string", `str[${length}]`, length + paddingLength);
    this.length = length;
    this.#paddingLength = paddingLength;
  }
  encode(value) {
    if (this.length !== value.length) {
      this.throwError(ErrorCode.ENCODE_ERROR, `Value length mismatch during encode.`);
    }
    const encoded = toUtf8Bytes(value);
    const padding = new Uint8Array(this.#paddingLength);
    return concat2([encoded, padding]);
  }
  decode(data3, offset) {
    const bytes3 = data3.slice(offset, offset + this.length);
    const value = toUtf8String(bytes3);
    const padding = this.#paddingLength;
    return [value, offset + this.length + padding];
  }
};
var OptionCoder = class extends EnumCoder {
  encode(value) {
    const result = super.encode(this.toSwayOption(value));
    return result;
  }
  toSwayOption(input) {
    if (input !== undefined) {
      return { Some: input };
    }
    return { None: [] };
  }
  decode(data3, offset) {
    const [decoded, newOffset] = super.decode(data3, offset);
    return [this.toOption(decoded), newOffset];
  }
  toOption(output3) {
    if (output3 && ("Some" in output3)) {
      return output3.Some;
    }
    return;
  }
};
var StructCoder = class extends Coder {
  name;
  coders;
  constructor(name, coders) {
    const encodedLength = Object.values(coders).reduce((acc, coder) => acc + coder.encodedLength, 0);
    super("struct", `struct ${name}`, encodedLength);
    this.name = name;
    this.coders = coders;
  }
  encode(value) {
    const encodedFields = Object.keys(this.coders).map((fieldName) => {
      const fieldCoder = this.coders[fieldName];
      const fieldValue = value[fieldName];
      if (!(fieldCoder instanceof OptionCoder) && fieldValue == null) {
        this.throwError(ErrorCode.ENCODE_ERROR, `Invalid ${this.type}. Field "${fieldName}" not present.`);
      }
      const encoded = fieldCoder.encode(fieldValue);
      return encoded;
    });
    return concatWithDynamicData([concatWithDynamicData(encodedFields)]);
  }
  decode(data3, offset) {
    let newOffset = offset;
    const decodedValue = Object.keys(this.coders).reduce((obj, fieldName) => {
      const fieldCoder = this.coders[fieldName];
      let decoded;
      [decoded, newOffset] = fieldCoder.decode(data3, newOffset);
      obj[fieldName] = decoded;
      return obj;
    }, {});
    return [decodedValue, newOffset];
  }
};
var TupleCoder = class extends Coder {
  coders;
  constructor(coders) {
    const encodedLength = coders.reduce((acc, coder) => acc + coder.encodedLength, 0);
    super("tuple", `(${coders.map((coder) => coder.type).join(", ")})`, encodedLength);
    this.coders = coders;
  }
  encode(value) {
    if (this.coders.length !== value.length) {
      this.throwError(ErrorCode.ENCODE_ERROR, `Types/values length mismatch.`);
    }
    return concatWithDynamicData(this.coders.map((coder, i) => coder.encode(value[i])));
  }
  decode(data3, offset) {
    let newOffset = offset;
    const decodedValue = this.coders.map((coder) => {
      let decoded;
      [decoded, newOffset] = coder.decode(data3, newOffset);
      return decoded;
    });
    return [decodedValue, newOffset];
  }
};
var VecCoder = class extends Coder {
  coder;
  constructor(coder) {
    super("struct", `struct Vec`, coder.encodedLength + BASE_VECTOR_OFFSET);
    this.coder = coder;
  }
  encode(value) {
    if (!Array.isArray(value)) {
      this.throwError(ErrorCode.ENCODE_ERROR, `Expected array value.`);
    }
    const parts = [];
    const pointer = new U64Coder().encode(BASE_VECTOR_OFFSET);
    pointer.dynamicData = {
      0: concatWithDynamicData(Array.from(value).map((v2) => this.coder.encode(v2)))
    };
    parts.push(pointer);
    parts.push(new U64Coder().encode(value.length));
    parts.push(new U64Coder().encode(value.length));
    return concatWithDynamicData(parts);
  }
  decode(data3, offset) {
    const len = data3.slice(16, 24);
    const length = bn(new U64Coder().decode(len, 0)[0]).toNumber();
    const vectorRawData = data3.slice(BASE_VECTOR_OFFSET, BASE_VECTOR_OFFSET + length * this.coder.encodedLength);
    return [
      chunkByLength(vectorRawData, this.coder.encodedLength).map((chunk) => this.coder.decode(chunk, 0)[0]),
      offset + BASE_VECTOR_OFFSET
    ];
  }
};
var AssetIdCoder = class extends Coder {
  constructor() {
    super("AssetId", "struct AssetId", 32);
  }
  encode(value) {
    let encodedValue;
    try {
      encodedValue = getBytes(value);
    } catch (error) {
      this.throwError(ErrorCode.ENCODE_ERROR, `Invalid ${this.type}.`);
    }
    if (encodedValue.length !== 32) {
      this.throwError(ErrorCode.ENCODE_ERROR, `Invalid ${this.type}.`);
    }
    return encodedValue;
  }
  decode(data3, offset) {
    let bytes3 = data3.slice(offset, offset + 32);
    const decoded = bn(bytes3);
    if (decoded.isZero()) {
      bytes3 = new Uint8Array(32);
    }
    if (bytes3.length !== 32) {
      this.throwError(ErrorCode.DECODE_ERROR, `Invalid size for AssetId.`);
    }
    return [toHex(bytes3, 32), offset + 32];
  }
};
var _getPaddedData;
var getPaddedData_fn;
var ByteCoder = class extends Coder {
  constructor() {
    super("struct", "struct Bytes", BASE_VECTOR_OFFSET);
    __privateAdd(this, _getPaddedData);
  }
  encode(value) {
    if (!Array.isArray(value)) {
      this.throwError(ErrorCode.ENCODE_ERROR, `Expected array value.`);
    }
    const parts = [];
    const pointer = new U64Coder().encode(BASE_VECTOR_OFFSET);
    const data3 = __privateMethod(this, _getPaddedData, getPaddedData_fn).call(this, value);
    pointer.dynamicData = {
      0: concatWithDynamicData([data3])
    };
    parts.push(pointer);
    parts.push(new U64Coder().encode(data3.byteLength));
    parts.push(new U64Coder().encode(value.length));
    return concatWithDynamicData(parts);
  }
  decode(data3, offset) {
    const len = data3.slice(16, 24);
    const length = bn(new U64Coder().decode(len, 0)[0]).toNumber();
    const byteData = data3.slice(BASE_VECTOR_OFFSET, BASE_VECTOR_OFFSET + length * 8);
    return [byteData, offset + BASE_VECTOR_OFFSET];
  }
};
_getPaddedData = new WeakSet;
getPaddedData_fn = function(value) {
  const data3 = [Uint8Array.from(value)];
  const paddingLength = (WORD_SIZE - value.length % WORD_SIZE) % WORD_SIZE;
  if (paddingLength) {
    data3.push(new Uint8Array(paddingLength));
  }
  return concat2(data3);
};
__publicField3(ByteCoder, "memorySize", 1);
var RawSliceCoder = class extends Coder {
  constructor() {
    super("raw untyped slice", "raw untyped slice", BASE_RAW_SLICE_OFFSET);
  }
  encode(value) {
    if (!Array.isArray(value)) {
      this.throwError(ErrorCode.ENCODE_ERROR, `Expected array value.`);
    }
    const parts = [];
    const coder = new U64Coder;
    const pointer = new U64Coder().encode(BASE_RAW_SLICE_OFFSET);
    pointer.dynamicData = {
      0: concatWithDynamicData(value.map((v2) => coder.encode(v2)))
    };
    parts.push(pointer);
    parts.push(new U64Coder().encode(value.length * WORD_SIZE));
    return concatWithDynamicData(parts);
  }
  decode(data3, offset) {
    const internalCoder = new ArrayCoder(new U64Coder, data3.length / 8);
    const decoded = internalCoder.decode(data3, offset);
    return decoded;
  }
};
var _getPaddedData2;
var getPaddedData_fn2;
var StdStringCoder = class extends Coder {
  constructor() {
    super("struct", "struct String", 1);
    __privateAdd(this, _getPaddedData2);
  }
  encode(value) {
    const parts = [];
    const pointer = new U64Coder().encode(BASE_VECTOR_OFFSET);
    const data3 = __privateMethod(this, _getPaddedData2, getPaddedData_fn2).call(this, value);
    pointer.dynamicData = {
      0: concatWithDynamicData([data3])
    };
    parts.push(pointer);
    parts.push(new U64Coder().encode(data3.byteLength));
    parts.push(new U64Coder().encode(value.length));
    return concatWithDynamicData(parts);
  }
  decode(data3, offset) {
    const len = data3.slice(16, 24);
    const length = bn(new U64Coder().decode(len, 0)[0]).toNumber();
    const byteData = data3.slice(BASE_VECTOR_OFFSET, BASE_VECTOR_OFFSET + length);
    const value = toUtf8String(byteData);
    return [value, offset + BASE_VECTOR_OFFSET];
  }
};
_getPaddedData2 = new WeakSet;
getPaddedData_fn2 = function(value) {
  const data3 = [toUtf8Bytes(value)];
  const paddingLength = (WORD_SIZE - value.length % WORD_SIZE) % WORD_SIZE;
  if (paddingLength) {
    data3.push(new Uint8Array(paddingLength));
  }
  return concat2(data3);
};
__publicField3(StdStringCoder, "memorySize", 1);
var ResolvedAbiType = class {
  abi;
  name;
  type;
  originalTypeArguments;
  components;
  constructor(abi, argument) {
    this.abi = abi;
    const type = findOrThrow(abi.types, (t) => t.typeId === argument.type, () => {
      throw new FuelError(ErrorCode.TYPE_NOT_FOUND, `Type does not exist in the provided abi: ${JSON.stringify({
        argument,
        abi: this.abi
      })}`);
    });
    this.name = argument.name;
    this.type = type.type;
    this.originalTypeArguments = argument.typeArguments;
    this.components = ResolvedAbiType.getResolvedGenericComponents(abi, argument, type.components, type.typeParameters ?? ResolvedAbiType.getImplicitGenericTypeParameters(abi, type.components));
  }
  static getResolvedGenericComponents(abi, arg, components, typeParameters) {
    if (components === null)
      return null;
    if (typeParameters === null || typeParameters.length === 0)
      return components.map((c) => new ResolvedAbiType(abi, c));
    const typeParametersAndArgsMap = typeParameters.reduce((obj, typeParameter, typeParameterIndex) => {
      const o = { ...obj };
      o[typeParameter] = structuredClone(arg.typeArguments?.[typeParameterIndex]);
      return o;
    }, {});
    const resolvedComponents = this.resolveGenericArgTypes(abi, components, typeParametersAndArgsMap);
    return resolvedComponents.map((c) => new ResolvedAbiType(abi, c));
  }
  static resolveGenericArgTypes(abi, args, typeParametersAndArgsMap) {
    return args.map((arg) => {
      if (typeParametersAndArgsMap[arg.type] !== undefined) {
        return {
          ...typeParametersAndArgsMap[arg.type],
          name: arg.name
        };
      }
      if (arg.typeArguments) {
        return {
          ...structuredClone(arg),
          typeArguments: this.resolveGenericArgTypes(abi, arg.typeArguments, typeParametersAndArgsMap)
        };
      }
      const argType = findOrThrow(abi.types, (t) => t.typeId === arg.type);
      const implicitTypeParameters = this.getImplicitGenericTypeParameters(abi, argType.components);
      if (implicitTypeParameters && implicitTypeParameters.length > 0) {
        return {
          ...structuredClone(arg),
          typeArguments: implicitTypeParameters.map((itp) => typeParametersAndArgsMap[itp])
        };
      }
      return arg;
    });
  }
  static getImplicitGenericTypeParameters(abi, args, implicitGenericParametersParam) {
    if (!Array.isArray(args))
      return null;
    const implicitGenericParameters = implicitGenericParametersParam ?? [];
    args.forEach((a) => {
      const argType = findOrThrow(abi.types, (t) => t.typeId === a.type);
      if (genericRegEx.test(argType.type)) {
        implicitGenericParameters.push(argType.typeId);
        return;
      }
      if (!Array.isArray(a.typeArguments))
        return;
      this.getImplicitGenericTypeParameters(abi, a.typeArguments, implicitGenericParameters);
    });
    return implicitGenericParameters.length > 0 ? implicitGenericParameters : null;
  }
  getSignature() {
    const prefix = this.getArgSignaturePrefix();
    const content = this.getArgSignatureContent();
    return `${prefix}${content}`;
  }
  getArgSignaturePrefix() {
    const structMatch = structRegEx.test(this.type);
    if (structMatch)
      return "s";
    const arrayMatch = arrayRegEx.test(this.type);
    if (arrayMatch)
      return "a";
    const enumMatch = enumRegEx.test(this.type);
    if (enumMatch)
      return "e";
    return "";
  }
  getArgSignatureContent() {
    if (this.type === "raw untyped ptr") {
      return "rawptr";
    }
    if (this.type === "raw untyped slice") {
      return "rawslice";
    }
    const strMatch = stringRegEx.exec(this.type)?.groups;
    if (strMatch) {
      return `str[${strMatch.length}]`;
    }
    if (this.components === null)
      return this.type;
    const arrayMatch = arrayRegEx.exec(this.type)?.groups;
    if (arrayMatch) {
      return `[${this.components[0].getSignature()};${arrayMatch.length}]`;
    }
    const typeArgumentsSignature = this.originalTypeArguments !== null ? `<${this.originalTypeArguments.map((a) => new ResolvedAbiType(this.abi, a).getSignature()).join(",")}>` : "";
    const componentsSignature = `(${this.components.map((c) => c.getSignature()).join(",")})`;
    return `${typeArgumentsSignature}${componentsSignature}`;
  }
};
var AbiCoder = class {
  static getCoder(abi, argument) {
    const resolvedAbiType = new ResolvedAbiType(abi, argument);
    return AbiCoder.getCoderImpl(resolvedAbiType);
  }
  static encode(abi, argument, value) {
    return this.getCoder(abi, argument).encode(value);
  }
  static decode(abi, argument, data3, offset) {
    return this.getCoder(abi, argument).decode(data3, offset);
  }
  static getCoderImpl(resolvedAbiType) {
    switch (resolvedAbiType.type) {
      case "u8":
      case "u16":
      case "u32":
        return new NumberCoder(resolvedAbiType.type);
      case "u64":
      case "raw untyped ptr":
        return new U64Coder;
      case "raw untyped slice":
        return new RawSliceCoder;
      case "bool":
        return new BooleanCoder;
      case "b256":
        return new B256Coder;
      case "struct B512":
        return new B512Coder;
      case "struct AssetId":
        return new AssetIdCoder;
      case BYTES_CODER_TYPE:
        return new ByteCoder;
      case STD_STRING_CODER_TYPE:
        return new StdStringCoder;
      default:
        break;
    }
    const stringMatch = stringRegEx.exec(resolvedAbiType.type)?.groups;
    if (stringMatch) {
      const length = parseInt(stringMatch.length, 10);
      return new StringCoder(length);
    }
    const components = resolvedAbiType.components;
    const arrayMatch = arrayRegEx.exec(resolvedAbiType.type)?.groups;
    if (arrayMatch) {
      const length = parseInt(arrayMatch.length, 10);
      const arg = components[0];
      if (!arg) {
        throw new FuelError(ErrorCode.INVALID_COMPONENT, `The provided Array type is missing an item of 'component'.`);
      }
      const arrayElementCoder = AbiCoder.getCoderImpl(arg);
      return new ArrayCoder(arrayElementCoder, length);
    }
    if (resolvedAbiType.type === VEC_CODER_TYPE) {
      const arg = findOrThrow(components, (c) => c.name === "buf").originalTypeArguments?.[0];
      if (!arg) {
        throw new FuelError(ErrorCode.INVALID_COMPONENT, `The provided Vec type is missing the 'type argument'.`);
      }
      const argType = new ResolvedAbiType(resolvedAbiType.abi, arg);
      const itemCoder = AbiCoder.getCoderImpl(argType);
      return new VecCoder(itemCoder);
    }
    const structMatch = structRegEx.exec(resolvedAbiType.type)?.groups;
    if (structMatch) {
      const coders = AbiCoder.getCoders(components);
      return new StructCoder(structMatch.name, coders);
    }
    const enumMatch = enumRegEx.exec(resolvedAbiType.type)?.groups;
    if (enumMatch) {
      const coders = AbiCoder.getCoders(components);
      const isOptionEnum = resolvedAbiType.type === OPTION_CODER_TYPE;
      if (isOptionEnum) {
        return new OptionCoder(enumMatch.name, coders);
      }
      return new EnumCoder(enumMatch.name, coders);
    }
    const tupleMatch = tupleRegEx.exec(resolvedAbiType.type)?.groups;
    if (tupleMatch) {
      const coders = components.map((component) => AbiCoder.getCoderImpl(component));
      return new TupleCoder(coders);
    }
    if (resolvedAbiType.type === "str") {
      throw new FuelError(ErrorCode.INVALID_DATA, "String slices can not be decoded from logs. Convert the slice to `str[N]` with `__to_str_array`");
    }
    throw new FuelError(ErrorCode.CODER_NOT_FOUND, `Coder not found: ${JSON.stringify(resolvedAbiType)}.`);
  }
  static getCoders(components) {
    return components.reduce((obj, component) => {
      const o = obj;
      o[component.name] = AbiCoder.getCoderImpl(component);
      return o;
    }, {});
  }
};
var FunctionFragment = class {
  signature;
  selector;
  name;
  jsonFn;
  attributes;
  isInputDataPointer;
  outputMetadata;
  jsonAbi;
  constructor(jsonAbi, name) {
    this.jsonAbi = jsonAbi;
    this.jsonFn = findOrThrow(this.jsonAbi.functions, (f2) => f2.name === name);
    this.name = name;
    this.signature = FunctionFragment.getSignature(this.jsonAbi, this.jsonFn);
    this.selector = FunctionFragment.getFunctionSelector(this.signature);
    this.isInputDataPointer = this.#isInputDataPointer();
    this.outputMetadata = {
      isHeapType: this.#isOutputDataHeap(),
      encodedLength: this.#getOutputEncodedLength()
    };
    this.attributes = this.jsonFn.attributes ?? [];
  }
  static getSignature(abi, fn) {
    const inputsSignatures = fn.inputs.map((input) => new ResolvedAbiType(abi, input).getSignature());
    return `${fn.name}(${inputsSignatures.join(",")})`;
  }
  static getFunctionSelector(functionSignature) {
    const hashedFunctionSignature = sha2563(bufferFromString2(functionSignature, "utf-8"));
    return bn(hashedFunctionSignature.slice(0, 10)).toHex(8);
  }
  #isInputDataPointer() {
    const inputTypes = this.jsonFn.inputs.map((i) => this.jsonAbi.types.find((t) => t.typeId === i.type));
    return this.jsonFn.inputs.length > 1 || isPointerType(inputTypes[0]?.type || "");
  }
  #isOutputDataHeap() {
    const outputType = findOrThrow(this.jsonAbi.types, (t) => t.typeId === this.jsonFn.output.type);
    return isHeapType(outputType?.type || "");
  }
  #getOutputEncodedLength() {
    try {
      const heapCoder = AbiCoder.getCoder(this.jsonAbi, this.jsonFn.output);
      if (heapCoder instanceof VecCoder) {
        return heapCoder.coder.encodedLength;
      }
      if (heapCoder instanceof ByteCoder) {
        return ByteCoder.memorySize;
      }
      return heapCoder.encodedLength;
    } catch (e) {
      return 0;
    }
  }
  encodeArguments(values, offset = 0) {
    FunctionFragment.verifyArgsAndInputsAlign(values, this.jsonFn.inputs, this.jsonAbi);
    const shallowCopyValues = values.slice();
    const nonEmptyInputs = this.jsonFn.inputs.filter((x) => findOrThrow(this.jsonAbi.types, (t) => t.typeId === x.type).type !== "()");
    if (Array.isArray(values) && nonEmptyInputs.length !== values.length) {
      shallowCopyValues.length = this.jsonFn.inputs.length;
      shallowCopyValues.fill(undefined, values.length);
    }
    const coders = nonEmptyInputs.map((t) => AbiCoder.getCoder(this.jsonAbi, t));
    const coder = new TupleCoder(coders);
    const results = coder.encode(shallowCopyValues);
    return unpackDynamicData(results, offset, results.byteLength);
  }
  static verifyArgsAndInputsAlign(args, inputs, abi) {
    if (args.length === inputs.length)
      return;
    const inputTypes = inputs.map((i) => findOrThrow(abi.types, (t) => t.typeId === i.type));
    const optionalInputs = inputTypes.filter((x) => x.type === OPTION_CODER_TYPE || x.type === "()");
    if (optionalInputs.length === inputTypes.length)
      return;
    if (inputTypes.length - optionalInputs.length === args.length)
      return;
    const errorMsg = `Mismatch between provided arguments and expected ABI inputs. Provided ${args.length} arguments, but expected ${inputs.length - optionalInputs.length} (excluding ${optionalInputs.length} optional inputs).`;
    throw new FuelError(ErrorCode.ABI_TYPES_AND_VALUES_MISMATCH, errorMsg);
  }
  decodeArguments(data3) {
    const bytes3 = getBytesCopy(data3);
    const nonEmptyInputs = this.jsonFn.inputs.filter((x) => findOrThrow(this.jsonAbi.types, (t) => t.typeId === x.type).type !== "()");
    if (nonEmptyInputs.length === 0) {
      if (bytes3.length === 0)
        return;
      throw new FuelError(ErrorCode.DECODE_ERROR, `Types/values length mismatch during decode. ${JSON.stringify({
        count: {
          types: this.jsonFn.inputs.length,
          nonEmptyInputs: nonEmptyInputs.length,
          values: bytes3.length
        },
        value: {
          args: this.jsonFn.inputs,
          nonEmptyInputs,
          values: bytes3
        }
      })}`);
    }
    const result = nonEmptyInputs.reduce((obj, input) => {
      const coder = AbiCoder.getCoder(this.jsonAbi, input);
      const [decodedValue, decodedValueByteSize] = coder.decode(bytes3, obj.offset);
      return {
        decoded: [...obj.decoded, decodedValue],
        offset: obj.offset + decodedValueByteSize
      };
    }, { decoded: [], offset: 0 });
    return result.decoded;
  }
  decodeOutput(data3) {
    const outputAbiType = findOrThrow(this.jsonAbi.types, (t) => t.typeId === this.jsonFn.output.type);
    if (outputAbiType.type === "()")
      return [undefined, 0];
    const bytes3 = getBytesCopy(data3);
    const coder = AbiCoder.getCoder(this.jsonAbi, this.jsonFn.output);
    if (outputAbiType.type === "raw untyped slice") {
      coder.length = bytes3.length / 8;
    }
    return coder.decode(bytes3, 0);
  }
};
var Interface = class {
  functions;
  configurables;
  externalLoggedTypes;
  jsonAbi;
  constructor(jsonAbi) {
    this.jsonAbi = jsonAbi;
    this.externalLoggedTypes = {};
    this.functions = Object.fromEntries(this.jsonAbi.functions.map((x) => [x.name, new FunctionFragment(this.jsonAbi, x.name)]));
    this.configurables = Object.fromEntries(this.jsonAbi.configurables.map((x) => [x.name, x]));
  }
  getFunction(nameOrSignatureOrSelector) {
    const fn = Object.values(this.functions).find((f2) => f2.name === nameOrSignatureOrSelector || f2.signature === nameOrSignatureOrSelector || f2.selector === nameOrSignatureOrSelector);
    if (fn !== undefined)
      return fn;
    throw new FuelError(ErrorCode.FUNCTION_NOT_FOUND, `function ${nameOrSignatureOrSelector} not found: ${JSON.stringify(fn)}.`);
  }
  decodeFunctionData(functionFragment, data3) {
    const fragment = typeof functionFragment === "string" ? this.getFunction(functionFragment) : functionFragment;
    if (!fragment) {
      throw new FuelError(ErrorCode.FRAGMENT_NOT_FOUND, "Fragment not found.");
    }
    return fragment.decodeArguments(data3);
  }
  encodeFunctionData(functionFragment, values, offset = 0) {
    const fragment = typeof functionFragment === "string" ? this.getFunction(functionFragment) : functionFragment;
    if (!fragment) {
      throw new FuelError(ErrorCode.FRAGMENT_NOT_FOUND, "Fragment not found.");
    }
    return fragment.encodeArguments(values, offset);
  }
  decodeFunctionResult(functionFragment, data3) {
    const fragment = typeof functionFragment === "string" ? this.getFunction(functionFragment) : functionFragment;
    return fragment.decodeOutput(data3);
  }
  decodeLog(data3, logId, receiptId) {
    const isExternalLoggedType = this.externalLoggedTypes[receiptId];
    if (isExternalLoggedType) {
      const externalInterface = this.externalLoggedTypes[receiptId];
      return externalInterface.decodeLog(data3, logId, receiptId);
    }
    const { loggedType } = findOrThrow(this.jsonAbi.loggedTypes, (type) => type.logId === logId);
    return AbiCoder.decode(this.jsonAbi, loggedType, getBytesCopy(data3), 0);
  }
  updateExternalLoggedTypes(id, loggedTypes) {
    this.externalLoggedTypes[id] = loggedTypes;
  }
  encodeConfigurable(name, value) {
    const configurable = findOrThrow(this.jsonAbi.configurables, (c) => c.name === name, () => {
      throw new FuelError(ErrorCode.CONFIGURABLE_NOT_FOUND, `A configurable with the '${name}' was not found in the ABI.`);
    });
    return AbiCoder.encode(this.jsonAbi, configurable.configurableType, value);
  }
  getTypeById(typeId) {
    return findOrThrow(this.jsonAbi.types, (t) => t.typeId === typeId, () => {
      throw new FuelError(ErrorCode.TYPE_NOT_FOUND, `Type with typeId '${typeId}' doesn't exist in the ABI.`);
    });
  }
};

// node_modules/@fuel-ts/interfaces/dist/index.mjs
var AbstractAddress = class {
};
var AbstractAccount = class {
};
var AbstractProgram = class {
};
var AbstractContract = class extends AbstractProgram {
};

// node_modules/@fuel-ts/transactions/dist/index.mjs
var ByteArrayCoder = class extends Coder {
  length;
  #paddingLength;
  constructor(length) {
    const paddingLength = (8 - length % 8) % 8;
    const encodedLength = length + paddingLength;
    super("ByteArray", `[u64; ${encodedLength / 4}]`, encodedLength);
    this.length = length;
    this.#paddingLength = paddingLength;
  }
  encode(value) {
    const parts = [];
    const data3 = getBytesCopy(value);
    parts.push(data3);
    if (this.#paddingLength) {
      parts.push(new Uint8Array(this.#paddingLength));
    }
    return concat2(parts);
  }
  decode(data3, offset) {
    let decoded;
    let o = offset;
    [decoded, o] = [hexlify(data3.slice(o, o + this.length)), o + this.length];
    const value = decoded;
    if (this.#paddingLength) {
      [decoded, o] = [null, o + this.#paddingLength];
    }
    return [value, o];
  }
};
var TxPointerCoder = class extends StructCoder {
  constructor() {
    super("TxPointer", {
      blockHeight: new NumberCoder("u32"),
      txIndex: new NumberCoder("u16")
    });
  }
};
var UtxoIdCoder = class extends StructCoder {
  constructor() {
    super("UtxoId", {
      transactionId: new B256Coder,
      outputIndex: new NumberCoder("u8")
    });
  }
};
var InputType = ((InputType2) => {
  InputType2[InputType2["Coin"] = 0] = "Coin";
  InputType2[InputType2["Contract"] = 1] = "Contract";
  InputType2[InputType2["Message"] = 2] = "Message";
  return InputType2;
})(InputType || {});
var InputCoinCoder = class extends Coder {
  constructor() {
    super("InputCoin", "struct InputCoin", 0);
  }
  encode(value) {
    const parts = [];
    parts.push(new UtxoIdCoder().encode(value.utxoID));
    parts.push(new B256Coder().encode(value.owner));
    parts.push(new U64Coder().encode(value.amount));
    parts.push(new B256Coder().encode(value.assetId));
    parts.push(new TxPointerCoder().encode(value.txPointer));
    parts.push(new NumberCoder("u8").encode(value.witnessIndex));
    parts.push(new NumberCoder("u32").encode(value.maturity));
    parts.push(new U64Coder().encode(value.predicateGasUsed));
    parts.push(new NumberCoder("u32").encode(value.predicateLength));
    parts.push(new NumberCoder("u32").encode(value.predicateDataLength));
    parts.push(new ByteArrayCoder(value.predicateLength).encode(value.predicate));
    parts.push(new ByteArrayCoder(value.predicateDataLength).encode(value.predicateData));
    return concat2(parts);
  }
  decode(data3, offset) {
    let decoded;
    let o = offset;
    [decoded, o] = new UtxoIdCoder().decode(data3, o);
    const utxoID = decoded;
    [decoded, o] = new B256Coder().decode(data3, o);
    const owner = decoded;
    [decoded, o] = new U64Coder().decode(data3, o);
    const amount = decoded;
    [decoded, o] = new B256Coder().decode(data3, o);
    const assetId = decoded;
    [decoded, o] = new TxPointerCoder().decode(data3, o);
    const txPointer = decoded;
    [decoded, o] = new NumberCoder("u8").decode(data3, o);
    const witnessIndex = Number(decoded);
    [decoded, o] = new NumberCoder("u32").decode(data3, o);
    const maturity = decoded;
    [decoded, o] = new U64Coder().decode(data3, o);
    const predicateGasUsed = decoded;
    [decoded, o] = new NumberCoder("u32").decode(data3, o);
    const predicateLength = decoded;
    [decoded, o] = new NumberCoder("u32").decode(data3, o);
    const predicateDataLength = decoded;
    [decoded, o] = new ByteArrayCoder(predicateLength).decode(data3, o);
    const predicate = decoded;
    [decoded, o] = new ByteArrayCoder(predicateDataLength).decode(data3, o);
    const predicateData = decoded;
    return [
      {
        type: 0,
        utxoID,
        owner,
        amount,
        assetId,
        txPointer,
        witnessIndex,
        maturity,
        predicateGasUsed,
        predicateLength,
        predicateDataLength,
        predicate,
        predicateData
      },
      o
    ];
  }
};
var InputContractCoder = class extends Coder {
  constructor() {
    super("InputContract", "struct InputContract", 0);
  }
  encode(value) {
    const parts = [];
    parts.push(new UtxoIdCoder().encode(value.utxoID));
    parts.push(new B256Coder().encode(value.balanceRoot));
    parts.push(new B256Coder().encode(value.stateRoot));
    parts.push(new TxPointerCoder().encode(value.txPointer));
    parts.push(new B256Coder().encode(value.contractID));
    return concat2(parts);
  }
  decode(data3, offset) {
    let decoded;
    let o = offset;
    [decoded, o] = new UtxoIdCoder().decode(data3, o);
    const utxoID = decoded;
    [decoded, o] = new B256Coder().decode(data3, o);
    const balanceRoot = decoded;
    [decoded, o] = new B256Coder().decode(data3, o);
    const stateRoot = decoded;
    [decoded, o] = new TxPointerCoder().decode(data3, o);
    const txPointer = decoded;
    [decoded, o] = new B256Coder().decode(data3, o);
    const contractID = decoded;
    return [
      {
        type: 1,
        utxoID,
        balanceRoot,
        stateRoot,
        txPointer,
        contractID
      },
      o
    ];
  }
};
var InputMessageCoder = class extends Coder {
  constructor() {
    super("InputMessage", "struct InputMessage", 0);
  }
  static getMessageId(value) {
    const parts = [];
    parts.push(new ByteArrayCoder(32).encode(value.sender));
    parts.push(new ByteArrayCoder(32).encode(value.recipient));
    parts.push(new ByteArrayCoder(32).encode(value.nonce));
    parts.push(new U64Coder().encode(value.amount));
    parts.push(getBytesCopy(value.data || "0x"));
    return sha2563(concat2(parts));
  }
  static encodeData(messageData) {
    const bytes3 = getBytesCopy(messageData || "0x");
    const dataLength2 = bytes3.length;
    return new ByteArrayCoder(dataLength2).encode(bytes3);
  }
  encode(value) {
    const parts = [];
    const data3 = InputMessageCoder.encodeData(value.data);
    parts.push(new ByteArrayCoder(32).encode(value.sender));
    parts.push(new ByteArrayCoder(32).encode(value.recipient));
    parts.push(new U64Coder().encode(value.amount));
    parts.push(new ByteArrayCoder(32).encode(value.nonce));
    parts.push(new NumberCoder("u8").encode(value.witnessIndex));
    parts.push(new U64Coder().encode(value.predicateGasUsed));
    parts.push(new NumberCoder("u16").encode(data3.length));
    parts.push(new NumberCoder("u16").encode(value.predicateLength));
    parts.push(new NumberCoder("u16").encode(value.predicateDataLength));
    parts.push(new ByteArrayCoder(data3.length).encode(data3));
    parts.push(new ByteArrayCoder(value.predicateLength).encode(value.predicate));
    parts.push(new ByteArrayCoder(value.predicateDataLength).encode(value.predicateData));
    return concat2(parts);
  }
  static decodeData(messageData) {
    const bytes3 = getBytesCopy(messageData);
    const dataLength2 = bytes3.length;
    const [data3] = new ByteArrayCoder(dataLength2).decode(bytes3, 0);
    return getBytesCopy(data3);
  }
  decode(data3, offset) {
    let decoded;
    let o = offset;
    [decoded, o] = new B256Coder().decode(data3, o);
    const sender = decoded;
    [decoded, o] = new B256Coder().decode(data3, o);
    const recipient = decoded;
    [decoded, o] = new U64Coder().decode(data3, o);
    const amount = decoded;
    [decoded, o] = new B256Coder().decode(data3, o);
    const nonce = decoded;
    [decoded, o] = new NumberCoder("u8").decode(data3, o);
    const witnessIndex = Number(decoded);
    [decoded, o] = new U64Coder().decode(data3, o);
    const predicateGasUsed = decoded;
    [decoded, o] = new NumberCoder("u16").decode(data3, o);
    const predicateLength = decoded;
    [decoded, o] = new NumberCoder("u16").decode(data3, o);
    const dataLength2 = decoded;
    [decoded, o] = new NumberCoder("u16").decode(data3, o);
    const predicateDataLength = decoded;
    [decoded, o] = new ByteArrayCoder(dataLength2).decode(data3, o);
    const messageData = decoded;
    [decoded, o] = new ByteArrayCoder(predicateLength).decode(data3, o);
    const predicate = decoded;
    [decoded, o] = new ByteArrayCoder(predicateDataLength).decode(data3, o);
    const predicateData = decoded;
    return [
      {
        type: 2,
        sender,
        recipient,
        amount,
        witnessIndex,
        nonce,
        predicateGasUsed,
        dataLength: dataLength2,
        predicateLength,
        predicateDataLength,
        data: messageData,
        predicate,
        predicateData
      },
      o
    ];
  }
};
var InputCoder = class extends Coder {
  constructor() {
    super("Input", "struct Input", 0);
  }
  encode(value) {
    const parts = [];
    parts.push(new NumberCoder("u8").encode(value.type));
    const { type } = value;
    switch (type) {
      case 0: {
        parts.push(new InputCoinCoder().encode(value));
        break;
      }
      case 1: {
        parts.push(new InputContractCoder().encode(value));
        break;
      }
      case 2: {
        parts.push(new InputMessageCoder().encode(value));
        break;
      }
      default: {
        throw new FuelError(ErrorCode.INVALID_TRANSACTION_INPUT, `Invalid transaction input type: ${type}.`);
      }
    }
    return concat2(parts);
  }
  decode(data3, offset) {
    let decoded;
    let o = offset;
    [decoded, o] = new NumberCoder("u8").decode(data3, o);
    const type = decoded;
    switch (type) {
      case 0: {
        [decoded, o] = new InputCoinCoder().decode(data3, o);
        return [decoded, o];
      }
      case 1: {
        [decoded, o] = new InputContractCoder().decode(data3, o);
        return [decoded, o];
      }
      case 2: {
        [decoded, o] = new InputMessageCoder().decode(data3, o);
        return [decoded, o];
      }
      default: {
        throw new FuelError(ErrorCode.INVALID_TRANSACTION_INPUT, `Invalid transaction input type: ${type}.`);
      }
    }
  }
};
var OutputType = ((OutputType2) => {
  OutputType2[OutputType2["Coin"] = 0] = "Coin";
  OutputType2[OutputType2["Contract"] = 1] = "Contract";
  OutputType2[OutputType2["Change"] = 2] = "Change";
  OutputType2[OutputType2["Variable"] = 3] = "Variable";
  OutputType2[OutputType2["ContractCreated"] = 4] = "ContractCreated";
  return OutputType2;
})(OutputType || {});
var OutputCoinCoder = class extends Coder {
  constructor() {
    super("OutputCoin", "struct OutputCoin", 0);
  }
  encode(value) {
    const parts = [];
    parts.push(new B256Coder().encode(value.to));
    parts.push(new U64Coder().encode(value.amount));
    parts.push(new B256Coder().encode(value.assetId));
    return concat2(parts);
  }
  decode(data3, offset) {
    let decoded;
    let o = offset;
    [decoded, o] = new B256Coder().decode(data3, o);
    const to = decoded;
    [decoded, o] = new U64Coder().decode(data3, o);
    const amount = decoded;
    [decoded, o] = new B256Coder().decode(data3, o);
    const assetId = decoded;
    return [
      {
        type: 0,
        to,
        amount,
        assetId
      },
      o
    ];
  }
};
var OutputContractCoder = class extends Coder {
  constructor() {
    super("OutputContract", "struct OutputContract", 0);
  }
  encode(value) {
    const parts = [];
    parts.push(new NumberCoder("u8").encode(value.inputIndex));
    parts.push(new B256Coder().encode(value.balanceRoot));
    parts.push(new B256Coder().encode(value.stateRoot));
    return concat2(parts);
  }
  decode(data3, offset) {
    let decoded;
    let o = offset;
    [decoded, o] = new NumberCoder("u8").decode(data3, o);
    const inputIndex = decoded;
    [decoded, o] = new B256Coder().decode(data3, o);
    const balanceRoot = decoded;
    [decoded, o] = new B256Coder().decode(data3, o);
    const stateRoot = decoded;
    return [
      {
        type: 1,
        inputIndex,
        balanceRoot,
        stateRoot
      },
      o
    ];
  }
};
var OutputChangeCoder = class extends Coder {
  constructor() {
    super("OutputChange", "struct OutputChange", 0);
  }
  encode(value) {
    const parts = [];
    parts.push(new B256Coder().encode(value.to));
    parts.push(new U64Coder().encode(value.amount));
    parts.push(new B256Coder().encode(value.assetId));
    return concat2(parts);
  }
  decode(data3, offset) {
    let decoded;
    let o = offset;
    [decoded, o] = new B256Coder().decode(data3, o);
    const to = decoded;
    [decoded, o] = new U64Coder().decode(data3, o);
    const amount = decoded;
    [decoded, o] = new B256Coder().decode(data3, o);
    const assetId = decoded;
    return [
      {
        type: 2,
        to,
        amount,
        assetId
      },
      o
    ];
  }
};
var OutputVariableCoder = class extends Coder {
  constructor() {
    super("OutputVariable", "struct OutputVariable", 0);
  }
  encode(value) {
    const parts = [];
    parts.push(new B256Coder().encode(value.to));
    parts.push(new U64Coder().encode(value.amount));
    parts.push(new B256Coder().encode(value.assetId));
    return concat2(parts);
  }
  decode(data3, offset) {
    let decoded;
    let o = offset;
    [decoded, o] = new B256Coder().decode(data3, o);
    const to = decoded;
    [decoded, o] = new U64Coder().decode(data3, o);
    const amount = decoded;
    [decoded, o] = new B256Coder().decode(data3, o);
    const assetId = decoded;
    return [
      {
        type: 3,
        to,
        amount,
        assetId
      },
      o
    ];
  }
};
var OutputContractCreatedCoder = class extends Coder {
  constructor() {
    super("OutputContractCreated", "struct OutputContractCreated", 0);
  }
  encode(value) {
    const parts = [];
    parts.push(new B256Coder().encode(value.contractId));
    parts.push(new B256Coder().encode(value.stateRoot));
    return concat2(parts);
  }
  decode(data3, offset) {
    let decoded;
    let o = offset;
    [decoded, o] = new B256Coder().decode(data3, o);
    const contractId = decoded;
    [decoded, o] = new B256Coder().decode(data3, o);
    const stateRoot = decoded;
    return [
      {
        type: 4,
        contractId,
        stateRoot
      },
      o
    ];
  }
};
var OutputCoder = class extends Coder {
  constructor() {
    super("Output", " struct Output", 0);
  }
  encode(value) {
    const parts = [];
    parts.push(new NumberCoder("u8").encode(value.type));
    const { type } = value;
    switch (type) {
      case 0: {
        parts.push(new OutputCoinCoder().encode(value));
        break;
      }
      case 1: {
        parts.push(new OutputContractCoder().encode(value));
        break;
      }
      case 2: {
        parts.push(new OutputChangeCoder().encode(value));
        break;
      }
      case 3: {
        parts.push(new OutputVariableCoder().encode(value));
        break;
      }
      case 4: {
        parts.push(new OutputContractCreatedCoder().encode(value));
        break;
      }
      default: {
        throw new FuelError(ErrorCode.INVALID_TRANSACTION_OUTPUT, `Invalid transaction output type: ${type}.`);
      }
    }
    return concat2(parts);
  }
  decode(data3, offset) {
    let decoded;
    let o = offset;
    [decoded, o] = new NumberCoder("u8").decode(data3, o);
    const type = decoded;
    switch (type) {
      case 0: {
        [decoded, o] = new OutputCoinCoder().decode(data3, o);
        return [decoded, o];
      }
      case 1: {
        [decoded, o] = new OutputContractCoder().decode(data3, o);
        return [decoded, o];
      }
      case 2: {
        [decoded, o] = new OutputChangeCoder().decode(data3, o);
        return [decoded, o];
      }
      case 3: {
        [decoded, o] = new OutputVariableCoder().decode(data3, o);
        return [decoded, o];
      }
      case 4: {
        [decoded, o] = new OutputContractCreatedCoder().decode(data3, o);
        return [decoded, o];
      }
      default: {
        throw new FuelError(ErrorCode.INVALID_TRANSACTION_OUTPUT, `Invalid transaction output type: ${type}.`);
      }
    }
  }
};
var ReceiptType = ((ReceiptType2) => {
  ReceiptType2[ReceiptType2["Call"] = 0] = "Call";
  ReceiptType2[ReceiptType2["Return"] = 1] = "Return";
  ReceiptType2[ReceiptType2["ReturnData"] = 2] = "ReturnData";
  ReceiptType2[ReceiptType2["Panic"] = 3] = "Panic";
  ReceiptType2[ReceiptType2["Revert"] = 4] = "Revert";
  ReceiptType2[ReceiptType2["Log"] = 5] = "Log";
  ReceiptType2[ReceiptType2["LogData"] = 6] = "LogData";
  ReceiptType2[ReceiptType2["Transfer"] = 7] = "Transfer";
  ReceiptType2[ReceiptType2["TransferOut"] = 8] = "TransferOut";
  ReceiptType2[ReceiptType2["ScriptResult"] = 9] = "ScriptResult";
  ReceiptType2[ReceiptType2["MessageOut"] = 10] = "MessageOut";
  ReceiptType2[ReceiptType2["Mint"] = 11] = "Mint";
  ReceiptType2[ReceiptType2["Burn"] = 12] = "Burn";
  return ReceiptType2;
})(ReceiptType || {});
var ReceiptMessageOutCoder = class extends Coder {
  constructor() {
    super("ReceiptMessageOut", "struct ReceiptMessageOut", 0);
  }
  static getMessageId(value) {
    const parts = [];
    parts.push(new ByteArrayCoder(32).encode(value.sender));
    parts.push(new ByteArrayCoder(32).encode(value.recipient));
    parts.push(new ByteArrayCoder(32).encode(value.nonce));
    parts.push(new U64Coder().encode(value.amount));
    parts.push(getBytesCopy(value.data || "0x"));
    return sha2563(concat2(parts));
  }
  encode(value) {
    const parts = [];
    parts.push(new B256Coder().encode(value.sender));
    parts.push(new B256Coder().encode(value.recipient));
    parts.push(new U64Coder().encode(value.amount));
    parts.push(new B256Coder().encode(value.nonce));
    parts.push(new NumberCoder("u16").encode(value.data.length));
    parts.push(new B256Coder().encode(value.digest));
    parts.push(new ByteArrayCoder(value.data.length).encode(value.data));
    return concat2(parts);
  }
  decode(data3, offset) {
    let decoded;
    let o = offset;
    [decoded, o] = new B256Coder().decode(data3, o);
    const sender = decoded;
    [decoded, o] = new B256Coder().decode(data3, o);
    const recipient = decoded;
    [decoded, o] = new U64Coder().decode(data3, o);
    const amount = decoded;
    [decoded, o] = new B256Coder().decode(data3, o);
    const nonce = decoded;
    [decoded, o] = new NumberCoder("u16").decode(data3, o);
    const len = decoded;
    [decoded, o] = new B256Coder().decode(data3, o);
    const digest = decoded;
    [decoded, o] = new ByteArrayCoder(len).decode(data3, o);
    const messageData = getBytesCopy(decoded);
    const receiptMessageOut = {
      type: 10,
      messageId: "",
      sender,
      recipient,
      amount,
      nonce,
      digest,
      data: messageData
    };
    receiptMessageOut.messageId = ReceiptMessageOutCoder.getMessageId(receiptMessageOut);
    return [receiptMessageOut, o];
  }
};
var getAssetIdForMintAndBurnReceipts = (contractId, subId) => {
  const contractIdBytes = getBytesCopy(contractId);
  const subIdBytes = getBytesCopy(subId);
  return sha2563(concat2([contractIdBytes, subIdBytes]));
};
var ReceiptMintCoder = class extends Coder {
  constructor() {
    super("ReceiptMint", "struct ReceiptMint", 0);
  }
  static getAssetId(contractId, subId) {
    return getAssetIdForMintAndBurnReceipts(contractId, subId);
  }
  encode(value) {
    const parts = [];
    parts.push(new B256Coder().encode(value.subId));
    parts.push(new B256Coder().encode(value.contractId));
    parts.push(new U64Coder().encode(value.val));
    parts.push(new U64Coder().encode(value.pc));
    parts.push(new U64Coder().encode(value.is));
    return concat2(parts);
  }
  decode(data3, offset) {
    let decoded;
    let o = offset;
    [decoded, o] = new B256Coder().decode(data3, o);
    const subId = decoded;
    [decoded, o] = new B256Coder().decode(data3, o);
    const contractId = decoded;
    [decoded, o] = new U64Coder().decode(data3, o);
    const val = decoded;
    [decoded, o] = new U64Coder().decode(data3, o);
    const pc = decoded;
    [decoded, o] = new U64Coder().decode(data3, o);
    const is = decoded;
    const assetId = ReceiptMintCoder.getAssetId(contractId, subId);
    const receiptMint = {
      type: 11,
      subId,
      contractId,
      val,
      pc,
      is,
      assetId
    };
    return [receiptMint, o];
  }
};
var ReceiptBurnCoder = class extends Coder {
  constructor() {
    super("ReceiptBurn", "struct ReceiptBurn", 0);
  }
  static getAssetId(contractId, subId) {
    return getAssetIdForMintAndBurnReceipts(contractId, subId);
  }
  encode(value) {
    const parts = [];
    parts.push(new B256Coder().encode(value.subId));
    parts.push(new B256Coder().encode(value.contractId));
    parts.push(new U64Coder().encode(value.val));
    parts.push(new U64Coder().encode(value.pc));
    parts.push(new U64Coder().encode(value.is));
    return concat2(parts);
  }
  decode(data3, offset) {
    let decoded;
    let o = offset;
    [decoded, o] = new B256Coder().decode(data3, o);
    const subId = decoded;
    [decoded, o] = new B256Coder().decode(data3, o);
    const contractId = decoded;
    [decoded, o] = new U64Coder().decode(data3, o);
    const val = decoded;
    [decoded, o] = new U64Coder().decode(data3, o);
    const pc = decoded;
    [decoded, o] = new U64Coder().decode(data3, o);
    const is = decoded;
    const assetId = ReceiptMintCoder.getAssetId(contractId, subId);
    const receiptBurn = {
      type: 12,
      subId,
      contractId,
      val,
      pc,
      is,
      assetId
    };
    return [receiptBurn, o];
  }
};
var StorageSlotCoder = class extends StructCoder {
  constructor() {
    super("StorageSlot", {
      key: new B256Coder,
      value: new B256Coder
    });
  }
};
var WitnessCoder = class extends Coder {
  constructor() {
    super("Witness", "unknown", 0);
  }
  encode(value) {
    const parts = [];
    parts.push(new NumberCoder("u32").encode(value.dataLength));
    parts.push(new ByteArrayCoder(value.dataLength).encode(value.data));
    return concat2(parts);
  }
  decode(data3, offset) {
    let decoded;
    let o = offset;
    [decoded, o] = new NumberCoder("u32").decode(data3, o);
    const dataLength2 = decoded;
    [decoded, o] = new ByteArrayCoder(dataLength2).decode(data3, o);
    const witnessData = decoded;
    return [
      {
        dataLength: dataLength2,
        data: witnessData,
        offset
      },
      o
    ];
  }
};
var TransactionType = ((TransactionType2) => {
  TransactionType2[TransactionType2["Script"] = 0] = "Script";
  TransactionType2[TransactionType2["Create"] = 1] = "Create";
  TransactionType2[TransactionType2["Mint"] = 2] = "Mint";
  return TransactionType2;
})(TransactionType || {});
var TransactionScriptCoder = class extends Coder {
  constructor() {
    super("TransactionScript", "struct TransactionScript", 0);
  }
  encode(value) {
    const parts = [];
    parts.push(new U64Coder().encode(value.gasPrice));
    parts.push(new U64Coder().encode(value.gasLimit));
    parts.push(new NumberCoder("u32").encode(value.maturity));
    parts.push(new NumberCoder("u16").encode(value.scriptLength));
    parts.push(new NumberCoder("u16").encode(value.scriptDataLength));
    parts.push(new NumberCoder("u8").encode(value.inputsCount));
    parts.push(new NumberCoder("u8").encode(value.outputsCount));
    parts.push(new NumberCoder("u8").encode(value.witnessesCount));
    parts.push(new B256Coder().encode(value.receiptsRoot));
    parts.push(new ByteArrayCoder(value.scriptLength).encode(value.script));
    parts.push(new ByteArrayCoder(value.scriptDataLength).encode(value.scriptData));
    parts.push(new ArrayCoder(new InputCoder, value.inputsCount).encode(value.inputs));
    parts.push(new ArrayCoder(new OutputCoder, value.outputsCount).encode(value.outputs));
    parts.push(new ArrayCoder(new WitnessCoder, value.witnessesCount).encode(value.witnesses));
    return concat2(parts);
  }
  decode(data3, offset) {
    let decoded;
    let o = offset;
    [decoded, o] = new U64Coder().decode(data3, o);
    const gasPrice = decoded;
    [decoded, o] = new U64Coder().decode(data3, o);
    const gasLimit = decoded;
    [decoded, o] = new NumberCoder("u32").decode(data3, o);
    const maturity = decoded;
    [decoded, o] = new NumberCoder("u16").decode(data3, o);
    const scriptLength = decoded;
    [decoded, o] = new NumberCoder("u16").decode(data3, o);
    const scriptDataLength = decoded;
    [decoded, o] = new NumberCoder("u8").decode(data3, o);
    const inputsCount = decoded;
    [decoded, o] = new NumberCoder("u8").decode(data3, o);
    const outputsCount = decoded;
    [decoded, o] = new NumberCoder("u8").decode(data3, o);
    const witnessesCount = decoded;
    [decoded, o] = new B256Coder().decode(data3, o);
    const receiptsRoot = decoded;
    [decoded, o] = new ByteArrayCoder(scriptLength).decode(data3, o);
    const script = decoded;
    [decoded, o] = new ByteArrayCoder(scriptDataLength).decode(data3, o);
    const scriptData = decoded;
    [decoded, o] = new ArrayCoder(new InputCoder, inputsCount).decode(data3, o);
    const inputs = decoded;
    [decoded, o] = new ArrayCoder(new OutputCoder, outputsCount).decode(data3, o);
    const outputs = decoded;
    [decoded, o] = new ArrayCoder(new WitnessCoder, witnessesCount).decode(data3, o);
    const witnesses = decoded;
    return [
      {
        type: 0,
        gasPrice,
        gasLimit,
        maturity,
        scriptLength,
        scriptDataLength,
        inputsCount,
        outputsCount,
        witnessesCount,
        receiptsRoot,
        script,
        scriptData,
        inputs,
        outputs,
        witnesses
      },
      o
    ];
  }
};
var TransactionCreateCoder = class extends Coder {
  constructor() {
    super("TransactionCreate", "struct TransactionCreate", 0);
  }
  encode(value) {
    const parts = [];
    parts.push(new U64Coder().encode(value.gasPrice));
    parts.push(new U64Coder().encode(value.gasLimit));
    parts.push(new NumberCoder("u32").encode(value.maturity));
    parts.push(new NumberCoder("u16").encode(value.bytecodeLength));
    parts.push(new NumberCoder("u8").encode(value.bytecodeWitnessIndex));
    parts.push(new NumberCoder("u16").encode(value.storageSlotsCount));
    parts.push(new NumberCoder("u8").encode(value.inputsCount));
    parts.push(new NumberCoder("u8").encode(value.outputsCount));
    parts.push(new NumberCoder("u8").encode(value.witnessesCount));
    parts.push(new B256Coder().encode(value.salt));
    parts.push(new ArrayCoder(new StorageSlotCoder, value.storageSlotsCount).encode(value.storageSlots));
    parts.push(new ArrayCoder(new InputCoder, value.inputsCount).encode(value.inputs));
    parts.push(new ArrayCoder(new OutputCoder, value.outputsCount).encode(value.outputs));
    parts.push(new ArrayCoder(new WitnessCoder, value.witnessesCount).encode(value.witnesses));
    return concat2(parts);
  }
  decode(data3, offset) {
    let decoded;
    let o = offset;
    [decoded, o] = new U64Coder().decode(data3, o);
    const gasPrice = decoded;
    [decoded, o] = new U64Coder().decode(data3, o);
    const gasLimit = decoded;
    [decoded, o] = new NumberCoder("u32").decode(data3, o);
    const maturity = decoded;
    [decoded, o] = new NumberCoder("u16").decode(data3, o);
    const bytecodeLength = decoded;
    [decoded, o] = new NumberCoder("u8").decode(data3, o);
    const bytecodeWitnessIndex = decoded;
    [decoded, o] = new NumberCoder("u16").decode(data3, o);
    const storageSlotsCount = decoded;
    [decoded, o] = new NumberCoder("u8").decode(data3, o);
    const inputsCount = decoded;
    [decoded, o] = new NumberCoder("u8").decode(data3, o);
    const outputsCount = decoded;
    [decoded, o] = new NumberCoder("u8").decode(data3, o);
    const witnessesCount = decoded;
    [decoded, o] = new B256Coder().decode(data3, o);
    const salt = decoded;
    [decoded, o] = new ArrayCoder(new StorageSlotCoder, storageSlotsCount).decode(data3, o);
    const storageSlots = decoded;
    [decoded, o] = new ArrayCoder(new InputCoder, inputsCount).decode(data3, o);
    const inputs = decoded;
    [decoded, o] = new ArrayCoder(new OutputCoder, outputsCount).decode(data3, o);
    const outputs = decoded;
    [decoded, o] = new ArrayCoder(new WitnessCoder, witnessesCount).decode(data3, o);
    const witnesses = decoded;
    return [
      {
        type: 1,
        gasPrice,
        gasLimit,
        maturity,
        bytecodeLength,
        bytecodeWitnessIndex,
        storageSlotsCount,
        inputsCount,
        outputsCount,
        witnessesCount,
        salt,
        storageSlots,
        inputs,
        outputs,
        witnesses
      },
      o
    ];
  }
};
var TransactionMintCoder = class extends Coder {
  constructor() {
    super("TransactionMint", "struct TransactionMint", 0);
  }
  encode(value) {
    const parts = [];
    parts.push(new TxPointerCoder().encode(value.txPointer));
    parts.push(new NumberCoder("u8").encode(value.outputsCount));
    parts.push(new ArrayCoder(new OutputCoder, value.outputsCount).encode(value.outputs));
    return concat2(parts);
  }
  decode(data3, offset) {
    let decoded;
    let o = offset;
    [decoded, o] = new TxPointerCoder().decode(data3, o);
    const txPointer = decoded;
    [decoded, o] = new NumberCoder("u8").decode(data3, o);
    const outputsCount = decoded;
    [decoded, o] = new ArrayCoder(new OutputCoder, outputsCount).decode(data3, o);
    const outputs = decoded;
    return [
      {
        type: 2,
        outputsCount,
        outputs,
        txPointer
      },
      o
    ];
  }
};
var TransactionCoder = class extends Coder {
  constructor() {
    super("Transaction", "struct Transaction", 0);
  }
  encode(value) {
    const parts = [];
    parts.push(new NumberCoder("u8").encode(value.type));
    const { type } = value;
    switch (value.type) {
      case 0: {
        parts.push(new TransactionScriptCoder().encode(value));
        break;
      }
      case 1: {
        parts.push(new TransactionCreateCoder().encode(value));
        break;
      }
      case 2: {
        parts.push(new TransactionMintCoder().encode(value));
        break;
      }
      default: {
        throw new FuelError(ErrorCode.INVALID_TRANSACTION_TYPE, `Invalid transaction type: ${type}`);
      }
    }
    return concat2(parts);
  }
  decode(data3, offset) {
    let decoded;
    let o = offset;
    [decoded, o] = new NumberCoder("u8").decode(data3, o);
    const type = decoded;
    switch (type) {
      case 0: {
        [decoded, o] = new TransactionScriptCoder().decode(data3, o);
        return [decoded, o];
      }
      case 1: {
        [decoded, o] = new TransactionCreateCoder().decode(data3, o);
        return [decoded, o];
      }
      case 2: {
        [decoded, o] = new TransactionMintCoder().decode(data3, o);
        return [decoded, o];
      }
      default: {
        throw new FuelError(ErrorCode.INVALID_TRANSACTION_TYPE, `Invalid transaction type: ${type}`);
      }
    }
  }
};

// node_modules/@fuel-ts/transactions/dist/configs.mjs
var CONTRACT_MAX_SIZE = 16 * 1024;
var MAX_SCRIPT_LENGTH = 1024 * 1024 * 1024;
var MAX_SCRIPT_DATA_LENGTH = 1024 * 1024 * 1024;
var MAX_PREDICATE_LENGTH = 1024 * 1024;
var MAX_PREDICATE_DATA_LENGTH = 1024 * 1024;
var FAILED_REQUIRE_SIGNAL = "0xffffffffffff0000";
var FAILED_TRANSFER_TO_ADDRESS_SIGNAL = "0xffffffffffff0001";
var FAILED_SEND_MESSAGE_SIGNAL = "0xffffffffffff0002";
var FAILED_ASSERT_EQ_SIGNAL = "0xffffffffffff0003";
var FAILED_ASSERT_SIGNAL = "0xffffffffffff0004";
var FAILED_UNKNOWN_SIGNAL = "0x0";

// node_modules/@fuel-ts/address/dist/configs.mjs
var ZeroBytes32 = "0x0000000000000000000000000000000000000000000000000000000000000000";
var BaseAssetId = ZeroBytes32;

// node_modules/@fuel-ts/address/dist/index.mjs
var import_bech32 = __toESM(require_dist(), 1);
var fromBech32 = function(address2) {
  return import_bech32.bech32m.decode(address2);
};
var toBech32 = function(address2) {
  return import_bech32.bech32m.encode(FUEL_BECH32_HRP_PREFIX, import_bech32.bech32m.toWords(getBytesCopy(hexlify(address2))));
};
var isBech32 = function(address2) {
  return typeof address2 === "string" && address2.indexOf(FUEL_BECH32_HRP_PREFIX + 1) === 0 && fromBech32(address2).prefix === FUEL_BECH32_HRP_PREFIX;
};
var isB256 = function(address2) {
  return (address2.length === 66 || address2.length === 64) && /(0x)?[0-9a-f]{64}$/i.test(address2);
};
var isPublicKey = function(address2) {
  return (address2.length === 130 || address2.length === 128) && /(0x)?[0-9a-f]{128}$/i.test(address2);
};
var isEvmAddress = function(address2) {
  return (address2.length === 42 || address2.length === 40) && /(0x)?[0-9a-f]{40}$/i.test(address2);
};
var getBytesFromBech32 = function(address2) {
  return new Uint8Array(import_bech32.bech32m.fromWords(fromBech32(address2).words));
};
var toB256 = function(address2) {
  if (!isBech32(address2)) {
    throw new FuelError(FuelError.CODES.INVALID_BECH32_ADDRESS, `Invalid Bech32 Address: ${address2}.`);
  }
  return hexlify(getBytesFromBech32(address2));
};
var normalizeBech32 = function(address2) {
  const { words } = fromBech32(address2);
  return import_bech32.bech32m.encode(FUEL_BECH32_HRP_PREFIX, words);
};
var FUEL_BECH32_HRP_PREFIX = "fuel";
var addressify = (addressLike) => {
  if (addressLike instanceof AbstractAccount) {
    return addressLike.address;
  }
  if (addressLike instanceof AbstractContract) {
    return addressLike.id;
  }
  return addressLike;
};
var getRandomB256 = () => hexlify(randomBytes22(32));
var clearFirst12BytesFromB256 = (b256) => {
  let bytes3;
  try {
    if (!isB256(b256)) {
      throw new FuelError(FuelError.CODES.INVALID_BECH32_ADDRESS, `Invalid Bech32 Address: ${b256}.`);
    }
    bytes3 = getBytesFromBech32(toBech32(b256));
    bytes3 = hexlify(bytes3.fill(0, 0, 12));
  } catch (error) {
    throw new FuelError(FuelError.CODES.PARSE_FAILED, `Cannot generate EVM Address B256 from: ${b256}.`);
  }
  return bytes3;
};
var padFirst12BytesOfEvmAddress = (address2) => {
  if (!isEvmAddress(address2)) {
    throw new FuelError(FuelError.CODES.INVALID_EVM_ADDRESS, "Invalid EVM address format.");
  }
  const prefixedAddress = address2.startsWith("0x") ? address2 : `0x${address2}`;
  return prefixedAddress.replace("0x", "0x000000000000000000000000");
};
var Address = class extends AbstractAddress {
  bech32Address;
  constructor(address2) {
    super();
    this.bech32Address = normalizeBech32(address2);
    if (!isBech32(this.bech32Address)) {
      throw new FuelError(FuelError.CODES.INVALID_BECH32_ADDRESS, `Invalid Bech32 Address: ${address2}.`);
    }
  }
  toAddress() {
    return this.bech32Address;
  }
  toB256() {
    return toB256(this.bech32Address);
  }
  toBytes() {
    return getBytesFromBech32(this.bech32Address);
  }
  toHexString() {
    return this.toB256();
  }
  toString() {
    return this.bech32Address;
  }
  toJSON() {
    return this.bech32Address;
  }
  toEvmAddress() {
    const b256Address = toB256(this.bech32Address);
    return {
      value: clearFirst12BytesFromB256(b256Address)
    };
  }
  valueOf() {
    return this.bech32Address;
  }
  equals(other) {
    return this.bech32Address === other.bech32Address;
  }
  static fromPublicKey(publicKey) {
    const b256Address = sha2563(hexlify(getBytesCopy(publicKey)));
    return new Address(toBech32(b256Address));
  }
  static fromB256(b256Address) {
    return new Address(toBech32(b256Address));
  }
  static fromRandom() {
    return this.fromB256(getRandomB256());
  }
  static fromString(address2) {
    return isBech32(address2) ? new Address(address2) : this.fromB256(address2);
  }
  static fromAddressOrString(address2) {
    return typeof address2 === "string" ? this.fromString(address2) : address2;
  }
  static fromDynamicInput(address2) {
    if (typeof address2 !== "string" && ("toB256" in address2)) {
      return Address.fromB256(address2.toB256());
    }
    if (isPublicKey(address2)) {
      return Address.fromPublicKey(address2);
    }
    if (isBech32(address2)) {
      return new Address(address2);
    }
    if (isB256(address2)) {
      return Address.fromB256(address2);
    }
    if (isEvmAddress(address2)) {
      return Address.fromEvmAddress(address2);
    }
    throw new FuelError(FuelError.CODES.PARSE_FAILED, `Unknown address format: only 'Bech32', 'B256', or 'Public Key (512)' are supported.`);
  }
  static fromEvmAddress(evmAddress) {
    const paddedAddress = padFirst12BytesOfEvmAddress(evmAddress);
    return new Address(toBech32(paddedAddress));
  }
};

// node_modules/graphql-request/build/esm/defaultJsonSerializer.js
var defaultJsonSerializer = {
  parse: JSON.parse,
  stringify: JSON.stringify
};

// node_modules/extract-files/public/index.mjs
var import_extractFiles = __toESM(require_extractFiles(), 1);
var import_isExtractableFile = __toESM(require_isExtractableFile(), 1);

// node_modules/graphql-request/build/esm/createRequestBody.js
var import_form_data = __toESM(require_browser(), 1);
var isExtractableFileEnhanced = (value) => import_isExtractableFile.default(value) || value !== null && typeof value === `object` && typeof value.pipe === `function`;
var createRequestBody = (query, variables, operationName, jsonSerializer = defaultJsonSerializer) => {
  const { clone, files } = import_extractFiles.default({ query, variables, operationName }, ``, isExtractableFileEnhanced);
  if (files.size === 0) {
    if (!Array.isArray(query)) {
      return jsonSerializer.stringify(clone);
    }
    if (typeof variables !== `undefined` && !Array.isArray(variables)) {
      throw new Error(`Cannot create request body with given variable type, array expected`);
    }
    const payload = query.reduce((accu, currentQuery, index) => {
      accu.push({ query: currentQuery, variables: variables ? variables[index] : undefined });
      return accu;
    }, []);
    return jsonSerializer.stringify(payload);
  }
  const Form = typeof FormData === `undefined` ? import_form_data.default : FormData;
  const form = new Form;
  form.append(`operations`, jsonSerializer.stringify(clone));
  const map = {};
  let i = 0;
  files.forEach((paths) => {
    map[++i] = paths;
  });
  form.append(`map`, jsonSerializer.stringify(map));
  i = 0;
  files.forEach((paths, file) => {
    form.append(`${++i}`, file);
  });
  return form;
};
var createRequestBody_default = createRequestBody;

// node_modules/graphql-request/build/esm/helpers.js
var uppercase = (str) => str.toUpperCase();
var HeadersInstanceToPlainObject = (headers) => {
  const o = {};
  headers.forEach((v2, k) => {
    o[k] = v2;
  });
  return o;
};

// node_modules/graphql-request/build/esm/parseArgs.js
var parseRequestArgs = (documentOrOptions, variables, requestHeaders) => {
  return documentOrOptions.document ? documentOrOptions : {
    document: documentOrOptions,
    variables,
    requestHeaders,
    signal: undefined
  };
};
var parseRawRequestArgs = (queryOrOptions, variables, requestHeaders) => {
  return queryOrOptions.query ? queryOrOptions : {
    query: queryOrOptions,
    variables,
    requestHeaders,
    signal: undefined
  };
};
var parseBatchRequestArgs = (documentsOrOptions, requestHeaders) => {
  return documentsOrOptions.documents ? documentsOrOptions : {
    documents: documentsOrOptions,
    requestHeaders,
    signal: undefined
  };
};

// node_modules/graphql/jsutils/devAssert.mjs
function devAssert(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(message);
  }
}

// node_modules/graphql/jsutils/isObjectLike.mjs
function isObjectLike(value) {
  return typeof value == "object" && value !== null;
}

// node_modules/graphql/jsutils/invariant.mjs
function invariant(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(message != null ? message : "Unexpected invariant triggered.");
  }
}

// node_modules/graphql/language/location.mjs
function getLocation(source, position) {
  let lastLineStart = 0;
  let line = 1;
  for (const match of source.body.matchAll(LineRegExp)) {
    typeof match.index === "number" || invariant(false);
    if (match.index >= position) {
      break;
    }
    lastLineStart = match.index + match[0].length;
    line += 1;
  }
  return {
    line,
    column: position + 1 - lastLineStart
  };
}
var LineRegExp = /\r\n|[\n\r]/g;

// node_modules/graphql/language/printLocation.mjs
function printLocation(location2) {
  return printSourceLocation(location2.source, getLocation(location2.source, location2.start));
}
function printSourceLocation(source, sourceLocation) {
  const firstLineColumnOffset = source.locationOffset.column - 1;
  const body = "".padStart(firstLineColumnOffset) + source.body;
  const lineIndex = sourceLocation.line - 1;
  const lineOffset = source.locationOffset.line - 1;
  const lineNum = sourceLocation.line + lineOffset;
  const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
  const columnNum = sourceLocation.column + columnOffset;
  const locationStr = `${source.name}:${lineNum}:${columnNum}\n`;
  const lines = body.split(/\r\n|[\n\r]/g);
  const locationLine = lines[lineIndex];
  if (locationLine.length > 120) {
    const subLineIndex = Math.floor(columnNum / 80);
    const subLineColumnNum = columnNum % 80;
    const subLines = [];
    for (let i = 0;i < locationLine.length; i += 80) {
      subLines.push(locationLine.slice(i, i + 80));
    }
    return locationStr + printPrefixedLines([
      [`${lineNum} |`, subLines[0]],
      ...subLines.slice(1, subLineIndex + 1).map((subLine) => ["|", subLine]),
      ["|", "^".padStart(subLineColumnNum)],
      ["|", subLines[subLineIndex + 1]]
    ]);
  }
  return locationStr + printPrefixedLines([
    [`${lineNum - 1} |`, lines[lineIndex - 1]],
    [`${lineNum} |`, locationLine],
    ["|", "^".padStart(columnNum)],
    [`${lineNum + 1} |`, lines[lineIndex + 1]]
  ]);
}
var printPrefixedLines = function(lines) {
  const existingLines = lines.filter(([_2, line]) => line !== undefined);
  const padLen = Math.max(...existingLines.map(([prefix]) => prefix.length));
  return existingLines.map(([prefix, line]) => prefix.padStart(padLen) + (line ? " " + line : "")).join("\n");
};

// node_modules/graphql/error/GraphQLError.mjs
var toNormalizedOptions = function(args) {
  const firstArg = args[0];
  if (firstArg == null || ("kind" in firstArg) || ("length" in firstArg)) {
    return {
      nodes: firstArg,
      source: args[1],
      positions: args[2],
      path: args[3],
      originalError: args[4],
      extensions: args[5]
    };
  }
  return firstArg;
};
var undefinedIfEmpty = function(array) {
  return array === undefined || array.length === 0 ? undefined : array;
};
class GraphQLError extends Error {
  constructor(message, ...rawArgs) {
    var _this$nodes, _nodeLocations$, _ref;
    const { nodes, source, positions, path, originalError, extensions } = toNormalizedOptions(rawArgs);
    super(message);
    this.name = "GraphQLError";
    this.path = path !== null && path !== undefined ? path : undefined;
    this.originalError = originalError !== null && originalError !== undefined ? originalError : undefined;
    this.nodes = undefinedIfEmpty(Array.isArray(nodes) ? nodes : nodes ? [nodes] : undefined);
    const nodeLocations = undefinedIfEmpty((_this$nodes = this.nodes) === null || _this$nodes === undefined ? undefined : _this$nodes.map((node) => node.loc).filter((loc) => loc != null));
    this.source = source !== null && source !== undefined ? source : nodeLocations === null || nodeLocations === undefined ? undefined : (_nodeLocations$ = nodeLocations[0]) === null || _nodeLocations$ === undefined ? undefined : _nodeLocations$.source;
    this.positions = positions !== null && positions !== undefined ? positions : nodeLocations === null || nodeLocations === undefined ? undefined : nodeLocations.map((loc) => loc.start);
    this.locations = positions && source ? positions.map((pos) => getLocation(source, pos)) : nodeLocations === null || nodeLocations === undefined ? undefined : nodeLocations.map((loc) => getLocation(loc.source, loc.start));
    const originalExtensions = isObjectLike(originalError === null || originalError === undefined ? undefined : originalError.extensions) ? originalError === null || originalError === undefined ? undefined : originalError.extensions : undefined;
    this.extensions = (_ref = extensions !== null && extensions !== undefined ? extensions : originalExtensions) !== null && _ref !== undefined ? _ref : Object.create(null);
    Object.defineProperties(this, {
      message: {
        writable: true,
        enumerable: true
      },
      name: {
        enumerable: false
      },
      nodes: {
        enumerable: false
      },
      source: {
        enumerable: false
      },
      positions: {
        enumerable: false
      },
      originalError: {
        enumerable: false
      }
    });
    if (originalError !== null && originalError !== undefined && originalError.stack) {
      Object.defineProperty(this, "stack", {
        value: originalError.stack,
        writable: true,
        configurable: true
      });
    } else if (Error.captureStackTrace) {
      Error.captureStackTrace(this, GraphQLError);
    } else {
      Object.defineProperty(this, "stack", {
        value: Error().stack,
        writable: true,
        configurable: true
      });
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLError";
  }
  toString() {
    let output3 = this.message;
    if (this.nodes) {
      for (const node of this.nodes) {
        if (node.loc) {
          output3 += "\n\n" + printLocation(node.loc);
        }
      }
    } else if (this.source && this.locations) {
      for (const location3 of this.locations) {
        output3 += "\n\n" + printSourceLocation(this.source, location3);
      }
    }
    return output3;
  }
  toJSON() {
    const formattedError = {
      message: this.message
    };
    if (this.locations != null) {
      formattedError.locations = this.locations;
    }
    if (this.path != null) {
      formattedError.path = this.path;
    }
    if (this.extensions != null && Object.keys(this.extensions).length > 0) {
      formattedError.extensions = this.extensions;
    }
    return formattedError;
  }
}

// node_modules/graphql/error/syntaxError.mjs
function syntaxError(source, position, description) {
  return new GraphQLError(`Syntax Error: ${description}`, {
    source,
    positions: [position]
  });
}

// node_modules/graphql/language/ast.mjs
function isNode(maybeNode) {
  const maybeKind = maybeNode === null || maybeNode === undefined ? undefined : maybeNode.kind;
  return typeof maybeKind === "string" && kindValues.has(maybeKind);
}

class Location {
  constructor(startToken, endToken, source) {
    this.start = startToken.start;
    this.end = endToken.end;
    this.startToken = startToken;
    this.endToken = endToken;
    this.source = source;
  }
  get [Symbol.toStringTag]() {
    return "Location";
  }
  toJSON() {
    return {
      start: this.start,
      end: this.end
    };
  }
}

class Token {
  constructor(kind, start, end, line, column, value) {
    this.kind = kind;
    this.start = start;
    this.end = end;
    this.line = line;
    this.column = column;
    this.value = value;
    this.prev = null;
    this.next = null;
  }
  get [Symbol.toStringTag]() {
    return "Token";
  }
  toJSON() {
    return {
      kind: this.kind,
      value: this.value,
      line: this.line,
      column: this.column
    };
  }
}
var QueryDocumentKeys = {
  Name: [],
  Document: ["definitions"],
  OperationDefinition: [
    "name",
    "variableDefinitions",
    "directives",
    "selectionSet"
  ],
  VariableDefinition: ["variable", "type", "defaultValue", "directives"],
  Variable: ["name"],
  SelectionSet: ["selections"],
  Field: ["alias", "name", "arguments", "directives", "selectionSet"],
  Argument: ["name", "value"],
  FragmentSpread: ["name", "directives"],
  InlineFragment: ["typeCondition", "directives", "selectionSet"],
  FragmentDefinition: [
    "name",
    "variableDefinitions",
    "typeCondition",
    "directives",
    "selectionSet"
  ],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ["values"],
  ObjectValue: ["fields"],
  ObjectField: ["name", "value"],
  Directive: ["name", "arguments"],
  NamedType: ["name"],
  ListType: ["type"],
  NonNullType: ["type"],
  SchemaDefinition: ["description", "directives", "operationTypes"],
  OperationTypeDefinition: ["type"],
  ScalarTypeDefinition: ["description", "name", "directives"],
  ObjectTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  FieldDefinition: ["description", "name", "arguments", "type", "directives"],
  InputValueDefinition: [
    "description",
    "name",
    "type",
    "defaultValue",
    "directives"
  ],
  InterfaceTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  UnionTypeDefinition: ["description", "name", "directives", "types"],
  EnumTypeDefinition: ["description", "name", "directives", "values"],
  EnumValueDefinition: ["description", "name", "directives"],
  InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
  DirectiveDefinition: ["description", "name", "arguments", "locations"],
  SchemaExtension: ["directives", "operationTypes"],
  ScalarTypeExtension: ["name", "directives"],
  ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
  InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
  UnionTypeExtension: ["name", "directives", "types"],
  EnumTypeExtension: ["name", "directives", "values"],
  InputObjectTypeExtension: ["name", "directives", "fields"]
};
var kindValues = new Set(Object.keys(QueryDocumentKeys));
var OperationTypeNode;
(function(OperationTypeNode2) {
  OperationTypeNode2["QUERY"] = "query";
  OperationTypeNode2["MUTATION"] = "mutation";
  OperationTypeNode2["SUBSCRIPTION"] = "subscription";
})(OperationTypeNode || (OperationTypeNode = {}));

// node_modules/graphql/language/directiveLocation.mjs
var DirectiveLocation;
(function(DirectiveLocation2) {
  DirectiveLocation2["QUERY"] = "QUERY";
  DirectiveLocation2["MUTATION"] = "MUTATION";
  DirectiveLocation2["SUBSCRIPTION"] = "SUBSCRIPTION";
  DirectiveLocation2["FIELD"] = "FIELD";
  DirectiveLocation2["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
  DirectiveLocation2["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
  DirectiveLocation2["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
  DirectiveLocation2["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
  DirectiveLocation2["SCHEMA"] = "SCHEMA";
  DirectiveLocation2["SCALAR"] = "SCALAR";
  DirectiveLocation2["OBJECT"] = "OBJECT";
  DirectiveLocation2["FIELD_DEFINITION"] = "FIELD_DEFINITION";
  DirectiveLocation2["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
  DirectiveLocation2["INTERFACE"] = "INTERFACE";
  DirectiveLocation2["UNION"] = "UNION";
  DirectiveLocation2["ENUM"] = "ENUM";
  DirectiveLocation2["ENUM_VALUE"] = "ENUM_VALUE";
  DirectiveLocation2["INPUT_OBJECT"] = "INPUT_OBJECT";
  DirectiveLocation2["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
})(DirectiveLocation || (DirectiveLocation = {}));

// node_modules/graphql/language/kinds.mjs
var Kind;
(function(Kind2) {
  Kind2["NAME"] = "Name";
  Kind2["DOCUMENT"] = "Document";
  Kind2["OPERATION_DEFINITION"] = "OperationDefinition";
  Kind2["VARIABLE_DEFINITION"] = "VariableDefinition";
  Kind2["SELECTION_SET"] = "SelectionSet";
  Kind2["FIELD"] = "Field";
  Kind2["ARGUMENT"] = "Argument";
  Kind2["FRAGMENT_SPREAD"] = "FragmentSpread";
  Kind2["INLINE_FRAGMENT"] = "InlineFragment";
  Kind2["FRAGMENT_DEFINITION"] = "FragmentDefinition";
  Kind2["VARIABLE"] = "Variable";
  Kind2["INT"] = "IntValue";
  Kind2["FLOAT"] = "FloatValue";
  Kind2["STRING"] = "StringValue";
  Kind2["BOOLEAN"] = "BooleanValue";
  Kind2["NULL"] = "NullValue";
  Kind2["ENUM"] = "EnumValue";
  Kind2["LIST"] = "ListValue";
  Kind2["OBJECT"] = "ObjectValue";
  Kind2["OBJECT_FIELD"] = "ObjectField";
  Kind2["DIRECTIVE"] = "Directive";
  Kind2["NAMED_TYPE"] = "NamedType";
  Kind2["LIST_TYPE"] = "ListType";
  Kind2["NON_NULL_TYPE"] = "NonNullType";
  Kind2["SCHEMA_DEFINITION"] = "SchemaDefinition";
  Kind2["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
  Kind2["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
  Kind2["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
  Kind2["FIELD_DEFINITION"] = "FieldDefinition";
  Kind2["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
  Kind2["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
  Kind2["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
  Kind2["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
  Kind2["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
  Kind2["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
  Kind2["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
  Kind2["SCHEMA_EXTENSION"] = "SchemaExtension";
  Kind2["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
  Kind2["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
  Kind2["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
  Kind2["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
  Kind2["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
  Kind2["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
})(Kind || (Kind = {}));

// node_modules/graphql/language/characterClasses.mjs
function isWhiteSpace(code) {
  return code === 9 || code === 32;
}
function isDigit(code) {
  return code >= 48 && code <= 57;
}
function isLetter(code) {
  return code >= 97 && code <= 122 || code >= 65 && code <= 90;
}
function isNameStart(code) {
  return isLetter(code) || code === 95;
}
function isNameContinue(code) {
  return isLetter(code) || isDigit(code) || code === 95;
}

// node_modules/graphql/language/blockString.mjs
function dedentBlockStringLines(lines) {
  var _firstNonEmptyLine2;
  let commonIndent = Number.MAX_SAFE_INTEGER;
  let firstNonEmptyLine = null;
  let lastNonEmptyLine = -1;
  for (let i = 0;i < lines.length; ++i) {
    var _firstNonEmptyLine;
    const line = lines[i];
    const indent = leadingWhitespace(line);
    if (indent === line.length) {
      continue;
    }
    firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) !== null && _firstNonEmptyLine !== undefined ? _firstNonEmptyLine : i;
    lastNonEmptyLine = i;
    if (i !== 0 && indent < commonIndent) {
      commonIndent = indent;
    }
  }
  return lines.map((line, i) => i === 0 ? line : line.slice(commonIndent)).slice((_firstNonEmptyLine2 = firstNonEmptyLine) !== null && _firstNonEmptyLine2 !== undefined ? _firstNonEmptyLine2 : 0, lastNonEmptyLine + 1);
}
var leadingWhitespace = function(str) {
  let i = 0;
  while (i < str.length && isWhiteSpace(str.charCodeAt(i))) {
    ++i;
  }
  return i;
};
function printBlockString(value, options) {
  const escapedValue = value.replace(/"""/g, '\\"""');
  const lines = escapedValue.split(/\r\n|[\n\r]/g);
  const isSingleLine = lines.length === 1;
  const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every((line) => line.length === 0 || isWhiteSpace(line.charCodeAt(0)));
  const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
  const hasTrailingQuote = value.endsWith('"') && !hasTrailingTripleQuotes;
  const hasTrailingSlash = value.endsWith("\\");
  const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
  const printAsMultipleLines = !(options !== null && options !== undefined && options.minimize) && (!isSingleLine || value.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);
  let result = "";
  const skipLeadingNewLine = isSingleLine && isWhiteSpace(value.charCodeAt(0));
  if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
    result += "\n";
  }
  result += escapedValue;
  if (printAsMultipleLines || forceTrailingNewline) {
    result += "\n";
  }
  return '"""' + result + '"""';
}

// node_modules/graphql/language/tokenKind.mjs
var TokenKind;
(function(TokenKind2) {
  TokenKind2["SOF"] = "<SOF>";
  TokenKind2["EOF"] = "<EOF>";
  TokenKind2["BANG"] = "!";
  TokenKind2["DOLLAR"] = "$";
  TokenKind2["AMP"] = "&";
  TokenKind2["PAREN_L"] = "(";
  TokenKind2["PAREN_R"] = ")";
  TokenKind2["SPREAD"] = "...";
  TokenKind2["COLON"] = ":";
  TokenKind2["EQUALS"] = "=";
  TokenKind2["AT"] = "@";
  TokenKind2["BRACKET_L"] = "[";
  TokenKind2["BRACKET_R"] = "]";
  TokenKind2["BRACE_L"] = "{";
  TokenKind2["PIPE"] = "|";
  TokenKind2["BRACE_R"] = "}";
  TokenKind2["NAME"] = "Name";
  TokenKind2["INT"] = "Int";
  TokenKind2["FLOAT"] = "Float";
  TokenKind2["STRING"] = "String";
  TokenKind2["BLOCK_STRING"] = "BlockString";
  TokenKind2["COMMENT"] = "Comment";
})(TokenKind || (TokenKind = {}));

// node_modules/graphql/language/lexer.mjs
function isPunctuatorTokenKind(kind) {
  return kind === TokenKind.BANG || kind === TokenKind.DOLLAR || kind === TokenKind.AMP || kind === TokenKind.PAREN_L || kind === TokenKind.PAREN_R || kind === TokenKind.SPREAD || kind === TokenKind.COLON || kind === TokenKind.EQUALS || kind === TokenKind.AT || kind === TokenKind.BRACKET_L || kind === TokenKind.BRACKET_R || kind === TokenKind.BRACE_L || kind === TokenKind.PIPE || kind === TokenKind.BRACE_R;
}
var isUnicodeScalarValue = function(code) {
  return code >= 0 && code <= 55295 || code >= 57344 && code <= 1114111;
};
var isSupplementaryCodePoint = function(body, location3) {
  return isLeadingSurrogate(body.charCodeAt(location3)) && isTrailingSurrogate(body.charCodeAt(location3 + 1));
};
var isLeadingSurrogate = function(code) {
  return code >= 55296 && code <= 56319;
};
var isTrailingSurrogate = function(code) {
  return code >= 56320 && code <= 57343;
};
var printCodePointAt = function(lexer, location3) {
  const code = lexer.source.body.codePointAt(location3);
  if (code === undefined) {
    return TokenKind.EOF;
  } else if (code >= 32 && code <= 126) {
    const char = String.fromCodePoint(code);
    return char === '"' ? "'\"'" : `"${char}"`;
  }
  return "U+" + code.toString(16).toUpperCase().padStart(4, "0");
};
var createToken = function(lexer, kind, start, end, value) {
  const line = lexer.line;
  const col = 1 + start - lexer.lineStart;
  return new Token(kind, start, end, line, col, value);
};
var readNextToken = function(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    switch (code) {
      case 65279:
      case 9:
      case 32:
      case 44:
        ++position;
        continue;
      case 10:
        ++position;
        ++lexer.line;
        lexer.lineStart = position;
        continue;
      case 13:
        if (body.charCodeAt(position + 1) === 10) {
          position += 2;
        } else {
          ++position;
        }
        ++lexer.line;
        lexer.lineStart = position;
        continue;
      case 35:
        return readComment(lexer, position);
      case 33:
        return createToken(lexer, TokenKind.BANG, position, position + 1);
      case 36:
        return createToken(lexer, TokenKind.DOLLAR, position, position + 1);
      case 38:
        return createToken(lexer, TokenKind.AMP, position, position + 1);
      case 40:
        return createToken(lexer, TokenKind.PAREN_L, position, position + 1);
      case 41:
        return createToken(lexer, TokenKind.PAREN_R, position, position + 1);
      case 46:
        if (body.charCodeAt(position + 1) === 46 && body.charCodeAt(position + 2) === 46) {
          return createToken(lexer, TokenKind.SPREAD, position, position + 3);
        }
        break;
      case 58:
        return createToken(lexer, TokenKind.COLON, position, position + 1);
      case 61:
        return createToken(lexer, TokenKind.EQUALS, position, position + 1);
      case 64:
        return createToken(lexer, TokenKind.AT, position, position + 1);
      case 91:
        return createToken(lexer, TokenKind.BRACKET_L, position, position + 1);
      case 93:
        return createToken(lexer, TokenKind.BRACKET_R, position, position + 1);
      case 123:
        return createToken(lexer, TokenKind.BRACE_L, position, position + 1);
      case 124:
        return createToken(lexer, TokenKind.PIPE, position, position + 1);
      case 125:
        return createToken(lexer, TokenKind.BRACE_R, position, position + 1);
      case 34:
        if (body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
          return readBlockString(lexer, position);
        }
        return readString(lexer, position);
    }
    if (isDigit(code) || code === 45) {
      return readNumber(lexer, position, code);
    }
    if (isNameStart(code)) {
      return readName(lexer, position);
    }
    throw syntaxError(lexer.source, position, code === 39 ? 'Unexpected single quote character (\'), did you mean to use a double quote (")?' : isUnicodeScalarValue(code) || isSupplementaryCodePoint(body, position) ? `Unexpected character: ${printCodePointAt(lexer, position)}.` : `Invalid character: ${printCodePointAt(lexer, position)}.`);
  }
  return createToken(lexer, TokenKind.EOF, bodyLength, bodyLength);
};
var readComment = function(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 10 || code === 13) {
      break;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      break;
    }
  }
  return createToken(lexer, TokenKind.COMMENT, start, position, body.slice(start + 1, position));
};
var readNumber = function(lexer, start, firstCode) {
  const body = lexer.source.body;
  let position = start;
  let code = firstCode;
  let isFloat = false;
  if (code === 45) {
    code = body.charCodeAt(++position);
  }
  if (code === 48) {
    code = body.charCodeAt(++position);
    if (isDigit(code)) {
      throw syntaxError(lexer.source, position, `Invalid number, unexpected digit after 0: ${printCodePointAt(lexer, position)}.`);
    }
  } else {
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 46) {
    isFloat = true;
    code = body.charCodeAt(++position);
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 69 || code === 101) {
    isFloat = true;
    code = body.charCodeAt(++position);
    if (code === 43 || code === 45) {
      code = body.charCodeAt(++position);
    }
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 46 || isNameStart(code)) {
    throw syntaxError(lexer.source, position, `Invalid number, expected digit but got: ${printCodePointAt(lexer, position)}.`);
  }
  return createToken(lexer, isFloat ? TokenKind.FLOAT : TokenKind.INT, start, position, body.slice(start, position));
};
var readDigits = function(lexer, start, firstCode) {
  if (!isDigit(firstCode)) {
    throw syntaxError(lexer.source, start, `Invalid number, expected digit but got: ${printCodePointAt(lexer, start)}.`);
  }
  const body = lexer.source.body;
  let position = start + 1;
  while (isDigit(body.charCodeAt(position))) {
    ++position;
  }
  return position;
};
var readString = function(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  let chunkStart = position;
  let value = "";
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 34) {
      value += body.slice(chunkStart, position);
      return createToken(lexer, TokenKind.STRING, start, position + 1, value);
    }
    if (code === 92) {
      value += body.slice(chunkStart, position);
      const escape = body.charCodeAt(position + 1) === 117 ? body.charCodeAt(position + 2) === 123 ? readEscapedUnicodeVariableWidth(lexer, position) : readEscapedUnicodeFixedWidth(lexer, position) : readEscapedCharacter(lexer, position);
      value += escape.value;
      position += escape.size;
      chunkStart = position;
      continue;
    }
    if (code === 10 || code === 13) {
      break;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      throw syntaxError(lexer.source, position, `Invalid character within String: ${printCodePointAt(lexer, position)}.`);
    }
  }
  throw syntaxError(lexer.source, position, "Unterminated string.");
};
var readEscapedUnicodeVariableWidth = function(lexer, position) {
  const body = lexer.source.body;
  let point = 0;
  let size = 3;
  while (size < 12) {
    const code = body.charCodeAt(position + size++);
    if (code === 125) {
      if (size < 5 || !isUnicodeScalarValue(point)) {
        break;
      }
      return {
        value: String.fromCodePoint(point),
        size
      };
    }
    point = point << 4 | readHexDigit(code);
    if (point < 0) {
      break;
    }
  }
  throw syntaxError(lexer.source, position, `Invalid Unicode escape sequence: "${body.slice(position, position + size)}".`);
};
var readEscapedUnicodeFixedWidth = function(lexer, position) {
  const body = lexer.source.body;
  const code = read16BitHexCode(body, position + 2);
  if (isUnicodeScalarValue(code)) {
    return {
      value: String.fromCodePoint(code),
      size: 6
    };
  }
  if (isLeadingSurrogate(code)) {
    if (body.charCodeAt(position + 6) === 92 && body.charCodeAt(position + 7) === 117) {
      const trailingCode = read16BitHexCode(body, position + 8);
      if (isTrailingSurrogate(trailingCode)) {
        return {
          value: String.fromCodePoint(code, trailingCode),
          size: 12
        };
      }
    }
  }
  throw syntaxError(lexer.source, position, `Invalid Unicode escape sequence: "${body.slice(position, position + 6)}".`);
};
var read16BitHexCode = function(body, position) {
  return readHexDigit(body.charCodeAt(position)) << 12 | readHexDigit(body.charCodeAt(position + 1)) << 8 | readHexDigit(body.charCodeAt(position + 2)) << 4 | readHexDigit(body.charCodeAt(position + 3));
};
var readHexDigit = function(code) {
  return code >= 48 && code <= 57 ? code - 48 : code >= 65 && code <= 70 ? code - 55 : code >= 97 && code <= 102 ? code - 87 : -1;
};
var readEscapedCharacter = function(lexer, position) {
  const body = lexer.source.body;
  const code = body.charCodeAt(position + 1);
  switch (code) {
    case 34:
      return {
        value: '"',
        size: 2
      };
    case 92:
      return {
        value: "\\",
        size: 2
      };
    case 47:
      return {
        value: "/",
        size: 2
      };
    case 98:
      return {
        value: "\b",
        size: 2
      };
    case 102:
      return {
        value: "\f",
        size: 2
      };
    case 110:
      return {
        value: `
`,
        size: 2
      };
    case 114:
      return {
        value: `\r`,
        size: 2
      };
    case 116:
      return {
        value: "\t",
        size: 2
      };
  }
  throw syntaxError(lexer.source, position, `Invalid character escape sequence: "${body.slice(position, position + 2)}".`);
};
var readBlockString = function(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let lineStart = lexer.lineStart;
  let position = start + 3;
  let chunkStart = position;
  let currentLine = "";
  const blockLines = [];
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
      currentLine += body.slice(chunkStart, position);
      blockLines.push(currentLine);
      const token = createToken(lexer, TokenKind.BLOCK_STRING, start, position + 3, dedentBlockStringLines(blockLines).join("\n"));
      lexer.line += blockLines.length - 1;
      lexer.lineStart = lineStart;
      return token;
    }
    if (code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {
      currentLine += body.slice(chunkStart, position);
      chunkStart = position + 1;
      position += 4;
      continue;
    }
    if (code === 10 || code === 13) {
      currentLine += body.slice(chunkStart, position);
      blockLines.push(currentLine);
      if (code === 13 && body.charCodeAt(position + 1) === 10) {
        position += 2;
      } else {
        ++position;
      }
      currentLine = "";
      chunkStart = position;
      lineStart = position;
      continue;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      throw syntaxError(lexer.source, position, `Invalid character within String: ${printCodePointAt(lexer, position)}.`);
    }
  }
  throw syntaxError(lexer.source, position, "Unterminated string.");
};
var readName = function(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (isNameContinue(code)) {
      ++position;
    } else {
      break;
    }
  }
  return createToken(lexer, TokenKind.NAME, start, position, body.slice(start, position));
};

class Lexer {
  constructor(source) {
    const startOfFileToken = new Token(TokenKind.SOF, 0, 0, 0, 0);
    this.source = source;
    this.lastToken = startOfFileToken;
    this.token = startOfFileToken;
    this.line = 1;
    this.lineStart = 0;
  }
  get [Symbol.toStringTag]() {
    return "Lexer";
  }
  advance() {
    this.lastToken = this.token;
    const token = this.token = this.lookahead();
    return token;
  }
  lookahead() {
    let token = this.token;
    if (token.kind !== TokenKind.EOF) {
      do {
        if (token.next) {
          token = token.next;
        } else {
          const nextToken = readNextToken(this, token.end);
          token.next = nextToken;
          nextToken.prev = token;
          token = nextToken;
        }
      } while (token.kind === TokenKind.COMMENT);
    }
    return token;
  }
}

// node_modules/graphql/jsutils/inspect.mjs
function inspect(value) {
  return formatValue(value, []);
}
var formatValue = function(value, seenValues) {
  switch (typeof value) {
    case "string":
      return JSON.stringify(value);
    case "function":
      return value.name ? `[function ${value.name}]` : "[function]";
    case "object":
      return formatObjectValue(value, seenValues);
    default:
      return String(value);
  }
};
var formatObjectValue = function(value, previouslySeenValues) {
  if (value === null) {
    return "null";
  }
  if (previouslySeenValues.includes(value)) {
    return "[Circular]";
  }
  const seenValues = [...previouslySeenValues, value];
  if (isJSONable(value)) {
    const jsonValue = value.toJSON();
    if (jsonValue !== value) {
      return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
    }
  } else if (Array.isArray(value)) {
    return formatArray(value, seenValues);
  }
  return formatObject(value, seenValues);
};
var isJSONable = function(value) {
  return typeof value.toJSON === "function";
};
var formatObject = function(object, seenValues) {
  const entries = Object.entries(object);
  if (entries.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[" + getObjectTag(object) + "]";
  }
  const properties3 = entries.map(([key, value]) => key + ": " + formatValue(value, seenValues));
  return "{ " + properties3.join(", ") + " }";
};
var formatArray = function(array, seenValues) {
  if (array.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[Array]";
  }
  const len = Math.min(MAX_ARRAY_LENGTH, array.length);
  const remaining = array.length - len;
  const items = [];
  for (let i = 0;i < len; ++i) {
    items.push(formatValue(array[i], seenValues));
  }
  if (remaining === 1) {
    items.push("... 1 more item");
  } else if (remaining > 1) {
    items.push(`... ${remaining} more items`);
  }
  return "[" + items.join(", ") + "]";
};
var getObjectTag = function(object) {
  const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
  if (tag === "Object" && typeof object.constructor === "function") {
    const name = object.constructor.name;
    if (typeof name === "string" && name !== "") {
      return name;
    }
  }
  return tag;
};
var MAX_ARRAY_LENGTH = 10;
var MAX_RECURSIVE_DEPTH = 2;

// node_modules/graphql/jsutils/instanceOf.mjs
var instanceOf = globalThis.process && globalThis.process.env.NODE_ENV === "production" ? function instanceOf2(value, constructor) {
  return value instanceof constructor;
} : function instanceOf3(value, constructor) {
  if (value instanceof constructor) {
    return true;
  }
  if (typeof value === "object" && value !== null) {
    var _value$constructor;
    const className = constructor.prototype[Symbol.toStringTag];
    const valueClassName = Symbol.toStringTag in value ? value[Symbol.toStringTag] : (_value$constructor = value.constructor) === null || _value$constructor === undefined ? undefined : _value$constructor.name;
    if (className === valueClassName) {
      const stringifiedValue = inspect(value);
      throw new Error(`Cannot use ${className} "${stringifiedValue}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
    }
  }
  return false;
};

// node_modules/graphql/language/source.mjs
function isSource(source) {
  return instanceOf(source, Source);
}

class Source {
  constructor(body, name = "GraphQL request", locationOffset = {
    line: 1,
    column: 1
  }) {
    typeof body === "string" || devAssert(false, `Body must be a string. Received: ${inspect(body)}.`);
    this.body = body;
    this.name = name;
    this.locationOffset = locationOffset;
    this.locationOffset.line > 0 || devAssert(false, "line in locationOffset is 1-indexed and must be positive.");
    this.locationOffset.column > 0 || devAssert(false, "column in locationOffset is 1-indexed and must be positive.");
  }
  get [Symbol.toStringTag]() {
    return "Source";
  }
}

// node_modules/graphql/language/parser.mjs
function parse(source2, options) {
  const parser = new Parser(source2, options);
  return parser.parseDocument();
}
var getTokenDesc = function(token) {
  const value = token.value;
  return getTokenKindDesc(token.kind) + (value != null ? ` "${value}"` : "");
};
var getTokenKindDesc = function(kind) {
  return isPunctuatorTokenKind(kind) ? `"${kind}"` : kind;
};

class Parser {
  constructor(source2, options = {}) {
    const sourceObj = isSource(source2) ? source2 : new Source(source2);
    this._lexer = new Lexer(sourceObj);
    this._options = options;
    this._tokenCounter = 0;
  }
  parseName() {
    const token = this.expectToken(TokenKind.NAME);
    return this.node(token, {
      kind: Kind.NAME,
      value: token.value
    });
  }
  parseDocument() {
    return this.node(this._lexer.token, {
      kind: Kind.DOCUMENT,
      definitions: this.many(TokenKind.SOF, this.parseDefinition, TokenKind.EOF)
    });
  }
  parseDefinition() {
    if (this.peek(TokenKind.BRACE_L)) {
      return this.parseOperationDefinition();
    }
    const hasDescription = this.peekDescription();
    const keywordToken = hasDescription ? this._lexer.lookahead() : this._lexer.token;
    if (keywordToken.kind === TokenKind.NAME) {
      switch (keywordToken.value) {
        case "schema":
          return this.parseSchemaDefinition();
        case "scalar":
          return this.parseScalarTypeDefinition();
        case "type":
          return this.parseObjectTypeDefinition();
        case "interface":
          return this.parseInterfaceTypeDefinition();
        case "union":
          return this.parseUnionTypeDefinition();
        case "enum":
          return this.parseEnumTypeDefinition();
        case "input":
          return this.parseInputObjectTypeDefinition();
        case "directive":
          return this.parseDirectiveDefinition();
      }
      if (hasDescription) {
        throw syntaxError(this._lexer.source, this._lexer.token.start, "Unexpected description, descriptions are supported only on type definitions.");
      }
      switch (keywordToken.value) {
        case "query":
        case "mutation":
        case "subscription":
          return this.parseOperationDefinition();
        case "fragment":
          return this.parseFragmentDefinition();
        case "extend":
          return this.parseTypeSystemExtension();
      }
    }
    throw this.unexpected(keywordToken);
  }
  parseOperationDefinition() {
    const start = this._lexer.token;
    if (this.peek(TokenKind.BRACE_L)) {
      return this.node(start, {
        kind: Kind.OPERATION_DEFINITION,
        operation: OperationTypeNode.QUERY,
        name: undefined,
        variableDefinitions: [],
        directives: [],
        selectionSet: this.parseSelectionSet()
      });
    }
    const operation = this.parseOperationType();
    let name;
    if (this.peek(TokenKind.NAME)) {
      name = this.parseName();
    }
    return this.node(start, {
      kind: Kind.OPERATION_DEFINITION,
      operation,
      name,
      variableDefinitions: this.parseVariableDefinitions(),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  parseOperationType() {
    const operationToken = this.expectToken(TokenKind.NAME);
    switch (operationToken.value) {
      case "query":
        return OperationTypeNode.QUERY;
      case "mutation":
        return OperationTypeNode.MUTATION;
      case "subscription":
        return OperationTypeNode.SUBSCRIPTION;
    }
    throw this.unexpected(operationToken);
  }
  parseVariableDefinitions() {
    return this.optionalMany(TokenKind.PAREN_L, this.parseVariableDefinition, TokenKind.PAREN_R);
  }
  parseVariableDefinition() {
    return this.node(this._lexer.token, {
      kind: Kind.VARIABLE_DEFINITION,
      variable: this.parseVariable(),
      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),
      defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseConstValueLiteral() : undefined,
      directives: this.parseConstDirectives()
    });
  }
  parseVariable() {
    const start = this._lexer.token;
    this.expectToken(TokenKind.DOLLAR);
    return this.node(start, {
      kind: Kind.VARIABLE,
      name: this.parseName()
    });
  }
  parseSelectionSet() {
    return this.node(this._lexer.token, {
      kind: Kind.SELECTION_SET,
      selections: this.many(TokenKind.BRACE_L, this.parseSelection, TokenKind.BRACE_R)
    });
  }
  parseSelection() {
    return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
  }
  parseField() {
    const start = this._lexer.token;
    const nameOrAlias = this.parseName();
    let alias;
    let name;
    if (this.expectOptionalToken(TokenKind.COLON)) {
      alias = nameOrAlias;
      name = this.parseName();
    } else {
      name = nameOrAlias;
    }
    return this.node(start, {
      kind: Kind.FIELD,
      alias,
      name,
      arguments: this.parseArguments(false),
      directives: this.parseDirectives(false),
      selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : undefined
    });
  }
  parseArguments(isConst) {
    const item = isConst ? this.parseConstArgument : this.parseArgument;
    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);
  }
  parseArgument(isConst = false) {
    const start = this._lexer.token;
    const name = this.parseName();
    this.expectToken(TokenKind.COLON);
    return this.node(start, {
      kind: Kind.ARGUMENT,
      name,
      value: this.parseValueLiteral(isConst)
    });
  }
  parseConstArgument() {
    return this.parseArgument(true);
  }
  parseFragment() {
    const start = this._lexer.token;
    this.expectToken(TokenKind.SPREAD);
    const hasTypeCondition = this.expectOptionalKeyword("on");
    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {
      return this.node(start, {
        kind: Kind.FRAGMENT_SPREAD,
        name: this.parseFragmentName(),
        directives: this.parseDirectives(false)
      });
    }
    return this.node(start, {
      kind: Kind.INLINE_FRAGMENT,
      typeCondition: hasTypeCondition ? this.parseNamedType() : undefined,
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  parseFragmentDefinition() {
    const start = this._lexer.token;
    this.expectKeyword("fragment");
    if (this._options.allowLegacyFragmentVariables === true) {
      return this.node(start, {
        kind: Kind.FRAGMENT_DEFINITION,
        name: this.parseFragmentName(),
        variableDefinitions: this.parseVariableDefinitions(),
        typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet()
      });
    }
    return this.node(start, {
      kind: Kind.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  parseFragmentName() {
    if (this._lexer.token.value === "on") {
      throw this.unexpected();
    }
    return this.parseName();
  }
  parseValueLiteral(isConst) {
    const token = this._lexer.token;
    switch (token.kind) {
      case TokenKind.BRACKET_L:
        return this.parseList(isConst);
      case TokenKind.BRACE_L:
        return this.parseObject(isConst);
      case TokenKind.INT:
        this.advanceLexer();
        return this.node(token, {
          kind: Kind.INT,
          value: token.value
        });
      case TokenKind.FLOAT:
        this.advanceLexer();
        return this.node(token, {
          kind: Kind.FLOAT,
          value: token.value
        });
      case TokenKind.STRING:
      case TokenKind.BLOCK_STRING:
        return this.parseStringLiteral();
      case TokenKind.NAME:
        this.advanceLexer();
        switch (token.value) {
          case "true":
            return this.node(token, {
              kind: Kind.BOOLEAN,
              value: true
            });
          case "false":
            return this.node(token, {
              kind: Kind.BOOLEAN,
              value: false
            });
          case "null":
            return this.node(token, {
              kind: Kind.NULL
            });
          default:
            return this.node(token, {
              kind: Kind.ENUM,
              value: token.value
            });
        }
      case TokenKind.DOLLAR:
        if (isConst) {
          this.expectToken(TokenKind.DOLLAR);
          if (this._lexer.token.kind === TokenKind.NAME) {
            const varName = this._lexer.token.value;
            throw syntaxError(this._lexer.source, token.start, `Unexpected variable "\$${varName}" in constant value.`);
          } else {
            throw this.unexpected(token);
          }
        }
        return this.parseVariable();
      default:
        throw this.unexpected();
    }
  }
  parseConstValueLiteral() {
    return this.parseValueLiteral(true);
  }
  parseStringLiteral() {
    const token = this._lexer.token;
    this.advanceLexer();
    return this.node(token, {
      kind: Kind.STRING,
      value: token.value,
      block: token.kind === TokenKind.BLOCK_STRING
    });
  }
  parseList(isConst) {
    const item = () => this.parseValueLiteral(isConst);
    return this.node(this._lexer.token, {
      kind: Kind.LIST,
      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R)
    });
  }
  parseObject(isConst) {
    const item = () => this.parseObjectField(isConst);
    return this.node(this._lexer.token, {
      kind: Kind.OBJECT,
      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R)
    });
  }
  parseObjectField(isConst) {
    const start = this._lexer.token;
    const name = this.parseName();
    this.expectToken(TokenKind.COLON);
    return this.node(start, {
      kind: Kind.OBJECT_FIELD,
      name,
      value: this.parseValueLiteral(isConst)
    });
  }
  parseDirectives(isConst) {
    const directives = [];
    while (this.peek(TokenKind.AT)) {
      directives.push(this.parseDirective(isConst));
    }
    return directives;
  }
  parseConstDirectives() {
    return this.parseDirectives(true);
  }
  parseDirective(isConst) {
    const start = this._lexer.token;
    this.expectToken(TokenKind.AT);
    return this.node(start, {
      kind: Kind.DIRECTIVE,
      name: this.parseName(),
      arguments: this.parseArguments(isConst)
    });
  }
  parseTypeReference() {
    const start = this._lexer.token;
    let type;
    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {
      const innerType = this.parseTypeReference();
      this.expectToken(TokenKind.BRACKET_R);
      type = this.node(start, {
        kind: Kind.LIST_TYPE,
        type: innerType
      });
    } else {
      type = this.parseNamedType();
    }
    if (this.expectOptionalToken(TokenKind.BANG)) {
      return this.node(start, {
        kind: Kind.NON_NULL_TYPE,
        type
      });
    }
    return type;
  }
  parseNamedType() {
    return this.node(this._lexer.token, {
      kind: Kind.NAMED_TYPE,
      name: this.parseName()
    });
  }
  peekDescription() {
    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);
  }
  parseDescription() {
    if (this.peekDescription()) {
      return this.parseStringLiteral();
    }
  }
  parseSchemaDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("schema");
    const directives = this.parseConstDirectives();
    const operationTypes = this.many(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);
    return this.node(start, {
      kind: Kind.SCHEMA_DEFINITION,
      description,
      directives,
      operationTypes
    });
  }
  parseOperationTypeDefinition() {
    const start = this._lexer.token;
    const operation = this.parseOperationType();
    this.expectToken(TokenKind.COLON);
    const type = this.parseNamedType();
    return this.node(start, {
      kind: Kind.OPERATION_TYPE_DEFINITION,
      operation,
      type
    });
  }
  parseScalarTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("scalar");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.SCALAR_TYPE_DEFINITION,
      description,
      name,
      directives
    });
  }
  parseObjectTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("type");
    const name = this.parseName();
    const interfaces3 = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    return this.node(start, {
      kind: Kind.OBJECT_TYPE_DEFINITION,
      description,
      name,
      interfaces: interfaces3,
      directives,
      fields
    });
  }
  parseImplementsInterfaces() {
    return this.expectOptionalKeyword("implements") ? this.delimitedMany(TokenKind.AMP, this.parseNamedType) : [];
  }
  parseFieldsDefinition() {
    return this.optionalMany(TokenKind.BRACE_L, this.parseFieldDefinition, TokenKind.BRACE_R);
  }
  parseFieldDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    const name = this.parseName();
    const args = this.parseArgumentDefs();
    this.expectToken(TokenKind.COLON);
    const type = this.parseTypeReference();
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.FIELD_DEFINITION,
      description,
      name,
      arguments: args,
      type,
      directives
    });
  }
  parseArgumentDefs() {
    return this.optionalMany(TokenKind.PAREN_L, this.parseInputValueDef, TokenKind.PAREN_R);
  }
  parseInputValueDef() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    const name = this.parseName();
    this.expectToken(TokenKind.COLON);
    const type = this.parseTypeReference();
    let defaultValue;
    if (this.expectOptionalToken(TokenKind.EQUALS)) {
      defaultValue = this.parseConstValueLiteral();
    }
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.INPUT_VALUE_DEFINITION,
      description,
      name,
      type,
      defaultValue,
      directives
    });
  }
  parseInterfaceTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("interface");
    const name = this.parseName();
    const interfaces3 = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    return this.node(start, {
      kind: Kind.INTERFACE_TYPE_DEFINITION,
      description,
      name,
      interfaces: interfaces3,
      directives,
      fields
    });
  }
  parseUnionTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("union");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const types = this.parseUnionMemberTypes();
    return this.node(start, {
      kind: Kind.UNION_TYPE_DEFINITION,
      description,
      name,
      directives,
      types
    });
  }
  parseUnionMemberTypes() {
    return this.expectOptionalToken(TokenKind.EQUALS) ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType) : [];
  }
  parseEnumTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("enum");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const values = this.parseEnumValuesDefinition();
    return this.node(start, {
      kind: Kind.ENUM_TYPE_DEFINITION,
      description,
      name,
      directives,
      values
    });
  }
  parseEnumValuesDefinition() {
    return this.optionalMany(TokenKind.BRACE_L, this.parseEnumValueDefinition, TokenKind.BRACE_R);
  }
  parseEnumValueDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    const name = this.parseEnumValueName();
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.ENUM_VALUE_DEFINITION,
      description,
      name,
      directives
    });
  }
  parseEnumValueName() {
    if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null") {
      throw syntaxError(this._lexer.source, this._lexer.token.start, `${getTokenDesc(this._lexer.token)} is reserved and cannot be used for an enum value.`);
    }
    return this.parseName();
  }
  parseInputObjectTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("input");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const fields = this.parseInputFieldsDefinition();
    return this.node(start, {
      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,
      description,
      name,
      directives,
      fields
    });
  }
  parseInputFieldsDefinition() {
    return this.optionalMany(TokenKind.BRACE_L, this.parseInputValueDef, TokenKind.BRACE_R);
  }
  parseTypeSystemExtension() {
    const keywordToken = this._lexer.lookahead();
    if (keywordToken.kind === TokenKind.NAME) {
      switch (keywordToken.value) {
        case "schema":
          return this.parseSchemaExtension();
        case "scalar":
          return this.parseScalarTypeExtension();
        case "type":
          return this.parseObjectTypeExtension();
        case "interface":
          return this.parseInterfaceTypeExtension();
        case "union":
          return this.parseUnionTypeExtension();
        case "enum":
          return this.parseEnumTypeExtension();
        case "input":
          return this.parseInputObjectTypeExtension();
      }
    }
    throw this.unexpected(keywordToken);
  }
  parseSchemaExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("schema");
    const directives = this.parseConstDirectives();
    const operationTypes = this.optionalMany(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);
    if (directives.length === 0 && operationTypes.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.SCHEMA_EXTENSION,
      directives,
      operationTypes
    });
  }
  parseScalarTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("scalar");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    if (directives.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.SCALAR_TYPE_EXTENSION,
      name,
      directives
    });
  }
  parseObjectTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("type");
    const name = this.parseName();
    const interfaces3 = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    if (interfaces3.length === 0 && directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.OBJECT_TYPE_EXTENSION,
      name,
      interfaces: interfaces3,
      directives,
      fields
    });
  }
  parseInterfaceTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("interface");
    const name = this.parseName();
    const interfaces3 = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    if (interfaces3.length === 0 && directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.INTERFACE_TYPE_EXTENSION,
      name,
      interfaces: interfaces3,
      directives,
      fields
    });
  }
  parseUnionTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("union");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const types = this.parseUnionMemberTypes();
    if (directives.length === 0 && types.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.UNION_TYPE_EXTENSION,
      name,
      directives,
      types
    });
  }
  parseEnumTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("enum");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const values = this.parseEnumValuesDefinition();
    if (directives.length === 0 && values.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.ENUM_TYPE_EXTENSION,
      name,
      directives,
      values
    });
  }
  parseInputObjectTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("input");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const fields = this.parseInputFieldsDefinition();
    if (directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,
      name,
      directives,
      fields
    });
  }
  parseDirectiveDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("directive");
    this.expectToken(TokenKind.AT);
    const name = this.parseName();
    const args = this.parseArgumentDefs();
    const repeatable = this.expectOptionalKeyword("repeatable");
    this.expectKeyword("on");
    const locations = this.parseDirectiveLocations();
    return this.node(start, {
      kind: Kind.DIRECTIVE_DEFINITION,
      description,
      name,
      arguments: args,
      repeatable,
      locations
    });
  }
  parseDirectiveLocations() {
    return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);
  }
  parseDirectiveLocation() {
    const start = this._lexer.token;
    const name = this.parseName();
    if (Object.prototype.hasOwnProperty.call(DirectiveLocation, name.value)) {
      return name;
    }
    throw this.unexpected(start);
  }
  node(startToken, node) {
    if (this._options.noLocation !== true) {
      node.loc = new Location(startToken, this._lexer.lastToken, this._lexer.source);
    }
    return node;
  }
  peek(kind) {
    return this._lexer.token.kind === kind;
  }
  expectToken(kind) {
    const token = this._lexer.token;
    if (token.kind === kind) {
      this.advanceLexer();
      return token;
    }
    throw syntaxError(this._lexer.source, token.start, `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`);
  }
  expectOptionalToken(kind) {
    const token = this._lexer.token;
    if (token.kind === kind) {
      this.advanceLexer();
      return true;
    }
    return false;
  }
  expectKeyword(value) {
    const token = this._lexer.token;
    if (token.kind === TokenKind.NAME && token.value === value) {
      this.advanceLexer();
    } else {
      throw syntaxError(this._lexer.source, token.start, `Expected "${value}", found ${getTokenDesc(token)}.`);
    }
  }
  expectOptionalKeyword(value) {
    const token = this._lexer.token;
    if (token.kind === TokenKind.NAME && token.value === value) {
      this.advanceLexer();
      return true;
    }
    return false;
  }
  unexpected(atToken) {
    const token = atToken !== null && atToken !== undefined ? atToken : this._lexer.token;
    return syntaxError(this._lexer.source, token.start, `Unexpected ${getTokenDesc(token)}.`);
  }
  any(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    const nodes = [];
    while (!this.expectOptionalToken(closeKind)) {
      nodes.push(parseFn.call(this));
    }
    return nodes;
  }
  optionalMany(openKind, parseFn, closeKind) {
    if (this.expectOptionalToken(openKind)) {
      const nodes = [];
      do {
        nodes.push(parseFn.call(this));
      } while (!this.expectOptionalToken(closeKind));
      return nodes;
    }
    return [];
  }
  many(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    const nodes = [];
    do {
      nodes.push(parseFn.call(this));
    } while (!this.expectOptionalToken(closeKind));
    return nodes;
  }
  delimitedMany(delimiterKind, parseFn) {
    this.expectOptionalToken(delimiterKind);
    const nodes = [];
    do {
      nodes.push(parseFn.call(this));
    } while (this.expectOptionalToken(delimiterKind));
    return nodes;
  }
  advanceLexer() {
    const { maxTokens } = this._options;
    const token = this._lexer.advance();
    if (maxTokens !== undefined && token.kind !== TokenKind.EOF) {
      ++this._tokenCounter;
      if (this._tokenCounter > maxTokens) {
        throw syntaxError(this._lexer.source, token.start, `Document contains more that ${maxTokens} tokens. Parsing aborted.`);
      }
    }
  }
}

// node_modules/graphql/language/printString.mjs
function printString(str) {
  return `"${str.replace(escapedRegExp, escapedReplacer)}"`;
}
var escapedReplacer = function(str) {
  return escapeSequences[str.charCodeAt(0)];
};
var escapedRegExp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
var escapeSequences = [
  "\\u0000",
  "\\u0001",
  "\\u0002",
  "\\u0003",
  "\\u0004",
  "\\u0005",
  "\\u0006",
  "\\u0007",
  "\\b",
  "\\t",
  "\\n",
  "\\u000B",
  "\\f",
  "\\r",
  "\\u000E",
  "\\u000F",
  "\\u0010",
  "\\u0011",
  "\\u0012",
  "\\u0013",
  "\\u0014",
  "\\u0015",
  "\\u0016",
  "\\u0017",
  "\\u0018",
  "\\u0019",
  "\\u001A",
  "\\u001B",
  "\\u001C",
  "\\u001D",
  "\\u001E",
  "\\u001F",
  "",
  "",
  '\\"',
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\\\",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\u007F",
  "\\u0080",
  "\\u0081",
  "\\u0082",
  "\\u0083",
  "\\u0084",
  "\\u0085",
  "\\u0086",
  "\\u0087",
  "\\u0088",
  "\\u0089",
  "\\u008A",
  "\\u008B",
  "\\u008C",
  "\\u008D",
  "\\u008E",
  "\\u008F",
  "\\u0090",
  "\\u0091",
  "\\u0092",
  "\\u0093",
  "\\u0094",
  "\\u0095",
  "\\u0096",
  "\\u0097",
  "\\u0098",
  "\\u0099",
  "\\u009A",
  "\\u009B",
  "\\u009C",
  "\\u009D",
  "\\u009E",
  "\\u009F"
];

// node_modules/graphql/language/visitor.mjs
function visit(root, visitor, visitorKeys = QueryDocumentKeys) {
  const enterLeaveMap = new Map;
  for (const kind of Object.values(Kind)) {
    enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));
  }
  let stack = undefined;
  let inArray = Array.isArray(root);
  let keys = [root];
  let index = -1;
  let edits = [];
  let node = root;
  let key = undefined;
  let parent = undefined;
  const path = [];
  const ancestors = [];
  do {
    index++;
    const isLeaving = index === keys.length;
    const isEdited = isLeaving && edits.length !== 0;
    if (isLeaving) {
      key = ancestors.length === 0 ? undefined : path[path.length - 1];
      node = parent;
      parent = ancestors.pop();
      if (isEdited) {
        if (inArray) {
          node = node.slice();
          let editOffset = 0;
          for (const [editKey, editValue] of edits) {
            const arrayKey = editKey - editOffset;
            if (editValue === null) {
              node.splice(arrayKey, 1);
              editOffset++;
            } else {
              node[arrayKey] = editValue;
            }
          }
        } else {
          node = Object.defineProperties({}, Object.getOwnPropertyDescriptors(node));
          for (const [editKey, editValue] of edits) {
            node[editKey] = editValue;
          }
        }
      }
      index = stack.index;
      keys = stack.keys;
      edits = stack.edits;
      inArray = stack.inArray;
      stack = stack.prev;
    } else if (parent) {
      key = inArray ? index : keys[index];
      node = parent[key];
      if (node === null || node === undefined) {
        continue;
      }
      path.push(key);
    }
    let result;
    if (!Array.isArray(node)) {
      var _enterLeaveMap$get, _enterLeaveMap$get2;
      isNode(node) || devAssert(false, `Invalid AST Node: ${inspect(node)}.`);
      const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get === undefined ? undefined : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get2 === undefined ? undefined : _enterLeaveMap$get2.enter;
      result = visitFn === null || visitFn === undefined ? undefined : visitFn.call(visitor, node, key, parent, path, ancestors);
      if (result === BREAK) {
        break;
      }
      if (result === false) {
        if (!isLeaving) {
          path.pop();
          continue;
        }
      } else if (result !== undefined) {
        edits.push([key, result]);
        if (!isLeaving) {
          if (isNode(result)) {
            node = result;
          } else {
            path.pop();
            continue;
          }
        }
      }
    }
    if (result === undefined && isEdited) {
      edits.push([key, node]);
    }
    if (isLeaving) {
      path.pop();
    } else {
      var _node$kind;
      stack = {
        inArray,
        index,
        keys,
        edits,
        prev: stack
      };
      inArray = Array.isArray(node);
      keys = inArray ? node : (_node$kind = visitorKeys[node.kind]) !== null && _node$kind !== undefined ? _node$kind : [];
      index = -1;
      edits = [];
      if (parent) {
        ancestors.push(parent);
      }
      parent = node;
    }
  } while (stack !== undefined);
  if (edits.length !== 0) {
    return edits[edits.length - 1][1];
  }
  return root;
}
function getEnterLeaveForKind(visitor, kind) {
  const kindVisitor = visitor[kind];
  if (typeof kindVisitor === "object") {
    return kindVisitor;
  } else if (typeof kindVisitor === "function") {
    return {
      enter: kindVisitor,
      leave: undefined
    };
  }
  return {
    enter: visitor.enter,
    leave: visitor.leave
  };
}
var BREAK = Object.freeze({});

// node_modules/graphql/language/printer.mjs
function print(ast4) {
  return visit(ast4, printDocASTReducer);
}
var join = function(maybeArray, separator = "") {
  var _maybeArray$filter$jo;
  return (_maybeArray$filter$jo = maybeArray === null || maybeArray === undefined ? undefined : maybeArray.filter((x) => x).join(separator)) !== null && _maybeArray$filter$jo !== undefined ? _maybeArray$filter$jo : "";
};
var block = function(array) {
  return wrap("{\n", indent(join(array, "\n")), "\n}");
};
var wrap = function(start, maybeString, end = "") {
  return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
};
var indent = function(str) {
  return wrap("  ", str.replace(/\n/g, "\n  "));
};
var hasMultilineItems = function(maybeArray) {
  var _maybeArray$some;
  return (_maybeArray$some = maybeArray === null || maybeArray === undefined ? undefined : maybeArray.some((str) => str.includes("\n"))) !== null && _maybeArray$some !== undefined ? _maybeArray$some : false;
};
var MAX_LINE_LENGTH = 80;
var printDocASTReducer = {
  Name: {
    leave: (node) => node.value
  },
  Variable: {
    leave: (node) => "$" + node.name
  },
  Document: {
    leave: (node) => join(node.definitions, "\n\n")
  },
  OperationDefinition: {
    leave(node) {
      const varDefs = wrap("(", join(node.variableDefinitions, ", "), ")");
      const prefix = join([
        node.operation,
        join([node.name, varDefs]),
        join(node.directives, " ")
      ], " ");
      return (prefix === "query" ? "" : prefix + " ") + node.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable, type, defaultValue, directives }) => variable + ": " + type + wrap(" = ", defaultValue) + wrap(" ", join(directives, " "))
  },
  SelectionSet: {
    leave: ({ selections }) => block(selections)
  },
  Field: {
    leave({ alias, name, arguments: args, directives, selectionSet }) {
      const prefix = wrap("", alias, ": ") + name;
      let argsLine = prefix + wrap("(", join(args, ", "), ")");
      if (argsLine.length > MAX_LINE_LENGTH) {
        argsLine = prefix + wrap("(\n", indent(join(args, "\n")), "\n)");
      }
      return join([argsLine, join(directives, " "), selectionSet], " ");
    }
  },
  Argument: {
    leave: ({ name, value }) => name + ": " + value
  },
  FragmentSpread: {
    leave: ({ name, directives }) => "..." + name + wrap(" ", join(directives, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition, directives, selectionSet }) => join([
      "...",
      wrap("on ", typeCondition),
      join(directives, " "),
      selectionSet
    ], " ")
  },
  FragmentDefinition: {
    leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => `fragment ${name}${wrap("(", join(variableDefinitions, ", "), ")")} ` + `on ${typeCondition} ${wrap("", join(directives, " "), " ")}` + selectionSet
  },
  IntValue: {
    leave: ({ value }) => value
  },
  FloatValue: {
    leave: ({ value }) => value
  },
  StringValue: {
    leave: ({ value, block: isBlockString }) => isBlockString ? printBlockString(value) : printString(value)
  },
  BooleanValue: {
    leave: ({ value }) => value ? "true" : "false"
  },
  NullValue: {
    leave: () => "null"
  },
  EnumValue: {
    leave: ({ value }) => value
  },
  ListValue: {
    leave: ({ values }) => "[" + join(values, ", ") + "]"
  },
  ObjectValue: {
    leave: ({ fields }) => "{" + join(fields, ", ") + "}"
  },
  ObjectField: {
    leave: ({ name, value }) => name + ": " + value
  },
  Directive: {
    leave: ({ name, arguments: args }) => "@" + name + wrap("(", join(args, ", "), ")")
  },
  NamedType: {
    leave: ({ name }) => name
  },
  ListType: {
    leave: ({ type }) => "[" + type + "]"
  },
  NonNullType: {
    leave: ({ type }) => type + "!"
  },
  SchemaDefinition: {
    leave: ({ description, directives, operationTypes }) => wrap("", description, "\n") + join(["schema", join(directives, " "), block(operationTypes)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation, type }) => operation + ": " + type
  },
  ScalarTypeDefinition: {
    leave: ({ description, name, directives }) => wrap("", description, "\n") + join(["scalar", name, join(directives, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ description, name, interfaces: interfaces3, directives, fields }) => wrap("", description, "\n") + join([
      "type",
      name,
      wrap("implements ", join(interfaces3, " & ")),
      join(directives, " "),
      block(fields)
    ], " ")
  },
  FieldDefinition: {
    leave: ({ description, name, arguments: args, type, directives }) => wrap("", description, "\n") + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + ": " + type + wrap(" ", join(directives, " "))
  },
  InputValueDefinition: {
    leave: ({ description, name, type, defaultValue, directives }) => wrap("", description, "\n") + join([name + ": " + type, wrap("= ", defaultValue), join(directives, " ")], " ")
  },
  InterfaceTypeDefinition: {
    leave: ({ description, name, interfaces: interfaces3, directives, fields }) => wrap("", description, "\n") + join([
      "interface",
      name,
      wrap("implements ", join(interfaces3, " & ")),
      join(directives, " "),
      block(fields)
    ], " ")
  },
  UnionTypeDefinition: {
    leave: ({ description, name, directives, types }) => wrap("", description, "\n") + join(["union", name, join(directives, " "), wrap("= ", join(types, " | "))], " ")
  },
  EnumTypeDefinition: {
    leave: ({ description, name, directives, values }) => wrap("", description, "\n") + join(["enum", name, join(directives, " "), block(values)], " ")
  },
  EnumValueDefinition: {
    leave: ({ description, name, directives }) => wrap("", description, "\n") + join([name, join(directives, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ description, name, directives, fields }) => wrap("", description, "\n") + join(["input", name, join(directives, " "), block(fields)], " ")
  },
  DirectiveDefinition: {
    leave: ({ description, name, arguments: args, repeatable, locations }) => wrap("", description, "\n") + "directive @" + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ")
  },
  SchemaExtension: {
    leave: ({ directives, operationTypes }) => join(["extend schema", join(directives, " "), block(operationTypes)], " ")
  },
  ScalarTypeExtension: {
    leave: ({ name, directives }) => join(["extend scalar", name, join(directives, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name, interfaces: interfaces3, directives, fields }) => join([
      "extend type",
      name,
      wrap("implements ", join(interfaces3, " & ")),
      join(directives, " "),
      block(fields)
    ], " ")
  },
  InterfaceTypeExtension: {
    leave: ({ name, interfaces: interfaces3, directives, fields }) => join([
      "extend interface",
      name,
      wrap("implements ", join(interfaces3, " & ")),
      join(directives, " "),
      block(fields)
    ], " ")
  },
  UnionTypeExtension: {
    leave: ({ name, directives, types }) => join([
      "extend union",
      name,
      join(directives, " "),
      wrap("= ", join(types, " | "))
    ], " ")
  },
  EnumTypeExtension: {
    leave: ({ name, directives, values }) => join(["extend enum", name, join(directives, " "), block(values)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name, directives, fields }) => join(["extend input", name, join(directives, " "), block(fields)], " ")
  }
};
// node_modules/graphql-request/build/esm/resolveRequestDocument.js
var extractOperationName = (document) => {
  let operationName = undefined;
  const operationDefinitions = document.definitions.filter((definition) => definition.kind === `OperationDefinition`);
  if (operationDefinitions.length === 1) {
    operationName = operationDefinitions[0]?.name?.value;
  }
  return operationName;
};
var resolveRequestDocument = (document) => {
  if (typeof document === `string`) {
    let operationName2 = undefined;
    try {
      const parsedDocument = parse(document);
      operationName2 = extractOperationName(parsedDocument);
    } catch (err) {
    }
    return { query: document, operationName: operationName2 };
  }
  const operationName = extractOperationName(document);
  return { query: print(document), operationName };
};

// node_modules/graphql-request/build/esm/types.js
class ClientError extends Error {
  constructor(response, request) {
    const message = `${ClientError.extractMessage(response)}: ${JSON.stringify({
      response,
      request
    })}`;
    super(message);
    Object.setPrototypeOf(this, ClientError.prototype);
    this.response = response;
    this.request = request;
    if (typeof Error.captureStackTrace === `function`) {
      Error.captureStackTrace(this, ClientError);
    }
  }
  static extractMessage(response) {
    return response.errors?.[0]?.message ?? `GraphQL Error (Code: ${response.status})`;
  }
}

// node_modules/graphql-request/build/esm/index.js
var CrossFetch = __toESM(require_browser_ponyfill(), 1);

// node_modules/graphql-request/build/esm/graphql-ws.js
var parseMessage = function(data3, f2 = (a) => a) {
  const m = GraphQLWebSocketMessage.parse(data3, f2);
  return m;
};
var ConnectionInit = function(payload) {
  return new GraphQLWebSocketMessage(CONNECTION_INIT, payload);
};
var Ping = function(payload) {
  return new GraphQLWebSocketMessage(PING, payload, undefined);
};
var Pong = function(payload) {
  return new GraphQLWebSocketMessage(PONG, payload, undefined);
};
var Subscribe = function(id, payload) {
  return new GraphQLWebSocketMessage(SUBSCRIBE, payload, id);
};
var Complete = function(id) {
  return new GraphQLWebSocketMessage(COMPLETE, undefined, id);
};
var CONNECTION_INIT = `connection_init`;
var CONNECTION_ACK = `connection_ack`;
var PING = `ping`;
var PONG = `pong`;
var SUBSCRIBE = `subscribe`;
var NEXT = `next`;
var ERROR = `error`;
var COMPLETE = `complete`;

class GraphQLWebSocketMessage {
  get type() {
    return this._type;
  }
  get id() {
    return this._id;
  }
  get payload() {
    return this._payload;
  }
  constructor(type, payload, id) {
    this._type = type;
    this._payload = payload;
    this._id = id;
  }
  get text() {
    const result = { type: this.type };
    if (this.id != null && this.id != null)
      result.id = this.id;
    if (this.payload != null && this.payload != null)
      result.payload = this.payload;
    return JSON.stringify(result);
  }
  static parse(data3, f2) {
    const { type, payload, id } = JSON.parse(data3);
    return new GraphQLWebSocketMessage(type, f2(payload), id);
  }
}

class GraphQLWebSocketClient {
  constructor(socket, { onInit, onAcknowledged, onPing, onPong }) {
    this.socketState = { acknowledged: false, lastRequestId: 0, subscriptions: {} };
    this.socket = socket;
    socket.onopen = async (e) => {
      this.socketState.acknowledged = false;
      this.socketState.subscriptions = {};
      socket.send(ConnectionInit(onInit ? await onInit() : null).text);
    };
    socket.onclose = (e) => {
      this.socketState.acknowledged = false;
      this.socketState.subscriptions = {};
    };
    socket.onerror = (e) => {
      console.error(e);
    };
    socket.onmessage = (e) => {
      try {
        const message = parseMessage(e.data);
        switch (message.type) {
          case CONNECTION_ACK: {
            if (this.socketState.acknowledged) {
              console.warn(`Duplicate CONNECTION_ACK message ignored`);
            } else {
              this.socketState.acknowledged = true;
              if (onAcknowledged)
                onAcknowledged(message.payload);
            }
            return;
          }
          case PING: {
            if (onPing)
              onPing(message.payload).then((r) => socket.send(Pong(r).text));
            else
              socket.send(Pong(null).text);
            return;
          }
          case PONG: {
            if (onPong)
              onPong(message.payload);
            return;
          }
        }
        if (!this.socketState.acknowledged) {
          return;
        }
        if (message.id === undefined || message.id === null || !this.socketState.subscriptions[message.id]) {
          return;
        }
        const { query, variables, subscriber } = this.socketState.subscriptions[message.id];
        switch (message.type) {
          case NEXT: {
            if (!message.payload.errors && message.payload.data) {
              subscriber.next && subscriber.next(message.payload.data);
            }
            if (message.payload.errors) {
              subscriber.error && subscriber.error(new ClientError({ ...message.payload, status: 200 }, { query, variables }));
            } else {
            }
            return;
          }
          case ERROR: {
            subscriber.error && subscriber.error(new ClientError({ errors: message.payload, status: 200 }, { query, variables }));
            return;
          }
          case COMPLETE: {
            subscriber.complete && subscriber.complete();
            delete this.socketState.subscriptions[message.id];
            return;
          }
        }
      } catch (e2) {
        console.error(e2);
        socket.close(1006);
      }
      socket.close(4400, `Unknown graphql-ws message.`);
    };
  }
  makeSubscribe(query, operationName, subscriber, variables) {
    const subscriptionId = (this.socketState.lastRequestId++).toString();
    this.socketState.subscriptions[subscriptionId] = { query, variables, subscriber };
    this.socket.send(Subscribe(subscriptionId, { query, operationName, variables }).text);
    return () => {
      this.socket.send(Complete(subscriptionId).text);
      delete this.socketState.subscriptions[subscriptionId];
    };
  }
  rawRequest(query, variables) {
    return new Promise((resolve, reject) => {
      let result;
      this.rawSubscribe(query, {
        next: (data3, extensions) => result = { data: data3, extensions },
        error: reject,
        complete: () => resolve(result)
      }, variables);
    });
  }
  request(document, variables) {
    return new Promise((resolve, reject) => {
      let result;
      this.subscribe(document, {
        next: (data3) => result = data3,
        error: reject,
        complete: () => resolve(result)
      }, variables);
    });
  }
  subscribe(document, subscriber, variables) {
    const { query, operationName } = resolveRequestDocument(document);
    return this.makeSubscribe(query, operationName, subscriber, variables);
  }
  rawSubscribe(query, subscriber, variables) {
    return this.makeSubscribe(query, undefined, subscriber, variables);
  }
  ping(payload) {
    this.socket.send(Ping(payload).text);
  }
  close() {
    this.socket.close(1000);
  }
}
GraphQLWebSocketClient.PROTOCOL = `graphql-transport-ws`;
// node_modules/graphql-request/build/esm/index.js
var resolveHeaders = (headers) => {
  let oHeaders = {};
  if (headers) {
    if (typeof Headers !== `undefined` && headers instanceof Headers || CrossFetch && CrossFetch.Headers && headers instanceof CrossFetch.Headers) {
      oHeaders = HeadersInstanceToPlainObject(headers);
    } else if (Array.isArray(headers)) {
      headers.forEach(([name, value]) => {
        if (name && value !== undefined) {
          oHeaders[name] = value;
        }
      });
    } else {
      oHeaders = headers;
    }
  }
  return oHeaders;
};
var cleanQuery = (str) => str.replace(/([\s,]|#[^\n\r]+)+/g, ` `).trim();
var buildRequestConfig = (params) => {
  if (!Array.isArray(params.query)) {
    const params_2 = params;
    const search = [`query=${encodeURIComponent(cleanQuery(params_2.query))}`];
    if (params.variables) {
      search.push(`variables=${encodeURIComponent(params_2.jsonSerializer.stringify(params_2.variables))}`);
    }
    if (params_2.operationName) {
      search.push(`operationName=${encodeURIComponent(params_2.operationName)}`);
    }
    return search.join(`&`);
  }
  if (typeof params.variables !== `undefined` && !Array.isArray(params.variables)) {
    throw new Error(`Cannot create query with given variable type, array expected`);
  }
  const params_ = params;
  const payload = params.query.reduce((acc, currentQuery, index) => {
    acc.push({
      query: cleanQuery(currentQuery),
      variables: params_.variables ? params_.jsonSerializer.stringify(params_.variables[index]) : undefined
    });
    return acc;
  }, []);
  return `query=${encodeURIComponent(params_.jsonSerializer.stringify(payload))}`;
};
var createHttpMethodFetcher = (method) => async (params) => {
  const { url, query, variables, operationName, fetch, fetchOptions, middleware } = params;
  const headers = { ...params.headers };
  let queryParams = ``;
  let body = undefined;
  if (method === `POST`) {
    body = createRequestBody_default(query, variables, operationName, fetchOptions.jsonSerializer);
    if (typeof body === `string`) {
      headers[`Content-Type`] = `application/json`;
    }
  } else {
    queryParams = buildRequestConfig({
      query,
      variables,
      operationName,
      jsonSerializer: fetchOptions.jsonSerializer ?? defaultJsonSerializer
    });
  }
  const init = {
    method,
    headers,
    body,
    ...fetchOptions
  };
  let urlResolved = url;
  let initResolved = init;
  if (middleware) {
    const result = await Promise.resolve(middleware({ ...init, url, operationName, variables }));
    const { url: urlNew, ...initNew } = result;
    urlResolved = urlNew;
    initResolved = initNew;
  }
  if (queryParams) {
    urlResolved = `${urlResolved}?${queryParams}`;
  }
  return await fetch(urlResolved, initResolved);
};

class GraphQLClient {
  constructor(url, requestConfig = {}) {
    this.url = url;
    this.requestConfig = requestConfig;
    this.rawRequest = async (...args) => {
      const [queryOrOptions, variables, requestHeaders] = args;
      const rawRequestOptions = parseRawRequestArgs(queryOrOptions, variables, requestHeaders);
      const { headers, fetch = CrossFetch.default, method = `POST`, requestMiddleware, responseMiddleware, ...fetchOptions } = this.requestConfig;
      const { url: url2 } = this;
      if (rawRequestOptions.signal !== undefined) {
        fetchOptions.signal = rawRequestOptions.signal;
      }
      const { operationName } = resolveRequestDocument(rawRequestOptions.query);
      return makeRequest({
        url: url2,
        query: rawRequestOptions.query,
        variables: rawRequestOptions.variables,
        headers: {
          ...resolveHeaders(callOrIdentity(headers)),
          ...resolveHeaders(rawRequestOptions.requestHeaders)
        },
        operationName,
        fetch,
        method,
        fetchOptions,
        middleware: requestMiddleware
      }).then((response) => {
        if (responseMiddleware) {
          responseMiddleware(response);
        }
        return response;
      }).catch((error) => {
        if (responseMiddleware) {
          responseMiddleware(error);
        }
        throw error;
      });
    };
  }
  async request(documentOrOptions, ...variablesAndRequestHeaders) {
    const [variables, requestHeaders] = variablesAndRequestHeaders;
    const requestOptions = parseRequestArgs(documentOrOptions, variables, requestHeaders);
    const { headers, fetch = CrossFetch.default, method = `POST`, requestMiddleware, responseMiddleware, ...fetchOptions } = this.requestConfig;
    const { url } = this;
    if (requestOptions.signal !== undefined) {
      fetchOptions.signal = requestOptions.signal;
    }
    const { query, operationName } = resolveRequestDocument(requestOptions.document);
    return makeRequest({
      url,
      query,
      variables: requestOptions.variables,
      headers: {
        ...resolveHeaders(callOrIdentity(headers)),
        ...resolveHeaders(requestOptions.requestHeaders)
      },
      operationName,
      fetch,
      method,
      fetchOptions,
      middleware: requestMiddleware
    }).then((response) => {
      if (responseMiddleware) {
        responseMiddleware(response);
      }
      return response.data;
    }).catch((error) => {
      if (responseMiddleware) {
        responseMiddleware(error);
      }
      throw error;
    });
  }
  batchRequests(documentsOrOptions, requestHeaders) {
    const batchRequestOptions = parseBatchRequestArgs(documentsOrOptions, requestHeaders);
    const { headers, ...fetchOptions } = this.requestConfig;
    if (batchRequestOptions.signal !== undefined) {
      fetchOptions.signal = batchRequestOptions.signal;
    }
    const queries = batchRequestOptions.documents.map(({ document }) => resolveRequestDocument(document).query);
    const variables = batchRequestOptions.documents.map(({ variables: variables2 }) => variables2);
    return makeRequest({
      url: this.url,
      query: queries,
      variables,
      headers: {
        ...resolveHeaders(callOrIdentity(headers)),
        ...resolveHeaders(batchRequestOptions.requestHeaders)
      },
      operationName: undefined,
      fetch: this.requestConfig.fetch ?? CrossFetch.default,
      method: this.requestConfig.method || `POST`,
      fetchOptions,
      middleware: this.requestConfig.requestMiddleware
    }).then((response) => {
      if (this.requestConfig.responseMiddleware) {
        this.requestConfig.responseMiddleware(response);
      }
      return response.data;
    }).catch((error) => {
      if (this.requestConfig.responseMiddleware) {
        this.requestConfig.responseMiddleware(error);
      }
      throw error;
    });
  }
  setHeaders(headers) {
    this.requestConfig.headers = headers;
    return this;
  }
  setHeader(key, value) {
    const { headers } = this.requestConfig;
    if (headers) {
      headers[key] = value;
    } else {
      this.requestConfig.headers = { [key]: value };
    }
    return this;
  }
  setEndpoint(value) {
    this.url = value;
    return this;
  }
}
var makeRequest = async (params) => {
  const { query, variables, fetchOptions } = params;
  const fetcher = createHttpMethodFetcher(uppercase(params.method ?? `post`));
  const isBatchingQuery = Array.isArray(params.query);
  const response = await fetcher(params);
  const result = await getResult(response, fetchOptions.jsonSerializer ?? defaultJsonSerializer);
  const successfullyReceivedData = Array.isArray(result) ? !result.some(({ data: data3 }) => !data3) : Boolean(result.data);
  const successfullyPassedErrorPolicy = Array.isArray(result) || !result.errors || Array.isArray(result.errors) && !result.errors.length || fetchOptions.errorPolicy === `all` || fetchOptions.errorPolicy === `ignore`;
  if (response.ok && successfullyPassedErrorPolicy && successfullyReceivedData) {
    const { errors: errors34, ...rest } = Array.isArray(result) ? result : result;
    const data3 = fetchOptions.errorPolicy === `ignore` ? rest : result;
    const dataEnvelope = isBatchingQuery ? { data: data3 } : data3;
    return {
      ...dataEnvelope,
      headers: response.headers,
      status: response.status
    };
  } else {
    const errorResult = typeof result === `string` ? {
      error: result
    } : result;
    throw new ClientError({ ...errorResult, status: response.status, headers: response.headers }, { query, variables });
  }
};
var getResult = async (response, jsonSerializer) => {
  let contentType;
  response.headers.forEach((value, key) => {
    if (key.toLowerCase() === `content-type`) {
      contentType = value;
    }
  });
  if (contentType && (contentType.toLowerCase().startsWith(`application/json`) || contentType.toLowerCase().startsWith(`application/graphql+json`) || contentType.toLowerCase().startsWith(`application/graphql-response+json`))) {
    return jsonSerializer.parse(await response.text());
  } else {
    return response.text();
  }
};
var callOrIdentity = (value) => {
  return typeof value === `function` ? value() : value;
};

// node_modules/ramda/es/internal/_isPlaceholder.js
function _isPlaceholder(a) {
  return a != null && typeof a === "object" && a["@@functional/placeholder"] === true;
}

// node_modules/ramda/es/internal/_curry1.js
function _curry1(fn) {
  return function f1(a) {
    if (arguments.length === 0 || _isPlaceholder(a)) {
      return f1;
    } else {
      return fn.apply(this, arguments);
    }
  };
}

// node_modules/ramda/es/type.js
var type = _curry1(function type2(val) {
  return val === null ? "Null" : val === undefined ? "Undefined" : Object.prototype.toString.call(val).slice(8, -1);
});
var type_default = type;

// node_modules/ramda/es/internal/_cloneRegExp.js
function _cloneRegExp(pattern) {
  return new RegExp(pattern.source, pattern.flags ? pattern.flags : (pattern.global ? "g" : "") + (pattern.ignoreCase ? "i" : "") + (pattern.multiline ? "m" : "") + (pattern.sticky ? "y" : "") + (pattern.unicode ? "u" : "") + (pattern.dotAll ? "s" : ""));
}

// node_modules/ramda/es/internal/_clone.js
var _isPrimitive = function(param) {
  var type4 = typeof param;
  return param == null || type4 != "object" && type4 != "function";
};
function _clone(value, deep, map) {
  map || (map = new _ObjectMap);
  if (_isPrimitive(value)) {
    return value;
  }
  var copy = function copy(copiedValue) {
    var cachedCopy = map.get(value);
    if (cachedCopy) {
      return cachedCopy;
    }
    map.set(value, copiedValue);
    for (var key in value) {
      if (Object.prototype.hasOwnProperty.call(value, key)) {
        copiedValue[key] = deep ? _clone(value[key], true, map) : value[key];
      }
    }
    return copiedValue;
  };
  switch (type_default(value)) {
    case "Object":
      return copy(Object.create(Object.getPrototypeOf(value)));
    case "Array":
      return copy([]);
    case "Date":
      return new Date(value.valueOf());
    case "RegExp":
      return _cloneRegExp(value);
    case "Int8Array":
    case "Uint8Array":
    case "Uint8ClampedArray":
    case "Int16Array":
    case "Uint16Array":
    case "Int32Array":
    case "Uint32Array":
    case "Float32Array":
    case "Float64Array":
    case "BigInt64Array":
    case "BigUint64Array":
      return value.slice();
    default:
      return value;
  }
}
var _ObjectMap = function() {
  function _ObjectMap2() {
    this.map = {};
    this.length = 0;
  }
  _ObjectMap2.prototype.set = function(key, value) {
    const hashedKey = this.hash(key);
    let bucket = this.map[hashedKey];
    if (!bucket) {
      this.map[hashedKey] = bucket = [];
    }
    bucket.push([key, value]);
    this.length += 1;
  };
  _ObjectMap2.prototype.hash = function(key) {
    let hashedKey = [];
    for (var value in key) {
      hashedKey.push(Object.prototype.toString.call(key[value]));
    }
    return hashedKey.join();
  };
  _ObjectMap2.prototype.get = function(key) {
    if (this.length <= 180) {
      for (const p in this.map) {
        const bucket2 = this.map[p];
        for (let i = 0;i < bucket2.length; i += 1) {
          const element = bucket2[i];
          if (element[0] === key) {
            return element[1];
          }
        }
      }
      return;
    }
    const hashedKey = this.hash(key);
    const bucket = this.map[hashedKey];
    if (!bucket) {
      return;
    }
    for (let i = 0;i < bucket.length; i += 1) {
      const element = bucket[i];
      if (element[0] === key) {
        return element[1];
      }
    }
  };
  return _ObjectMap2;
}();

// node_modules/ramda/es/clone.js
var clone = _curry1(function clone2(value) {
  return value != null && typeof value.clone === "function" ? value.clone() : _clone(value, true);
});
var clone_default = clone;
// node_modules/graphql-tag/node_modules/tslib/tslib.es6.mjs
var __assign = function() {
  __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length;i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};

// node_modules/graphql-tag/lib/index.js
var normalize = function(string) {
  return string.replace(/[\s,]+/g, " ").trim();
};
var cacheKeyFromLoc = function(loc) {
  return normalize(loc.source.body.substring(loc.start, loc.end));
};
var processFragments = function(ast4) {
  var seenKeys = new Set;
  var definitions = [];
  ast4.definitions.forEach(function(fragmentDefinition) {
    if (fragmentDefinition.kind === "FragmentDefinition") {
      var fragmentName = fragmentDefinition.name.value;
      var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);
      var sourceKeySet = fragmentSourceMap.get(fragmentName);
      if (sourceKeySet && !sourceKeySet.has(sourceKey)) {
        if (printFragmentWarnings) {
          console.warn("Warning: fragment with name " + fragmentName + " already exists.\ngraphql-tag enforces all fragment names across your application to be unique; read more about\nthis in the docs: http://dev.apollodata.com/core/fragments.html#unique-names");
        }
      } else if (!sourceKeySet) {
        fragmentSourceMap.set(fragmentName, sourceKeySet = new Set);
      }
      sourceKeySet.add(sourceKey);
      if (!seenKeys.has(sourceKey)) {
        seenKeys.add(sourceKey);
        definitions.push(fragmentDefinition);
      }
    } else {
      definitions.push(fragmentDefinition);
    }
  });
  return __assign(__assign({}, ast4), { definitions });
};
var stripLoc = function(doc) {
  var workSet = new Set(doc.definitions);
  workSet.forEach(function(node) {
    if (node.loc)
      delete node.loc;
    Object.keys(node).forEach(function(key) {
      var value = node[key];
      if (value && typeof value === "object") {
        workSet.add(value);
      }
    });
  });
  var loc = doc.loc;
  if (loc) {
    delete loc.startToken;
    delete loc.endToken;
  }
  return doc;
};
var parseDocument = function(source2) {
  var cacheKey = normalize(source2);
  if (!docCache.has(cacheKey)) {
    var parsed = parse(source2, {
      experimentalFragmentVariables,
      allowLegacyFragmentVariables: experimentalFragmentVariables
    });
    if (!parsed || parsed.kind !== "Document") {
      throw new Error("Not a valid GraphQL document.");
    }
    docCache.set(cacheKey, stripLoc(processFragments(parsed)));
  }
  return docCache.get(cacheKey);
};
function gql(literals) {
  var args = [];
  for (var _i = 1;_i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  if (typeof literals === "string") {
    literals = [literals];
  }
  var result = literals[0];
  args.forEach(function(arg, i) {
    if (arg && arg.kind === "Document") {
      result += arg.loc.source.body;
    } else {
      result += arg;
    }
    result += literals[i + 1];
  });
  return parseDocument(result);
}
function resetCaches() {
  docCache.clear();
  fragmentSourceMap.clear();
}
function disableFragmentWarnings() {
  printFragmentWarnings = false;
}
function enableExperimentalFragmentVariables() {
  experimentalFragmentVariables = true;
}
function disableExperimentalFragmentVariables() {
  experimentalFragmentVariables = false;
}
var docCache = new Map;
var fragmentSourceMap = new Map;
var printFragmentWarnings = true;
var experimentalFragmentVariables = false;
var extras = {
  gql,
  resetCaches,
  disableFragmentWarnings,
  enableExperimentalFragmentVariables,
  disableExperimentalFragmentVariables
};
(function(gql_1) {
  gql_1.gql = extras.gql, gql_1.resetCaches = extras.resetCaches, gql_1.disableFragmentWarnings = extras.disableFragmentWarnings, gql_1.enableExperimentalFragmentVariables = extras.enableExperimentalFragmentVariables, gql_1.disableExperimentalFragmentVariables = extras.disableExperimentalFragmentVariables;
})(gql || (gql = {}));
gql["default"] = gql;
var lib_default = gql;

// node_modules/@fuel-ts/providers/dist/index.mjs
var getSdk = function(client, withWrapper = defaultWrapper) {
  return {
    getVersion(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(GetVersionDocument, variables, { ...requestHeaders, ...wrappedRequestHeaders }), "getVersion", "query");
    },
    getNodeInfo(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(GetNodeInfoDocument, variables, { ...requestHeaders, ...wrappedRequestHeaders }), "getNodeInfo", "query");
    },
    getChain(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(GetChainDocument, variables, { ...requestHeaders, ...wrappedRequestHeaders }), "getChain", "query");
    },
    getTransaction(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(GetTransactionDocument, variables, { ...requestHeaders, ...wrappedRequestHeaders }), "getTransaction", "query");
    },
    getTransactionWithReceipts(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(GetTransactionWithReceiptsDocument, variables, { ...requestHeaders, ...wrappedRequestHeaders }), "getTransactionWithReceipts", "query");
    },
    getTransactions(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(GetTransactionsDocument, variables, { ...requestHeaders, ...wrappedRequestHeaders }), "getTransactions", "query");
    },
    getTransactionsByOwner(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(GetTransactionsByOwnerDocument, variables, { ...requestHeaders, ...wrappedRequestHeaders }), "getTransactionsByOwner", "query");
    },
    estimatePredicates(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(EstimatePredicatesDocument, variables, { ...requestHeaders, ...wrappedRequestHeaders }), "estimatePredicates", "query");
    },
    getBlock(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(GetBlockDocument, variables, { ...requestHeaders, ...wrappedRequestHeaders }), "getBlock", "query");
    },
    getBlockWithTransactions(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(GetBlockWithTransactionsDocument, variables, { ...requestHeaders, ...wrappedRequestHeaders }), "getBlockWithTransactions", "query");
    },
    getBlocks(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(GetBlocksDocument, variables, { ...requestHeaders, ...wrappedRequestHeaders }), "getBlocks", "query");
    },
    getCoin(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(GetCoinDocument, variables, { ...requestHeaders, ...wrappedRequestHeaders }), "getCoin", "query");
    },
    getCoins(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(GetCoinsDocument, variables, { ...requestHeaders, ...wrappedRequestHeaders }), "getCoins", "query");
    },
    getCoinsToSpend(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(GetCoinsToSpendDocument, variables, { ...requestHeaders, ...wrappedRequestHeaders }), "getCoinsToSpend", "query");
    },
    getContract(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(GetContractDocument, variables, { ...requestHeaders, ...wrappedRequestHeaders }), "getContract", "query");
    },
    getContractBalance(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(GetContractBalanceDocument, variables, { ...requestHeaders, ...wrappedRequestHeaders }), "getContractBalance", "query");
    },
    getBalance(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(GetBalanceDocument, variables, { ...requestHeaders, ...wrappedRequestHeaders }), "getBalance", "query");
    },
    getBalances(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(GetBalancesDocument, variables, { ...requestHeaders, ...wrappedRequestHeaders }), "getBalances", "query");
    },
    getMessages(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(GetMessagesDocument, variables, { ...requestHeaders, ...wrappedRequestHeaders }), "getMessages", "query");
    },
    getMessageProof(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(GetMessageProofDocument, variables, { ...requestHeaders, ...wrappedRequestHeaders }), "getMessageProof", "query");
    },
    getMessageStatus(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(GetMessageStatusDocument, variables, { ...requestHeaders, ...wrappedRequestHeaders }), "getMessageStatus", "query");
    },
    dryRun(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(DryRunDocument, variables, { ...requestHeaders, ...wrappedRequestHeaders }), "dryRun", "mutation");
    },
    submit(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(SubmitDocument, variables, { ...requestHeaders, ...wrappedRequestHeaders }), "submit", "mutation");
    },
    produceBlocks(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(ProduceBlocksDocument, variables, { ...requestHeaders, ...wrappedRequestHeaders }), "produceBlocks", "mutation");
    }
  };
};
var assembleReceiptByType = function(receipt) {
  const { receiptType } = receipt;
  switch (receiptType) {
    case "CALL": {
      const callReceipt = {
        type: ReceiptType.Call,
        from: hexOrZero(receipt.contract?.id),
        to: hexOrZero(receipt?.to?.id),
        amount: bn(receipt.amount),
        assetId: hexOrZero(receipt.assetId),
        gas: bn(receipt.gas),
        param1: bn(receipt.param1),
        param2: bn(receipt.param2),
        pc: bn(receipt.pc),
        is: bn(receipt.is)
      };
      return callReceipt;
    }
    case "RETURN": {
      const returnReceipt = {
        type: ReceiptType.Return,
        id: hexOrZero(receipt.contract?.id),
        val: bn(receipt.val),
        pc: bn(receipt.pc),
        is: bn(receipt.is)
      };
      return returnReceipt;
    }
    case "RETURN_DATA": {
      const returnDataReceipt = {
        type: ReceiptType.ReturnData,
        id: hexOrZero(receipt.contract?.id),
        ptr: bn(receipt.ptr),
        len: bn(receipt.len),
        digest: hexOrZero(receipt.digest),
        pc: bn(receipt.pc),
        is: bn(receipt.is)
      };
      return returnDataReceipt;
    }
    case "PANIC": {
      const panicReceipt = {
        type: ReceiptType.Panic,
        id: hexOrZero(receipt.contract?.id),
        reason: bn(receipt.reason),
        pc: bn(receipt.pc),
        is: bn(receipt.is),
        contractId: hexOrZero(receipt.contractId)
      };
      return panicReceipt;
    }
    case "REVERT": {
      const revertReceipt = {
        type: ReceiptType.Revert,
        id: hexOrZero(receipt.contract?.id),
        val: bn(receipt.ra),
        pc: bn(receipt.pc),
        is: bn(receipt.is)
      };
      return revertReceipt;
    }
    case "LOG": {
      const logReceipt = {
        type: ReceiptType.Log,
        id: hexOrZero(receipt.contract?.id),
        val0: bn(receipt.ra),
        val1: bn(receipt.rb),
        val2: bn(receipt.rc),
        val3: bn(receipt.rd),
        pc: bn(receipt.pc),
        is: bn(receipt.is)
      };
      return logReceipt;
    }
    case "LOG_DATA": {
      const logDataReceipt = {
        type: ReceiptType.LogData,
        id: hexOrZero(receipt.contract?.id),
        val0: bn(receipt.ra),
        val1: bn(receipt.rb),
        ptr: bn(receipt.ptr),
        len: bn(receipt.len),
        digest: hexOrZero(receipt.digest),
        pc: bn(receipt.pc),
        is: bn(receipt.is)
      };
      return logDataReceipt;
    }
    case "TRANSFER": {
      const transferReceipt = {
        type: ReceiptType.Transfer,
        from: hexOrZero(receipt.contract?.id),
        to: hexOrZero(receipt.toAddress || receipt?.to?.id),
        amount: bn(receipt.amount),
        assetId: hexOrZero(receipt.assetId),
        pc: bn(receipt.pc),
        is: bn(receipt.is)
      };
      return transferReceipt;
    }
    case "TRANSFER_OUT": {
      const transferOutReceipt = {
        type: ReceiptType.TransferOut,
        from: hexOrZero(receipt.contract?.id),
        to: hexOrZero(receipt.toAddress || receipt.to?.id),
        amount: bn(receipt.amount),
        assetId: hexOrZero(receipt.assetId),
        pc: bn(receipt.pc),
        is: bn(receipt.is)
      };
      return transferOutReceipt;
    }
    case "SCRIPT_RESULT": {
      const scriptResultReceipt = {
        type: ReceiptType.ScriptResult,
        result: bn(receipt.result),
        gasUsed: bn(receipt.gasUsed)
      };
      return scriptResultReceipt;
    }
    case "MESSAGE_OUT": {
      const sender = hexOrZero(receipt.sender);
      const recipient = hexOrZero(receipt.recipient);
      const nonce = hexOrZero(receipt.nonce);
      const amount = bn(receipt.amount);
      const data3 = receipt.data ? getBytesCopy(receipt.data) : Uint8Array.from([]);
      const digest = hexOrZero(receipt.digest);
      const messageId = ReceiptMessageOutCoder.getMessageId({
        sender,
        recipient,
        nonce,
        amount,
        data: data3
      });
      const receiptMessageOut = {
        type: ReceiptType.MessageOut,
        sender,
        recipient,
        amount,
        nonce,
        data: data3,
        digest,
        messageId
      };
      return receiptMessageOut;
    }
    case "MINT": {
      const contractId = hexOrZero(receipt.contract?.id);
      const subId = hexOrZero(receipt.subId);
      const assetId = ReceiptMintCoder.getAssetId(contractId, subId);
      const mintReceipt = {
        type: ReceiptType.Mint,
        subId,
        contractId,
        assetId,
        val: bn(receipt.val),
        pc: bn(receipt.pc),
        is: bn(receipt.is)
      };
      return mintReceipt;
    }
    case "BURN": {
      const contractId = hexOrZero(receipt.contract?.id);
      const subId = hexOrZero(receipt.subId);
      const assetId = ReceiptBurnCoder.getAssetId(contractId, subId);
      const burnReceipt = {
        type: ReceiptType.Burn,
        subId,
        contractId,
        assetId,
        val: bn(receipt.val),
        pc: bn(receipt.pc),
        is: bn(receipt.is)
      };
      return burnReceipt;
    }
    default:
      throw new FuelError(ErrorCode.INVALID_RECEIPT_TYPE, `Invalid receipt type: ${receiptType}.`);
  }
};
var normalize2 = function(object) {
  Object.keys(object).forEach((key) => {
    switch (object[key]?.constructor.name) {
      case "Uint8Array":
        object[key] = hexlify(object[key]);
        break;
      case "Array":
        object[key] = normalize2(object[key]);
        break;
      case "BN":
        object[key] = object[key].toHex();
        break;
      case "Address":
        object[key] = object[key].toB256();
        break;
      case "Object":
        object[key] = normalize2(object[key]);
        break;
      default:
        break;
    }
  });
  return object;
};
var normalizeJSON = function(root) {
  return normalize2(clone_default(root));
};
var sleep = function(time) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(true);
    }, time);
  });
};
var import_tai64 = __toESM(require_lib(), 1);
var getInputsByType = function(inputs, type4) {
  return inputs.filter((i) => i.type === type4);
};
var getInputsCoin = function(inputs) {
  return getInputsByType(inputs, InputType.Coin);
};
var getInputsMessage = function(inputs) {
  return getInputsByType(inputs, InputType.Message);
};
var getInputsContract = function(inputs) {
  return getInputsByType(inputs, InputType.Contract);
};
var getInputFromAssetId = function(inputs, assetId) {
  const coinInputs = getInputsCoin(inputs);
  const messageInputs = getInputsMessage(inputs);
  const coinInput = coinInputs.find((i) => i.assetId === assetId);
  const messageInput = messageInputs.find((_2) => assetId === "0x0000000000000000000000000000000000000000000000000000000000000000");
  return coinInput || messageInput;
};
var getInputContractFromIndex = function(inputs, inputIndex) {
  if (inputIndex == null)
    return;
  const contractInput = inputs?.[inputIndex];
  if (!contractInput)
    return;
  if (contractInput.type !== InputType.Contract) {
    throw new FuelError(ErrorCode.INVALID_TRANSACTION_INPUT, `Contract input should be of type 'contract'.`);
  }
  return contractInput;
};
var getInputAccountAddress = function(input) {
  if (input.type === InputType.Coin) {
    return input.owner.toString();
  }
  if (input.type === InputType.Message) {
    return input.recipient.toString();
  }
  return "";
};
var getOutputsByType = function(outputs, type4) {
  return outputs.filter((o) => o.type === type4);
};
var getOutputsContractCreated = function(outputs) {
  return getOutputsByType(outputs, OutputType.ContractCreated);
};
var getOutputsCoin = function(outputs) {
  return getOutputsByType(outputs, OutputType.Coin);
};
var getOutputsChange = function(outputs) {
  return getOutputsByType(outputs, OutputType.Change);
};
var getOutputsContract = function(outputs) {
  return getOutputsByType(outputs, OutputType.Contract);
};
var getReceiptsByType = function(receipts, type4) {
  return (receipts ?? []).filter((r) => r.type === type4);
};
var getTransactionTypeName = function(transactionType) {
  switch (transactionType) {
    case TransactionType.Mint:
      return "Mint";
    case TransactionType.Create:
      return "Create";
    case TransactionType.Script:
      return "Script";
    default:
      throw new FuelError(ErrorCode.INVALID_TRANSACTION_TYPE, `Invalid transaction type: ${transactionType}.`);
  }
};
var isType = function(transactionType, type4) {
  const txType = getTransactionTypeName(transactionType);
  return txType === type4;
};
var isTypeMint = function(transactionType) {
  return isType(transactionType, "Mint");
};
var isTypeCreate = function(transactionType) {
  return isType(transactionType, "Create");
};
var isTypeScript = function(transactionType) {
  return isType(transactionType, "Script");
};
var hasSameAssetId = function(a) {
  return (b2) => a.assetId === b2.assetId;
};
var getReceiptsCall = function(receipts) {
  return getReceiptsByType(receipts, ReceiptType.Call);
};
var getReceiptsMessageOut = function(receipts) {
  return getReceiptsByType(receipts, ReceiptType.MessageOut);
};
var isSameOperation = function(a, b2) {
  return a.name === b2.name && a.from?.address === b2.from?.address && a.to?.address === b2.to?.address && a.from?.type === b2.from?.type && a.to?.type === b2.to?.type;
};
var addOperation = function(operations, toAdd) {
  const ops = operations.map((op) => {
    if (!isSameOperation(op, toAdd))
      return null;
    let newOp = { ...op };
    if (toAdd.assetsSent?.length) {
      newOp = {
        ...newOp,
        assetsSent: op.assetsSent?.length ? mergeAssets(op, toAdd) : toAdd.assetsSent
      };
    }
    if (toAdd.calls?.length) {
      newOp = {
        ...newOp,
        calls: [...op.calls || [], ...toAdd.calls || []]
      };
    }
    return newOp;
  }).filter(Boolean);
  return ops.length ? ops : [...operations, toAdd];
};
var getReceiptsTransferOut = function(receipts) {
  return getReceiptsByType(receipts, ReceiptType.TransferOut);
};
var getContractTransferOperations = function({ receipts }) {
  const transferOutReceipts = getReceiptsTransferOut(receipts);
  const contractTransferOperations = transferOutReceipts.reduce((prevContractTransferOps, receipt) => {
    const newContractTransferOps = addOperation(prevContractTransferOps, {
      name: "Contract transfer",
      from: {
        type: 0,
        address: receipt.from
      },
      to: {
        type: 1,
        address: receipt.to
      },
      assetsSent: [
        {
          amount: receipt.amount,
          assetId: receipt.assetId
        }
      ]
    });
    return newContractTransferOps;
  }, []);
  return contractTransferOperations;
};
var getWithdrawFromFuelOperations = function({
  inputs,
  receipts
}) {
  const messageOutReceipts = getReceiptsMessageOut(receipts);
  const withdrawFromFuelOperations = messageOutReceipts.reduce((prevWithdrawFromFuelOps, receipt) => {
    const assetId = "0x0000000000000000000000000000000000000000000000000000000000000000";
    const input = getInputFromAssetId(inputs, assetId);
    if (input) {
      const inputAddress = getInputAccountAddress(input);
      const newWithdrawFromFuelOps = addOperation(prevWithdrawFromFuelOps, {
        name: "Withdraw from Fuel",
        from: {
          type: 1,
          address: inputAddress
        },
        to: {
          type: 1,
          address: receipt.recipient.toString(),
          chain: "ethereum"
        },
        assetsSent: [
          {
            amount: receipt.amount,
            assetId
          }
        ]
      });
      return newWithdrawFromFuelOps;
    }
    return prevWithdrawFromFuelOps;
  }, []);
  return withdrawFromFuelOperations;
};
var getContractCallOperations = function({
  inputs,
  outputs,
  receipts,
  abiMap,
  rawPayload,
  maxInputs
}) {
  const contractCallReceipts = getReceiptsCall(receipts);
  const contractOutputs = getOutputsContract(outputs);
  const contractCallOperations = contractOutputs.reduce((prevOutputCallOps, output3) => {
    const contractInput = getInputContractFromIndex(inputs, output3.inputIndex);
    if (contractInput) {
      const newCallOps = contractCallReceipts.reduce((prevContractCallOps, receipt) => {
        if (receipt.to === contractInput.contractID) {
          const input = getInputFromAssetId(inputs, receipt.assetId);
          if (input) {
            const inputAddress = getInputAccountAddress(input);
            const calls = [];
            const abi = abiMap?.[contractInput.contractID];
            if (abi) {
              calls.push(getFunctionCall({
                abi,
                receipt,
                rawPayload,
                maxInputs
              }));
            }
            const newContractCallOps = addOperation(prevContractCallOps, {
              name: "Contract call",
              from: {
                type: 1,
                address: inputAddress
              },
              to: {
                type: 0,
                address: receipt.to
              },
              assetsSent: receipt.amount?.isZero() ? undefined : [
                {
                  amount: receipt.amount,
                  assetId: receipt.assetId
                }
              ],
              calls
            });
            return newContractCallOps;
          }
        }
        return prevContractCallOps;
      }, prevOutputCallOps);
      return newCallOps;
    }
    return prevOutputCallOps;
  }, []);
  return contractCallOperations;
};
var getTransferOperations = function({
  inputs,
  outputs,
  receipts
}) {
  const coinOutputs = getOutputsCoin(outputs);
  const [transferReceipt] = getReceiptsByType(receipts, ReceiptType.Transfer);
  let operations = [];
  if (transferReceipt) {
    const changeOutputs = getOutputsChange(outputs);
    changeOutputs.forEach((output3) => {
      const { assetId } = output3;
      const [contractInput] = getInputsContract(inputs);
      const utxo = getInputFromAssetId(inputs, assetId);
      if (utxo && contractInput) {
        const inputAddress = getInputAccountAddress(utxo);
        operations = addOperation(operations, {
          name: "Transfer asset",
          from: {
            type: 1,
            address: inputAddress
          },
          to: {
            type: 0,
            address: contractInput.contractID
          },
          assetsSent: [
            {
              assetId: assetId.toString(),
              amount: transferReceipt.amount
            }
          ]
        });
      }
    });
  } else {
    coinOutputs.forEach((output3) => {
      const input = getInputFromAssetId(inputs, output3.assetId);
      if (input) {
        const inputAddress = getInputAccountAddress(input);
        operations = addOperation(operations, {
          name: "Transfer asset",
          from: {
            type: 1,
            address: inputAddress
          },
          to: {
            type: 1,
            address: output3.to.toString()
          },
          assetsSent: [
            {
              assetId: output3.assetId.toString(),
              amount: output3.amount
            }
          ]
        });
      }
    });
  }
  return operations;
};
var getPayProducerOperations = function(outputs) {
  const coinOutputs = getOutputsCoin(outputs);
  const payProducerOperations = coinOutputs.reduce((prev, output3) => {
    const operations = addOperation(prev, {
      name: "Pay network fee to block producer",
      from: {
        type: 1,
        address: "Network"
      },
      to: {
        type: 1,
        address: output3.to.toString()
      },
      assetsSent: [
        {
          assetId: output3.assetId.toString(),
          amount: output3.amount
        }
      ]
    });
    return operations;
  }, []);
  return payProducerOperations;
};
var getContractCreatedOperations = function({ inputs, outputs }) {
  const contractCreatedOutputs = getOutputsContractCreated(outputs);
  const input = getInputsCoin(inputs)[0];
  const fromAddress = getInputAccountAddress(input);
  const contractCreatedOperations = contractCreatedOutputs.reduce((prev, contractCreatedOutput) => {
    const operations = addOperation(prev, {
      name: "Contract created",
      from: {
        type: 1,
        address: fromAddress
      },
      to: {
        type: 0,
        address: contractCreatedOutput?.contractId || ""
      }
    });
    return operations;
  }, []);
  return contractCreatedOperations;
};
var getOperations = function({
  transactionType,
  inputs,
  outputs,
  receipts,
  abiMap,
  rawPayload,
  maxInputs
}) {
  if (isTypeCreate(transactionType)) {
    return [
      ...getContractCreatedOperations({ inputs, outputs }),
      ...getTransferOperations({ inputs, outputs, receipts })
    ];
  }
  if (isTypeScript(transactionType)) {
    return [
      ...getTransferOperations({ inputs, outputs, receipts }),
      ...getContractCallOperations({
        inputs,
        outputs,
        receipts,
        abiMap,
        rawPayload,
        maxInputs
      }),
      ...getContractTransferOperations({ receipts }),
      ...getWithdrawFromFuelOperations({ inputs, receipts })
    ];
  }
  return [...getPayProducerOperations(outputs)];
};
var assembleTransactionSummary = function(params) {
  const {
    receipts,
    gasPerByte,
    gasPriceFactor,
    transaction: transaction2,
    transactionBytes,
    id,
    gqlTransactionStatus,
    abiMap = {},
    maxInputs
  } = params;
  const { gasLimit = bn(0), witnesses } = transaction2;
  const gasPrice = bn(transaction2.gasPrice);
  const gasUsed = getGasUsedFromReceipts(receipts);
  const chargeableBytes = calculateTxChargeableBytes({
    transactionBytes,
    transactionWitnesses: witnesses
  });
  const { minFee: fee } = calculateTransactionFee({
    gasUsed,
    gasPrice,
    gasLimit,
    gasPerByte,
    gasPriceFactor,
    chargeableBytes
  });
  const operations = getOperations({
    transactionType: transaction2.type,
    inputs: transaction2.inputs || [],
    outputs: transaction2.outputs || [],
    receipts,
    rawPayload: hexlify(transactionBytes),
    abiMap,
    maxInputs
  });
  const typeName = getTransactionTypeName(transaction2.type);
  const { isStatusFailure, isStatusPending, isStatusSuccess, blockId, status, time } = processGraphqlStatus(gqlTransactionStatus);
  const mintedAssets = extractMintedAssetsFromReceipts(receipts);
  const burnedAssets = extractBurnedAssetsFromReceipts(receipts);
  let date;
  if (time) {
    date = fromTai64ToDate(time);
  }
  const transactionSummary = {
    id,
    fee,
    gasUsed,
    operations,
    type: typeName,
    blockId,
    time,
    status,
    receipts,
    mintedAssets,
    burnedAssets,
    isTypeMint: isTypeMint(transaction2.type),
    isTypeCreate: isTypeCreate(transaction2.type),
    isTypeScript: isTypeScript(transaction2.type),
    isStatusFailure,
    isStatusSuccess,
    isStatusPending,
    date,
    transaction: transaction2
  };
  return transactionSummary;
};
var __defProp5 = Object.defineProperty;
var __defNormalProp4 = (obj, key, value) => (key in obj) ? __defProp5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField4 = (obj, key, value) => {
  __defNormalProp4(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck2 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateAdd2 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateMethod2 = (obj, member, method) => {
  __accessCheck2(obj, member, "access private method");
  return method;
};
var coinQuantityfy = (coinQuantityLike) => {
  let assetId;
  let amount;
  let max2;
  if (Array.isArray(coinQuantityLike)) {
    amount = coinQuantityLike[0];
    assetId = coinQuantityLike[1] ?? BaseAssetId;
    max2 = coinQuantityLike[2] ?? undefined;
  } else {
    amount = coinQuantityLike.amount;
    assetId = coinQuantityLike.assetId ?? BaseAssetId;
    max2 = coinQuantityLike.max ?? undefined;
  }
  return {
    assetId: hexlify(assetId),
    amount: bn(amount),
    max: max2 ? bn(max2) : undefined
  };
};
var addAmountToAsset = (params) => {
  const { amount, assetId, coinQuantities } = params;
  const assetIdx = coinQuantities.findIndex((coinQuantity) => coinQuantity.assetId === assetId);
  if (assetIdx !== -1) {
    coinQuantities[assetIdx].amount = coinQuantities[assetIdx].amount.add(amount);
  } else {
    coinQuantities.push({ assetId, amount });
  }
  return coinQuantities;
};
var ReceiptFragmentFragmentDoc = lib_default`
    fragment receiptFragment on Receipt {
  contract {
    id
    bytecode
    salt
  }
  pc
  is
  to {
    id
    bytecode
    salt
  }
  toAddress
  amount
  assetId
  gas
  param1
  param2
  val
  ptr
  digest
  reason
  ra
  rb
  rc
  rd
  len
  receiptType
  result
  gasUsed
  data
  sender
  recipient
  nonce
  contractId
  subId
}
    `;
var TransactionFragmentFragmentDoc = lib_default`
    fragment transactionFragment on Transaction {
  id
  rawPayload
  gasPrice
  receipts {
    ...receiptFragment
  }
  status {
    type: __typename
    ... on SubmittedStatus {
      time
    }
    ... on SuccessStatus {
      block {
        id
      }
      time
      programState {
        returnType
        data
      }
    }
    ... on FailureStatus {
      block {
        id
      }
      time
      reason
    }
  }
}
    ${ReceiptFragmentFragmentDoc}`;
var CoinFragmentFragmentDoc = lib_default`
    fragment coinFragment on Coin {
  __typename
  utxoId
  owner
  amount
  assetId
  maturity
  blockCreated
  txCreatedIdx
}
    `;
var MessageCoinFragmentFragmentDoc = lib_default`
    fragment messageCoinFragment on MessageCoin {
  __typename
  sender
  recipient
  nonce
  amount
  assetId
  daHeight
}
    `;
var MessageFragmentFragmentDoc = lib_default`
    fragment messageFragment on Message {
  amount
  sender
  recipient
  data
  nonce
  daHeight
}
    `;
var MessageProofFragmentFragmentDoc = lib_default`
    fragment messageProofFragment on MessageProof {
  messageProof {
    proofSet
    proofIndex
  }
  blockProof {
    proofSet
    proofIndex
  }
  messageBlockHeader {
    id
    daHeight
    transactionsCount
    transactionsRoot
    height
    prevRoot
    time
    applicationHash
    messageReceiptRoot
    messageReceiptCount
  }
  commitBlockHeader {
    id
    daHeight
    transactionsCount
    transactionsRoot
    height
    prevRoot
    time
    applicationHash
    messageReceiptRoot
    messageReceiptCount
  }
  sender
  recipient
  nonce
  amount
  data
}
    `;
var BalanceFragmentFragmentDoc = lib_default`
    fragment balanceFragment on Balance {
  owner
  amount
  assetId
}
    `;
var ConsensusParametersFragmentFragmentDoc = lib_default`
    fragment consensusParametersFragment on ConsensusParameters {
  contractMaxSize
  maxInputs
  maxOutputs
  maxWitnesses
  maxGasPerTx
  maxScriptLength
  maxScriptDataLength
  maxStorageSlots
  maxPredicateLength
  maxPredicateDataLength
  maxGasPerPredicate
  gasPriceFactor
  gasPerByte
  maxMessageDataLength
  chainId
}
    `;
var BlockFragmentFragmentDoc = lib_default`
    fragment blockFragment on Block {
  id
  header {
    height
    time
  }
  transactions {
    id
  }
}
    `;
var ChainInfoFragmentFragmentDoc = lib_default`
    fragment chainInfoFragment on ChainInfo {
  name
  baseChainHeight
  peerCount
  consensusParameters {
    ...consensusParametersFragment
  }
  latestBlock {
    ...blockFragment
  }
}
    ${ConsensusParametersFragmentFragmentDoc}
${BlockFragmentFragmentDoc}`;
var ContractBalanceFragmentFragmentDoc = lib_default`
    fragment contractBalanceFragment on ContractBalance {
  contract
  amount
  assetId
}
    `;
var PageInfoFragmentFragmentDoc = lib_default`
    fragment pageInfoFragment on PageInfo {
  hasPreviousPage
  hasNextPage
  startCursor
  endCursor
}
    `;
var NodeInfoFragmentFragmentDoc = lib_default`
    fragment nodeInfoFragment on NodeInfo {
  utxoValidation
  vmBacktrace
  minGasPrice
  maxTx
  maxDepth
  nodeVersion
}
    `;
var GetVersionDocument = lib_default`
    query getVersion {
  nodeInfo {
    nodeVersion
  }
}
    `;
var GetNodeInfoDocument = lib_default`
    query getNodeInfo {
  nodeInfo {
    ...nodeInfoFragment
  }
}
    ${NodeInfoFragmentFragmentDoc}`;
var GetChainDocument = lib_default`
    query getChain {
  chain {
    ...chainInfoFragment
  }
}
    ${ChainInfoFragmentFragmentDoc}`;
var GetTransactionDocument = lib_default`
    query getTransaction($transactionId: TransactionId!) {
  transaction(id: $transactionId) {
    ...transactionFragment
  }
}
    ${TransactionFragmentFragmentDoc}`;
var GetTransactionWithReceiptsDocument = lib_default`
    query getTransactionWithReceipts($transactionId: TransactionId!) {
  transaction(id: $transactionId) {
    ...transactionFragment
    receipts {
      ...receiptFragment
    }
  }
}
    ${TransactionFragmentFragmentDoc}
${ReceiptFragmentFragmentDoc}`;
var GetTransactionsDocument = lib_default`
    query getTransactions($after: String, $before: String, $first: Int, $last: Int) {
  transactions(after: $after, before: $before, first: $first, last: $last) {
    edges {
      node {
        ...transactionFragment
      }
    }
  }
}
    ${TransactionFragmentFragmentDoc}`;
var GetTransactionsByOwnerDocument = lib_default`
    query getTransactionsByOwner($owner: Address!, $after: String, $before: String, $first: Int, $last: Int) {
  transactionsByOwner(
    owner: $owner
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    pageInfo {
      ...pageInfoFragment
    }
    edges {
      node {
        ...transactionFragment
      }
    }
  }
}
    ${PageInfoFragmentFragmentDoc}
${TransactionFragmentFragmentDoc}`;
var EstimatePredicatesDocument = lib_default`
    query estimatePredicates($encodedTransaction: HexString!) {
  estimatePredicates(tx: $encodedTransaction) {
    ...transactionFragment
  }
}
    ${TransactionFragmentFragmentDoc}`;
var GetBlockDocument = lib_default`
    query getBlock($blockId: BlockId, $blockHeight: U64) {
  block(id: $blockId, height: $blockHeight) {
    ...blockFragment
  }
}
    ${BlockFragmentFragmentDoc}`;
var GetBlockWithTransactionsDocument = lib_default`
    query getBlockWithTransactions($blockId: BlockId, $blockHeight: U64) {
  block(id: $blockId, height: $blockHeight) {
    ...blockFragment
    transactions {
      ...transactionFragment
    }
  }
}
    ${BlockFragmentFragmentDoc}
${TransactionFragmentFragmentDoc}`;
var GetBlocksDocument = lib_default`
    query getBlocks($after: String, $before: String, $first: Int, $last: Int) {
  blocks(after: $after, before: $before, first: $first, last: $last) {
    edges {
      node {
        ...blockFragment
      }
    }
  }
}
    ${BlockFragmentFragmentDoc}`;
var GetCoinDocument = lib_default`
    query getCoin($coinId: UtxoId!) {
  coin(utxoId: $coinId) {
    ...coinFragment
  }
}
    ${CoinFragmentFragmentDoc}`;
var GetCoinsDocument = lib_default`
    query getCoins($filter: CoinFilterInput!, $after: String, $before: String, $first: Int, $last: Int) {
  coins(
    filter: $filter
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    edges {
      node {
        ...coinFragment
      }
    }
  }
}
    ${CoinFragmentFragmentDoc}`;
var GetCoinsToSpendDocument = lib_default`
    query getCoinsToSpend($owner: Address!, $queryPerAsset: [SpendQueryElementInput!]!, $excludedIds: ExcludeInput) {
  coinsToSpend(
    owner: $owner
    queryPerAsset: $queryPerAsset
    excludedIds: $excludedIds
  ) {
    ...coinFragment
    ...messageCoinFragment
  }
}
    ${CoinFragmentFragmentDoc}
${MessageCoinFragmentFragmentDoc}`;
var GetContractDocument = lib_default`
    query getContract($contractId: ContractId!) {
  contract(id: $contractId) {
    bytecode
    id
  }
}
    `;
var GetContractBalanceDocument = lib_default`
    query getContractBalance($contract: ContractId!, $asset: AssetId!) {
  contractBalance(contract: $contract, asset: $asset) {
    ...contractBalanceFragment
  }
}
    ${ContractBalanceFragmentFragmentDoc}`;
var GetBalanceDocument = lib_default`
    query getBalance($owner: Address!, $assetId: AssetId!) {
  balance(owner: $owner, assetId: $assetId) {
    ...balanceFragment
  }
}
    ${BalanceFragmentFragmentDoc}`;
var GetBalancesDocument = lib_default`
    query getBalances($filter: BalanceFilterInput!, $after: String, $before: String, $first: Int, $last: Int) {
  balances(
    filter: $filter
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    edges {
      node {
        ...balanceFragment
      }
    }
  }
}
    ${BalanceFragmentFragmentDoc}`;
var GetMessagesDocument = lib_default`
    query getMessages($owner: Address!, $after: String, $before: String, $first: Int, $last: Int) {
  messages(
    owner: $owner
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    edges {
      node {
        ...messageFragment
      }
    }
  }
}
    ${MessageFragmentFragmentDoc}`;
var GetMessageProofDocument = lib_default`
    query getMessageProof($transactionId: TransactionId!, $messageId: MessageId!, $commitBlockId: BlockId, $commitBlockHeight: U32) {
  messageProof(
    transactionId: $transactionId
    messageId: $messageId
    commitBlockId: $commitBlockId
    commitBlockHeight: $commitBlockHeight
  ) {
    ...messageProofFragment
  }
}
    ${MessageProofFragmentFragmentDoc}`;
var GetMessageStatusDocument = lib_default`
    query getMessageStatus($nonce: Nonce!) {
  messageStatus(nonce: $nonce) {
    state
  }
}
    `;
var DryRunDocument = lib_default`
    mutation dryRun($encodedTransaction: HexString!, $utxoValidation: Boolean) {
  dryRun(tx: $encodedTransaction, utxoValidation: $utxoValidation) {
    ...receiptFragment
  }
}
    ${ReceiptFragmentFragmentDoc}`;
var SubmitDocument = lib_default`
    mutation submit($encodedTransaction: HexString!) {
  submit(tx: $encodedTransaction) {
    id
  }
}
    `;
var ProduceBlocksDocument = lib_default`
    mutation produceBlocks($startTimestamp: Tai64Timestamp, $blocksToProduce: U64!) {
  produceBlocks(
    blocksToProduce: $blocksToProduce
    startTimestamp: $startTimestamp
  )
}
    `;
var defaultWrapper = (action, _operationName, _operationType) => action();
var cache = {};
var DEFAULT_TTL_IN_MS = 30 * 1000;
var MemoryCache = class {
  ttl;
  constructor(ttlInMs = DEFAULT_TTL_IN_MS) {
    this.ttl = ttlInMs;
    if (typeof ttlInMs !== "number" || this.ttl <= 0) {
      throw new FuelError(ErrorCode.INVALID_TTL, `Invalid TTL: ${this.ttl}. Use a value greater than zero.`);
    }
  }
  get(value, isAutoExpiring = true) {
    const key = hexlify(value);
    if (cache[key]) {
      if (!isAutoExpiring || cache[key].expires > Date.now()) {
        return cache[key].value;
      }
      this.del(value);
    }
    return;
  }
  set(value) {
    const expiresAt = Date.now() + this.ttl;
    const key = hexlify(value);
    cache[key] = {
      expires: expiresAt,
      value
    };
    return expiresAt;
  }
  getAllData() {
    return Object.keys(cache).reduce((list, key) => {
      const data3 = this.get(key, false);
      if (data3) {
        list.push(data3);
      }
      return list;
    }, []);
  }
  getActiveData() {
    return Object.keys(cache).reduce((list, key) => {
      const data3 = this.get(key);
      if (data3) {
        list.push(data3);
      }
      return list;
    }, []);
  }
  del(value) {
    const key = hexlify(value);
    delete cache[key];
  }
};
var inputify = (value) => {
  const { type: type4 } = value;
  switch (value.type) {
    case InputType.Coin: {
      const predicate = getBytesCopy(value.predicate ?? "0x");
      const predicateData = getBytesCopy(value.predicateData ?? "0x");
      return {
        type: InputType.Coin,
        utxoID: {
          transactionId: hexlify(getBytesCopy(value.id).slice(0, 32)),
          outputIndex: getBytesCopy(value.id)[32]
        },
        owner: hexlify(value.owner),
        amount: bn(value.amount),
        assetId: hexlify(value.assetId),
        txPointer: {
          blockHeight: toNumber2(getBytesCopy(value.txPointer).slice(0, 8)),
          txIndex: toNumber2(getBytesCopy(value.txPointer).slice(8, 16))
        },
        witnessIndex: value.witnessIndex,
        maturity: value.maturity ?? 0,
        predicateGasUsed: bn(value.predicateGasUsed),
        predicateLength: predicate.length,
        predicateDataLength: predicateData.length,
        predicate: hexlify(predicate),
        predicateData: hexlify(predicateData)
      };
    }
    case InputType.Contract: {
      return {
        type: InputType.Contract,
        utxoID: {
          transactionId: ZeroBytes32,
          outputIndex: 0
        },
        balanceRoot: ZeroBytes32,
        stateRoot: ZeroBytes32,
        txPointer: {
          blockHeight: toNumber2(getBytesCopy(value.txPointer).slice(0, 8)),
          txIndex: toNumber2(getBytesCopy(value.txPointer).slice(8, 16))
        },
        contractID: hexlify(value.contractId)
      };
    }
    case InputType.Message: {
      const predicate = getBytesCopy(value.predicate ?? "0x");
      const predicateData = getBytesCopy(value.predicateData ?? "0x");
      const data3 = getBytesCopy(value.data ?? "0x");
      return {
        type: InputType.Message,
        sender: hexlify(value.sender),
        recipient: hexlify(value.recipient),
        amount: bn(value.amount),
        nonce: hexlify(value.nonce),
        witnessIndex: value.witnessIndex,
        predicateGasUsed: bn(value.predicateGasUsed),
        predicateLength: predicate.length,
        predicateDataLength: predicateData.length,
        predicate: hexlify(predicate),
        predicateData: hexlify(predicateData),
        data: hexlify(data3),
        dataLength: data3.length
      };
    }
    default: {
      throw new FuelError(ErrorCode.INVALID_TRANSACTION_INPUT, `Invalid transaction input type: ${type4}.`);
    }
  }
};
var outputify = (value) => {
  const { type: type4 } = value;
  switch (type4) {
    case OutputType.Coin: {
      return {
        type: OutputType.Coin,
        to: hexlify(value.to),
        amount: bn(value.amount),
        assetId: hexlify(value.assetId)
      };
    }
    case OutputType.Contract: {
      return {
        type: OutputType.Contract,
        inputIndex: value.inputIndex,
        balanceRoot: ZeroBytes32,
        stateRoot: ZeroBytes32
      };
    }
    case OutputType.Change: {
      return {
        type: OutputType.Change,
        to: hexlify(value.to),
        amount: bn(0),
        assetId: hexlify(value.assetId)
      };
    }
    case OutputType.Variable: {
      return {
        type: OutputType.Variable,
        to: ZeroBytes32,
        amount: bn(0),
        assetId: ZeroBytes32
      };
    }
    case OutputType.ContractCreated: {
      return {
        type: OutputType.ContractCreated,
        contractId: hexlify(value.contractId),
        stateRoot: hexlify(value.stateRoot)
      };
    }
    default: {
      throw new FuelError(ErrorCode.INVALID_TRANSACTION_INPUT, `Invalid transaction output type: ${type4}.`);
    }
  }
};
var isCoin = (resource) => ("id" in resource);
var doesReceiptHaveMissingOutputVariables = (receipt) => receipt.type === ReceiptType.Revert && receipt.val.toString("hex") === FAILED_TRANSFER_TO_ADDRESS_SIGNAL;
var doesReceiptHaveMissingContractId = (receipt) => receipt.type === ReceiptType.Panic && receipt.contractId !== "0x0000000000000000000000000000000000000000000000000000000000000000";
var getReceiptsWithMissingData = (receipts) => receipts.reduce((memo, receipt) => {
  if (doesReceiptHaveMissingOutputVariables(receipt)) {
    memo.missingOutputVariables.push(receipt);
  }
  if (doesReceiptHaveMissingContractId(receipt)) {
    memo.missingOutputContractIds.push(receipt);
  }
  return memo;
}, {
  missingOutputVariables: [],
  missingOutputContractIds: []
});
var hexOrZero = (hex) => hex || ZeroBytes32;
var calculatePriceWithFactor = (gasUsed, gasPrice, priceFactor) => bn(Math.ceil(gasUsed.toNumber() / priceFactor.toNumber()) * gasPrice.toNumber());
var getGasUsedFromReceipts = (receipts) => {
  const scriptResult = receipts.filter((receipt) => receipt.type === ReceiptType.ScriptResult);
  const gasUsed = scriptResult.reduce((prev, receipt) => prev.add(receipt.gasUsed), bn(0));
  return gasUsed;
};
var calculateTxChargeableBytes = (params) => {
  const { transactionWitnesses } = params;
  const txChargeableBytes = bn(transactionWitnesses?.[0]?.offset || 0);
  return txChargeableBytes;
};
var calculateTransactionFee = ({
  gasPrice,
  gasUsed,
  gasLimit,
  gasPerByte,
  gasPriceFactor,
  chargeableBytes
}) => {
  const bytesGas = chargeableBytes.mul(gasPerByte.toNumber());
  const minGas = bytesGas;
  const maxGas = bytesGas.add(gasLimit);
  const minGasToPay = bn(Math.ceil(minGas.mul(gasPrice).toNumber() / gasPriceFactor.toNumber()));
  const maxGasToPay = bn(Math.ceil(maxGas.mul(gasPrice).toNumber() / gasPriceFactor.toNumber()));
  const feeFromGasUsed = bn(Math.ceil(gasUsed.mul(gasPrice).toNumber() / gasPriceFactor.toNumber()));
  const minFee = minGasToPay.add(feeFromGasUsed);
  const maxFee = maxGasToPay.add(feeFromGasUsed);
  return {
    minFee,
    maxFee,
    minGasToPay,
    maxGasToPay,
    feeFromGasUsed
  };
};
var fromUnixToTai64 = (unixTimestampMs) => (BigInt(unixTimestampMs) + BigInt(2 ** 62) + BigInt(10)).toString();
var ChangeOutputCollisionError = class extends Error {
  name = "ChangeOutputCollisionError";
  message = 'A ChangeOutput with the same "assetId" already exists for a different "to" address';
};
var NoWitnessAtIndexError = class extends Error {
  constructor(index) {
    super();
    this.index = index;
    this.message = `Witness at index "${index}" was not found`;
  }
  name = "NoWitnessAtIndexError";
};
var witnessify = (value) => {
  const data3 = getBytesCopy(value);
  return {
    data: hexlify(data3),
    dataLength: data3.length
  };
};
var BaseTransactionRequest = class {
  gasPrice;
  gasLimit;
  maturity;
  inputs = [];
  outputs = [];
  witnesses = [];
  constructor({
    gasPrice,
    gasLimit,
    maturity,
    inputs,
    outputs,
    witnesses
  } = {}) {
    this.gasPrice = bn(gasPrice);
    this.gasLimit = bn(gasLimit);
    this.maturity = maturity ?? 0;
    this.inputs = inputs ?? [];
    this.outputs = outputs ?? [];
    this.witnesses = witnesses ?? [];
  }
  getBaseTransaction() {
    const inputs = this.inputs?.map(inputify) ?? [];
    const outputs = this.outputs?.map(outputify) ?? [];
    const witnesses = this.witnesses?.map(witnessify) ?? [];
    return {
      gasPrice: this.gasPrice,
      gasLimit: this.gasLimit,
      maturity: this.maturity,
      inputs,
      outputs,
      witnesses,
      inputsCount: inputs.length,
      outputsCount: outputs.length,
      witnessesCount: witnesses.length
    };
  }
  toTransactionBytes() {
    return new TransactionCoder().encode(this.toTransaction());
  }
  pushInput(input) {
    this.inputs.push(input);
    return this.inputs.length - 1;
  }
  pushOutput(output3) {
    this.outputs.push(output3);
    return this.outputs.length - 1;
  }
  createWitness() {
    this.witnesses.push("0x");
    return this.witnesses.length - 1;
  }
  updateWitnessByOwner(address5, signature) {
    const witnessIndex = this.getCoinInputWitnessIndexByOwner(address5);
    if (typeof witnessIndex === "number") {
      this.updateWitness(witnessIndex, signature);
    }
  }
  updateWitness(index, witness) {
    if (!this.witnesses[index]) {
      throw new NoWitnessAtIndexError(index);
    }
    this.witnesses[index] = witness;
  }
  getCoinInputs() {
    return this.inputs.filter((input) => input.type === InputType.Coin);
  }
  getCoinOutputs() {
    return this.outputs.filter((output3) => output3.type === OutputType.Coin);
  }
  getChangeOutputs() {
    return this.outputs.filter((output3) => output3.type === OutputType.Change);
  }
  getCoinInputWitnessIndexByOwner(owner) {
    const ownerAddress = addressify(owner);
    const found = this.inputs.find((input) => {
      switch (input.type) {
        case InputType.Coin:
          return hexlify(input.owner) === ownerAddress.toB256();
        case InputType.Message:
          return hexlify(input.recipient) === ownerAddress.toB256();
        default:
          return false;
      }
    });
    return found?.witnessIndex;
  }
  addCoinInput(coin, predicate) {
    const { assetId, owner, amount } = coin;
    let witnessIndex;
    if (predicate) {
      witnessIndex = 0;
    } else {
      witnessIndex = this.getCoinInputWitnessIndexByOwner(owner);
      if (typeof witnessIndex !== "number") {
        witnessIndex = this.createWitness();
      }
    }
    const input = {
      ...coin,
      type: InputType.Coin,
      owner: owner.toB256(),
      amount,
      assetId,
      txPointer: "0x00000000000000000000000000000000",
      witnessIndex,
      predicate: predicate?.bytes,
      predicateData: predicate?.predicateData
    };
    this.pushInput(input);
    this.addChangeOutput(owner, assetId);
  }
  addMessageInput(message, predicate) {
    const { recipient, sender, amount } = message;
    const assetId = BaseAssetId;
    let witnessIndex;
    if (predicate) {
      witnessIndex = 0;
    } else {
      witnessIndex = this.getCoinInputWitnessIndexByOwner(recipient);
      if (typeof witnessIndex !== "number") {
        witnessIndex = this.createWitness();
      }
    }
    const input = {
      ...message,
      type: InputType.Message,
      sender: sender.toB256(),
      recipient: recipient.toB256(),
      amount,
      witnessIndex,
      predicate: predicate?.bytes,
      predicateData: predicate?.predicateData
    };
    this.pushInput(input);
    this.addChangeOutput(recipient, assetId);
  }
  addResource(resource) {
    if (isCoin(resource)) {
      this.addCoinInput(resource);
    } else {
      this.addMessageInput(resource);
    }
    return this;
  }
  addResources(resources) {
    resources.forEach((resource) => this.addResource(resource));
    return this;
  }
  addPredicateResource(resource, predicate) {
    if (isCoin(resource)) {
      this.addCoinInput(resource, predicate);
    } else {
      this.addMessageInput(resource, predicate);
    }
    return this;
  }
  addPredicateResources(resources, predicate) {
    resources.forEach((resource) => this.addPredicateResource(resource, predicate));
    return this;
  }
  addCoinOutput(to, amount, assetId = BaseAssetId) {
    this.pushOutput({
      type: OutputType.Coin,
      to: addressify(to).toB256(),
      amount,
      assetId
    });
    return this;
  }
  addCoinOutputs(to, quantities) {
    quantities.map(coinQuantityfy).forEach((quantity) => {
      this.pushOutput({
        type: OutputType.Coin,
        to: addressify(to).toB256(),
        amount: quantity.amount,
        assetId: quantity.assetId
      });
    });
    return this;
  }
  addChangeOutput(to, assetId = BaseAssetId) {
    const changeOutput = this.getChangeOutputs().find((output3) => hexlify(output3.assetId) === assetId);
    if (changeOutput && hexlify(changeOutput.to) !== addressify(to).toB256()) {
      throw new ChangeOutputCollisionError;
    }
    if (!changeOutput) {
      this.pushOutput({
        type: OutputType.Change,
        to: addressify(to).toB256(),
        assetId
      });
    }
  }
  byteSize() {
    return this.toTransactionBytes().length;
  }
  calculateFee(gasPriceFactor) {
    const gasFee = calculatePriceWithFactor(this.gasLimit, this.gasPrice, gasPriceFactor);
    return {
      assetId: BaseAssetId,
      amount: gasFee.isZero() ? bn(1) : gasFee
    };
  }
  fundWithFakeUtxos(quantities) {
    const hasBaseAssetId = quantities.some(({ assetId }) => assetId === BaseAssetId);
    if (!hasBaseAssetId) {
      quantities.push({ assetId: BaseAssetId, amount: bn(1) });
    }
    const owner = getRandomB256();
    this.inputs = this.inputs.filter((input) => input.type === InputType.Contract);
    this.outputs = this.outputs.filter((output3) => output3.type !== OutputType.Change);
    const fakeResources = quantities.map(({ assetId, amount }, idx) => ({
      id: `${ZeroBytes32}0${idx}`,
      amount,
      assetId,
      owner: Address.fromB256(owner),
      maturity: 0,
      blockCreated: bn(1),
      txCreatedIdx: bn(1)
    }));
    this.addResources(fakeResources);
  }
  getCoinOutputsQuantities() {
    const coinsQuantities = this.getCoinOutputs().map(({ amount, assetId }) => ({
      amount: bn(amount),
      assetId: assetId.toString()
    }));
    return coinsQuantities;
  }
  toJSON() {
    return normalizeJSON(this);
  }
  hasPredicateInput() {
    return Boolean(this.inputs.find((input) => ("predicate" in input) && input.predicate && input.predicate !== getBytesCopy("0x")));
  }
};
var getStorageValue = (value) => {
  const v2 = new Uint8Array(32);
  v2.set(getBytesCopy(value));
  return v2;
};
var storageSlotify = (storageSlot) => {
  let key;
  let value;
  if (Array.isArray(storageSlot)) {
    key = storageSlot[0];
    value = storageSlot[1];
  } else {
    key = storageSlot.key;
    value = storageSlot.value;
  }
  return {
    key: hexlify(key),
    value: hexlify(getStorageValue(value))
  };
};
var CreateTransactionRequest = class extends BaseTransactionRequest {
  static from(obj) {
    if (obj instanceof this) {
      return obj;
    }
    return new this(obj);
  }
  type = TransactionType.Create;
  bytecodeWitnessIndex;
  salt;
  storageSlots;
  constructor({
    bytecodeWitnessIndex,
    salt,
    storageSlots,
    ...rest
  } = {}) {
    super(rest);
    this.bytecodeWitnessIndex = bytecodeWitnessIndex ?? 0;
    this.salt = hexlify(salt ?? ZeroBytes32);
    this.storageSlots = [...storageSlots ?? []];
  }
  toTransaction() {
    const baseTransaction = this.getBaseTransaction();
    const bytecodeWitnessIndex = this.bytecodeWitnessIndex;
    const storageSlots = this.storageSlots?.map(storageSlotify) ?? [];
    return {
      type: TransactionType.Create,
      ...baseTransaction,
      bytecodeLength: baseTransaction.witnesses[bytecodeWitnessIndex].dataLength / 4,
      bytecodeWitnessIndex,
      storageSlotsCount: storageSlots.length,
      salt: this.salt ? hexlify(this.salt) : ZeroBytes32,
      storageSlots
    };
  }
  getContractCreatedOutputs() {
    return this.outputs.filter((output3) => output3.type === OutputType.ContractCreated);
  }
  addContractCreatedOutput(contractId, stateRoot) {
    this.pushOutput({
      type: OutputType.ContractCreated,
      contractId,
      stateRoot
    });
  }
};
var returnZeroScript = {
  bytes: getBytesCopy("0x24000000"),
  encodeScriptData: () => new Uint8Array(0)
};
var withdrawScript = {
  bytes: getBytesCopy("0x5040C0105D44C0064C40001124000000"),
  encodeScriptData: () => new Uint8Array(0)
};
var ScriptTransactionRequest = class extends BaseTransactionRequest {
  static from(obj) {
    if (obj instanceof this) {
      return obj;
    }
    return new this(obj);
  }
  type = TransactionType.Script;
  script;
  scriptData;
  constructor({ script, scriptData, ...rest } = {}) {
    super(rest);
    this.script = getBytesCopy(script ?? returnZeroScript.bytes);
    this.scriptData = getBytesCopy(scriptData ?? returnZeroScript.encodeScriptData());
  }
  toTransaction() {
    const script = getBytesCopy(this.script ?? "0x");
    const scriptData = getBytesCopy(this.scriptData ?? "0x");
    return {
      type: TransactionType.Script,
      ...super.getBaseTransaction(),
      scriptLength: script.length,
      scriptDataLength: scriptData.length,
      receiptsRoot: ZeroBytes32,
      script: hexlify(script),
      scriptData: hexlify(scriptData)
    };
  }
  getContractInputs() {
    return this.inputs.filter((input) => input.type === InputType.Contract);
  }
  getContractOutputs() {
    return this.outputs.filter((output3) => output3.type === OutputType.Contract);
  }
  getVariableOutputs() {
    return this.outputs.filter((output3) => output3.type === OutputType.Variable);
  }
  setScript(script, data3) {
    this.scriptData = script.encodeScriptData(data3);
    this.script = script.bytes;
  }
  addVariableOutputs(numberOfVariables = 1) {
    let outputsNumber = numberOfVariables;
    while (outputsNumber) {
      this.pushOutput({
        type: OutputType.Variable
      });
      outputsNumber -= 1;
    }
    return this.outputs.length - 1;
  }
  addContractInputAndOutput(contract) {
    const contractAddress = addressify(contract);
    if (this.getContractInputs().find((i) => i.contractId === contractAddress.toB256())) {
      return this;
    }
    const inputIndex = super.pushInput({
      type: InputType.Contract,
      contractId: contractAddress.toB256(),
      txPointer: "0x00000000000000000000000000000000"
    });
    this.pushOutput({
      type: OutputType.Contract,
      inputIndex
    });
    return this;
  }
  setData(abi, args) {
    const abiInterface = new Interface(abi);
    this.scriptData = abiInterface.functions.main.encodeArguments(args);
    return this;
  }
};
var transactionRequestify = (obj) => {
  if (obj instanceof ScriptTransactionRequest || obj instanceof CreateTransactionRequest) {
    return obj;
  }
  const { type: type4 } = obj;
  switch (obj.type) {
    case TransactionType.Script: {
      return ScriptTransactionRequest.from(obj);
    }
    case TransactionType.Create: {
      return CreateTransactionRequest.from(obj);
    }
    default: {
      throw new FuelError(ErrorCode.INVALID_TRANSACTION_TYPE, `Invalid transaction type: ${type4}.`);
    }
  }
};
var fromTai64ToDate = (tai64Timestamp) => {
  const timestamp = import_tai64.TAI64.fromString(tai64Timestamp, 10).toUnix();
  return new Date(timestamp * 1000);
};
var getFunctionCall = ({ abi, receipt, rawPayload, maxInputs }) => {
  const abiInterface = new Interface(abi);
  const callFunctionSelector = receipt.param1.toHex(8);
  const functionFragment = abiInterface.getFunction(callFunctionSelector);
  const inputs = functionFragment.jsonFn.inputs;
  let encodedArgs;
  if (functionFragment.isInputDataPointer) {
    if (rawPayload) {
      const argsOffset = bn(receipt.param2).sub(calculateVmTxMemory({ maxInputs: maxInputs.toNumber() })).toNumber();
      encodedArgs = `0x${rawPayload.slice(2).slice(argsOffset * 2)}`;
    }
  } else {
    encodedArgs = receipt.param2.toHex();
  }
  let argumentsProvided;
  if (encodedArgs) {
    const data3 = functionFragment.decodeArguments(encodedArgs);
    if (data3) {
      argumentsProvided = inputs.reduce((prev, input, index) => {
        const value = data3[index];
        const name = input.name;
        if (name) {
          return {
            ...prev,
            [name]: JSON.parse(JSON.stringify(value))
          };
        }
        return prev;
      }, {});
    }
  }
  const call = {
    functionSignature: functionFragment.signature,
    functionName: functionFragment.name,
    argumentsProvided,
    ...receipt.amount?.isZero() ? {} : { amount: receipt.amount, assetId: receipt.assetId }
  };
  return call;
};
var mergeAssets = (op1, op2) => {
  const assets1 = op1.assetsSent || [];
  const assets2 = op2.assetsSent || [];
  const filtered = assets2.filter((c) => !assets1.some(hasSameAssetId(c)));
  return assets1.map((coin) => {
    const asset = assets2.find(hasSameAssetId(coin));
    if (!asset)
      return coin;
    return { ...coin, amount: bn(coin.amount).add(asset.amount) };
  }).concat(filtered);
};
var processGqlReceipt = (gqlReceipt) => {
  const receipt = assembleReceiptByType(gqlReceipt);
  switch (receipt.type) {
    case ReceiptType.ReturnData: {
      return {
        ...receipt,
        data: gqlReceipt.data || "0x"
      };
    }
    case ReceiptType.LogData: {
      return {
        ...receipt,
        data: gqlReceipt.data || "0x"
      };
    }
    default:
      return receipt;
  }
};
var extractMintedAssetsFromReceipts = (receipts) => {
  const mintedAssets = [];
  receipts.forEach((receipt) => {
    if (receipt.type === ReceiptType.Mint) {
      mintedAssets.push({
        subId: receipt.subId,
        contractId: receipt.contractId,
        assetId: receipt.assetId,
        amount: receipt.val
      });
    }
  });
  return mintedAssets;
};
var extractBurnedAssetsFromReceipts = (receipts) => {
  const burnedAssets = [];
  receipts.forEach((receipt) => {
    if (receipt.type === ReceiptType.Burn) {
      burnedAssets.push({
        subId: receipt.subId,
        contractId: receipt.contractId,
        assetId: receipt.assetId,
        amount: receipt.val
      });
    }
  });
  return burnedAssets;
};
var getTransactionStatusName = (gqlStatus) => {
  switch (gqlStatus) {
    case "FailureStatus":
      return "failure";
    case "SuccessStatus":
      return "success";
    case "SubmittedStatus":
      return "submitted";
    case "SqueezedOutStatus":
      return "squeezedout";
    default:
      throw new FuelError(ErrorCode.INVALID_TRANSACTION_STATUS, `Invalid transaction status: ${gqlStatus}.`);
  }
};
var processGraphqlStatus = (gqlTransactionStatus) => {
  let time;
  let blockId;
  let status;
  let isStatusFailure = false;
  let isStatusSuccess = false;
  let isStatusPending = false;
  if (gqlTransactionStatus?.type) {
    status = getTransactionStatusName(gqlTransactionStatus.type);
    switch (gqlTransactionStatus.type) {
      case "SuccessStatus":
        time = gqlTransactionStatus.time;
        blockId = gqlTransactionStatus.block.id;
        isStatusSuccess = true;
        break;
      case "FailureStatus":
        time = gqlTransactionStatus.time;
        blockId = gqlTransactionStatus.block.id;
        isStatusFailure = true;
        break;
      case "SubmittedStatus":
        time = gqlTransactionStatus.time;
        isStatusPending = true;
        break;
      default:
    }
  }
  const processedGraphqlStatus = {
    time,
    blockId,
    status,
    isStatusFailure,
    isStatusSuccess,
    isStatusPending
  };
  return processedGraphqlStatus;
};
var STATUS_POLLING_INTERVAL_MAX_MS = 5000;
var STATUS_POLLING_INTERVAL_MIN_MS = 1000;
var TransactionResponse2 = class {
  id;
  provider;
  gasUsed = bn(0);
  fetchAttempts = 0;
  resultAttempts = 0;
  gqlTransaction;
  constructor(id, provider) {
    this.id = id;
    this.provider = provider;
  }
  static async create(id, provider) {
    const response = new TransactionResponse2(id, provider);
    await response.fetch();
    return response;
  }
  async fetch() {
    const response = await this.provider.operations.getTransactionWithReceipts({
      transactionId: this.id
    });
    if (!response.transaction) {
      await this.sleepBasedOnAttempts(++this.fetchAttempts);
      return this.fetch();
    }
    this.gqlTransaction = response.transaction;
    return response.transaction;
  }
  decodeTransaction(transactionWithReceipts) {
    return new TransactionCoder().decode(getBytesCopy(transactionWithReceipts.rawPayload), 0)?.[0];
  }
  async getTransactionSummary(contractsAbiMap) {
    let transaction2 = this.gqlTransaction;
    if (!transaction2) {
      transaction2 = await this.fetch();
    }
    const decodedTransaction = this.decodeTransaction(transaction2);
    const receipts = transaction2.receipts?.map(processGqlReceipt) || [];
    const { gasPerByte, gasPriceFactor } = this.provider.getGasConfig();
    const maxInputs = this.provider.getChain().consensusParameters.maxInputs;
    const transactionSummary = assembleTransactionSummary({
      id: this.id,
      receipts,
      transaction: decodedTransaction,
      transactionBytes: getBytesCopy(transaction2.rawPayload),
      gqlTransactionStatus: transaction2.status,
      gasPerByte,
      gasPriceFactor,
      abiMap: contractsAbiMap,
      maxInputs
    });
    return transactionSummary;
  }
  async waitForResult(contractsAbiMap) {
    await this.fetch();
    if (this.gqlTransaction?.status?.type === "SubmittedStatus") {
      await this.sleepBasedOnAttempts(++this.resultAttempts);
      return this.waitForResult(contractsAbiMap);
    }
    const transactionSummary = await this.getTransactionSummary(contractsAbiMap);
    const transactionResult = {
      gqlTransaction: this.gqlTransaction,
      ...transactionSummary
    };
    return transactionResult;
  }
  async wait(contractsAbiMap) {
    const result = await this.waitForResult(contractsAbiMap);
    if (result.isStatusFailure) {
      throw new FuelError(ErrorCode.TRANSACTION_FAILED, `Transaction failed: ${result.gqlTransaction.status.reason}`);
    }
    return result;
  }
  async sleepBasedOnAttempts(attempts) {
    await sleep(Math.min(STATUS_POLLING_INTERVAL_MIN_MS * attempts, STATUS_POLLING_INTERVAL_MAX_MS));
  }
};
var mergeQuantities = (arr1, arr2) => {
  const resultMap = {};
  function addToMap({ amount, assetId }) {
    if (resultMap[assetId]) {
      resultMap[assetId] = resultMap[assetId].add(amount);
    } else {
      resultMap[assetId] = amount;
    }
  }
  arr1.forEach(addToMap);
  arr2.forEach(addToMap);
  return Object.entries(resultMap).map(([assetId, amount]) => ({ assetId, amount }));
};
var MAX_RETRIES = 10;
var processGqlChain = (chain) => {
  const { name, baseChainHeight, peerCount, consensusParameters, latestBlock } = chain;
  return {
    name,
    baseChainHeight: bn(baseChainHeight),
    peerCount,
    consensusParameters: {
      contractMaxSize: bn(consensusParameters.contractMaxSize),
      maxInputs: bn(consensusParameters.maxInputs),
      maxOutputs: bn(consensusParameters.maxOutputs),
      maxWitnesses: bn(consensusParameters.maxWitnesses),
      maxGasPerTx: bn(consensusParameters.maxGasPerTx),
      maxScriptLength: bn(consensusParameters.maxScriptLength),
      maxScriptDataLength: bn(consensusParameters.maxScriptDataLength),
      maxStorageSlots: bn(consensusParameters.maxStorageSlots),
      maxPredicateLength: bn(consensusParameters.maxPredicateLength),
      maxPredicateDataLength: bn(consensusParameters.maxPredicateDataLength),
      maxGasPerPredicate: bn(consensusParameters.maxGasPerPredicate),
      gasPriceFactor: bn(consensusParameters.gasPriceFactor),
      gasPerByte: bn(consensusParameters.gasPerByte),
      maxMessageDataLength: bn(consensusParameters.maxMessageDataLength),
      chainId: bn(consensusParameters.chainId)
    },
    latestBlock: {
      id: latestBlock.id,
      height: bn(latestBlock.header.height),
      time: latestBlock.header.time,
      transactions: latestBlock.transactions.map((i) => ({
        id: i.id
      }))
    }
  };
};
var _cacheInputs;
var cacheInputs_fn;
var _Provider = class {
  constructor(url, options = {}) {
    this.url = url;
    this.options = options;
    __privateAdd2(this, _cacheInputs);
    __publicField4(this, "operations");
    __publicField4(this, "cache");
    this.operations = this.createOperations(url, options);
    this.cache = options.cacheUtxo ? new MemoryCache(options.cacheUtxo) : undefined;
  }
  static clearChainAndNodeCaches() {
    _Provider.nodeInfoCache = {};
    _Provider.chainInfoCache = {};
  }
  static async create(url, options = {}) {
    const provider = new _Provider(url, options);
    await provider.fetchChainAndNodeInfo();
    return provider;
  }
  getChain() {
    const chain = _Provider.chainInfoCache[this.url];
    if (!chain) {
      throw new FuelError(ErrorCode.CHAIN_INFO_CACHE_EMPTY, "Chain info cache is empty. Make sure you have called `Provider.create` to initialize the provider.");
    }
    return chain;
  }
  getNode() {
    const node = _Provider.nodeInfoCache[this.url];
    if (!node) {
      throw new FuelError(ErrorCode.NODE_INFO_CACHE_EMPTY, "Node info cache is empty. Make sure you have called `Provider.create` to initialize the provider.");
    }
    return node;
  }
  getGasConfig() {
    const { minGasPrice } = this.getNode();
    const { maxGasPerTx, maxGasPerPredicate, gasPriceFactor, gasPerByte } = this.getChain().consensusParameters;
    return {
      minGasPrice,
      maxGasPerTx,
      maxGasPerPredicate,
      gasPriceFactor,
      gasPerByte
    };
  }
  async connect(url, options) {
    this.url = url;
    this.operations = this.createOperations(url, options ?? this.options);
    await this.fetchChainAndNodeInfo();
  }
  async fetchChainAndNodeInfo() {
    const chain = await this.fetchChain();
    const nodeInfo = await this.fetchNode();
    _Provider.ensureClientVersionIsSupported(nodeInfo);
    return {
      chain,
      nodeInfo
    };
  }
  static ensureClientVersionIsSupported(nodeInfo) {
    const { isMajorSupported, isMinorSupported, supportedVersion } = checkFuelCoreVersionCompatibility(nodeInfo.nodeVersion);
    if (!isMajorSupported || !isMinorSupported) {
      throw new FuelError(FuelError.CODES.UNSUPPORTED_FUEL_CLIENT_VERSION, `Fuel client version: ${nodeInfo.nodeVersion}, Supported version: ${supportedVersion}`);
    }
  }
  createOperations(url, options = {}) {
    this.url = url;
    const gqlClient = new GraphQLClient(url, options.fetch ? { fetch: options.fetch } : undefined);
    return getSdk(gqlClient);
  }
  async getVersion() {
    const {
      nodeInfo: { nodeVersion }
    } = await this.operations.getVersion();
    return nodeVersion;
  }
  async getNetwork() {
    const {
      name,
      consensusParameters: { chainId }
    } = await this.getChain();
    const network = new Network(name, chainId.toNumber());
    return Promise.resolve(network);
  }
  async getBlockNumber() {
    const { chain } = await this.operations.getChain();
    return bn(chain.latestBlock.header.height, 10);
  }
  async fetchNode() {
    const { nodeInfo } = await this.operations.getNodeInfo();
    const processedNodeInfo = {
      maxDepth: bn(nodeInfo.maxDepth),
      maxTx: bn(nodeInfo.maxTx),
      minGasPrice: bn(nodeInfo.minGasPrice),
      nodeVersion: nodeInfo.nodeVersion,
      utxoValidation: nodeInfo.utxoValidation,
      vmBacktrace: nodeInfo.vmBacktrace
    };
    _Provider.nodeInfoCache[this.url] = processedNodeInfo;
    return processedNodeInfo;
  }
  async fetchChain() {
    const { chain } = await this.operations.getChain();
    const processedChain = processGqlChain(chain);
    _Provider.chainInfoCache[this.url] = processedChain;
    return processedChain;
  }
  getChainId() {
    const {
      consensusParameters: { chainId }
    } = this.getChain();
    return chainId.toNumber();
  }
  async sendTransaction(transactionRequestLike) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    __privateMethod2(this, _cacheInputs, cacheInputs_fn).call(this, transactionRequest.inputs);
    await this.estimateTxDependencies(transactionRequest);
    const encodedTransaction = hexlify(transactionRequest.toTransactionBytes());
    const { gasUsed, minGasPrice } = await this.getTransactionCost(transactionRequest);
    if (bn(gasUsed).gt(bn(transactionRequest.gasLimit))) {
      throw new FuelError(ErrorCode.GAS_LIMIT_TOO_LOW, `Gas limit '${transactionRequest.gasLimit}' is lower than the required: '${gasUsed}'.`);
    } else if (bn(minGasPrice).gt(bn(transactionRequest.gasPrice))) {
      throw new FuelError(ErrorCode.GAS_PRICE_TOO_LOW, `Gas price '${transactionRequest.gasPrice}' is lower than the required: '${minGasPrice}'.`);
    }
    const {
      submit: { id: transactionId }
    } = await this.operations.submit({ encodedTransaction });
    const response = new TransactionResponse2(transactionId, this);
    return response;
  }
  async call(transactionRequestLike, { utxoValidation } = {}) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    await this.estimateTxDependencies(transactionRequest);
    const encodedTransaction = hexlify(transactionRequest.toTransactionBytes());
    const { dryRun: gqlReceipts } = await this.operations.dryRun({
      encodedTransaction,
      utxoValidation: utxoValidation || false
    });
    const receipts = gqlReceipts.map(processGqlReceipt);
    return {
      receipts
    };
  }
  async estimatePredicates(transactionRequest) {
    const encodedTransaction = hexlify(transactionRequest.toTransactionBytes());
    const response = await this.operations.estimatePredicates({
      encodedTransaction
    });
    const estimatedTransaction = transactionRequest;
    const [decodedTransaction] = new TransactionCoder().decode(getBytesCopy(response.estimatePredicates.rawPayload), 0);
    if (decodedTransaction.inputs) {
      decodedTransaction.inputs.forEach((input, index) => {
        if (("predicate" in input) && input.predicateGasUsed.gt(0)) {
          estimatedTransaction.inputs[index].predicateGasUsed = input.predicateGasUsed;
        }
      });
    }
    return estimatedTransaction;
  }
  async estimateTxDependencies(transactionRequest) {
    let missingOutputVariableCount = 0;
    let missingOutputContractIdsCount = 0;
    let tries = 0;
    if (transactionRequest.type === TransactionType.Create) {
      return;
    }
    const encodedTransaction = transactionRequest.hasPredicateInput() ? hexlify((await this.estimatePredicates(transactionRequest)).toTransactionBytes()) : hexlify(transactionRequest.toTransactionBytes());
    do {
      const { dryRun: gqlReceipts } = await this.operations.dryRun({
        encodedTransaction,
        utxoValidation: false
      });
      const receipts = gqlReceipts.map(processGqlReceipt);
      const { missingOutputVariables, missingOutputContractIds } = getReceiptsWithMissingData(receipts);
      missingOutputVariableCount = missingOutputVariables.length;
      missingOutputContractIdsCount = missingOutputContractIds.length;
      if (missingOutputVariableCount === 0 && missingOutputContractIdsCount === 0) {
        return;
      }
      if (transactionRequest instanceof ScriptTransactionRequest) {
        transactionRequest.addVariableOutputs(missingOutputVariableCount);
        missingOutputContractIds.forEach(({ contractId }) => transactionRequest.addContractInputAndOutput(Address.fromString(contractId)));
      }
      tries += 1;
    } while (tries < MAX_RETRIES);
  }
  async simulate(transactionRequestLike) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    await this.estimateTxDependencies(transactionRequest);
    const encodedTransaction = hexlify(transactionRequest.toTransactionBytes());
    const { dryRun: gqlReceipts } = await this.operations.dryRun({
      encodedTransaction,
      utxoValidation: true
    });
    const receipts = gqlReceipts.map(processGqlReceipt);
    return {
      receipts
    };
  }
  async getTransactionCost(transactionRequestLike, forwardingQuantities = []) {
    const clonedTransactionRequest = transactionRequestify(clone_default(transactionRequestLike));
    const { gasLimit } = clonedTransactionRequest;
    let { gasPrice } = clonedTransactionRequest;
    const { minGasPrice, gasPerByte, gasPriceFactor, maxGasPerTx } = this.getGasConfig();
    gasPrice = max(gasPrice, minGasPrice);
    const coinOutputsQuantitites = clonedTransactionRequest.getCoinOutputsQuantities();
    const allQuantities = mergeQuantities(coinOutputsQuantitites, forwardingQuantities);
    clonedTransactionRequest.fundWithFakeUtxos(allQuantities);
    const transactionBytes = clonedTransactionRequest.toTransactionBytes();
    const chargeableBytes = calculateTxChargeableBytes({
      transactionBytes,
      transactionWitnesses: new TransactionCoder().decode(transactionBytes, 0)[0].witnesses
    });
    let gasUsed = bn(0);
    let receipts = [];
    const isTransactionCreate = clonedTransactionRequest.type === TransactionType.Create;
    if (!isTransactionCreate) {
      clonedTransactionRequest.gasPrice = bn(0);
      clonedTransactionRequest.gasLimit = maxGasPerTx;
      const result = await this.call(clonedTransactionRequest);
      receipts = result.receipts;
      gasUsed = getGasUsedFromReceipts(receipts);
    }
    const { minFee, maxFee } = calculateTransactionFee({
      gasPrice,
      gasPerByte,
      gasPriceFactor,
      chargeableBytes,
      gasLimit,
      gasUsed
    });
    return {
      requiredQuantities: allQuantities,
      minGasPrice,
      receipts,
      gasPrice,
      gasUsed,
      minFee,
      maxFee
    };
  }
  async getCoins(owner, assetId, paginationArgs) {
    const result = await this.operations.getCoins({
      first: 10,
      ...paginationArgs,
      filter: { owner: owner.toB256(), assetId: assetId && hexlify(assetId) }
    });
    const coins = result.coins.edges.map((edge) => edge.node);
    return coins.map((coin) => ({
      id: coin.utxoId,
      assetId: coin.assetId,
      amount: bn(coin.amount),
      owner: Address.fromAddressOrString(coin.owner),
      maturity: bn(coin.maturity).toNumber(),
      blockCreated: bn(coin.blockCreated),
      txCreatedIdx: bn(coin.txCreatedIdx)
    }));
  }
  async getResourcesToSpend(owner, quantities, excludedIds) {
    const excludeInput = {
      messages: excludedIds?.messages?.map((id) => hexlify(id)) || [],
      utxos: excludedIds?.utxos?.map((id) => hexlify(id)) || []
    };
    if (this.cache) {
      const uniqueUtxos = new Set(excludeInput.utxos.concat(this.cache?.getActiveData().map((id) => hexlify(id))));
      excludeInput.utxos = Array.from(uniqueUtxos);
    }
    const coinsQuery = {
      owner: owner.toB256(),
      queryPerAsset: quantities.map(coinQuantityfy).map(({ assetId, amount, max: maxPerAsset }) => ({
        assetId: hexlify(assetId),
        amount: amount.toString(10),
        max: maxPerAsset ? maxPerAsset.toString(10) : undefined
      })),
      excludedIds: excludeInput
    };
    const result = await this.operations.getCoinsToSpend(coinsQuery);
    const coins = result.coinsToSpend.flat().map((coin) => {
      switch (coin.__typename) {
        case "MessageCoin":
          return {
            amount: bn(coin.amount),
            assetId: coin.assetId,
            daHeight: bn(coin.daHeight),
            sender: Address.fromAddressOrString(coin.sender),
            recipient: Address.fromAddressOrString(coin.recipient),
            nonce: coin.nonce
          };
        case "Coin":
          return {
            id: coin.utxoId,
            amount: bn(coin.amount),
            assetId: coin.assetId,
            owner: Address.fromAddressOrString(coin.owner),
            maturity: bn(coin.maturity).toNumber(),
            blockCreated: bn(coin.blockCreated),
            txCreatedIdx: bn(coin.txCreatedIdx)
          };
        default:
          return null;
      }
    }).filter((v2) => !!v2);
    return coins;
  }
  async getBlock(idOrHeight) {
    let variables;
    if (typeof idOrHeight === "number") {
      variables = { blockHeight: bn(idOrHeight).toString(10) };
    } else if (idOrHeight === "latest") {
      variables = { blockHeight: (await this.getBlockNumber()).toString(10) };
    } else if (idOrHeight.length === 66) {
      variables = { blockId: idOrHeight };
    } else {
      variables = { blockId: bn(idOrHeight).toString(10) };
    }
    const { block: block2 } = await this.operations.getBlock(variables);
    if (!block2) {
      return null;
    }
    return {
      id: block2.id,
      height: bn(block2.header.height),
      time: block2.header.time,
      transactionIds: block2.transactions.map((tx) => tx.id)
    };
  }
  async getBlocks(params) {
    const { blocks: fetchedData } = await this.operations.getBlocks(params);
    const blocks = fetchedData.edges.map(({ node: block2 }) => ({
      id: block2.id,
      height: bn(block2.header.height),
      time: block2.header.time,
      transactionIds: block2.transactions.map((tx) => tx.id)
    }));
    return blocks;
  }
  async getBlockWithTransactions(idOrHeight) {
    let variables;
    if (typeof idOrHeight === "number") {
      variables = { blockHeight: bn(idOrHeight).toString(10) };
    } else if (idOrHeight === "latest") {
      variables = { blockHeight: (await this.getBlockNumber()).toString() };
    } else {
      variables = { blockId: idOrHeight };
    }
    const { block: block2 } = await this.operations.getBlockWithTransactions(variables);
    if (!block2) {
      return null;
    }
    return {
      id: block2.id,
      height: bn(block2.header.height, 10),
      time: block2.header.time,
      transactionIds: block2.transactions.map((tx) => tx.id),
      transactions: block2.transactions.map((tx) => new TransactionCoder().decode(getBytesCopy(tx.rawPayload), 0)?.[0])
    };
  }
  async getTransaction(transactionId) {
    const { transaction: transaction2 } = await this.operations.getTransaction({ transactionId });
    if (!transaction2) {
      return null;
    }
    return new TransactionCoder().decode(getBytesCopy(transaction2.rawPayload), 0)?.[0];
  }
  async getContract(contractId) {
    const { contract } = await this.operations.getContract({ contractId });
    if (!contract) {
      return null;
    }
    return contract;
  }
  async getContractBalance(contractId, assetId) {
    const { contractBalance } = await this.operations.getContractBalance({
      contract: contractId.toB256(),
      asset: hexlify(assetId)
    });
    return bn(contractBalance.amount, 10);
  }
  async getBalance(owner, assetId) {
    const { balance } = await this.operations.getBalance({
      owner: owner.toB256(),
      assetId: hexlify(assetId)
    });
    return bn(balance.amount, 10);
  }
  async getBalances(owner, paginationArgs) {
    const result = await this.operations.getBalances({
      first: 10,
      ...paginationArgs,
      filter: { owner: owner.toB256() }
    });
    const balances = result.balances.edges.map((edge) => edge.node);
    return balances.map((balance) => ({
      assetId: balance.assetId,
      amount: bn(balance.amount)
    }));
  }
  async getMessages(address5, paginationArgs) {
    const result = await this.operations.getMessages({
      first: 10,
      ...paginationArgs,
      owner: address5.toB256()
    });
    const messages = result.messages.edges.map((edge) => edge.node);
    return messages.map((message) => ({
      messageId: InputMessageCoder.getMessageId({
        sender: message.sender,
        recipient: message.recipient,
        nonce: message.nonce,
        amount: bn(message.amount),
        data: message.data
      }),
      sender: Address.fromAddressOrString(message.sender),
      recipient: Address.fromAddressOrString(message.recipient),
      nonce: message.nonce,
      amount: bn(message.amount),
      data: InputMessageCoder.decodeData(message.data),
      daHeight: bn(message.daHeight)
    }));
  }
  async getMessageProof(transactionId, messageId, commitBlockId, commitBlockHeight) {
    let inputObject = {
      transactionId,
      messageId
    };
    if (commitBlockId && commitBlockHeight) {
      throw new FuelError(ErrorCode.INVALID_INPUT_PARAMETERS, "commitBlockId and commitBlockHeight cannot be used together");
    }
    if (commitBlockId) {
      inputObject = {
        ...inputObject,
        commitBlockId
      };
    }
    if (commitBlockHeight) {
      inputObject = {
        ...inputObject,
        commitBlockHeight: commitBlockHeight.toNumber().toString()
      };
    }
    const result = await this.operations.getMessageProof(inputObject);
    if (!result.messageProof) {
      return null;
    }
    const {
      messageProof,
      messageBlockHeader,
      commitBlockHeader,
      blockProof,
      nonce,
      sender,
      recipient,
      amount,
      data: data3
    } = result.messageProof;
    return {
      messageProof: {
        proofIndex: bn(messageProof.proofIndex),
        proofSet: messageProof.proofSet
      },
      blockProof: {
        proofIndex: bn(blockProof.proofIndex),
        proofSet: blockProof.proofSet
      },
      messageBlockHeader: {
        id: messageBlockHeader.id,
        daHeight: bn(messageBlockHeader.daHeight),
        transactionsCount: bn(messageBlockHeader.transactionsCount),
        transactionsRoot: messageBlockHeader.transactionsRoot,
        height: bn(messageBlockHeader.height),
        prevRoot: messageBlockHeader.prevRoot,
        time: messageBlockHeader.time,
        applicationHash: messageBlockHeader.applicationHash,
        messageReceiptRoot: messageBlockHeader.messageReceiptRoot,
        messageReceiptCount: bn(messageBlockHeader.messageReceiptCount)
      },
      commitBlockHeader: {
        id: commitBlockHeader.id,
        daHeight: bn(commitBlockHeader.daHeight),
        transactionsCount: bn(commitBlockHeader.transactionsCount),
        transactionsRoot: commitBlockHeader.transactionsRoot,
        height: bn(commitBlockHeader.height),
        prevRoot: commitBlockHeader.prevRoot,
        time: commitBlockHeader.time,
        applicationHash: commitBlockHeader.applicationHash,
        messageReceiptRoot: commitBlockHeader.messageReceiptRoot,
        messageReceiptCount: bn(commitBlockHeader.messageReceiptCount)
      },
      sender: Address.fromAddressOrString(sender),
      recipient: Address.fromAddressOrString(recipient),
      nonce,
      amount: bn(amount),
      data: data3
    };
  }
  async getMessageStatus(nonce) {
    const result = await this.operations.getMessageStatus({ nonce });
    return result.messageStatus;
  }
  async produceBlocks(amount, startTime) {
    const { produceBlocks: latestBlockHeight } = await this.operations.produceBlocks({
      blocksToProduce: bn(amount).toString(10),
      startTimestamp: startTime ? fromUnixToTai64(startTime) : undefined
    });
    return bn(latestBlockHeight);
  }
};
var Provider = _Provider;
_cacheInputs = new WeakSet;
cacheInputs_fn = function(inputs) {
  if (!this.cache) {
    return;
  }
  inputs.forEach((input) => {
    if (input.type === InputType.Coin) {
      this.cache?.set(input.id);
    }
  });
};
__publicField4(Provider, "chainInfoCache", {});
__publicField4(Provider, "nodeInfoCache", {});

// node_modules/@fuels/vm-asm/dist/web/index.mjs
var getUint8Memory0 = function() {
  if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {
    cachedUint8Memory0 = new Uint8Array(wasm$1.memory.buffer);
  }
  return cachedUint8Memory0;
};
var getStringFromWasm0 = function(ptr, len) {
  ptr = ptr >>> 0;
  return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
};
var ret = function(value) {
  const ret2 = wasm$1.ret(value);
  return Instruction.__wrap(ret2);
};
var tr = function(contract_id_addr, amount, asset_id_addr) {
  const ret2 = wasm$1.tr(contract_id_addr, amount, asset_id_addr);
  return Instruction.__wrap(ret2);
};
var addi = function(dst, lhs, rhs) {
  const ret2 = wasm$1.addi(dst, lhs, rhs);
  return Instruction.__wrap(ret2);
};
var lw = function(dst, addr, offset) {
  const ret2 = wasm$1.lw(dst, addr, offset);
  return Instruction.__wrap(ret2);
};
var gtf = function(dst, arg, selector) {
  const ret2 = wasm$1.gtf(dst, arg, selector);
  return Instruction.__wrap(ret2);
};
var getInt32Memory0 = function() {
  if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {
    cachedInt32Memory0 = new Int32Array(wasm$1.memory.buffer);
  }
  return cachedInt32Memory0;
};
var getArrayU8FromWasm0 = function(ptr, len) {
  ptr = ptr >>> 0;
  return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);
};
async function __wbg_load(module, imports) {
  if (typeof Response === "function" && module instanceof Response) {
    if (typeof WebAssembly.instantiateStreaming === "function") {
      try {
        return await WebAssembly.instantiateStreaming(module, imports);
      } catch (e) {
        if (module.headers.get("Content-Type") != "application/wasm") {
          console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e);
        } else {
          throw e;
        }
      }
    }
    const bytes3 = await module.arrayBuffer();
    return await WebAssembly.instantiate(bytes3, imports);
  } else {
    const instance = await WebAssembly.instantiate(module, imports);
    if (instance instanceof WebAssembly.Instance) {
      return { instance, module };
    } else {
      return instance;
    }
  }
}
var __wbg_get_imports = function() {
  const imports = {};
  imports.wbg = {};
  imports.wbg.__wbindgen_throw = function(arg0, arg1) {
    throw new Error(getStringFromWasm0(arg0, arg1));
  };
  return imports;
};
var __wbg_finalize_init = function(instance, module) {
  wasm$1 = instance.exports;
  __wbg_init.__wbindgen_wasm_module = module;
  cachedInt32Memory0 = null;
  cachedUint8Memory0 = null;
  return wasm$1;
};
async function __wbg_init(input) {
  if (wasm$1 !== undefined)
    return wasm$1;
  const imports = __wbg_get_imports();
  const { instance, module } = await __wbg_load(await input, imports);
  return __wbg_finalize_init(instance, module);
}
var _loadWasmModule = function(sync, filepath, src, imports) {
  function _instantiateOrCompile(source2, imports2, stream) {
    var instantiateFunc = stream ? WebAssembly.instantiateStreaming : WebAssembly.instantiate;
    var compileFunc = stream ? WebAssembly.compileStreaming : WebAssembly.compile;
    if (imports2) {
      return instantiateFunc(source2, imports2);
    } else {
      return compileFunc(source2);
    }
  }
  var buf = null;
  var isNode2 = typeof process !== "undefined" && process.versions != null && process.versions.node != null;
  if (isNode2) {
    buf = Buffer.from(src, "base64");
  } else {
    var raw = globalThis.atob(src);
    var rawLength = raw.length;
    buf = new Uint8Array(new ArrayBuffer(rawLength));
    for (var i = 0;i < rawLength; i++) {
      buf[i] = raw.charCodeAt(i);
    }
  }
  if (sync) {
    var mod = new WebAssembly.Module(buf);
    return imports ? new WebAssembly.Instance(mod, imports) : mod;
  } else {
    return _instantiateOrCompile(buf, imports, false);
  }
};
var wasm = function(imports) {
  return _loadWasmModule(1, null, "AGFzbQEAAAABVA5gA39/fwF/YAF/AX9gAn9/AX9gBH9/f38Bf2ACf38AYAABf2ABfwBgBX9/f39/AX9gA39/fwBgAABgAX8BfmACfn8Bf2AFf39/f38AYAR/f39/AAIYAQN3YmcQX193YmluZGdlbl90aHJvdwAEA4AC/gEBBgIEAQIDAwMDAwMDAwMDAgsAAAAAAAAAAAAAAAAAAAAAAAAAAAYEAwMDAwMDBQMDAgICAgICAwMDAwMDAwMDAwMDAwMDAwMDBAMDAQEBAQEBAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAwAAg0CAgQCAgICAgICAgICAQIBAQEBAQEEBAEBAQEBAQEBAQEBAQIBBgUAAgkBBAQEAwQGBAEEAQEBBAYFBQUFBQUFBQUFBQUFBQUFBQEBBggFBAYBAQQCCAECBAECAQEEAQICAgIJAQQJCQEBAQEEAAICAQEFCgoKBgIIAgMDAgcABwABAgcHBwQFAXABFhYFAwEAEQYJAX8BQYCAwAALB5JNugUGbWVtb3J5AgAOX193YmdfYWRkX2ZyZWUAsQESYWRkX25ld190eXBlc2NyaXB0AHEGYWRkX3JhAJEBBmFkZF9yYgCLAQZhZGRfcmMAjAEDYWRkAHADYW5kAFQDZGl2AFUCZXEAVgNleHAAVwJndABYAmx0AFkEbWxvZwBaBG1yb28AWwRtb2RfAFwFbW92ZV8AfANtdWwAXQNub3QAfQJvcgBeA3NsbABfA3NybABgA3N1YgBhA3hvcgBiBG1sZHYAOgNyZXQAkgEEcmV0ZAB+E2Fsb2NfbmV3X3R5cGVzY3JpcHQAnQEEYWxvYwCTAQNtY2wAfwNtY3AAYwNtZXEAOxNiaHNoX25ld190eXBlc2NyaXB0AIcBBGJoc2gAgAEEYmhlaQCUAQRidXJuAIEBE2NhbGxfbmV3X3R5cGVzY3JpcHQATAdjYWxsX3JkAJUBBGNhbGwAPANjY3AAPQRjcm9vAIIBBGNzaXoAgwECY2IAlgEDbGRjAGQDbG9nAD4EbG9nZAA/BG1pbnQAhAEEcnZydACXAQRzY3dxAGUDc3J3AGYEc3J3cQBAA3N3dwBnBHN3d3EAQQJ0cgBoA3RybwBCBGVjazEAaQRlY3IxAGoEZWQxOQBrBGsyNTYAbARzMjU2AG0EdGltZQCFARNub29wX25ld190eXBlc2NyaXB0AMcBBG5vb3AAnwEEZmxhZwCYAQNiYWwAbgNqbXAAmQEDam5lAG8Dc21vAEMTYWRkaV9uZXdfdHlwZXNjcmlwdABzCmFkZGlfaW1tMTIAjQEEYWRkaQATBGFuZGkAFARkaXZpABUEZXhwaQAWBG1vZGkAFwRtdWxpABgDb3JpABkEc2xsaQAaBHNybGkAGwRzdWJpABwEeG9yaQAdBGpuZWkAHgJsYgAfAmx3ACACc2IAIQJzdwAiBG1jcGkAIwNndGYAJARtY2xpADIRZ21fbmV3X3R5cGVzY3JpcHQAeQhnbV9pbW0xOACJAQJnbQAzBG1vdmkANARqbnppADUEam1wZgA2BGptcGIANwRqbnpmACUEam56YgAmBGpuZWYABwRqbmViAAgCamkATRNjZmVpX25ld190eXBlc2NyaXB0AIgBCmNmZWlfaW1tMjQAigEEY2ZlaQBOBGNmc2kATwNjZmUAmgEDY2ZzAJsBBHBzaGwAUARwc2hoAFEEcG9wbABSBHBvcGgAUwR3ZGNtAAkEd3FjbQAKBHdkb3AACwR3cW9wAAwEd2RtbAANBHdxbWwADgR3ZGR2AA8Ed3FkdgAQBHdkbWQARAR3cW1kAEUEd2RhbQBGBHdxYW0ARwR3ZG1tAEgEd3FtbQBJCm1jbGlfaW1tMTgAiQEKbW92aV9pbW0xOACJAQpqbnppX2ltbTE4AIkBCmptcGZfaW1tMTgAiQEKam1wYl9pbW0xOACJAQhqaV9pbW0yNACKAQpjZnNpX2ltbTI0AIoBCnBzaGxfaW1tMjQAigEKcHNoaF9pbW0yNACKAQpwb3BsX2ltbTI0AIoBCnBvcGhfaW1tMjQAigETbWNsaV9uZXdfdHlwZXNjcmlwdAB5E21vdmlfbmV3X3R5cGVzY3JpcHQAeRNqbnppX25ld190eXBlc2NyaXB0AHkTam1wZl9uZXdfdHlwZXNjcmlwdAB5E2ptcGJfbmV3X3R5cGVzY3JpcHQAeRJub3RfbmV3X3R5cGVzY3JpcHQAhwETcmV0ZF9uZXdfdHlwZXNjcmlwdACHARNtb3ZlX25ld190eXBlc2NyaXB0AIcBEm1jbF9uZXdfdHlwZXNjcmlwdACHARNidXJuX25ld190eXBlc2NyaXB0AIcBE2Nyb29fbmV3X3R5cGVzY3JpcHQAhwETY3Npel9uZXdfdHlwZXNjcmlwdACHARNtaW50X25ld190eXBlc2NyaXB0AIcBE3RpbWVfbmV3X3R5cGVzY3JpcHQAhwERamlfbmV3X3R5cGVzY3JpcHQAiAETY2ZzaV9uZXdfdHlwZXNjcmlwdACIARNwc2hsX25ld190eXBlc2NyaXB0AIgBE3BzaGhfbmV3X3R5cGVzY3JpcHQAiAETcG9wbF9uZXdfdHlwZXNjcmlwdACIARNwb3BoX25ld190eXBlc2NyaXB0AIgBE2FuZGlfbmV3X3R5cGVzY3JpcHQAcxNkaXZpX25ld190eXBlc2NyaXB0AHMTZXhwaV9uZXdfdHlwZXNjcmlwdABzE21vZGlfbmV3X3R5cGVzY3JpcHQAcxNtdWxpX25ld190eXBlc2NyaXB0AHMSb3JpX25ld190eXBlc2NyaXB0AHMTc2xsaV9uZXdfdHlwZXNjcmlwdABzE3NybGlfbmV3X3R5cGVzY3JpcHQAcxNzdWJpX25ld190eXBlc2NyaXB0AHMTeG9yaV9uZXdfdHlwZXNjcmlwdABzE2puZWlfbmV3X3R5cGVzY3JpcHQAcxFsYl9uZXdfdHlwZXNjcmlwdABzEWx3X25ld190eXBlc2NyaXB0AHMRc2JfbmV3X3R5cGVzY3JpcHQAcxFzd19uZXdfdHlwZXNjcmlwdABzE21jcGlfbmV3X3R5cGVzY3JpcHQAcxJndGZfbmV3X3R5cGVzY3JpcHQAcxNqbnpmX25ld190eXBlc2NyaXB0AHMTam56Yl9uZXdfdHlwZXNjcmlwdABzCmFuZGlfaW1tMTIAjQEKZGl2aV9pbW0xMgCNAQpleHBpX2ltbTEyAI0BCm1vZGlfaW1tMTIAjQEKbXVsaV9pbW0xMgCNAQlvcmlfaW1tMTIAjQEKc2xsaV9pbW0xMgCNAQpzcmxpX2ltbTEyAI0BCnN1YmlfaW1tMTIAjQEKeG9yaV9pbW0xMgCNAQpqbmVpX2ltbTEyAI0BCGxiX2ltbTEyAI0BCGx3X2ltbTEyAI0BCHNiX2ltbTEyAI0BCHN3X2ltbTEyAI0BCm1jcGlfaW1tMTIAjQEJZ3RmX2ltbTEyAI0BCmpuemZfaW1tMTIAjQEKam56Yl9pbW0xMgCNARJhbmRfbmV3X3R5cGVzY3JpcHQAcRJkaXZfbmV3X3R5cGVzY3JpcHQAcRFlcV9uZXdfdHlwZXNjcmlwdABxEmV4cF9uZXdfdHlwZXNjcmlwdABxEWd0X25ld190eXBlc2NyaXB0AHERbHRfbmV3X3R5cGVzY3JpcHQAcRNtbG9nX25ld190eXBlc2NyaXB0AHETbXJvb19uZXdfdHlwZXNjcmlwdABxEm1vZF9uZXdfdHlwZXNjcmlwdABxEm11bF9uZXdfdHlwZXNjcmlwdABxEW9yX25ld190eXBlc2NyaXB0AHESc2xsX25ld190eXBlc2NyaXB0AHESc3JsX25ld190eXBlc2NyaXB0AHESc3ViX25ld190eXBlc2NyaXB0AHESeG9yX25ld190eXBlc2NyaXB0AHESbWNwX25ld190eXBlc2NyaXB0AHESbGRjX25ld190eXBlc2NyaXB0AHETc2N3cV9uZXdfdHlwZXNjcmlwdABxEnNyd19uZXdfdHlwZXNjcmlwdABxEnN3d19uZXdfdHlwZXNjcmlwdABxEXRyX25ld190eXBlc2NyaXB0AHETZWNrMV9uZXdfdHlwZXNjcmlwdABxE2VjcjFfbmV3X3R5cGVzY3JpcHQAcRNlZDE5X25ld190eXBlc2NyaXB0AHETazI1Nl9uZXdfdHlwZXNjcmlwdABxE3MyNTZfbmV3X3R5cGVzY3JpcHQAcRJiYWxfbmV3X3R5cGVzY3JpcHQAcRJqbmVfbmV3X3R5cGVzY3JpcHQAcRJyZXRfbmV3X3R5cGVzY3JpcHQAnQETYmhlaV9uZXdfdHlwZXNjcmlwdACdARFjYl9uZXdfdHlwZXNjcmlwdACdARNydnJ0X25ld190eXBlc2NyaXB0AJ0BE2ZsYWdfbmV3X3R5cGVzY3JpcHQAnQESam1wX25ld190eXBlc2NyaXB0AJ0BEmNmZV9uZXdfdHlwZXNjcmlwdACdARJjZnNfbmV3X3R5cGVzY3JpcHQAnQEGYW5kX3JiAIsBBmRpdl9yYgCLAQVlcV9yYgCLAQZleHBfcmIAiwEFZ3RfcmIAiwEFbHRfcmIAiwEHbWxvZ19yYgCLAQdtcm9vX3JiAIsBBm1vZF9yYgCLAQdtb3ZlX3JiAIsBBm11bF9yYgCLAQZub3RfcmIAiwEFb3JfcmIAiwEGc2xsX3JiAIsBBnNybF9yYgCLAQZzdWJfcmIAiwEGeG9yX3JiAIsBB21sZHZfcmIAiwEHcmV0ZF9yYgCLAQZtY2xfcmIAiwEGbWNwX3JiAIsBBm1lcV9yYgCLAQdiaHNoX3JiAIsBB2J1cm5fcmIAiwEHY2FsbF9yYgCLAQZjY3BfcmIAiwEHY3Jvb19yYgCLAQdjc2l6X3JiAIsBBmxkY19yYgCLAQZsb2dfcmIAiwEHbG9nZF9yYgCLAQdtaW50X3JiAIsBB3Njd3FfcmIAiwEGc3J3X3JiAIsBB3Nyd3FfcmIAiwEGc3d3X3JiAIsBB3N3d3FfcmIAiwEFdHJfcmIAiwEGdHJvX3JiAIsBB2VjazFfcmIAiwEHZWNyMV9yYgCLAQdlZDE5X3JiAIsBB2syNTZfcmIAiwEHczI1Nl9yYgCLAQd0aW1lX3JiAIsBBmJhbF9yYgCLAQZqbmVfcmIAiwEGc21vX3JiAIsBB2FkZGlfcmIAiwEHYW5kaV9yYgCLAQdkaXZpX3JiAIsBB2V4cGlfcmIAiwEHbW9kaV9yYgCLAQdtdWxpX3JiAIsBBm9yaV9yYgCLAQdzbGxpX3JiAIsBB3NybGlfcmIAiwEHc3ViaV9yYgCLAQd4b3JpX3JiAIsBB2puZWlfcmIAiwEFbGJfcmIAiwEFbHdfcmIAiwEFc2JfcmIAiwEFc3dfcmIAiwEHbWNwaV9yYgCLAQZndGZfcmIAiwEHam56Zl9yYgCLAQdqbnpiX3JiAIsBB2puZWZfcmIAiwEHam5lYl9yYgCLAQd3ZGNtX3JiAIsBB3dxY21fcmIAiwEHd2RvcF9yYgCLAQd3cW9wX3JiAIsBB3dkbWxfcmIAiwEHd3FtbF9yYgCLAQd3ZGR2X3JiAIsBB3dxZHZfcmIAiwEHd2RtZF9yYgCLAQd3cW1kX3JiAIsBB3dkYW1fcmIAiwEHd3FhbV9yYgCLAQd3ZG1tX3JiAIsBB3dxbW1fcmIAiwEGYW5kX3JhAJEBBmRpdl9yYQCRAQVlcV9yYQCRAQZleHBfcmEAkQEFZ3RfcmEAkQEFbHRfcmEAkQEHbWxvZ19yYQCRAQdtcm9vX3JhAJEBBm1vZF9yYQCRAQdtb3ZlX3JhAJEBBm11bF9yYQCRAQZub3RfcmEAkQEFb3JfcmEAkQEGc2xsX3JhAJEBBnNybF9yYQCRAQZzdWJfcmEAkQEGeG9yX3JhAJEBB21sZHZfcmEAkQEGcmV0X3JhAJEBB3JldGRfcmEAkQEHYWxvY19yYQCRAQZtY2xfcmEAkQEGbWNwX3JhAJEBBm1lcV9yYQCRAQdiaHNoX3JhAJEBB2JoZWlfcmEAkQEHYnVybl9yYQCRAQdjYWxsX3JhAJEBBmNjcF9yYQCRAQdjcm9vX3JhAJEBB2NzaXpfcmEAkQEFY2JfcmEAkQEGbGRjX3JhAJEBBmxvZ19yYQCRAQdsb2dkX3JhAJEBB21pbnRfcmEAkQEHcnZydF9yYQCRAQdzY3dxX3JhAJEBBnNyd19yYQCRAQdzcndxX3JhAJEBBnN3d19yYQCRAQdzd3dxX3JhAJEBBXRyX3JhAJEBBnRyb19yYQCRAQdlY2sxX3JhAJEBB2VjcjFfcmEAkQEHZWQxOV9yYQCRAQdrMjU2X3JhAJEBB3MyNTZfcmEAkQEHdGltZV9yYQCRAQdmbGFnX3JhAJEBBmJhbF9yYQCRAQZqbXBfcmEAkQEGam5lX3JhAJEBBnNtb19yYQCRAQdhZGRpX3JhAJEBB2FuZGlfcmEAkQEHZGl2aV9yYQCRAQdleHBpX3JhAJEBB21vZGlfcmEAkQEHbXVsaV9yYQCRAQZvcmlfcmEAkQEHc2xsaV9yYQCRAQdzcmxpX3JhAJEBB3N1YmlfcmEAkQEHeG9yaV9yYQCRAQdqbmVpX3JhAJEBBWxiX3JhAJEBBWx3X3JhAJEBBXNiX3JhAJEBBXN3X3JhAJEBB21jcGlfcmEAkQEGZ3RmX3JhAJEBB21jbGlfcmEAkQEFZ21fcmEAkQEHbW92aV9yYQCRAQdqbnppX3JhAJEBB2ptcGZfcmEAkQEHam1wYl9yYQCRAQdqbnpmX3JhAJEBB2puemJfcmEAkQEHam5lZl9yYQCRAQdqbmViX3JhAJEBBmNmZV9yYQCRAQZjZnNfcmEAkQEHd2RjbV9yYQCRAQd3cWNtX3JhAJEBB3dkb3BfcmEAkQEHd3FvcF9yYQCRAQd3ZG1sX3JhAJEBB3dxbWxfcmEAkQEHd2Rkdl9yYQCRAQd3cWR2X3JhAJEBB3dkbWRfcmEAkQEHd3FtZF9yYQCRAQd3ZGFtX3JhAJEBB3dxYW1fcmEAkQEHd2RtbV9yYQCRAQd3cW1tX3JhAJEBE21sZHZfbmV3X3R5cGVzY3JpcHQATBJtZXFfbmV3X3R5cGVzY3JpcHQATBJjY3BfbmV3X3R5cGVzY3JpcHQATBJsb2dfbmV3X3R5cGVzY3JpcHQATBNsb2dkX25ld190eXBlc2NyaXB0AEwTc3J3cV9uZXdfdHlwZXNjcmlwdABME3N3d3FfbmV3X3R5cGVzY3JpcHQATBJ0cm9fbmV3X3R5cGVzY3JpcHQATBJzbW9fbmV3X3R5cGVzY3JpcHQATBNqbmVmX25ld190eXBlc2NyaXB0AEwTam5lYl9uZXdfdHlwZXNjcmlwdABME3dkY21fbmV3X3R5cGVzY3JpcHQATBN3cWNtX25ld190eXBlc2NyaXB0AEwTd2RvcF9uZXdfdHlwZXNjcmlwdABME3dxb3BfbmV3X3R5cGVzY3JpcHQATBN3ZG1sX25ld190eXBlc2NyaXB0AEwTd3FtbF9uZXdfdHlwZXNjcmlwdABME3dkZHZfbmV3X3R5cGVzY3JpcHQATBN3cWR2X25ld190eXBlc2NyaXB0AEwTd2RtZF9uZXdfdHlwZXNjcmlwdABME3dxbWRfbmV3X3R5cGVzY3JpcHQATBN3ZGFtX25ld190eXBlc2NyaXB0AEwTd3FhbV9uZXdfdHlwZXNjcmlwdABME3dkbW1fbmV3X3R5cGVzY3JpcHQATBN3cW1tX25ld190eXBlc2NyaXB0AEwHbWxkdl9yZACVAQZtZXFfcmQAlQEGY2NwX3JkAJUBBmxvZ19yZACVAQdsb2dkX3JkAJUBB3Nyd3FfcmQAlQEHc3d3cV9yZACVAQZ0cm9fcmQAlQEGc21vX3JkAJUBCmpuZWZfaW1tMDYAlQEKam5lYl9pbW0wNgCVAQp3ZGNtX2ltbTA2AJUBCndxY21faW1tMDYAlQEKd2RvcF9pbW0wNgCVAQp3cW9wX2ltbTA2AJUBCndkbWxfaW1tMDYAlQEKd3FtbF9pbW0wNgCVAQp3ZGR2X2ltbTA2AJUBCndxZHZfaW1tMDYAlQEHd2RtZF9yZACVAQd3cW1kX3JkAJUBB3dkYW1fcmQAlQEHd3FhbV9yZACVAQd3ZG1tX3JkAJUBB3dxbW1fcmQAlQEOX193YmdfYW5kX2ZyZWUAsQEOX193YmdfZGl2X2ZyZWUAsQENX193YmdfZXFfZnJlZQCxAQ5fX3diZ19leHBfZnJlZQCxAQ1fX3diZ19ndF9mcmVlALEBDV9fd2JnX2x0X2ZyZWUAsQEPX193YmdfbWxvZ19mcmVlALEBD19fd2JnX21yb29fZnJlZQCxAQ5fX3diZ19tb2RfZnJlZQCxAQ9fX3diZ19tb3ZlX2ZyZWUAsQEOX193YmdfbXVsX2ZyZWUAsQEOX193Ymdfbm90X2ZyZWUAsQENX193Ymdfb3JfZnJlZQCxAQ5fX3diZ19zbGxfZnJlZQCxAQ5fX3diZ19zcmxfZnJlZQCxAQ5fX3diZ19zdWJfZnJlZQCxAQ5fX3diZ194b3JfZnJlZQCxAQ9fX3diZ19tbGR2X2ZyZWUAsQEOX193YmdfcmV0X2ZyZWUAsQEPX193YmdfcmV0ZF9mcmVlALEBD19fd2JnX2Fsb2NfZnJlZQCxAQ5fX3diZ19tY2xfZnJlZQCxAQ5fX3diZ19tY3BfZnJlZQCxAQ5fX3diZ19tZXFfZnJlZQCxAQ9fX3diZ19iaHNoX2ZyZWUAsQEPX193YmdfYmhlaV9mcmVlALEBD19fd2JnX2J1cm5fZnJlZQCxAQ9fX3diZ19jYWxsX2ZyZWUAsQEOX193YmdfY2NwX2ZyZWUAsQEPX193YmdfY3Jvb19mcmVlALEBD19fd2JnX2NzaXpfZnJlZQCxAQ1fX3diZ19jYl9mcmVlALEBDl9fd2JnX2xkY19mcmVlALEBDl9fd2JnX2xvZ19mcmVlALEBD19fd2JnX2xvZ2RfZnJlZQCxAQ9fX3diZ19taW50X2ZyZWUAsQEPX193YmdfcnZydF9mcmVlALEBD19fd2JnX3Njd3FfZnJlZQCxAQ5fX3diZ19zcndfZnJlZQCxAQ9fX3diZ19zcndxX2ZyZWUAsQEOX193Ymdfc3d3X2ZyZWUAsQEPX193Ymdfc3d3cV9mcmVlALEBDV9fd2JnX3RyX2ZyZWUAsQEOX193YmdfdHJvX2ZyZWUAsQEPX193YmdfZWNrMV9mcmVlALEBD19fd2JnX2VjcjFfZnJlZQCxAQ9fX3diZ19lZDE5X2ZyZWUAsQEPX193YmdfazI1Nl9mcmVlALEBD19fd2JnX3MyNTZfZnJlZQCxAQ9fX3diZ190aW1lX2ZyZWUAsQEPX193Ymdfbm9vcF9mcmVlALEBD19fd2JnX2ZsYWdfZnJlZQCxAQ5fX3diZ19iYWxfZnJlZQCxAQ5fX3diZ19qbXBfZnJlZQCxAQ5fX3diZ19qbmVfZnJlZQCxAQ5fX3diZ19zbW9fZnJlZQCxAQ9fX3diZ19hZGRpX2ZyZWUAsQEPX193YmdfYW5kaV9mcmVlALEBD19fd2JnX2RpdmlfZnJlZQCxAQ9fX3diZ19leHBpX2ZyZWUAsQEPX193YmdfbW9kaV9mcmVlALEBD19fd2JnX211bGlfZnJlZQCxAQ5fX3diZ19vcmlfZnJlZQCxAQ9fX3diZ19zbGxpX2ZyZWUAsQEPX193Ymdfc3JsaV9mcmVlALEBD19fd2JnX3N1YmlfZnJlZQCxAQ9fX3diZ194b3JpX2ZyZWUAsQEPX193Ymdfam5laV9mcmVlALEBDV9fd2JnX2xiX2ZyZWUAsQENX193YmdfbHdfZnJlZQCxAQ1fX3diZ19zYl9mcmVlALEBDV9fd2JnX3N3X2ZyZWUAsQEPX193YmdfbWNwaV9mcmVlALEBDl9fd2JnX2d0Zl9mcmVlALEBD19fd2JnX21jbGlfZnJlZQCxAQ1fX3diZ19nbV9mcmVlALEBD19fd2JnX21vdmlfZnJlZQCxAQ9fX3diZ19qbnppX2ZyZWUAsQEPX193Ymdfam1wZl9mcmVlALEBD19fd2JnX2ptcGJfZnJlZQCxAQ9fX3diZ19qbnpmX2ZyZWUAsQEPX193Ymdfam56Yl9mcmVlALEBD19fd2JnX2puZWZfZnJlZQCxAQ9fX3diZ19qbmViX2ZyZWUAsQENX193YmdfamlfZnJlZQCxAQ9fX3diZ19jZmVpX2ZyZWUAsQEPX193YmdfY2ZzaV9mcmVlALEBDl9fd2JnX2NmZV9mcmVlALEBDl9fd2JnX2Nmc19mcmVlALEBD19fd2JnX3BzaGxfZnJlZQCxAQ9fX3diZ19wc2hoX2ZyZWUAsQEPX193YmdfcG9wbF9mcmVlALEBD19fd2JnX3BvcGhfZnJlZQCxAQ9fX3diZ193ZGNtX2ZyZWUAsQEPX193Ymdfd3FjbV9mcmVlALEBD19fd2JnX3dkb3BfZnJlZQCxAQ9fX3diZ193cW9wX2ZyZWUAsQEPX193Ymdfd2RtbF9mcmVlALEBD19fd2JnX3dxbWxfZnJlZQCxAQ9fX3diZ193ZGR2X2ZyZWUAsQEPX193Ymdfd3Fkdl9mcmVlALEBD19fd2JnX3dkbWRfZnJlZQCxAQ9fX3diZ193cW1kX2ZyZWUAsQEPX193Ymdfd2RhbV9mcmVlALEBD19fd2JnX3dxYW1fZnJlZQCxAQ9fX3diZ193ZG1tX2ZyZWUAsQEPX193Ymdfd3FtbV9mcmVlALEBBmFuZF9yYwCMAQZkaXZfcmMAjAEFZXFfcmMAjAEGZXhwX3JjAIwBBWd0X3JjAIwBBWx0X3JjAIwBB21sb2dfcmMAjAEHbXJvb19yYwCMAQZtb2RfcmMAjAEGbXVsX3JjAIwBBW9yX3JjAIwBBnNsbF9yYwCMAQZzcmxfcmMAjAEGc3ViX3JjAIwBBnhvcl9yYwCMAQdtbGR2X3JjAIwBBm1jcF9yYwCMAQZtZXFfcmMAjAEHY2FsbF9yYwCMAQZjY3BfcmMAjAEGbGRjX3JjAIwBBmxvZ19yYwCMAQdsb2dkX3JjAIwBB3Njd3FfcmMAjAEGc3J3X3JjAIwBB3Nyd3FfcmMAjAEGc3d3X3JjAIwBB3N3d3FfcmMAjAEFdHJfcmMAjAEGdHJvX3JjAIwBB2VjazFfcmMAjAEHZWNyMV9yYwCMAQdlZDE5X3JjAIwBB2syNTZfcmMAjAEHczI1Nl9yYwCMAQZiYWxfcmMAjAEGam5lX3JjAIwBBnNtb19yYwCMAQdqbmVmX3JjAIwBB2puZWJfcmMAjAEHd2RjbV9yYwCMAQd3cWNtX3JjAIwBB3dkb3BfcmMAjAEHd3FvcF9yYwCMAQd3ZG1sX3JjAIwBB3dxbWxfcmMAjAEHd2Rkdl9yYwCMAQd3cWR2X3JjAIwBB3dkbWRfcmMAjAEHd3FtZF9yYwCMAQd3ZGFtX3JjAIwBB3dxYW1fcmMAjAEHd2RtbV9yYwCMAQd3cW1tX3JjAIwBEF9fd2JnX2ltbTA2X2ZyZWUAsQERcmVnaWRfbmV3X2NoZWNrZWQAowEJcmVnaWRfYmFsALIBCnJlZ2lkX2NnYXMAswEJcmVnaWRfZXJyALQBCnJlZ2lkX2ZsYWcAtQEIcmVnaWRfZnAAtgEKcmVnaWRfZ2dhcwC3AQhyZWdpZF9ocAC4AQhyZWdpZF9pcwC5AQhyZWdpZF9vZgC6AQlyZWdpZF9vbmUAuwEIcmVnaWRfcGMAvAEJcmVnaWRfcmV0AL0BCnJlZ2lkX3JldGwAvgEIcmVnaWRfc3AAvwEJcmVnaWRfc3BwAMABDnJlZ2lkX3dyaXRhYmxlAMEBCnJlZ2lkX3plcm8AwgEUcmVnaWRfbmV3X3R5cGVzY3JpcHQArQELcmVnaWRfdG9fdTgAqwEQX193YmdfcmVnaWRfZnJlZQCxARBfX3diZ19pbW0xMl9mcmVlALEBEF9fd2JnX2ltbTE4X2ZyZWUAsQEQX193YmdfaW1tMjRfZnJlZQCxARZfX3diZ19jb21wYXJlYXJnc19mcmVlALEBGl9fd2JnX2dldF9jb21wYXJlYXJnc19tb2RlAMMBGl9fd2JnX3NldF9jb21wYXJlYXJnc19tb2RlAKQBIl9fd2JnX2dldF9jb21wYXJlYXJnc19pbmRpcmVjdF9yaHMArgEiX193Ymdfc2V0X2NvbXBhcmVhcmdzX2luZGlyZWN0X3JocwCqARJjb21wYXJlYXJnc190b19pbW0AkAEUY29tcGFyZWFyZ3NfZnJvbV9pbW0AhgEVX193YmdfZ2V0X21hdGhhcmdzX29wAMMBFV9fd2JnX3NldF9tYXRoYXJnc19vcAClAR5fX3diZ19nZXRfZGl2YXJnc19pbmRpcmVjdF9yaHMAwwEeX193Ymdfc2V0X2RpdmFyZ3NfaW5kaXJlY3RfcmhzAKwBH19fd2JnX2dldF9tYXRoYXJnc19pbmRpcmVjdF9yaHMArgEeX193YmdfZ2V0X211bGFyZ3NfaW5kaXJlY3RfcmhzAK4BHl9fd2JnX2dldF9tdWxhcmdzX2luZGlyZWN0X2xocwDDAR9fX3diZ19zZXRfbWF0aGFyZ3NfaW5kaXJlY3RfcmhzAKoBHl9fd2JnX3NldF9tdWxhcmdzX2luZGlyZWN0X3JocwCqAR5fX3diZ19zZXRfbXVsYXJnc19pbmRpcmVjdF9saHMArAETX193YmdfbWF0aGFyZ3NfZnJlZQCxARJfX3diZ19tdWxhcmdzX2ZyZWUAsQESX193YmdfZGl2YXJnc19mcmVlALEBDGdtX2Zyb21fYXJncwB6DWd0Zl9mcm9tX2FyZ3MAdgdnbV9hcmdzAHcIZ3RmX2FyZ3MAcg53ZGNtX2Zyb21fYXJncwA4Dndkb3BfZnJvbV9hcmdzADgOd2RtbF9mcm9tX2FyZ3MAOQ53ZGR2X2Zyb21fYXJncwBLCXdkY21fYXJncwApCXdxY21fYXJncwAqCXdkb3BfYXJncwArCXdxb3BfYXJncwAsCXdkbWxfYXJncwAtCXdxbWxfYXJncwAuCXdkZHZfYXJncwAwCXdxZHZfYXJncwAxDndxbWxfZnJvbV9hcmdzADkOd3Fkdl9mcm9tX2FyZ3MASw53cWNtX2Zyb21fYXJncwA4Dndxb3BfZnJvbV9hcmdzADgbX193YmdfcGFuaWNpbnN0cnVjdGlvbl9mcmVlALEBIXBhbmljaW5zdHJ1Y3Rpb25fZXJyb3JfdHlwZXNjcmlwdAChARdwYW5pY2luc3RydWN0aW9uX3JlYXNvbgCvARxwYW5pY2luc3RydWN0aW9uX2luc3RydWN0aW9uAMQBFl9fd2JnX2luc3RydWN0aW9uX2ZyZWUAqQEUaW5zdHJ1Y3Rpb25fdG9fYnl0ZXMAjgEQaW5zdHJ1Y3Rpb25fc2l6ZQDrAR9fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyAN0BD19fd2JpbmRnZW5fZnJlZQDOAQktAQBBAQsV2wHZAdoBjwHvAaABEZwByQHtAe4BxQFKe6YB0QHsAdgB0wHvAewBCorBAf4B7SECD38BfiMAQRBrIgskAAJAAkACQAJAAkACQCAAQfUBTwRAQQhBCBDNASEGQRRBCBDNASEFQRBBCBDNASEBQQBBEEEIEM0BQQJ0ayICQYCAfCABIAUgBmpqa0F3cUEDayIBIAEgAksbIABNDQYgAEEEakEIEM0BIQRBwJDAACgCAEUNBUEAIARrIQMCf0EAIARBgAJJDQAaQR8gBEH///8HSw0AGiAEQQYgBEEIdmciAGt2QQFxIABBAXRrQT5qCyIGQQJ0QaSNwABqKAIAIgENAUEAIQBBACEFDAILQRAgAEEEakEQQQgQzQFBBWsgAEsbQQgQzQEhBAJAAkACQAJ/AkACQEG8kMAAKAIAIgEgBEEDdiIAdiICQQNxRQRAIARBxJDAACgCAE0NCyACDQFBwJDAACgCACIARQ0LIAAQ1AFoQQJ0QaSNwABqKAIAIgEQ4QEgBGshAyABEMoBIgAEQANAIAAQ4QEgBGsiAiADIAIgA0kiAhshAyAAIAEgAhshASAAEMoBIgANAAsLIAEgBBDnASEFIAEQJ0EQQQgQzQEgA0sNBSABIAQQ1gEgBSADEMwBQcSQwAAoAgAiAEUNBCAAQXhxQbSOwABqIQdBzJDAACgCACEGQbyQwAAoAgAiAkEBIABBA3Z0IgBxRQ0CIAcoAggMAwsCQCACQX9zQQFxIABqIgNBA3QiAEG8jsAAaigCACIFQQhqKAIAIgIgAEG0jsAAaiIARwRAIAIgADYCDCAAIAI2AggMAQtBvJDAACABQX4gA3dxNgIACyAFIANBA3QQyAEgBRDpASEDDAsLAkBBASAAQR9xIgB0EM8BIAIgAHRxENQBaCICQQN0IgBBvI7AAGooAgAiA0EIaigCACIBIABBtI7AAGoiAEcEQCABIAA2AgwgACABNgIIDAELQbyQwABBvJDAACgCAEF+IAJ3cTYCAAsgAyAEENYBIAMgBBDnASIFIAJBA3QgBGsiAhDMAUHEkMAAKAIAIgAEQCAAQXhxQbSOwABqIQdBzJDAACgCACEGAn9BvJDAACgCACIBQQEgAEEDdnQiAHEEQCAHKAIIDAELQbyQwAAgACABcjYCACAHCyEAIAcgBjYCCCAAIAY2AgwgBiAHNgIMIAYgADYCCAtBzJDAACAFNgIAQcSQwAAgAjYCACADEOkBIQMMCgtBvJDAACAAIAJyNgIAIAcLIQAgByAGNgIIIAAgBjYCDCAGIAc2AgwgBiAANgIIC0HMkMAAIAU2AgBBxJDAACADNgIADAELIAEgAyAEahDIAQsgARDpASIDDQUMBAsgBCAGEMsBdCEHQQAhAEEAIQUDQAJAIAEQ4QEiAiAESQ0AIAIgBGsiAiADTw0AIAEhBSACIgMNAEEAIQMgASEADAMLIAFBFGooAgAiAiAAIAIgASAHQR12QQRxakEQaigCACIBRxsgACACGyEAIAdBAXQhByABDQALCyAAIAVyRQRAQQAhBUEBIAZ0EM8BQcCQwAAoAgBxIgBFDQMgABDUAWhBAnRBpI3AAGooAgAhAAsgAEUNAQsDQCAAIAUgABDhASIBIARPIAEgBGsiAiADSXEiARshBSACIAMgARshAyAAEMoBIgANAAsLIAVFDQAgBEHEkMAAKAIAIgBNIAMgACAEa09xDQAgBSAEEOcBIQYgBRAnAkBBEEEIEM0BIANNBEAgBSAEENYBIAYgAxDMASADQYACTwRAIAYgAxAoDAILIANBeHFBtI7AAGohAgJ/QbyQwAAoAgAiAUEBIANBA3Z0IgBxBEAgAigCCAwBC0G8kMAAIAAgAXI2AgAgAgshACACIAY2AgggACAGNgIMIAYgAjYCDCAGIAA2AggMAQsgBSADIARqEMgBCyAFEOkBIgMNAQsCQAJAAkACQAJAAkACQCAEQcSQwAAoAgAiAEsEQEHIkMAAKAIAIgAgBEsNAkEIQQgQzQEgBGpBFEEIEM0BakEQQQgQzQFqQYCABBDNASIAQRB2QAAhASALQQA2AgggC0EAIABBgIB8cSABQX9GIgAbNgIEIAtBACABQRB0IAAbNgIAIAsoAgAiCA0BQQAhAwwIC0HMkMAAKAIAIQJBEEEIEM0BIAAgBGsiAUsEQEHMkMAAQQA2AgBBxJDAACgCACEAQcSQwABBADYCACACIAAQyAEgAhDpASEDDAgLIAIgBBDnASEAQcSQwAAgATYCAEHMkMAAIAA2AgAgACABEMwBIAIgBBDWASACEOkBIQMMBwsgCygCCCEMQdSQwAAgCygCBCIKQdSQwAAoAgBqIgE2AgBB2JDAAEHYkMAAKAIAIgAgASAAIAFLGzYCAAJAAkACQEHQkMAAKAIABEBBpI7AACEAA0AgABDXASAIRg0CIAAoAggiAA0ACwwCC0HgkMAAKAIAIgBFIAAgCEtyDQUMBwsgABDjAQ0AIAAQ5AEgDEcNACAAKAIAIgJB0JDAACgCACIBTQR/IAIgACgCBGogAUsFQQALDQELQeCQwABB4JDAACgCACIAIAggACAISRs2AgAgCCAKaiEBQaSOwAAhAAJAAkADQCABIAAoAgBHBEAgACgCCCIADQEMAgsLIAAQ4wENACAAEOQBIAxGDQELQdCQwAAoAgAhCUGkjsAAIQACQANAIAkgACgCAE8EQCAAENcBIAlLDQILIAAoAggiAA0AC0EAIQALIAkgABDXASIGQRRBCBDNASIPa0EXayIBEOkBIgBBCBDNASAAayABaiIAIABBEEEIEM0BIAlqSRsiDRDpASEOIA0gDxDnASEAQQhBCBDNASEDQRRBCBDNASEFQRBBCBDNASECQdCQwAAgCCAIEOkBIgFBCBDNASABayIBEOcBIgc2AgBByJDAACAKQQhqIAIgAyAFamogAWprIgM2AgAgByADQQFyNgIEQQhBCBDNASEFQRRBCBDNASECQRBBCBDNASEBIAcgAxDnASABIAIgBUEIa2pqNgIEQdyQwABBgICAATYCACANIA8Q1gFBpI7AACkCACEQIA5BCGpBrI7AACkCADcCACAOIBA3AgBBsI7AACAMNgIAQaiOwAAgCjYCAEGkjsAAIAg2AgBBrI7AACAONgIAA0AgAEEEEOcBIABBBzYCBCIAQQRqIAZJDQALIAkgDUYNByAJIA0gCWsiACAJIAAQ5wEQxgEgAEGAAk8EQCAJIAAQKAwICyAAQXhxQbSOwABqIQICf0G8kMAAKAIAIgFBASAAQQN2dCIAcQRAIAIoAggMAQtBvJDAACAAIAFyNgIAIAILIQAgAiAJNgIIIAAgCTYCDCAJIAI2AgwgCSAANgIIDAcLIAAoAgAhAyAAIAg2AgAgACAAKAIEIApqNgIEIAgQ6QEiBUEIEM0BIQIgAxDpASIBQQgQzQEhACAIIAIgBWtqIgYgBBDnASEHIAYgBBDWASADIAAgAWtqIgAgBCAGamshBEHQkMAAKAIAIABHBEAgAEHMkMAAKAIARg0DIAAoAgRBA3FBAUcNBQJAIAAQ4QEiBUGAAk8EQCAAECcMAQsgAEEMaigCACICIABBCGooAgAiAUcEQCABIAI2AgwgAiABNgIIDAELQbyQwABBvJDAACgCAEF+IAVBA3Z3cTYCAAsgBCAFaiEEIAAgBRDnASEADAULQdCQwAAgBzYCAEHIkMAAQciQwAAoAgAgBGoiADYCACAHIABBAXI2AgQgBhDpASEDDAcLIAAgACgCBCAKajYCBEHIkMAAKAIAIApqIQFB0JDAACgCACIAIAAQ6QEiAEEIEM0BIABrIgAQ5wEhA0HIkMAAIAEgAGsiBTYCAEHQkMAAIAM2AgAgAyAFQQFyNgIEQQhBCBDNASECQRRBCBDNASEBQRBBCBDNASEAIAMgBRDnASAAIAEgAkEIa2pqNgIEQdyQwABBgICAATYCAAwFC0HIkMAAIAAgBGsiATYCAEHQkMAAQdCQwAAoAgAiAiAEEOcBIgA2AgAgACABQQFyNgIEIAIgBBDWASACEOkBIQMMBQtBzJDAACAHNgIAQcSQwABBxJDAACgCACAEaiIANgIAIAcgABDMASAGEOkBIQMMBAtB4JDAACAINgIADAELIAcgBCAAEMYBIARBgAJPBEAgByAEECggBhDpASEDDAMLIARBeHFBtI7AAGohAgJ/QbyQwAAoAgAiAUEBIARBA3Z0IgBxBEAgAigCCAwBC0G8kMAAIAAgAXI2AgAgAgshACACIAc2AgggACAHNgIMIAcgAjYCDCAHIAA2AgggBhDpASEDDAILQeSQwABB/x82AgBBsI7AACAMNgIAQaiOwAAgCjYCAEGkjsAAIAg2AgBBwI7AAEG0jsAANgIAQciOwABBvI7AADYCAEG8jsAAQbSOwAA2AgBB0I7AAEHEjsAANgIAQcSOwABBvI7AADYCAEHYjsAAQcyOwAA2AgBBzI7AAEHEjsAANgIAQeCOwABB1I7AADYCAEHUjsAAQcyOwAA2AgBB6I7AAEHcjsAANgIAQdyOwABB1I7AADYCAEHwjsAAQeSOwAA2AgBB5I7AAEHcjsAANgIAQfiOwABB7I7AADYCAEHsjsAAQeSOwAA2AgBBgI/AAEH0jsAANgIAQfSOwABB7I7AADYCAEH8jsAAQfSOwAA2AgBBiI/AAEH8jsAANgIAQYSPwABB/I7AADYCAEGQj8AAQYSPwAA2AgBBjI/AAEGEj8AANgIAQZiPwABBjI/AADYCAEGUj8AAQYyPwAA2AgBBoI/AAEGUj8AANgIAQZyPwABBlI/AADYCAEGoj8AAQZyPwAA2AgBBpI/AAEGcj8AANgIAQbCPwABBpI/AADYCAEGsj8AAQaSPwAA2AgBBuI/AAEGsj8AANgIAQbSPwABBrI/AADYCAEHAj8AAQbSPwAA2AgBByI/AAEG8j8AANgIAQbyPwABBtI/AADYCAEHQj8AAQcSPwAA2AgBBxI/AAEG8j8AANgIAQdiPwABBzI/AADYCAEHMj8AAQcSPwAA2AgBB4I/AAEHUj8AANgIAQdSPwABBzI/AADYCAEHoj8AAQdyPwAA2AgBB3I/AAEHUj8AANgIAQfCPwABB5I/AADYCAEHkj8AAQdyPwAA2AgBB+I/AAEHsj8AANgIAQeyPwABB5I/AADYCAEGAkMAAQfSPwAA2AgBB9I/AAEHsj8AANgIAQYiQwABB/I/AADYCAEH8j8AAQfSPwAA2AgBBkJDAAEGEkMAANgIAQYSQwABB/I/AADYCAEGYkMAAQYyQwAA2AgBBjJDAAEGEkMAANgIAQaCQwABBlJDAADYCAEGUkMAAQYyQwAA2AgBBqJDAAEGckMAANgIAQZyQwABBlJDAADYCAEGwkMAAQaSQwAA2AgBBpJDAAEGckMAANgIAQbiQwABBrJDAADYCAEGskMAAQaSQwAA2AgBBtJDAAEGskMAANgIAQQhBCBDNASEFQRRBCBDNASECQRBBCBDNASEBQdCQwAAgCCAIEOkBIgBBCBDNASAAayIAEOcBIgM2AgBByJDAACAKQQhqIAEgAiAFamogAGprIgU2AgAgAyAFQQFyNgIEQQhBCBDNASECQRRBCBDNASEBQRBBCBDNASEAIAMgBRDnASAAIAEgAkEIa2pqNgIEQdyQwABBgICAATYCAAtBACEDQciQwAAoAgAiACAETQ0AQciQwAAgACAEayIBNgIAQdCQwABB0JDAACgCACICIAQQ5wEiADYCACAAIAFBAXI2AgQgAiAEENYBIAIQ6QEhAwsgC0EQaiQAIAMLkQcBBX8gABDqASIAIAAQ4QEiAhDnASEBAkACQAJAIAAQ4gENACAAKAIAIQMCQCAAENUBRQRAIAIgA2ohAiAAIAMQ6AEiAEHMkMAAKAIARw0BIAEoAgRBA3FBA0cNAkHEkMAAIAI2AgAgACACIAEQxgEPCyACIANqQRBqIQAMAgsgA0GAAk8EQCAAECcMAQsgAEEMaigCACIEIABBCGooAgAiBUcEQCAFIAQ2AgwgBCAFNgIIDAELQbyQwABBvJDAACgCAEF+IANBA3Z3cTYCAAsCQCABENIBBEAgACACIAEQxgEMAQsCQAJAAkBB0JDAACgCACABRwRAIAFBzJDAACgCAEcNAUHMkMAAIAA2AgBBxJDAAEHEkMAAKAIAIAJqIgE2AgAgACABEMwBDwtB0JDAACAANgIAQciQwABByJDAACgCACACaiIBNgIAIAAgAUEBcjYCBCAAQcyQwAAoAgBGDQEMAgsgARDhASIDIAJqIQICQCADQYACTwRAIAEQJwwBCyABQQxqKAIAIgQgAUEIaigCACIBRwRAIAEgBDYCDCAEIAE2AggMAQtBvJDAAEG8kMAAKAIAQX4gA0EDdndxNgIACyAAIAIQzAEgAEHMkMAAKAIARw0CQcSQwAAgAjYCAAwDC0HEkMAAQQA2AgBBzJDAAEEANgIAC0HckMAAKAIAIAFPDQFBCEEIEM0BIQBBFEEIEM0BIQFBEEEIEM0BIQNBAEEQQQgQzQFBAnRrIgJBgIB8IAMgACABamprQXdxQQNrIgAgACACSxtFDQFB0JDAACgCAEUNAUEIQQgQzQEhAEEUQQgQzQEhAUEQQQgQzQEhAkEAAkBByJDAACgCACIEIAIgASAAQQhramoiAk0NAEHQkMAAKAIAIQFBpI7AACEAAkADQCABIAAoAgBPBEAgABDXASABSw0CCyAAKAIIIgANAAtBACEACyAAEOMBDQAgAEEMaigCABoMAAtBABAva0cNAUHIkMAAKAIAQdyQwAAoAgBNDQFB3JDAAEF/NgIADwsgAkGAAkkNASAAIAIQKEHkkMAAQeSQwAAoAgBBAWsiADYCACAADQAQLxoPCw8LIAJBeHFBtI7AAGohAQJ/QbyQwAAoAgAiA0EBIAJBA3Z0IgJxBEAgASgCCAwBC0G8kMAAIAIgA3I2AgAgAQshAyABIAA2AgggAyAANgIMIAAgATYCDCAAIAM2AggL+gQBC38jAEEwayICJAAgAkEDOgAoIAJCgICAgIAENwMgIAJBADYCGCACQQA2AhAgAkGMiMAANgIMIAIgADYCCAJ/AkACQCABKAIAIgpFBEAgAUEUaigCACIARQ0BIAEoAhAhAyAAQQN0IQUgAEEBa0H/////AXFBAWohByABKAIIIQADQCAAQQRqKAIAIgQEQCACKAIIIAAoAgAgBCACKAIMKAIMEQAADQQLIAMoAgAgAkEIaiADQQRqKAIAEQIADQMgA0EIaiEDIABBCGohACAFQQhrIgUNAAsMAQsgASgCBCIARQ0AIABBBXQhCyAAQQFrQf///z9xQQFqIQcgASgCCCEAA0AgAEEEaigCACIDBEAgAigCCCAAKAIAIAMgAigCDCgCDBEAAA0DCyACIAUgCmoiBEEcai0AADoAKCACIARBFGopAgA3AyAgBEEQaigCACEGIAEoAhAhCEEAIQlBACEDAkACQAJAIARBDGooAgBBAWsOAgACAQsgBkEDdCAIaiIMQQRqKAIAQRJHDQEgDCgCACgCACEGC0EBIQMLIAIgBjYCFCACIAM2AhAgBEEIaigCACEDAkACQAJAIARBBGooAgBBAWsOAgACAQsgA0EDdCAIaiIGQQRqKAIAQRJHDQEgBigCACgCACEDC0EBIQkLIAIgAzYCHCACIAk2AhggCCAEKAIAQQN0aiIDKAIAIAJBCGogAygCBBECAA0CIABBCGohACALIAVBIGoiBUcNAAsLIAFBDGooAgAgB0sEQCACKAIIIAEoAgggB0EDdGoiACgCACAAKAIEIAIoAgwoAgwRAAANAQtBAAwBC0EBCyACQTBqJAAL1QQBBH8gACABEOcBIQICQAJAAkAgABDiAQ0AIAAoAgAhAwJAIAAQ1QFFBEAgASADaiEBIAAgAxDoASIAQcyQwAAoAgBHDQEgAigCBEEDcUEDRw0CQcSQwAAgATYCACAAIAEgAhDGAQ8LIAEgA2pBEGohAAwCCyADQYACTwRAIAAQJwwBCyAAQQxqKAIAIgQgAEEIaigCACIFRwRAIAUgBDYCDCAEIAU2AggMAQtBvJDAAEG8kMAAKAIAQX4gA0EDdndxNgIACyACENIBBEAgACABIAIQxgEMAgsCQEHQkMAAKAIAIAJHBEAgAkHMkMAAKAIARw0BQcyQwAAgADYCAEHEkMAAQcSQwAAoAgAgAWoiATYCACAAIAEQzAEPC0HQkMAAIAA2AgBByJDAAEHIkMAAKAIAIAFqIgE2AgAgACABQQFyNgIEIABBzJDAACgCAEcNAUHEkMAAQQA2AgBBzJDAAEEANgIADwsgAhDhASIDIAFqIQECQCADQYACTwRAIAIQJwwBCyACQQxqKAIAIgQgAkEIaigCACICRwRAIAIgBDYCDCAEIAI2AggMAQtBvJDAAEG8kMAAKAIAQX4gA0EDdndxNgIACyAAIAEQzAEgAEHMkMAAKAIARw0BQcSQwAAgATYCAAsPCyABQYACTwRAIAAgARAoDwsgAUF4cUG0jsAAaiECAn9BvJDAACgCACIDQQEgAUEDdnQiAXEEQCACKAIIDAELQbyQwAAgASADcjYCACACCyEBIAIgADYCCCABIAA2AgwgACACNgIMIAAgATYCCAuRCAEBf0EBIQECQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABBAWsOiQRJAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHEdHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHHR4fICEiIyQlJicoKSorLC0uLzAxMjM0NTY3ODk6OzxHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHRz0+P0BBQkNERQALIABBgQZrDgJFR0YLQQIPC0EDDwtBBA8LQQUPC0EGDwtBBw8LQQgPC0EJDwtBCg8LQQsPC0EMDwtBDQ8LQQ4PC0EPDwtBEA8LQREPC0ESDwtBEw8LQRQPC0EVDwtBFg8LQRcPC0EYDwtBGQ8LQRoPC0EbDwtBHA8LQR0PC0GBAg8LQYICDwtBgwIPC0GEAg8LQYUCDwtBhgIPC0GHAg8LQYgCDwtBiQIPC0GKAg8LQYsCDwtBjAIPC0GNAg8LQY4CDwtBjwIPC0GQAg8LQZECDwtBkgIPC0GTAg8LQZQCDwtBlQIPC0GWAg8LQZcCDwtBmAIPC0GZAg8LQZoCDwtBmwIPC0GcAg8LQZ0CDwtBngIPC0GfAg8LQaACDwtBgQQPC0GCBA8LQYMEDwtBhAQPC0GFBA8LQYYEDwtBhwQPC0GIBA8LQYkEDwtBgQYPC0HwhsAAQRkQ3gEAC0GCBiEBCyABC48DAQV/AkACQAJAAkAgAUEJTwRAQRBBCBDNASABSw0BDAILIAAQASEEDAILQRBBCBDNASEBC0EIQQgQzQEhA0EUQQgQzQEhAkEQQQgQzQEhBUEAQRBBCBDNAUECdGsiBkGAgHwgBSACIANqamtBd3FBA2siAyADIAZLGyABayAATQ0AIAFBECAAQQRqQRBBCBDNAUEFayAASxtBCBDNASIDakEQQQgQzQFqQQRrEAEiAkUNACACEOoBIQACQCABQQFrIgQgAnFFBEAgACEBDAELIAIgBGpBACABa3EQ6gEhAkEQQQgQzQEhBCAAEOEBIAIgAUEAIAIgAGsgBE0baiIBIABrIgJrIQQgABDVAUUEQCABIAQQsAEgACACELABIAAgAhAEDAELIAAoAgAhACABIAQ2AgQgASAAIAJqNgIACyABENUBDQEgARDhASICQRBBCBDNASADak0NASABIAMQ5wEhACABIAMQsAEgACACIANrIgMQsAEgACADEAQMAQsgBA8LIAEQ6QEgARDVARoLEAAgACABIAIgA0HTABD2AQsQACAAIAEgAiADQdQAEPYBCxAAIAAgASACIANB3gAQ9gELEAAgACABIAIgA0HfABD2AQsQACAAIAEgAiADQeAAEPYBCxAAIAAgASACIANB4QAQ9gELEAAgACABIAIgA0HiABD2AQsQACAAIAEgAiADQeMAEPYBCxAAIAAgASACIANB5AAQ9gELEAAgACABIAIgA0HlABD2AQuQBAEFfyMAQRBrIgMkACAAKAIAIQACQCABQf8ATQRAIAAoAggiAiAAKAIARgRAIwBBIGsiBCQAAkACQCACQQFqIgJFDQBBCCAAKAIAIgVBAXQiBiACIAIgBkkbIgIgAkEITRsiAkF/c0EfdiEGAkAgBQRAIARBATYCGCAEIAU2AhQgBCAAQQRqKAIANgIQDAELIARBADYCGAsgBCACIAYgBEEQahB4IAQoAgQhBSAEKAIARQRAIAAgAjYCACAAIAU2AgQMAgsgBEEIaigCACICQYGAgIB4Rg0BIAJFDQAgBSACEOUBAAsQogEACyAEQSBqJAAgACgCCCECCyAAIAJBAWo2AgggACgCBCACaiABOgAADAELIANBADYCDAJ/IAFBgBBPBEAgAUGAgARPBEAgAyABQT9xQYABcjoADyADIAFBBnZBP3FBgAFyOgAOIAMgAUEMdkE/cUGAAXI6AA0gAyABQRJ2QQdxQfABcjoADEEEDAILIAMgAUE/cUGAAXI6AA4gAyABQQx2QeABcjoADCADIAFBBnZBP3FBgAFyOgANQQMMAQsgAyABQT9xQYABcjoADSADIAFBBnZBwAFyOgAMQQILIQEgASAAKAIAIAAoAggiAmtLBEAgACACIAEQdCAAKAIIIQILIAAoAgQgAmogA0EMaiABEOYBGiAAIAEgAmo2AggLIANBEGokAEEAC9oGAgx/AX4jAEEwayIFJABBJyEDAkAgAEKQzgBUBEAgACEODAELA0AgBUEJaiADaiICQQRrIAAgAEKQzgCAIg5CkM4Afn2nIgRB//8DcUHkAG4iBkEBdEGgi8AAai8AADsAACACQQJrIAQgBkHkAGxrQf//A3FBAXRBoIvAAGovAAA7AAAgA0EEayEDIABC/8HXL1YgDiEADQALCyAOpyICQeMASwRAIANBAmsiAyAFQQlqaiAOpyICIAJB//8DcUHkAG4iAkHkAGxrQf//A3FBAXRBoIvAAGovAAA7AAALAkAgAkEKTwRAIANBAmsiAyAFQQlqaiACQQF0QaCLwABqLwAAOwAADAELIANBAWsiAyAFQQlqaiACQTBqOgAACwJ/IAVBCWogA2ohCUErQYCAxAAgASICKAIYIgFBAXEiBBshBiAEQScgA2siCmohA0GIi8AAQQAgAUEEcRshCAJAAkAgAigCCEUEQEEBIQEgAigCACIEIAJBBGooAgAiAiAGIAgQpwENAQwCCwJAAkACQAJAIAMgAkEMaigCACIESQRAIAFBCHENBCAEIANrIgMhBEEBIAItACAiASABQQNGG0EDcSIBQQFrDgIBAgMLQQEhASACKAIAIgQgAkEEaigCACICIAYgCBCnAQ0EDAULQQAhBCADIQEMAQsgA0EBdiEBIANBAWpBAXYhBAsgAUEBaiEBIAJBBGooAgAhAyACKAIcIQcgAigCACECAkADQCABQQFrIgFFDQEgAiAHIAMoAhARAgBFDQALQQEMBAtBASEBIAdBgIDEAEYNASACIAMgBiAIEKcBDQEgAiAJIAogAygCDBEAAA0BQQAhAQJ/A0AgBCABIARGDQEaIAFBAWohASACIAcgAygCEBECAEUNAAsgAUEBawsgBEkhAQwBCyACKAIcIQwgAkEwNgIcIAItACAhDUEBIQEgAkEBOgAgIAIoAgAiByACQQRqKAIAIgsgBiAIEKcBDQAgBCADa0EBaiEBAkADQCABQQFrIgFFDQEgB0EwIAsoAhARAgBFDQALQQEMAwtBASEBIAcgCSAKIAsoAgwRAAANACACIA06ACAgAiAMNgIcQQAMAgsgAQwBCyAEIAkgCiACKAIMEQAACyAFQTBqJAALDQAgACABIAJBORDzAQsNACAAIAEgAkE6EPMBCw0AIAAgASACQTsQ8wELDQAgACABIAJBPBDzAQsNACAAIAEgAkE9EPMBCw0AIAAgASACQT4Q8wELDQAgACABIAJBPxDzAQsOACAAIAEgAkHAABDzAQsOACAAIAEgAkHBABDzAQsOACAAIAEgAkHCABDzAQsOACAAIAEgAkHDABDzAQsOACAAIAEgAkHEABDzAQsOACAAIAEgAkHFABDzAQsOACAAIAEgAkHGABDzAQsOACAAIAEgAkHHABDzAQsOACAAIAEgAkHIABDzAQsOACAAIAEgAkHJABDzAQsOACAAIAEgAkHKABDzAQsOACAAIAEgAkHRABDzAQsOACAAIAEgAkHSABDzAQu8AgEFfyAAKAIYIQMCQAJAIAAgACgCDEYEQCAAQRRBECAAQRRqIgEoAgAiBBtqKAIAIgINAUEAIQEMAgsgACgCCCICIAAoAgwiATYCDCABIAI2AggMAQsgASAAQRBqIAQbIQQDQCAEIQUgAiIBQRRqIgIgAUEQaiACKAIAIgIbIQQgAUEUQRAgAhtqKAIAIgINAAsgBUEANgIACwJAIANFDQACQCAAIAAoAhxBAnRBpI3AAGoiAigCAEcEQCADQRBBFCADKAIQIABGG2ogATYCACABRQ0CDAELIAIgATYCACABDQBBwJDAAEHAkMAAKAIAQX4gACgCHHdxNgIADwsgASADNgIYIAAoAhAiAgRAIAEgAjYCECACIAE2AhgLIABBFGooAgAiAEUNACABQRRqIAA2AgAgACABNgIYCwuuAgEEfyAAQgA3AhAgAAJ/QQAgAUGAAkkNABpBHyABQf///wdLDQAaIAFBBiABQQh2ZyICa3ZBAXEgAkEBdGtBPmoLIgI2AhwgAkECdEGkjcAAaiEEIAAhAwJAAkACQAJAQcCQwAAoAgAiAEEBIAJ0IgVxBEAgBCgCACEAIAIQywEhAiAAEOEBIAFHDQEgACECDAILQcCQwAAgACAFcjYCACAEIAM2AgAgAyAENgIYDAMLIAEgAnQhBANAIAAgBEEddkEEcWpBEGoiBSgCACICRQ0CIARBAXQhBCACIgAQ4QEgAUcNAAsLIAIoAggiACADNgIMIAIgAzYCCCADIAI2AgwgAyAANgIIIANBADYCGA8LIAUgAzYCACADIAA2AhgLIAMgAzYCCCADIAM2AgwLEAAgACABIAIgA0HeABD8AQsQACAAIAEgAiADQd8AEPwBCxAAIAAgASACIANB4AAQ/AELEAAgACABIAIgA0HhABD8AQsQACAAIAEgAiADQeIAEP4BCxAAIAAgASACIANB4wAQ/gELYAEMf0GsjsAAKAIAIgIEQEGkjsAAIQYDQCACIgEoAgghAiABKAIEIQMgASgCACEEIAFBDGooAgAaIAEhBiAFQQFqIQUgAg0ACwtB5JDAAEH/HyAFIAVB/x9NGzYCAEEACxAAIAAgASACIANB5AAQ/QELEAAgACABIAIgA0HlABD9AQsMACAAIAFBywAQ9wELDAAgACABQcwAEPcBCwwAIAAgAUHNABD3AQsMACAAIAFBzgAQ9wELDAAgACABQc8AEPcBCwwAIAAgAUHQABD3AQv7AQIBfgJ/AkACQAJAIABFDQAgACgCAA0BIAAtAAQhBSAAEAIgAUUNACABKAIADQEgAS0ABCEGIAEQAiACRQ0AIAIoAgANASACLQAEIQEgAhACIANFDQAgAygCAA0BIANBADYCACADKQIAIQQgAxACQQhBBBDQASIARQ0CIAAgBkEMdCAFQRJ0ciABQQZ0ciICIARCIIinIARCI4inQSBxckH/AXFyIgFBGHQgAkEIdEGAgPwHcXIgAUEIdkGA/gNxIAFBGHZyciIBQQh2QYCA/AdxIAFBgP7/B3FBCHZyrUIghjcCACAADwsQ3wEACxDgAQALQQhBBBDlAQAL+gECAX4CfwJAAkACQCAARQ0AIAAoAgANASAALQAEIQUgABACIAFFDQAgASgCAA0BIAEtAAQhBiABEAIgAkUNACACKAIADQEgAi0ABCEBIAIQAiADRQ0AIAMoAgANASADQQA2AgAgAykCACEEIAMQAkEIQQQQ0AEiAEUNAiAAIARCI4inQSBxIAZBDHQgBUESdHIgAUEGdHIiAiAEQhyIp0EQcXJyIgFBGHQgAkEIdEGAgPwHcXIgAUEIdkGA/gNxIAFBGHZyciIBQQh2QYCA/AdxIAFBgP7/B3FBCHZyrUIghjcCACAADwsQ3wEACxDgAQALQQhBBBDlAQALDwAgACABIAIgA0ESEPgBCw8AIAAgASACIANBGBD4AQsPACAAIAEgAiADQRwQ+AELDwAgACABIAIgA0EdEPgBCw8AIAAgASACIANBIhD4AQsPACAAIAEgAiADQSMQ+AELDwAgACABIAIgA0EoEPgBCw8AIAAgASACIANBKhD4AQsPACAAIAEgAiADQSwQ+AELDwAgACABIAIgA0E4EPgBCxAAIAAgASACIANB5gAQ+AELEAAgACABIAIgA0HnABD4AQsQACAAIAEgAiADQegAEPgBCxAAIAAgASACIANB6QAQ+AELEAAgACABIAIgA0HqABD4AQsQACAAIAEgAiADQesAEPgBC4YCAgN/AX4jAEEwayICJAAgASgCBEUEQCABKAIMIQMgAkEQaiIEQQA2AgAgAkKAgICAEDcDCCACIAJBCGo2AhQgAkEoaiADQRBqKQIANwMAIAJBIGogA0EIaikCADcDACACIAMpAgA3AxggAkEUaiACQRhqEAMaIAFBCGogBCgCADYCACABIAIpAwg3AgALIAEpAgAhBSABQoCAgIAQNwIAIAJBIGoiAyABQQhqIgEoAgA2AgAgAUEANgIAIAIgBTcDGEEMQQQQ0AEiAUUEQEEMQQQQ5QEACyABIAIpAxg3AgAgAUEIaiADKAIANgIAIABB6InAADYCBCAAIAE2AgAgAkEwaiQAC+YBAQJ/AkACQAJAIABFDQAgACgCAA0BIAAtAAQhBCAAEAIgAUUNACABKAIADQEgAS0ABCEFIAEQAiACRQ0AIAIoAgANASACLQAEIQEgAhACIANFDQAgAygCAA0BIAMtAAQhAiADEAJBCEEEENABIgBFDQIgACAFQQx0IARBEnRyIAFBBnRyIgMgAkEFdEEgcXIiAUEYdCADQQh0QYCA/AdxciABQQh2QYD+A3EgAUEYdnJyIgFBCHZBgICAB3EgAUGA/v8HcUEIdnKtQiCGNwIAIAAPCxDfAQALEOABAAtBCEEEEOUBAAvgAQECfwJAAkACQCAARQ0AIAAoAgANASAALQAEIQQgABACIAFFDQAgASgCAA0BIAEtAAQhBSABEAIgAkUNACACKAIADQEgAi0ABCEBIAIQAiADRQ0AIAMoAgANASADLQAEIQIgAxACQQhBBBDQASIARQ0CIAAgAiAFQQx0IARBEnRyIAFBBnRyIgNyIgFBGHQgA0EIdEGAgPwHcXIgAUEIdkGA/gNxIAFBGHZyciIBQQh2QYCA/AdxIAFBgP7/B3FBCHZyrUIghjcCACAADwsQ3wEACxDgAQALQQhBBBDlAQALCgAgAEHVABD1AQsKACAAQdYAEPUBCwoAIABB1wAQ9QELCgAgAEHaABD1AQsKACAAQdsAEPUBCwoAIABB3AAQ9QELCgAgAEHdABD1AQsNACAAIAEgAkEBEPQBCw0AIAAgASACQQIQ9AELDQAgACABIAJBAxD0AQsNACAAIAEgAkEEEPQBCw0AIAAgASACQQUQ9AELDQAgACABIAJBBhD0AQsNACAAIAEgAkEHEPQBCw0AIAAgASACQQgQ9AELDQAgACABIAJBCRD0AQsNACAAIAEgAkELEPQBCw0AIAAgASACQQ0Q9AELDQAgACABIAJBDhD0AQsNACAAIAEgAkEPEPQBCw0AIAAgASACQRAQ9AELDQAgACABIAJBERD0AQsNACAAIAEgAkEXEPQBCw0AIAAgASACQSEQ9AELDQAgACABIAJBJhD0AQsNACAAIAEgAkEnEPQBCw0AIAAgASACQSkQ9AELDQAgACABIAJBKxD0AQsNACAAIAEgAkEtEPQBCw0AIAAgASACQS4Q9AELDQAgACABIAJBLxD0AQsNACAAIAEgAkEwEPQBCw0AIAAgASACQTEQ9AELDQAgACABIAJBNRD0AQsNACAAIAEgAkE3EPQBC8cBAQF/AkACQAJAIABBwAFxRQRAIAFBwAFxIAJBwAFxcg0DQQRBARDQASIDRQ0BIAMgAkEGdEHA/wBxIAFBDHRBgOA/cSAAQRJ0QYCA8B9xcnIiAEEIdEGAgPwHcSACQR50ciAAQQh2QYD+A3EgAEEYdnJyIgBBCHZBgICABnEgAEGA/v8HcUEIdnJBCHQ2AABBCEEEENABIgBFDQIgACADNgIEIABBADYCACAADwsMAgtBBEEBEOUBAAtBCEEEEOUBAAsQ3AEAC8QBAQJ/AkACQAJAIABFDQAgACgCAA0BIAAtAAQhAyAAEAIgAUUNACABKAIADQEgAS0ABCEEIAEQAiACRQ0AIAIoAgANASACLQAEIQAgAhACQQhBBBDQASIBRQ0CIAEgBEEMdCADQRJ0ciAAQQZ0ciICQQh0QYCA/AdxIABBHnRyIAJBCHZBgP4DcSACQRh2cnIiAEEIdkGAgIAGcSAAQYD+/wdxQQh2cq1CIIY3AgAgAQ8LEN8BAAsQ4AEAC0EIQQQQ5QEAC8kBAQF/IAIQBSECAkACQAJAIABBwAFxRQRAIAFBwAFxDQFBBEEBENABIgNFDQIgAyACQf//A3EgAUEMdEGA4D9xIABBEnRBgIDwH3FyciIAQQh0QYCA/AdxIAJBGHRyIABBCHZBgP4DcSAAQRh2cnIiAEEIdkGAgPwHcSAAQYD+/wdxQQh2ckEIdEHKAHI2AABBCEEEENABIgBFDQMgACADNgIEIABBADYCACAADwsQ3AEACxDcAQALQQRBARDlAQALQQhBBBDlAQALwQEBAn8CQAJAAkAgAEUNACAAKAIADQEgAC0ABCEDIAAQAiABRQ0AIAEoAgANASABLQAEIQQgARACIAJFDQAgAigCAA0BIAIvAQQhACACEAJBCEEEENABIgFFDQIgASAEQQx0IANBEnRyIAByIgJBCHRBgID8B3EgAEEYdHIgAkEIdkGA/gNxIAJBGHZyciIAQQh2QYCA/AdxIABBgP7/B3FBCHZyrUIghjcCACABDwsQ3wEACxDgAQALQQhBBBDlAQALywEBAn8jAEEgayIDJAACQAJAIAEgASACaiIBSw0AQQggACgCACICQQF0IgQgASABIARJGyIBIAFBCE0bIgFBf3NBH3YhBAJAIAIEQCADQQE2AhggAyACNgIUIAMgAEEEaigCADYCEAwBCyADQQA2AhgLIAMgASAEIANBEGoQeCADKAIEIQIgAygCAEUEQCAAIAE2AgAgACACNgIEDAILIANBCGooAgAiAEGBgICAeEYNASAARQ0AIAIgABDlAQALEKIBAAsgA0EgaiQAC4gCAQJ/IwBBIGsiBSQAQaCNwABBoI3AACgCACIGQQFqNgIAAkACQCAGQQBIDQBB6JDAAEHokMAAKAIAQQFqIgY2AgAgBkECSw0AIAUgBDoAGCAFIAM2AhQgBSACNgIQIAVBsIrAADYCDCAFQaSIwAA2AghBkI3AACgCACICQQBIDQBBkI3AACACQQFqIgI2AgBBkI3AAEGYjcAAKAIABH8gBSAAIAEoAhARBAAgBSAFKQMANwMIQZiNwAAoAgAgBUEIakGcjcAAKAIAKAIUEQQAQZCNwAAoAgAFIAILQQFrNgIAIAZBAUsNACAEDQELAAsjAEEQayICJAAgAiABNgIMIAIgADYCCAALtQEBAX8CQAJAAkAgAEUNACAAKAIADQEgAC0ABCEDIAAQAiABRQ0AIAEoAgANASABLQAEIQAgARACIAIQBSECQQhBBBDQASIBRQ0CIAEgAkH//wNxIABBDHQgA0ESdHJyIgBBCHRBgID8B3EgAkEYdHIgAEEIdkGA/gNxIABBGHZyciIAQQh2QYCA/AdxIABBgP7/B3FBCHZyrUIghjcCACABDwsQ3wEACxDgAQALQQhBBBDlAQALuwEBAX8CQAJAAkAgAUEBa0EESQRAIABBwAFxDQFBBEEBENABIgJFDQIgAiABQQh0QYCA/AdxIAFBGHRyIABBEnRBgIDwH3EgAXIiAEEIdkGA/gNxIABBGHZyciIAQQh2QYCA/AdxIABBgP7/B3FBCHZyQQh0QcwAcjYAAEEIQQQQ0AEiAEUNAyAAIAI2AgQgAEEANgIAIAAPC0HwhsAAQRkQ3gEACxDcAQALQQRBARDlAQALQQhBBBDlAQALowcBCX8CQCACBEACfwJAAkACQCABQQBOBEAgAygCCEUNAiADKAIEIgYNASABDQMgAgwECyAAQQhqQQA2AgAMBQsCfyADKAIAIQkCQAJAAkAgAkEJTwRAIAEgAhAGIgsNAUEADAQLQQhBCBDNASEKQRRBCBDNASEHQRBBCBDNASEDQQBBEEEIEM0BQQJ0ayIGQYCAfCADIAcgCmpqa0F3cUEDayIDIAMgBksbIAFNDQFBECABQQRqQRBBCBDNAUEFayABSxtBCBDNASEEIAkQ6gEiBSAFEOEBIgMQ5wEhCAJAAkACQAJAAkACQAJAIAUQ1QFFBEAgAyAETw0BIAhB0JDAACgCAEYNAiAIQcyQwAAoAgBGDQMgCBDSAQ0HIAgQ4QEiCiADaiIHIARJDQcgByAEayEMIApBgAJJDQQgCBAnDAULIAUQ4QEhAyAEQYACSQ0GIAMgBGtBgYAISSAEQQRqIANNcQ0FIAUoAgAaIARBH2pBgIAEEM0BGgwGC0EQQQgQzQEgAyAEayIGSw0EIAUgBBDnASEDIAUgBBCwASADIAYQsAEgAyAGEAQMBAtByJDAACgCACADaiIDIARNDQQgBSAEEOcBIQYgBSAEELABIAYgAyAEayIDQQFyNgIEQciQwAAgAzYCAEHQkMAAIAY2AgAMAwtBxJDAACgCACADaiIDIARJDQMCQEEQQQgQzQEgAyAEayIHSwRAIAUgAxCwAUEAIQdBACEGDAELIAUgBBDnASIGIAcQ5wEhAyAFIAQQsAEgBiAHEMwBIAMgAygCBEF+cTYCBAtBzJDAACAGNgIAQcSQwAAgBzYCAAwCCyAIQQxqKAIAIgYgCEEIaigCACIDRwRAIAMgBjYCDCAGIAM2AggMAQtBvJDAAEG8kMAAKAIAQX4gCkEDdndxNgIAC0EQQQgQzQEgDE0EQCAFIAQQ5wEhAyAFIAQQsAEgAyAMELABIAMgDBAEDAELIAUgBxCwAQsgBQ0DCyABEAEiA0UNASADIAkgBRDhAUF4QXwgBRDVARtqIgMgASABIANLGxDmASAJEAIMAwsgCyAJIAYgASABIAZLGxDmARogCRACCyALDAELIAUQ1QEaIAUQ6QELDAILIAENACACDAELIAEgAhDQAQsiAwRAIAAgAzYCBCAAQQhqIAE2AgAgAEEANgIADwsgACABNgIEIABBCGogAjYCAAwBCyAAIAE2AgQgAEEIakEANgIACyAAQQE2AgALpAEBAX8CQAJAAkAgAEUNACAAKAIADQEgAC0ABCECIAAQAiABRQ0AIAEoAgANASABKAIEIQAgARACQQhBBBDQASIBRQ0CIAEgAEEIdEGAgPwHcSAAQRh0ciAAIAJBEnRyIgBBCHZBgP4DcSAAQRh2cnIiAEEIdkGAgPwHcSAAQYD+/wdxQQh2cq1CIIY3AgAgAQ8LEN8BAAsQ4AEAC0EIQQQQ5QEAC6IBAQF/AkACQAJAIAAEQCAAKAIADQEgAC0ABCECIAAQAiABQQFrQQRPDQJBCEEEENABIgBFDQMgACABQQh0QYCA/AdxIAFBGHRyIAJBEnQgAXIiAUEIdkGA/gNxIAFBGHZyciIBQQh2QYCA/AdxIAFBgP7/B3FBCHZyrUIghjcCACAADwsQ3wEACxDgAQALQfCGwABBGRDeAQALQQhBBBDlAQALpAEBA38jAEEwayICJAAgASgCBEUEQCABKAIMIQMgAkEQaiIEQQA2AgAgAkKAgICAEDcDCCACIAJBCGo2AhQgAkEoaiADQRBqKQIANwMAIAJBIGogA0EIaikCADcDACACIAMpAgA3AxggAkEUaiACQRhqEAMaIAFBCGogBCgCADYCACABIAIpAwg3AgALIABB6InAADYCBCAAIAE2AgAgAkEwaiQACwsAIAAgAUEKEPkBCwsAIAAgAUEMEPkBCwsAIAAgAUEUEPkBCwsAIAAgAUEWEPkBCwsAIAAgAUEZEPkBCwsAIAAgAUEbEPkBCwsAIAAgAUEeEPkBCwsAIAAgAUEfEPkBCwsAIAAgAUEkEPkBCwsAIAAgAUEyEPkBC4IBAQJ/AkACQCAABEAgACgCAA0BIAAtAAQhASAAEAJBACEAAkAgAUEYcQ0AQfcBIAFBBHNBB3EiAnZBAXFFDQBBCEEEENABIgBFDQMgACACQQN0QbCGwABqKQMAIAFBBXZBAXGtQiiGhDcCAAsgAA8LEN8BAAsQ4AEAC0EIQQQQ5QEAC4ABAQF/AkACQAJAIABFDQAgACgCAA0BIAAtAAQhAiAAEAIgAUUNACABKAIADQEgAS0ABCEAIAEQAkEIQQQQ0AEiAUUNAiABIABBFHQgAEEMdCACQRJ0ckEIdnJBgP7DB3FBCHatQiCGNwIAIAEPCxDfAQALEOABAAtBCEEEEOUBAAuCAQEBfwJAAkAgAARAIAAoAgANASAAKAIEIQEgABACQQhBBBDQASIARQ0CIAAgAUEIdEGAgPwHcSABQRh0ciABQQh2QYD+A3EgAUEYdnJyIgFBCHZBgID8B3EgAUGA/v8HcUEIdnKtQiCGNwIAIAAPCxDfAQALEOABAAtBCEEEEOUBAAuCAQECfwJAAkAgAARAIAAoAgBBf0YNASAAQQZqLQAAIQEgAC8ABCECQQhBBBDQASIARQ0CIABBADYCACAAIAIgAUEQdHIiAUEQdEGAgAxxIAFBCHRBgIZ8cSIBQQh2QYD+A3EgAUEYdnJyNgIEIAAPCxDfAQALEOABAAtBCEEEEOUBAAt8AQJ/AkACQCAABEAgACgCAEF/Rg0BIABBBmotAAAhASAALwAEIQJBCEEEENABIgBFDQIgAEEANgIAIAAgAiABQRB0ciIBQRh0IAFBCHRBgID8B3FyIAFBCHZBgP4DcXJBCHY2AgQgAA8LEN8BAAsQ4AEAC0EIQQQQ5QEAC3QBAn8CQAJAIAAEQCAAKAIAQX9GDQEgAEEGai0AACEBIAAvAAQhAkEIQQQQ0AEiAEUNAiAAQQA2AgAgACACIAFBEHRyIgFBGHQgAUEIdEGAgMAHcXJBFHZBP3E6AAQgAA8LEN8BAAsQ4AEAC0EIQQQQ5QEAC3QBAn8CQAJAIAAEQCAAKAIAQX9GDQEgAEEGai0AACEBIAAvAAQhAkEIQQQQ0AEiAEUNAiAAQQA2AgAgACACIAFBEHRyQQh0QYCAvHhxIgFBCHYgAUEYdnJBBnY6AAQgAA8LEN8BAAsQ4AEAC0EIQQQQ5QEAC3EBAn8CQAJAIAAEQCAAKAIAQX9GDQEgAEEGai0AACEBIAAvAAQhAkEIQQQQ0AEiAEUNAiAAQQA2AgAgACACIAFBEHRyQQh0QYCAvHhxIgFBCHYgAUEYdnI7AQQgAA8LEN8BAAsQ4AEAC0EIQQQQ5QEAC4YBAQJ/AkACQCABBEAgASgCACICQX9GDQEgASACQQFqNgIAIAEoAgQoAAAiAkEYdEEWdUHggsAAaigCACACQYB+cXIhA0EEQQEQ0AEiAkUNAiACIAM2AAAgASABKAIAQQFrNgIAIABBBDYCBCAAIAI2AgAPCxDfAQALEOABAAtBBEEBEOUBAAtyACMAQTBrIgEkAEHojMAALQAABEAgAUEUakECNgIAIAFBHGpBATYCACABQfSIwAA2AhAgAUEANgIIIAFBAjYCJCABIAA2AiwgASABQSBqNgIYIAEgAUEsajYCICABQQhqQZyJwAAQqAEACyABQTBqJAALYwEBfgJAAkAgAARAIAAoAgANASAAQQA2AgAgACkCACEBIAAQAkEIQQQQ0AEiAEUNAiAAQQA2AgAgACABQiCIpyABQiOIp0EgcXI6AAQgAA8LEN8BAAsQ4AEAC0EIQQQQ5QEACwkAIABBAhDyAQsJACAAQRMQ+wELCQAgAEEVEPsBCwkAIABBGhD7AQsJACAAQRAQ8gELCQAgAEEgEPsBCwkAIABBJRD7AQsJACAAQTQQ+wELCQAgAEE2EPsBCwoAIABB2AAQ+wELCgAgAEHZABD7AQtUAQF/IwBBIGsiAiQAIAIgACgCADYCBCACQRhqIAFBEGopAgA3AwAgAkEQaiABQQhqKQIANwMAIAIgASkCADcDCCACQQRqIAJBCGoQAyACQSBqJAALUgEBfwJAAkAgAARAIAAoAgANASAALQAEIQEgABACQQhBBBDQASIARQ0CIAAgAUECdEH8AXGtQiCGNwIAIAAPCxDfAQALEOABAAtBCEEEEOUBAAtVAQF/IwBBIGsiASQAIAFBDGpBATYCACABQRRqQQA2AgAgAUGIi8AANgIQIAFBADYCACABQSs2AhwgAUGkiMAANgIYIAEgAUEYajYCCCABIAAQqAEAC0cBAn8CQEEEQQEQ0AEiAQRAIAFBMzYAAEEIQQQQ0AEiAEUNASAAIAE2AgQgAEEANgIAIAAPC0EEQQEQ5QEAC0EIQQQQ5QEAC0cBAX8gAiAAKAIAIgAoAgAgACgCCCIDa0sEQCAAIAMgAhB0IAAoAgghAwsgACgCBCADaiABIAIQ5gEaIAAgAiADajYCCEEAC0YBAX8CQCAAQSZJBEBBDEEEENABIgJFDQEgAiAAOgAIIAIgATYCBCACQQA2AgAgAg8LQYmHwABBGRDeAQALQQxBBBDlAQALSgEBfyMAQSBrIgAkACAAQRRqQQE2AgAgAEEcakEANgIAIABB8IrAADYCECAAQcCKwAA2AhggAEEANgIIIABBCGpB+IrAABCoAQALOAEBfwJAIABB/wFxQT9NBEBBCEEEENABIgFFDQEgASAAOgAEIAFBADYCAAsgAQ8LQQhBBBDlAQALCwAgACABQQcQ8QELCwAgACABQQgQ8QELRgECfyABKAIEIQIgASgCACEDQQhBBBDQASIBRQRAQQhBBBDlAQALIAEgAjYCBCABIAM2AgAgAEH4icAANgIEIAAgATYCAAs5AAJAAn8gAkGAgMQARwRAQQEgACACIAEoAhARAgANARoLIAMNAUEACw8LIAAgA0EAIAEoAgwRAAALsQIBAn8jAEEgayICJAAgAkEBOgAYIAIgATYCFCACIAA2AhAgAkGQi8AANgIMIAJBiIvAADYCCCMAQRBrIgAkAAJAIAJBCGoiASgCDCICBEAgASgCCCIDRQ0BIAAgAjYCCCAAIAE2AgQgACADNgIAIwBBEGsiASQAIAAoAgAiAkEUaigCACEDAkACfwJAAkAgAkEMaigCAA4CAAEDCyADDQJBACECQaSIwAAMAQsgAw0BIAIoAggiAygCBCECIAMoAgALIQMgASACNgIEIAEgAzYCACABQZyKwAAgACgCBCIBKAIIIAAoAgggAS0AEBB1AAsgAUEANgIEIAEgAjYCDCABQYiKwAAgACgCBCIBKAIIIAAoAgggAS0AEBB1AAtB2InAABCeAQALQciJwAAQngEACycBAX8CQCAABEAgACgCAA0BIAAoAgQgABACEAIPCxDfAQALEOABAAsuAAJAIAAEQCAAKAIADQEgAEEANgIAIABBBWogAUEARzoAAA8LEN8BAAsQ4AEACyUBAX8CQCAABEAgACgCAA0BIAAtAAQgABACDwsQ3wEACxDgAQALKwACQCAABEAgACgCAA0BIABBADYCACAAIAFBAEc6AAQPCxDfAQALEOABAAssAQF/QQhBBBDQASIBRQRAQQhBBBDlAQALIAFBADYCACABIABBP3E6AAQgAQsJACAAQQUQ8AELCQAgAEEIEPABCycAIAAgACgCBEEBcSABckECcjYCBCAAIAFqIgAgACgCBEEBcjYCBAseAAJAIAAEQCAAKAIADQEgABACDwsQ3wEACxDgAQALBwBBCxD6AQsHAEEKEPoBCwcAQQgQ+gELBwBBDxD6AQsHAEEGEPoBCwcAQQkQ+gELBwBBBxD6AQsHAEEMEPoBCwcAQQIQ+gELBwBBARD6AQsHAEEDEPoBCwcAQQ0Q+gELBwBBDhD6AQsHAEEFEPoBCwcAQQQQ+gELBwBBEBD6AQsHAEEAEPoBCyIAAkAgAARAIAAoAgBBf0YNASAALQAEDwsQ3wEACxDgAQALIgACQCAABEAgACgCAEF/Rg0BIAAoAgQPCxDfAQALEOABAAsgAQF/AkAgAEEEaigCACIBRQ0AIAAoAgBFDQAgARACCwsjACACIAIoAgRBfnE2AgQgACABQQFyNgIEIAAgAWogATYCAAsiAQF/QQhBBBDQASIARQRAQQhBBBDlAQALIABCADcCACAACx4AIAAgAUEDcjYCBCAAIAFqIgAgACgCBEEBcjYCBAsUACAAKAIABEAgAEEEaigCABACCwsZAQF/IAAoAhAiAQR/IAEFIABBFGooAgALCxIAQRkgAEEBdmtBACAAQR9HGwsWACAAIAFBAXI2AgQgACABaiABNgIACxAAIAAgAWpBAWtBACABa3ELCwAgAQRAIAAQAgsLDwAgAEEBdCIAQQAgAGtyCwgAIAAgARAGCxMAIABB+InAADYCBCAAIAE2AgALDQAgAC0ABEECcUEBdguHDwENfwJ/IAAoAgAhCSAAKAIEIQUCQAJAIAEiBigCCCIKQQFHIAEoAhAiAEEBR3FFBEACQCAAQQFHDQAgBSAJaiEHIAZBFGooAgBBAWohAyAJIQEDQAJAIAEhACADQQFrIgNFDQAgACAHRg0CAn8gACwAACIBQQBOBEAgAUH/AXEhAiAAQQFqDAELIAAtAAFBP3EhCCABQR9xIQIgAUFfTQRAIAJBBnQgCHIhAiAAQQJqDAELIAAtAAJBP3EgCEEGdHIhCCABQXBJBEAgCCACQQx0ciECIABBA2oMAQsgAkESdEGAgPAAcSAALQADQT9xIAhBBnRyciICQYCAxABGDQMgAEEEagsiASAEIABraiEEIAJBgIDEAEcNAQwCCwsgACAHRg0AIAAsAAAiAUEATiABQWBJciABQXBJckUEQCABQf8BcUESdEGAgPAAcSAALQADQT9xIAAtAAJBP3FBBnQgAC0AAUE/cUEMdHJyckGAgMQARg0BCwJAAkAgBEUNACAEIAVPBEBBACEAIAQgBUYNAQwCC0EAIQAgBCAJaiwAAEFASA0BCyAJIQALIAQgBSAAGyEFIAAgCSAAGyEJCyAKRQ0CIAZBDGooAgAhDAJAIAVBEE8EQAJ/QQAhAkEAIQQCQAJAIAkiAEEDakF8cSIBIABrIgcgBUsgB0EES3INACAFIAdrIgpBBEkNACAKQQNxIQtBACEDAkAgACABRg0AIAdBA3EhAgJAIAEgAEF/c2pBA0kEQCAAIQEMAQsgB0F8cSEIIAAhAQNAIAMgASwAAEG/f0pqIAEsAAFBv39KaiABLAACQb9/SmogASwAA0G/f0pqIQMgAUEEaiEBIAhBBGsiCA0ACwsgAkUNAANAIAMgASwAAEG/f0pqIQMgAUEBaiEBIAJBAWsiAg0ACwsgACAHaiEAAkAgC0UNACAAIApBfHFqIgEsAABBv39KIQQgC0EBRg0AIAQgASwAAUG/f0pqIQQgC0ECRg0AIAQgASwAAkG/f0pqIQQLIApBAnYhByADIARqIQIDQCAAIQMgB0UNAkHAASAHIAdBwAFPGyIEQQNxIQggBEECdCELAkAgBEH8AXEiCkUEQEEAIQEMAQsgAyAKQQJ0aiENQQAhAQNAIABFDQEgASAAKAIAIg5Bf3NBB3YgDkEGdnJBgYKECHFqIABBBGooAgAiAUF/c0EHdiABQQZ2ckGBgoQIcWogAEEIaigCACIBQX9zQQd2IAFBBnZyQYGChAhxaiAAQQxqKAIAIgFBf3NBB3YgAUEGdnJBgYKECHFqIQEgAEEQaiIAIA1HDQALCyAHIARrIQcgAyALaiEAIAFBCHZB/4H8B3EgAUH/gfwHcWpBgYAEbEEQdiACaiECIAhFDQALAkAgA0UEQEEAIQEMAQsgAyAKQQJ0aiEAIAhBAWtB/////wNxIgFBAWoiBEEDcSEDAkAgAUEDSQRAQQAhAQwBCyAEQfz///8HcSEIQQAhAQNAIAEgACgCACIEQX9zQQd2IARBBnZyQYGChAhxaiAAQQRqKAIAIgFBf3NBB3YgAUEGdnJBgYKECHFqIABBCGooAgAiAUF/c0EHdiABQQZ2ckGBgoQIcWogAEEMaigCACIBQX9zQQd2IAFBBnZyQYGChAhxaiEBIABBEGohACAIQQRrIggNAAsLIANFDQADQCABIAAoAgAiBEF/c0EHdiAEQQZ2ckGBgoQIcWohASAAQQRqIQAgA0EBayIDDQALCyABQQh2Qf+B/AdxIAFB/4H8B3FqQYGABGxBEHYgAmoMAgtBACAFRQ0BGiAFQQNxIQEgBUEBa0EDTwRAIAVBfHEhAwNAIAIgACwAAEG/f0pqIAAsAAFBv39KaiAALAACQb9/SmogACwAA0G/f0pqIQIgAEEEaiEAIANBBGsiAw0ACwsgAUUNAANAIAIgACwAAEG/f0pqIQIgAEEBaiEAIAFBAWsiAQ0ACwsgAgshAQwBCyAFRQRAQQAhAQwBCyAFQQNxIQICQCAFQQFrQQNJBEBBACEBIAkhAAwBCyAFQXxxIQNBACEBIAkhAANAIAEgACwAAEG/f0pqIAAsAAFBv39KaiAALAACQb9/SmogACwAA0G/f0pqIQEgAEEEaiEAIANBBGsiAw0ACwsgAkUNAANAIAEgACwAAEG/f0pqIQEgAEEBaiEAIAJBAWsiAg0ACwsgASAMSQRAIAwgAWsiASEDAkACQAJAIAYtACAiAEEAIABBA0cbQQNxIgBBAWsOAgABAgtBACEDIAEhAAwBCyABQQF2IQAgAUEBakEBdiEDCyAAQQFqIQAgBkEEaigCACEBIAYoAhwhAiAGKAIAIQYCQANAIABBAWsiAEUNASAGIAIgASgCEBECAEUNAAtBAQwFC0EBIQAgAkGAgMQARg0CIAYgCSAFIAEoAgwRAAANAkEAIQADQEEAIAAgA0YNBRogAEEBaiEAIAYgAiABKAIQEQIARQ0ACyAAQQFrIANJDAQLDAILIAYoAgAgCSAFIAYoAgQoAgwRAAAhAAsgAAwBCyAGKAIAIAkgBSAGKAIEKAIMEQAACwsKAEEAIABrIABxCwsAIAAtAARBA3FFCwwAIAAgAUEDcjYCBAsNACAAKAIAIAAoAgRqCw4AIAAoAgAaA0AMAAsACwsAIAA1AgAgARASCwsAIAAxAAAgARASCwsAIAAzAQAgARASC3IBAn8jAEEQayIBJAAgAUEiNgIMIAFBgIDAADYCCCMAQSBrIgAkACAAQQxqQQE2AgAgAEEUakEBNgIAIABBiIvAADYCCCAAQQA2AgAgAEETNgIcIAAgAUEIajYCGCAAIABBGGo2AhAgAEG4gMAAEKgBAAsLACAAIwBqJAAjAAsJACAAIAEQAAALDQBBoofAAEEbEN4BAAsOAEG9h8AAQc8AEN4BAAsKACAAKAIEQXhxCwoAIAAoAgRBAXELCgAgACgCDEEBcQsKACAAKAIMQQF2CxkAIAAgAUGMjcAAKAIAIgBBBCAAGxEEAAALswIBB38CQCACIgRBD00EQCAAIQIMAQsgAEEAIABrQQNxIgNqIQUgAwRAIAAhAiABIQYDQCACIAYtAAA6AAAgBkEBaiEGIAJBAWoiAiAFSQ0ACwsgBSAEIANrIghBfHEiB2ohAgJAIAEgA2oiA0EDcSIEBEAgB0EATA0BIANBfHEiBkEEaiEBQQAgBEEDdCIJa0EYcSEEIAYoAgAhBgNAIAUgBiAJdiABKAIAIgYgBHRyNgIAIAFBBGohASAFQQRqIgUgAkkNAAsMAQsgB0EATA0AIAMhAQNAIAUgASgCADYCACABQQRqIQEgBUEEaiIFIAJJDQALCyAIQQNxIQQgAyAHaiEBCyAEBEAgAiAEaiEDA0AgAiABLQAAOgAAIAFBAWohASACQQFqIgIgA0kNAAsLIAALBwAgACABagsHACAAIAFrCwcAIABBCGoLBwAgAEEIawsEAEEECwwAQtbkq/72/7CeagsNAELKvdvazqCx5od/Cw0AQsi14M/KhtvTiX8LAgALJQACQCAABEAgACgCAEF/Rg0BIAAgAWotAAAPCxDfAQALEOABAAs9AAJAAkAgAARAIAEgAk8NASAAKAIADQIgAEEANgIAIAAgAToABA8LEN8BAAtBkIbAAEEZEN4BAAsQ4AEAC2MBAn8CQAJAIAAEQCAAKAIAQX9GDQEgAEEGai0AACECIAAvAAQhA0EIQQQQ0AEiAEUNAiAAQQA2AgAgACADIAJBEHRyIAF2QT9xOgAEIAAPCxDfAQALEOABAAtBCEEEEOUBAAu3AgECfyMAQTBrIgQkAAJAAkACQAJAIABBwAFxRQRAIAFBwAFxDQEgBCACOwEOIAJB//8DcUGAIE8NAkEEQQEQ0AEiBUUNAyAFIAJB//8DcSABQQx0QYDgP3EgAEESdEGAgPAfcXJyIgBBCHRBgID8B3EgAkEYdHIgAEEIdkGA/gNxIABBGHZyciIAQQh2QYCA/AdxIABBgP7/B3FBCHZyQQh0IANyNgAAQQhBBBDQASIARQ0EIAAgBTYCBCAAQQA2AgAgBEEwaiQAIAAPCxDcAQALENwBAAsgBEEcakECNgIAIARBJGpBATYCACAEQbiBwAA2AhggBEEANgIQIARBATYCLCAEIARBKGo2AiAgBCAEQQ5qNgIoIARBEGpByIHAABCoAQALQQRBARDlAQALQQhBBBDlAQALygEBAX8CQAJAAkAgAEHAAXFFBEAgAUHAAXEgAkHAAXFyDQNBBEEBENABIgRFDQEgBCACQQZ0QcD/AHEgAUEMdEGA4D9xIABBEnRBgIDwH3FyciIAQQh0QYCA/AdxIAJBHnRyIABBCHZBgP4DcSAAQRh2cnIiAEEIdkGAgIAGcSAAQYD+/wdxQQh2ckEIdCADcjYAAEEIQQQQ0AEiAEUNAiAAIAQ2AgQgAEEANgIAIAAPCwwCC0EEQQEQ5QEAC0EIQQQQ5QEACxDcAQAL9wEBAn8jAEEwayICJAAgAiAANgIMAkACQCAAQYCAgAhJBEBBBEEBENABIgNFDQEgAyAAQQh0QYCA/AdxIABBGHRyIABBCHZBgP4DcSAAQRh2cnIiAEEIdkGAgPwHcSAAQYD+/wdxQQh2ckEIdCABcjYAAEEIQQQQ0AEiAEUNAiAAIAM2AgQgAEEANgIAIAJBMGokACAADwsgAkEcakECNgIAIAJBJGpBATYCACACQcCCwAA2AhggAkEANgIQIAJBAjYCLCACIAJBKGo2AiAgAiACQQxqNgIoIAJBEGpB0ILAABCoAQALQQRBARDlAQALQQhBBBDlAQALxwIBAn8jAEEwayIFJAACQAJAAkACQCAAQcABcUUEQCABQcABcSACQcABcXINBCAFIAM6AA8gA0H/AXFBwABPDQFBBEEBENABIgZFDQIgBiACQQZ0QcD/AHEgAUEMdEGA4D9xIABBEnRBgIDwH3FyciIBIANB/wFxciIAQRh0IAFBCHRBgID8B3FyIABBCHZBgP4DcSAAQRh2cnIiAEEIdkGAgPwHcSAAQYD+/wdxQQh2ckEIdCAEcjYAAEEIQQQQ0AEiAEUNAyAAIAY2AgQgAEEANgIAIAVBMGokACAADwsMAwsgBUEcakECNgIAIAVBJGpBATYCACAFQfSAwAA2AhggBUEANgIQIAVBAzYCLCAFIAVBKGo2AiAgBSAFQQ9qNgIoIAVBEGpBhIHAABCoAQALQQRBARDlAQALQQhBBBDlAQALENwBAAuUAgECfyMAQTBrIgMkAAJAAkACQCAAQcABcUUEQCADIAE2AgwgAUGAgBBPDQFBBEEBENABIgRFDQIgBCABQQh0QYCA/AdxIAFBGHRyIABBEnRBgIDwH3EgAXIiAEEIdkGA/gNxIABBGHZyciIAQQh2QYCA/AdxIABBgP7/B3FBCHZyQQh0IAJyNgAAQQhBBBDQASIARQ0DIAAgBDYCBCAAQQA2AgAgA0EwaiQAIAAPCxDcAQALIANBHGpBAjYCACADQSRqQQE2AgAgA0H8gcAANgIYIANBADYCECADQQI2AiwgAyADQShqNgIgIAMgA0EMajYCKCADQRBqQYyCwAAQqAEAC0EEQQEQ5QEAC0EIQQQQ5QEAC9sBAQF/AkACQAJAIABBwAFxRQRAIAFBwAFxIAJBwAFxcg0DIANBwAFxDQNBBEEBENABIgVFDQEgBSACQQZ0QcD/AHEgAUEMdEGA4D9xIABBEnRBgIDwH3FyciIBIANB/wFxciIAQRh0IAFBCHRBgID8B3FyIABBCHZBgP4DcSAAQRh2cnIiAEEIdkGAgPwHcSAAQYD+/wdxQQh2ckEIdCAEcjYAAEEIQQQQ0AEiAEUNAiAAIAU2AgQgAEEANgIAIAAPCwwCC0EEQQEQ5QEAC0EIQQQQ5QEACxDcAQALjQEBAX8CQAJAAkAgAEHAAXFFBEAgAUHAAXENAUEEQQEQ0AEiA0UNAiADIAFBFHRBgIDAB3EgAEESdEGAgPAHcSABQQx0QYCAPHFyQQh2ciACcjYAAEEIQQQQ0AEiAEUNAyAAIAM2AgQgAEEANgIAIAAPCxDcAQALENwBAAtBBEEBEOUBAAtBCEEEEOUBAAspAQF/QQhBBBDQASIBRQRAQQhBBBDlAQALIAEgADoABCABQQA2AgAgAQtjAQF/AkACQCAAQcABcUUEQEEEQQEQ0AEiAkUNASACIABBCnRBgPgDcSABcjYAAEEIQQQQ0AEiAEUNAiAAIAI2AgQgAEEANgIAIAAPCxDcAQALQQRBARDlAQALQQhBBBDlAQALhQIBAX4CQAJAAkACQCADBEAgAygCAA0BIANBADYCACADKQIAIQUgAxACIAJBwAFxIABBwAFxIAFBwAFxcnINBEEEQQEQ0AEiA0UNAiADIAJBBnRBwP8AcSABQQx0QYDgP3EgAEESdEGAgPAfcXJyIgEgBUIgiKcgBUIjiKdBIHFyQf8BcXIiAEEYdCABQQh0QYCA/AdxciAAQQh2QYD+A3EgAEEYdnJyIgBBCHZBgID8B3EgAEGA/v8HcUEIdnJBCHQgBHI2AABBCEEEENABIgBFDQMgACADNgIEIABBADYCACAADwsQ3wEACxDgAQALQQRBARDlAQALQQhBBBDlAQALENwBAAvyAQEBfwJAAkACQAJAIAMEQCADKAIADQEgAy0ABCEFIAMQAiACQcABcSAAQcABcSABQcABcXJyDQRBBEEBENABIgNFDQIgAyACQQZ0QcD/AHEgAUEMdEGA4D9xIABBEnRBgIDwH3FyciIBIAVBBXRBIHFyIgBBGHQgAUEIdEGAgPwHcXIgAEEIdkGA/gNxIABBGHZyciIAQQh2QYCAgAdxIABBgP7/B3FBCHZyQQh0IARyNgAAQQhBBBDQASIARQ0DIAAgAzYCBCAAQQA2AgAgAA8LEN8BAAsQ4AEAC0EEQQEQ5QEAC0EIQQQQ5QEACxDcAQALhAIBAX4CQAJAAkACQCADBEAgAygCAA0BIANBADYCACADKQIAIQUgAxACIAJBwAFxIABBwAFxIAFBwAFxcnINBEEEQQEQ0AEiA0UNAiADIAVCI4inQSBxIAJBBnRBwP8AcSABQQx0QYDgP3EgAEESdEGAgPAfcXJyIgEgBUIciKdBEHFyciIAQRh0IAFBCHRBgID8B3FyIABBCHZBgP4DcSAAQRh2cnIiAEEIdkGAgPwHcSAAQYD+/wdxQQh2ckEIdCAEcjYAAEEIQQQQ0AEiAEUNAyAAIAM2AgQgAEEANgIAIAAPCxDfAQALEOABAAtBBEEBEOUBAAtBCEEEEOUBAAsQ3AEACwvhDAMAQYCAwAALqQZDaGVja1JlZ0lkIHdhcyBnaXZlbiBpbnZhbGlkIFJlZ0lkZnVlbC1hc20vc3JjL2xpYi5ycwAAACIAEAATAAAAbAAAACIAAABWYWx1ZSBgYCBvdXQgb2YgcmFuZ2UgZm9yIDYtYml0IGltbWVkaWF0ZQAAAEgAEAAHAAAATwAQACIAAAAiABAAEwAAAKQDAAAcAAAAYCBvdXQgb2YgcmFuZ2UgZm9yIDEyLWJpdCBpbW1lZGlhdGUASAAQAAcAAACUABAAIwAAACIAEAATAAAAqQMAABwAAABgIG91dCBvZiByYW5nZSBmb3IgMTgtYml0IGltbWVkaWF0ZQBIABAABwAAANgAEAAjAAAAIgAQABMAAACuAwAAHAAAAGAgb3V0IG9mIHJhbmdlIGZvciAyNC1iaXQgaW1tZWRpYXRlAEgAEAAHAAAAHAEQACMAAAAiABAAEwAAALMDAAAcAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAACAAAAAhAAAAIgAAACQAAAAlAAAAJgAAACcAAAAoAAAAKQAAACoAAAArAAAALAAAAC0AAAAuAAAALwAAADAAAAAxAAAAMgAAADMAAAA0AAAANQAAADYAAAA3AAAAOAAAADkAAAA6AAAAOwAAADwAAAA9AAAAPgAAAD8AAABAAAAAQQAAAEIAAABDAAAARwAAAEgAAABJAAAASgAAAEsAAABMAAAAUAAAAFEAAABSAAAAUwAAAFQAAABVAAAAVgAAAFcAAABYAAAAWQAAAFoAAABbAAAAXAAAAF0AAABeAAAAXwAAAGAAAABhAAAAcAAAAHEAAAByAAAAcwAAAHQAAAB1AAAAdgAAAHcAAAB4AAAAeQAAAJAAAACRAAAAkgAAAJMAAACUAAAAlQAAAJYAAACXAAAAmAAAAKAAAAChAAAAogAAAKMAAACkAAAApQAAAKYAAACnAAAAqAAAAKkAAACqAAAAqwAAAKwAAACtAAAAaW52YWxpZCBlbnVtIHZhbHVlIHBhc3NlZABBtIbAAAsRBAAAAAAAAAAFAAAAAAAAAAYAQdyGwAALjAYBAAAAAAAAAAIAAAAAAAAAAwAAAGludmFsaWQgZW51bSB2YWx1ZSBwYXNzZWRpbnZhbGlkIGVudW0gdmFsdWUgcGFzc2VkbnVsbCBwb2ludGVyIHBhc3NlZCB0byBydXN0cmVjdXJzaXZlIHVzZSBvZiBhbiBvYmplY3QgZGV0ZWN0ZWQgd2hpY2ggd291bGQgbGVhZCB0byB1bnNhZmUgYWxpYXNpbmcgaW4gcnVzdAUAAAAEAAAABAAAAAYAAAAHAAAACAAAAGNhbGxlZCBgT3B0aW9uOjp1bndyYXAoKWAgb24gYSBgTm9uZWAgdmFsdWVtZW1vcnkgYWxsb2NhdGlvbiBvZiAgYnl0ZXMgZmFpbGVkAAAATwQQABUAAABkBBAADQAAAGxpYnJhcnkvc3RkL3NyYy9hbGxvYy5yc4QEEAAYAAAAVQEAAAkAAABsaWJyYXJ5L3N0ZC9zcmMvcGFuaWNraW5nLnJzrAQQABwAAABCAgAAHgAAAKwEEAAcAAAAQQIAAB8AAAAJAAAADAAAAAQAAAAKAAAABQAAAAgAAAAEAAAACwAAAAwAAAAQAAAABAAAAA0AAAAOAAAABQAAAAgAAAAEAAAADwAAABAAAAAFAAAAAAAAAAEAAAARAAAAbGlicmFyeS9hbGxvYy9zcmMvcmF3X3ZlYy5yc2NhcGFjaXR5IG92ZXJmbG93AAAAXAUQABEAAABABRAAHAAAAA0CAAAFAAAAiAUQAAAAAAAUAAAAAAAAAAEAAAAVAAAAMDAwMTAyMDMwNDA1MDYwNzA4MDkxMDExMTIxMzE0MTUxNjE3MTgxOTIwMjEyMjIzMjQyNTI2MjcyODI5MzAzMTMyMzMzNDM1MzYzNzM4Mzk0MDQxNDI0MzQ0NDU0NjQ3NDg0OTUwNTE1MjUzNTQ1NTU2NTc1ODU5NjA2MTYyNjM2NDY1NjY2NzY4Njk3MDcxNzI3Mzc0NzU3Njc3Nzg3OTgwODE4MjgzODQ4NTg2ODc4ODg5OTA5MTkyOTM5NDk1OTY5Nzk4OTkAbwlwcm9kdWNlcnMCCGxhbmd1YWdlAQRSdXN0AAxwcm9jZXNzZWQtYnkDBXJ1c3RjHTEuNjkuMCAoODRjODk4ZDY1IDIwMjMtMDQtMTYpBndhbHJ1cwYwLjE5LjAMd2FzbS1iaW5kZ2VuBjAuMi44Nw==", imports);
};
async function initWasm() {
  return await __wbg_init(wasm());
}
var wasm$1;
var cachedTextDecoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-8", { ignoreBOM: true, fatal: true }) : { decode: () => {
  throw Error("TextDecoder not available");
} };
if (typeof TextDecoder !== "undefined") {
  cachedTextDecoder.decode();
}
var cachedUint8Memory0 = null;
var cachedInt32Memory0 = null;
var GMArgs = Object.freeze({
  IsCallerExternal: 1,
  "1": "IsCallerExternal",
  GetCaller: 2,
  "2": "GetCaller",
  GetVerifyingPredicate: 3,
  "3": "GetVerifyingPredicate",
  GetChainId: 4,
  "4": "GetChainId"
});
var GTFArgs = Object.freeze({
  Type: 1,
  "1": "Type",
  ScriptGasPrice: 2,
  "2": "ScriptGasPrice",
  ScriptGasLimit: 3,
  "3": "ScriptGasLimit",
  ScriptMaturity: 4,
  "4": "ScriptMaturity",
  ScriptLength: 5,
  "5": "ScriptLength",
  ScriptDataLength: 6,
  "6": "ScriptDataLength",
  ScriptInputsCount: 7,
  "7": "ScriptInputsCount",
  ScriptOutputsCount: 8,
  "8": "ScriptOutputsCount",
  ScriptWitnessesCound: 9,
  "9": "ScriptWitnessesCound",
  ScriptReceiptsRoot: 10,
  "10": "ScriptReceiptsRoot",
  Script: 11,
  "11": "Script",
  ScriptData: 12,
  "12": "ScriptData",
  ScriptInputAtIndex: 13,
  "13": "ScriptInputAtIndex",
  ScriptOutputAtIndex: 14,
  "14": "ScriptOutputAtIndex",
  ScriptWitnessAtIndex: 15,
  "15": "ScriptWitnessAtIndex",
  CreateGasPrice: 16,
  "16": "CreateGasPrice",
  CreateGasLimit: 17,
  "17": "CreateGasLimit",
  CreateMaturity: 18,
  "18": "CreateMaturity",
  CreateBytecodeLength: 19,
  "19": "CreateBytecodeLength",
  CreateBytecodeWitnessIndex: 20,
  "20": "CreateBytecodeWitnessIndex",
  CreateStorageSlotsCount: 21,
  "21": "CreateStorageSlotsCount",
  CreateInputsCount: 22,
  "22": "CreateInputsCount",
  CreateOutputsCount: 23,
  "23": "CreateOutputsCount",
  CreateWitnessesCount: 24,
  "24": "CreateWitnessesCount",
  CreateSalt: 25,
  "25": "CreateSalt",
  CreateStorageSlotAtIndex: 26,
  "26": "CreateStorageSlotAtIndex",
  CreateInputAtIndex: 27,
  "27": "CreateInputAtIndex",
  CreateOutputAtIndex: 28,
  "28": "CreateOutputAtIndex",
  CreateWitnessAtIndex: 29,
  "29": "CreateWitnessAtIndex",
  InputType: 257,
  "257": "InputType",
  InputCoinTxId: 258,
  "258": "InputCoinTxId",
  InputCoinOutputIndex: 259,
  "259": "InputCoinOutputIndex",
  InputCoinOwner: 260,
  "260": "InputCoinOwner",
  InputCoinAmount: 261,
  "261": "InputCoinAmount",
  InputCoinAssetId: 262,
  "262": "InputCoinAssetId",
  InputCoinTxPointer: 263,
  "263": "InputCoinTxPointer",
  InputCoinWitnessIndex: 264,
  "264": "InputCoinWitnessIndex",
  InputCoinMaturity: 265,
  "265": "InputCoinMaturity",
  InputCoinPredicateLength: 266,
  "266": "InputCoinPredicateLength",
  InputCoinPredicateDataLength: 267,
  "267": "InputCoinPredicateDataLength",
  InputCoinPredicate: 268,
  "268": "InputCoinPredicate",
  InputCoinPredicateData: 269,
  "269": "InputCoinPredicateData",
  InputCoinPredicateGasUsed: 270,
  "270": "InputCoinPredicateGasUsed",
  InputContractTxId: 271,
  "271": "InputContractTxId",
  InputContractOutputIndex: 272,
  "272": "InputContractOutputIndex",
  InputContractBalanceRoot: 273,
  "273": "InputContractBalanceRoot",
  InputContractStateRoot: 274,
  "274": "InputContractStateRoot",
  InputContractTxPointer: 275,
  "275": "InputContractTxPointer",
  InputContractId: 276,
  "276": "InputContractId",
  InputMessageSender: 277,
  "277": "InputMessageSender",
  InputMessageRecipient: 278,
  "278": "InputMessageRecipient",
  InputMessageAmount: 279,
  "279": "InputMessageAmount",
  InputMessageNonce: 280,
  "280": "InputMessageNonce",
  InputMessageWitnessIndex: 281,
  "281": "InputMessageWitnessIndex",
  InputMessageDataLength: 282,
  "282": "InputMessageDataLength",
  InputMessagePredicateLength: 283,
  "283": "InputMessagePredicateLength",
  InputMessagePredicateDataLength: 284,
  "284": "InputMessagePredicateDataLength",
  InputMessageData: 285,
  "285": "InputMessageData",
  InputMessagePredicate: 286,
  "286": "InputMessagePredicate",
  InputMessagePredicateData: 287,
  "287": "InputMessagePredicateData",
  InputMessagePredicateGasUsed: 288,
  "288": "InputMessagePredicateGasUsed",
  OutputType: 513,
  "513": "OutputType",
  OutputCoinTo: 514,
  "514": "OutputCoinTo",
  OutputCoinAmount: 515,
  "515": "OutputCoinAmount",
  OutputCoinAssetId: 516,
  "516": "OutputCoinAssetId",
  OutputContractInputIndex: 517,
  "517": "OutputContractInputIndex",
  OutputContractBalanceRoot: 518,
  "518": "OutputContractBalanceRoot",
  OutputContractStateRoot: 519,
  "519": "OutputContractStateRoot",
  OutputContractCreatedContractId: 520,
  "520": "OutputContractCreatedContractId",
  OutputContractCreatedStateRoot: 521,
  "521": "OutputContractCreatedStateRoot",
  WitnessDataLength: 769,
  "769": "WitnessDataLength",
  WitnessData: 770,
  "770": "WitnessData"
});
var PanicReason = Object.freeze({
  UnknownPanicReason: 0,
  "0": "UnknownPanicReason",
  Revert: 1,
  "1": "Revert",
  OutOfGas: 2,
  "2": "OutOfGas",
  TransactionValidity: 3,
  "3": "TransactionValidity",
  MemoryOverflow: 4,
  "4": "MemoryOverflow",
  ArithmeticOverflow: 5,
  "5": "ArithmeticOverflow",
  ContractNotFound: 6,
  "6": "ContractNotFound",
  MemoryOwnership: 7,
  "7": "MemoryOwnership",
  NotEnoughBalance: 8,
  "8": "NotEnoughBalance",
  ExpectedInternalContext: 9,
  "9": "ExpectedInternalContext",
  AssetIdNotFound: 10,
  "10": "AssetIdNotFound",
  InputNotFound: 11,
  "11": "InputNotFound",
  OutputNotFound: 12,
  "12": "OutputNotFound",
  WitnessNotFound: 13,
  "13": "WitnessNotFound",
  TransactionMaturity: 14,
  "14": "TransactionMaturity",
  InvalidMetadataIdentifier: 15,
  "15": "InvalidMetadataIdentifier",
  MalformedCallStructure: 16,
  "16": "MalformedCallStructure",
  ReservedRegisterNotWritable: 17,
  "17": "ReservedRegisterNotWritable",
  ErrorFlag: 18,
  "18": "ErrorFlag",
  InvalidImmediateValue: 19,
  "19": "InvalidImmediateValue",
  ExpectedCoinInput: 20,
  "20": "ExpectedCoinInput",
  Unused0x15: 21,
  "21": "Unused0x15",
  MemoryWriteOverlap: 22,
  "22": "MemoryWriteOverlap",
  ContractNotInInputs: 23,
  "23": "ContractNotInInputs",
  InternalBalanceOverflow: 24,
  "24": "InternalBalanceOverflow",
  ContractMaxSize: 25,
  "25": "ContractMaxSize",
  ExpectedUnallocatedStack: 26,
  "26": "ExpectedUnallocatedStack",
  MaxStaticContractsReached: 27,
  "27": "MaxStaticContractsReached",
  TransferAmountCannotBeZero: 28,
  "28": "TransferAmountCannotBeZero",
  ExpectedOutputVariable: 29,
  "29": "ExpectedOutputVariable",
  ExpectedParentInternalContext: 30,
  "30": "ExpectedParentInternalContext",
  IllegalJump: 31,
  "31": "IllegalJump",
  ContractIdAlreadyDeployed: 32,
  "32": "ContractIdAlreadyDeployed",
  ContractMismatch: 33,
  "33": "ContractMismatch",
  MessageDataTooLong: 34,
  "34": "MessageDataTooLong",
  ArithmeticError: 35,
  "35": "ArithmeticError",
  ContractInstructionNotAllowed: 36,
  "36": "ContractInstructionNotAllowed",
  TransferZeroCoins: 37,
  "37": "TransferZeroCoins"
});
var CompareMode = Object.freeze({
  EQ: 0,
  "0": "EQ",
  NE: 1,
  "1": "NE",
  LT: 2,
  "2": "LT",
  GT: 3,
  "3": "GT",
  LTE: 4,
  "4": "LTE",
  GTE: 5,
  "5": "GTE",
  LZC: 6,
  "6": "LZC"
});
var MathOp = Object.freeze({
  ADD: 0,
  "0": "ADD",
  SUB: 1,
  "1": "SUB",
  NOT: 2,
  "2": "NOT",
  OR: 3,
  "3": "OR",
  XOR: 4,
  "4": "XOR",
  AND: 5,
  "5": "AND",
  SHL: 6,
  "6": "SHL",
  SHR: 7,
  "7": "SHR"
});
class Instruction {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(Instruction.prototype);
    obj.__wbg_ptr = ptr;
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_instruction_free(ptr);
  }
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.instruction_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  static size() {
    const ret2 = wasm$1.instruction_size();
    return ret2 >>> 0;
  }
}
initWasm();

// node_modules/@fuel-ts/program/dist/index.mjs
var callResultToScriptResult = function(callResult) {
  const receipts = [...callResult.receipts];
  let scriptResultReceipt;
  let returnReceipt;
  receipts.forEach((receipt) => {
    if (receipt.type === ReceiptType.ScriptResult) {
      scriptResultReceipt = receipt;
    } else if (receipt.type === ReceiptType.Return || receipt.type === ReceiptType.ReturnData || receipt.type === ReceiptType.Revert) {
      returnReceipt = receipt;
    }
  });
  if (!scriptResultReceipt) {
    throw new FuelError(ErrorCode.TRANSACTION_ERROR, `The script call result does not contain a 'scriptResultReceipt'.`);
  }
  if (!returnReceipt) {
    throw new FuelError(ErrorCode.TRANSACTION_ERROR, `The script call result does not contain a 'returnReceipt'.`);
  }
  const scriptResult = {
    code: scriptResultReceipt.result,
    gasUsed: scriptResultReceipt.gasUsed,
    receipts,
    scriptResultReceipt,
    returnReceipt,
    callResult
  };
  return scriptResult;
};
var decodeCallResult = function(callResult, decoder, logs = []) {
  try {
    const scriptResult = callResultToScriptResult(callResult);
    return decoder(scriptResult);
  } catch (error) {
    throw new ScriptResultDecoderError(callResult, error.message, logs);
  }
};
var PANIC_REASONS = [
  "Success",
  "Revert",
  "OutOfGas",
  "TransactionValidity",
  "MemoryOverflow",
  "ArithmeticOverflow",
  "ContractNotFound",
  "MemoryOwnership",
  "NotEnoughBalance",
  "ExpectedInternalContext",
  "AssetIdNotFound",
  "InputNotFound",
  "OutputNotFound",
  "WitnessNotFound",
  "TransactionMaturity",
  "InvalidMetadataIdentifier",
  "MalformedCallStructure",
  "ReservedRegisterNotWritable",
  "ErrorFlag",
  "InvalidImmediateValue",
  "ExpectedCoinInput",
  "MaxMemoryAccess",
  "MemoryWriteOverlap",
  "ContractNotInInputs",
  "InternalBalanceOverflow",
  "ContractMaxSize",
  "ExpectedUnallocatedStack",
  "MaxStaticContractsReached",
  "TransferAmountCannotBeZero",
  "ExpectedOutputVariable",
  "ExpectedParentInternalContext",
  "IllegalJump",
  "NonZeroMessageOutputRecipient",
  "ZeroedMessageOutputRecipient"
];
var PANIC_DOC_URL = "https://docs.rs/fuel-asm/latest/fuel_asm/enum.PanicReason.html";
var getFailureReason = (reason) => {
  if (PANIC_REASONS.includes(reason)) {
    return reason;
  }
  return reason === "Revert(123)" ? "MismatchedSelector" : "unknown";
};
var getDocs = (status) => {
  if (status?.type === "FailureStatus") {
    const reason = getFailureReason(status.reason);
    return {
      doc: reason !== "unknown" ? `${PANIC_DOC_URL}#variant.${reason}` : PANIC_DOC_URL,
      reason
    };
  }
  return { doc: PANIC_DOC_URL, reason: "unknown" };
};
var REVERT_MAP = {
  [FAILED_REQUIRE_SIGNAL]: "RequireFailed",
  [FAILED_TRANSFER_TO_ADDRESS_SIGNAL]: "TransferToAddressFailed",
  [FAILED_SEND_MESSAGE_SIGNAL]: "SendMessageFailed",
  [FAILED_ASSERT_EQ_SIGNAL]: "AssertEqFailed",
  [FAILED_ASSERT_SIGNAL]: "AssertFailed",
  [FAILED_UNKNOWN_SIGNAL]: "Unknown"
};
var decodeRevertErrorCode = (receipt) => {
  const signalHex = receipt.val.toHex();
  return REVERT_MAP[signalHex] ? REVERT_MAP[signalHex] : undefined;
};
var RevertError = class extends Error {
  receipt;
  constructor(receipt, reason) {
    super(`The script reverted with reason ${reason}`);
    this.name = "RevertError";
    this.receipt = receipt;
  }
  toString() {
    const { id, ...r } = this.receipt;
    return `${this.name}: ${this.message}
    ${id}: ${JSON.stringify(r)}`;
  }
};
var RequireRevertError = class extends RevertError {
  constructor(receipt, reason) {
    super(receipt, reason);
    this.name = "RequireRevertError";
  }
};
var TransferToAddressRevertError = class extends RevertError {
  constructor(receipt, reason) {
    super(receipt, reason);
    this.name = "TransferToAddressRevertError";
  }
};
var SendMessageRevertError = class extends RevertError {
  constructor(receipt, reason) {
    super(receipt, reason);
    this.name = "SendMessageRevertError";
  }
};
var AssertFailedRevertError = class extends RevertError {
  constructor(receipt, reason) {
    super(receipt, reason);
    this.name = "AssertFailedRevertError";
  }
};
var revertErrorFactory = (receipt) => {
  const reason = decodeRevertErrorCode(receipt);
  if (!reason) {
    return;
  }
  switch (reason) {
    case "RequireFailed":
      return new RequireRevertError(receipt, reason);
    case "TransferToAddressFailed":
      return new TransferToAddressRevertError(receipt, reason);
    case "SendMessageFailed":
      return new SendMessageRevertError(receipt, reason);
    case "AssertFailed":
      return new AssertFailedRevertError(receipt, reason);
    default:
      return new RevertError(receipt, reason);
  }
};
var { warn } = console;
var getRevertReceipts = (receipts) => receipts.filter((r) => r.type === ReceiptType.Revert);
var RevertErrorCodes = class {
  revertReceipts;
  constructor(receipts) {
    this.revertReceipts = getRevertReceipts(receipts);
  }
  assert(detailedError) {
    const revertError = this.getError();
    if (revertError) {
      revertError.cause = detailedError;
      throw revertError;
    }
  }
  getError() {
    if (!this.revertReceipts.length) {
      return;
    }
    if (this.revertReceipts.length !== 1) {
      warn("Multiple revert receipts found, expected one. Receipts:", JSON.stringify(this.revertReceipts));
    }
    return revertErrorFactory(this.revertReceipts[0]);
  }
};
var bigintReplacer = (key, value) => typeof value === "bigint" ? value.toString() : value;
var ScriptResultDecoderError = class extends Error {
  logs;
  constructor(result, message, logs) {
    let docLink = "";
    if (result?.gqlTransaction?.status) {
      docLink = `${JSON.stringify(getDocs(result.gqlTransaction.status), null, 2)}

`;
    }
    const logsText = logs.length ? `Logs:
${JSON.stringify(logs, null, 2)}

` : "";
    const receiptsText = `Receipts:
${JSON.stringify(result.receipts.map(({ type: type4, ...r }) => ({ type: ReceiptType[type4], ...r })), bigintReplacer, 2)}`;
    super(`${message}

${docLink}${logsText}${receiptsText}`);
    this.logs = logs;
    new RevertErrorCodes(result.receipts).assert(this);
  }
};
var InstructionSet = class {
  #operations;
  constructor(...args) {
    this.#operations = args || [];
  }
  entries() {
    return this.#operations;
  }
  push(...args) {
    this.#operations.push(...args);
  }
  concat(ops) {
    return this.#operations.concat(ops);
  }
  extend(ops) {
    this.#operations.push(...ops);
  }
  toBytes() {
    return concat2(this.#operations.reduce((instructions, line) => {
      instructions.push(line.to_bytes());
      return instructions;
    }, []));
  }
  toHex() {
    return hexlify(this.toBytes());
  }
  toString() {
    return `Program:
${JSON.stringify(this.#operations, null, 2)}`;
  }
  byteLength() {
    return this.toBytes().byteLength;
  }
};
var POINTER_DATA_OFFSET = WORD_SIZE + ASSET_ID_LEN + CONTRACT_ID_LEN + WORD_SIZE + WORD_SIZE;
var ScriptRequest = class {
  bytes;
  scriptDataEncoder;
  scriptResultDecoder;
  constructor(bytes3, scriptDataEncoder, scriptResultDecoder2) {
    this.bytes = getBytesCopy(bytes3);
    this.scriptDataEncoder = scriptDataEncoder;
    this.scriptResultDecoder = scriptResultDecoder2;
  }
  static getScriptDataOffsetWithScriptBytes(byteLength, maxInputs) {
    const scriptDataBaseOffset = calculateVmTxMemory({ maxInputs }) + SCRIPT_FIXED_SIZE;
    return scriptDataBaseOffset + byteLength;
  }
  getScriptDataOffset(maxInputs) {
    return ScriptRequest.getScriptDataOffsetWithScriptBytes(this.bytes.length, maxInputs);
  }
  encodeScriptData(data3) {
    const callScript = this.scriptDataEncoder(data3);
    if (ArrayBuffer.isView(callScript)) {
      return callScript;
    }
    this.bytes = getBytesCopy(callScript.script);
    return callScript.data;
  }
  decodeCallResult(callResult, logs = []) {
    return decodeCallResult(callResult, this.scriptResultDecoder, logs);
  }
};

// node_modules/@fuel-ts/script/dist/index.mjs
var returnZeroScript2 = new ScriptRequest("0x24000000", () => new Uint8Array(0), () => {
  return;
});
// node_modules/@fuel-ts/merkle/dist/index.mjs
var hash3 = function(data3) {
  return sha2563(data3);
};
var hashLeaf = function(data3) {
  return hash3("0x00".concat(data3.slice(2)));
};
var hashNode = function(left, right) {
  return hash3("0x01".concat(left.slice(2)).concat(right.slice(2)));
};
var calcRoot = function(data3) {
  if (!data3.length) {
    return EMPTY;
  }
  const nodes = [];
  for (let i = 0;i < data3.length; i += 1) {
    const hashed = hashLeaf(data3[i]);
    nodes.push(new node_default(-1, -1, -1, hashed, data3[i]));
  }
  let pNodes = nodes;
  let size = nodes.length + 1 >> 1;
  let odd = nodes.length & 1;
  while (true) {
    let i = 0;
    for (;i < size - odd; i += 1) {
      const j = i << 1;
      const hashed = hashNode(pNodes[j].hash, pNodes[j + 1].hash);
      nodes[i] = new node_default(pNodes[j].index, pNodes[j + 1].index, -1, hashed, "");
    }
    if (odd === 1) {
      nodes[i] = pNodes[i << 1];
    }
    if (size === 1) {
      break;
    }
    odd = size & 1;
    size = size + 1 >> 1;
    pNodes = nodes;
  }
  return nodes[0].hash;
};
var hashLeaf2 = function(key, data3) {
  const value = "0x00".concat(key.slice(2)).concat(hash3(data3).slice(2));
  return [hash3(value), value];
};
var hashNode2 = function(left, right) {
  const value = "0x01".concat(left.slice(2)).concat(right.slice(2));
  return [hash3(value), value];
};
var parseLeaf = function(data3) {
  const len = nodePrefix.length;
  return ["0x".concat(data3.slice(len, len + 64)), "0x".concat(data3.slice(len + 64))];
};
var parseNode = function(data3) {
  const len = nodePrefix.length;
  return ["0x".concat(data3.slice(len, len + 64)), "0x".concat(data3.slice(len + 64))];
};
var isLeaf = function(data3) {
  return data3.slice(0, 4) === leafPrefix;
};
var getBitAtFromMSB = function(data3, position) {
  const slicedData = data3.slice(2);
  const byte = "0x".concat(slicedData.slice(Math.floor(position / 8) * 2, Math.floor(position / 8) * 2 + 2));
  const bits = Number(byte) & 1 << 8 - 1 - position % 8;
  if (bits > 0) {
    return 1;
  }
  return 0;
};
var reverseSideNodes = function(sideNodes) {
  let left = 0;
  let right = sideNodes.length - 1;
  const reversedSideNodes = sideNodes;
  while (left < right) {
    [reversedSideNodes[left], reversedSideNodes[right]] = [
      reversedSideNodes[right],
      reversedSideNodes[left]
    ];
    left += 1;
    right -= 1;
  }
  return reversedSideNodes;
};
var countCommonPrefix = function(data1, data22) {
  let count = 0;
  for (let i = 0;i < MAX_HEIGHT; i += 1) {
    if (getBitAtFromMSB(data1, i) === getBitAtFromMSB(data22, i)) {
      count += 1;
    } else {
      break;
    }
  }
  return count;
};
var compactProof = function(proof) {
  const bitMask = [];
  const compactedSideNodes = [];
  let node;
  for (let i = 0;i < proof.SideNodes.length; i += 1) {
    node = proof.SideNodes[i];
    if (node === ZERO) {
      bitMask.push(0);
    } else {
      compactedSideNodes.push(node);
      bitMask.push(1);
    }
  }
  const compactedProof = new sparseCompactMerkleProof_default(compactedSideNodes, proof.NonMembershipLeafData, bitMask, proof.SideNodes.length, proof.SiblingData);
  return compactedProof;
};
var EMPTY = "0xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
var Node = class {
  left;
  right;
  parent;
  hash;
  data;
  index;
  constructor(left, right, parent, hash22, data3, index = 0) {
    this.left = left;
    this.right = right;
    this.parent = parent;
    this.hash = hash22;
    this.data = data3;
    this.index = index;
  }
};
var node_default = Node;
var leafPrefix = "0x00";
var nodePrefix = "0x01";
var SparseCompactMerkleProof = class {
  SideNodes;
  NonMembershipLeafData;
  BitMask;
  NumSideNodes;
  SiblingData;
  constructor(SideNodes, NonMembershipLeafData, Bitmask, NumSideNodes, SiblingData) {
    this.SideNodes = SideNodes;
    this.NonMembershipLeafData = NonMembershipLeafData;
    this.BitMask = Bitmask;
    this.NumSideNodes = NumSideNodes;
    this.SiblingData = SiblingData;
  }
};
var sparseCompactMerkleProof_default = SparseCompactMerkleProof;
var SparseMerkleProof = class {
  SideNodes;
  NonMembershipLeafData;
  SiblingData;
  constructor(sideNodes, NonMembershipLeafData, SiblingData) {
    this.SideNodes = sideNodes;
    this.NonMembershipLeafData = NonMembershipLeafData;
    this.SiblingData = SiblingData;
  }
};
var sparseMerkleProof_default = SparseMerkleProof;
var ZERO = "0x0000000000000000000000000000000000000000000000000000000000000000";
var MAX_HEIGHT = 256;
var SparseMerkleTree = class {
  ms;
  root;
  constructor() {
    const ms = {};
    this.ms = ms;
    this.root = ZERO;
    this.ms[this.root] = ZERO;
  }
  get(key) {
    return this.ms[key];
  }
  set(key, value) {
    this.ms[key] = value;
  }
  setRoot(root) {
    this.root = root;
  }
  sideNodesForRoot(key, root) {
    const sideNodes = [];
    if (root === ZERO) {
      return [sideNodes, ZERO, "", ""];
    }
    let currentData = this.get(root);
    if (isLeaf(currentData)) {
      return [sideNodes, root, currentData, ""];
    }
    let leftNode;
    let rightNode;
    let nodeHash = "";
    let sideNode = "";
    for (let i = 0;i < MAX_HEIGHT; i += 1) {
      [leftNode, rightNode] = parseNode(currentData);
      if (getBitAtFromMSB(key, i) === 1) {
        sideNode = leftNode;
        nodeHash = rightNode;
      } else {
        sideNode = rightNode;
        nodeHash = leftNode;
      }
      sideNodes.push(sideNode);
      if (nodeHash === ZERO) {
        currentData = "";
        break;
      }
      currentData = this.get(nodeHash);
      if (isLeaf(currentData)) {
        break;
      }
    }
    const siblingData = this.get(sideNode);
    return [reverseSideNodes(sideNodes), nodeHash, currentData, siblingData];
  }
  deleteWithSideNodes(key, sideNodes, oldLeafHash, oldLeafData) {
    if (oldLeafHash === ZERO) {
      return this.root;
    }
    const [actualPath] = parseLeaf(oldLeafData);
    if (actualPath !== key) {
      return this.root;
    }
    let currentHash = "";
    let currentData = "";
    let sideNode = "";
    let sideNodeValue = "";
    let nonPlaceholderReached = false;
    for (let i = 0;i < sideNodes.length; i += 1) {
      if (sideNodes[i] === "") {
        continue;
      }
      sideNode = sideNodes[i];
      if (currentData === "") {
        sideNodeValue = this.get(sideNode);
        if (isLeaf(sideNodeValue)) {
          currentHash = sideNode;
          currentData = sideNode;
          continue;
        } else {
          currentData = ZERO;
          nonPlaceholderReached = true;
        }
      }
      if (!nonPlaceholderReached && sideNode === ZERO) {
        continue;
      } else if (!nonPlaceholderReached) {
        nonPlaceholderReached = true;
      }
      if (getBitAtFromMSB(key, sideNodes.length - 1 - i) === 1) {
        [currentHash, currentData] = hashNode2(sideNode, currentData);
      } else {
        [currentHash, currentData] = hashNode2(currentData, sideNode);
      }
      this.set(currentHash, currentData);
      currentData = currentHash;
    }
    if (currentHash === "") {
      currentHash = ZERO;
    }
    return currentHash;
  }
  updateWithSideNodes(key, value, sideNodes, oldLeafHash, oldLeafData) {
    let currentHash;
    let currentData;
    this.set(hash3(value), value);
    [currentHash, currentData] = hashLeaf2(key, value);
    this.set(currentHash, currentData);
    currentData = currentHash;
    let commonPrefixCount;
    if (oldLeafHash === ZERO) {
      commonPrefixCount = MAX_HEIGHT;
    } else {
      const [actualPath] = parseLeaf(oldLeafData);
      commonPrefixCount = countCommonPrefix(key, actualPath);
    }
    if (commonPrefixCount !== MAX_HEIGHT) {
      if (getBitAtFromMSB(key, commonPrefixCount) === 1) {
        [currentHash, currentData] = hashNode2(oldLeafHash, currentData);
      } else {
        [currentHash, currentData] = hashNode2(currentData, oldLeafHash);
      }
      this.set(currentHash, currentData);
      currentData = currentHash;
    }
    for (let i = 0;i < MAX_HEIGHT; i += 1) {
      let sideNode;
      const offsetOfSideNodes = MAX_HEIGHT - sideNodes.length;
      if (i - offsetOfSideNodes < 0 || sideNodes[i - offsetOfSideNodes] === "") {
        if (commonPrefixCount !== MAX_HEIGHT && commonPrefixCount > MAX_HEIGHT - 1 - i) {
          sideNode = ZERO;
        } else {
          continue;
        }
      } else {
        sideNode = sideNodes[i - offsetOfSideNodes];
      }
      if (getBitAtFromMSB(key, MAX_HEIGHT - 1 - i) === 1) {
        [currentHash, currentData] = hashNode2(sideNode, currentData);
      } else {
        [currentHash, currentData] = hashNode2(currentData, sideNode);
      }
      this.set(currentHash, currentData);
      currentData = currentHash;
    }
    return currentHash;
  }
  update(key, value) {
    const [sideNodes, oldLeafHash, oldLeafData] = this.sideNodesForRoot(key, this.root);
    const newRoot = this.updateWithSideNodes(key, value, sideNodes, oldLeafHash, oldLeafData);
    this.setRoot(newRoot);
  }
  delete(key) {
    const [sideNodes, oldLeafHash, oldLeafData] = this.sideNodesForRoot(key, this.root);
    const newRoot = this.deleteWithSideNodes(key, sideNodes, oldLeafHash, oldLeafData);
    this.setRoot(newRoot);
  }
  prove(key) {
    const [sideNodes, leafHash, leafData, siblingData] = this.sideNodesForRoot(key, this.root);
    const nonEmptySideNodes = [];
    for (let i = 0;i < sideNodes.length; i += 1) {
      if (sideNodes[i] !== "") {
        nonEmptySideNodes.push(sideNodes[i]);
      }
    }
    let nonMembershipLeafData = "";
    if (leafHash !== ZERO) {
      const [actualPath] = parseLeaf(leafData);
      if (actualPath !== key) {
        nonMembershipLeafData = leafData;
      }
    }
    const proof = new sparseMerkleProof_default(nonEmptySideNodes, nonMembershipLeafData, siblingData);
    return proof;
  }
  proveCompacted(key) {
    const proof = this.prove(key);
    const compactedProof = compactProof(proof);
    return compactedProof;
  }
};

// node_modules/@fuel-ts/contract/dist/index.mjs
var __defProp6 = Object.defineProperty;
var __export2 = (target, all) => {
  for (var name in all)
    __defProp6(target, name, { get: all[name], enumerable: true });
};
var util_exports = {};
__export2(util_exports, {
  getContractId: () => getContractId,
  getContractRoot: () => getContractRoot,
  getContractStorageRoot: () => getContractStorageRoot,
  hexlifyWithPrefix: () => hexlifyWithPrefix
});
var getContractRoot = (bytecode) => {
  const chunkSize = 16 * 1024;
  const bytes3 = getBytesCopy(bytecode);
  const chunks = chunkAndPadBytes(bytes3, chunkSize);
  return calcRoot(chunks.map((c) => hexlify(c)));
};
var getContractStorageRoot = (storageSlots) => {
  const tree = new SparseMerkleTree;
  storageSlots.forEach(({ key, value }) => tree.update(sha2563(key), value));
  return tree.root;
};
var getContractId = (bytecode, salt, stateRoot) => {
  const root = getContractRoot(getBytesCopy(bytecode));
  const contractId = sha2563(concat(["0x4655454C", salt, root, stateRoot]));
  return contractId;
};
var hexlifyWithPrefix = (value) => {
  if (value.startsWith("0x"))
    return hexlify(value);
  return hexlify(`0x${value}`);
};
// node_modules/@fuel-ts/hasher/dist/index.mjs
var hashMessage = function(msg) {
  return sha2563(bufferFromString2(msg, "utf-8"));
};
var uint64ToBytesBE = function(value) {
  const bigIntValue = BigInt(value);
  const buffer = new ArrayBuffer(8);
  const dataView = new DataView(buffer);
  dataView.setBigUint64(0, bigIntValue, false);
  return new Uint8Array(dataView.buffer);
};
var hashTransaction = function(transactionRequestLike, chainId) {
  const transactionRequest = transactionRequestify(transactionRequestLike);
  const transaction2 = transactionRequest.toTransaction();
  if (transaction2.type === TransactionType.Script) {
    transaction2.receiptsRoot = ZeroBytes32;
  }
  transaction2.inputs = transaction2.inputs.map((input) => {
    const inputClone = clone_default(input);
    switch (inputClone.type) {
      case InputType.Coin: {
        inputClone.txPointer = {
          blockHeight: 0,
          txIndex: 0
        };
        inputClone.predicateGasUsed = bn(0);
        return inputClone;
      }
      case InputType.Message: {
        inputClone.predicateGasUsed = bn(0);
        return inputClone;
      }
      case InputType.Contract: {
        inputClone.txPointer = {
          blockHeight: 0,
          txIndex: 0
        };
        inputClone.utxoID = {
          transactionId: ZeroBytes32,
          outputIndex: 0
        };
        inputClone.balanceRoot = ZeroBytes32;
        inputClone.stateRoot = ZeroBytes32;
        return inputClone;
      }
      default:
        return inputClone;
    }
  });
  transaction2.outputs = transaction2.outputs.map((output3) => {
    const outputClone = clone_default(output3);
    switch (outputClone.type) {
      case OutputType.Contract: {
        outputClone.balanceRoot = ZeroBytes32;
        outputClone.stateRoot = ZeroBytes32;
        return outputClone;
      }
      case OutputType.Change: {
        outputClone.amount = bn(0);
        return outputClone;
      }
      case OutputType.Variable: {
        outputClone.to = ZeroBytes32;
        outputClone.amount = bn(0);
        outputClone.assetId = ZeroBytes32;
        return outputClone;
      }
      default:
        return outputClone;
    }
  });
  transaction2.witnessesCount = 0;
  transaction2.witnesses = [];
  const chainIdBytes = uint64ToBytesBE(chainId);
  const concatenatedData = concat([chainIdBytes, new TransactionCoder().encode(transaction2)]);
  return sha2563(concatenatedData);
};
var hash4 = function(data3) {
  return sha2563(data3);
};
// node_modules/@fuel-ts/wordlists/dist/index.mjs
var english = [
  "abandon",
  "ability",
  "able",
  "about",
  "above",
  "absent",
  "absorb",
  "abstract",
  "absurd",
  "abuse",
  "access",
  "accident",
  "account",
  "accuse",
  "achieve",
  "acid",
  "acoustic",
  "acquire",
  "across",
  "act",
  "action",
  "actor",
  "actress",
  "actual",
  "adapt",
  "add",
  "addict",
  "address",
  "adjust",
  "admit",
  "adult",
  "advance",
  "advice",
  "aerobic",
  "affair",
  "afford",
  "afraid",
  "again",
  "age",
  "agent",
  "agree",
  "ahead",
  "aim",
  "air",
  "airport",
  "aisle",
  "alarm",
  "album",
  "alcohol",
  "alert",
  "alien",
  "all",
  "alley",
  "allow",
  "almost",
  "alone",
  "alpha",
  "already",
  "also",
  "alter",
  "always",
  "amateur",
  "amazing",
  "among",
  "amount",
  "amused",
  "analyst",
  "anchor",
  "ancient",
  "anger",
  "angle",
  "angry",
  "animal",
  "ankle",
  "announce",
  "annual",
  "another",
  "answer",
  "antenna",
  "antique",
  "anxiety",
  "any",
  "apart",
  "apology",
  "appear",
  "apple",
  "approve",
  "april",
  "arch",
  "arctic",
  "area",
  "arena",
  "argue",
  "arm",
  "armed",
  "armor",
  "army",
  "around",
  "arrange",
  "arrest",
  "arrive",
  "arrow",
  "art",
  "artefact",
  "artist",
  "artwork",
  "ask",
  "aspect",
  "assault",
  "asset",
  "assist",
  "assume",
  "asthma",
  "athlete",
  "atom",
  "attack",
  "attend",
  "attitude",
  "attract",
  "auction",
  "audit",
  "august",
  "aunt",
  "author",
  "auto",
  "autumn",
  "average",
  "avocado",
  "avoid",
  "awake",
  "aware",
  "away",
  "awesome",
  "awful",
  "awkward",
  "axis",
  "baby",
  "bachelor",
  "bacon",
  "badge",
  "bag",
  "balance",
  "balcony",
  "ball",
  "bamboo",
  "banana",
  "banner",
  "bar",
  "barely",
  "bargain",
  "barrel",
  "base",
  "basic",
  "basket",
  "battle",
  "beach",
  "bean",
  "beauty",
  "because",
  "become",
  "beef",
  "before",
  "begin",
  "behave",
  "behind",
  "believe",
  "below",
  "belt",
  "bench",
  "benefit",
  "best",
  "betray",
  "better",
  "between",
  "beyond",
  "bicycle",
  "bid",
  "bike",
  "bind",
  "biology",
  "bird",
  "birth",
  "bitter",
  "black",
  "blade",
  "blame",
  "blanket",
  "blast",
  "bleak",
  "bless",
  "blind",
  "blood",
  "blossom",
  "blouse",
  "blue",
  "blur",
  "blush",
  "board",
  "boat",
  "body",
  "boil",
  "bomb",
  "bone",
  "bonus",
  "book",
  "boost",
  "border",
  "boring",
  "borrow",
  "boss",
  "bottom",
  "bounce",
  "box",
  "boy",
  "bracket",
  "brain",
  "brand",
  "brass",
  "brave",
  "bread",
  "breeze",
  "brick",
  "bridge",
  "brief",
  "bright",
  "bring",
  "brisk",
  "broccoli",
  "broken",
  "bronze",
  "broom",
  "brother",
  "brown",
  "brush",
  "bubble",
  "buddy",
  "budget",
  "buffalo",
  "build",
  "bulb",
  "bulk",
  "bullet",
  "bundle",
  "bunker",
  "burden",
  "burger",
  "burst",
  "bus",
  "business",
  "busy",
  "butter",
  "buyer",
  "buzz",
  "cabbage",
  "cabin",
  "cable",
  "cactus",
  "cage",
  "cake",
  "call",
  "calm",
  "camera",
  "camp",
  "can",
  "canal",
  "cancel",
  "candy",
  "cannon",
  "canoe",
  "canvas",
  "canyon",
  "capable",
  "capital",
  "captain",
  "car",
  "carbon",
  "card",
  "cargo",
  "carpet",
  "carry",
  "cart",
  "case",
  "cash",
  "casino",
  "castle",
  "casual",
  "cat",
  "catalog",
  "catch",
  "category",
  "cattle",
  "caught",
  "cause",
  "caution",
  "cave",
  "ceiling",
  "celery",
  "cement",
  "census",
  "century",
  "cereal",
  "certain",
  "chair",
  "chalk",
  "champion",
  "change",
  "chaos",
  "chapter",
  "charge",
  "chase",
  "chat",
  "cheap",
  "check",
  "cheese",
  "chef",
  "cherry",
  "chest",
  "chicken",
  "chief",
  "child",
  "chimney",
  "choice",
  "choose",
  "chronic",
  "chuckle",
  "chunk",
  "churn",
  "cigar",
  "cinnamon",
  "circle",
  "citizen",
  "city",
  "civil",
  "claim",
  "clap",
  "clarify",
  "claw",
  "clay",
  "clean",
  "clerk",
  "clever",
  "click",
  "client",
  "cliff",
  "climb",
  "clinic",
  "clip",
  "clock",
  "clog",
  "close",
  "cloth",
  "cloud",
  "clown",
  "club",
  "clump",
  "cluster",
  "clutch",
  "coach",
  "coast",
  "coconut",
  "code",
  "coffee",
  "coil",
  "coin",
  "collect",
  "color",
  "column",
  "combine",
  "come",
  "comfort",
  "comic",
  "common",
  "company",
  "concert",
  "conduct",
  "confirm",
  "congress",
  "connect",
  "consider",
  "control",
  "convince",
  "cook",
  "cool",
  "copper",
  "copy",
  "coral",
  "core",
  "corn",
  "correct",
  "cost",
  "cotton",
  "couch",
  "country",
  "couple",
  "course",
  "cousin",
  "cover",
  "coyote",
  "crack",
  "cradle",
  "craft",
  "cram",
  "crane",
  "crash",
  "crater",
  "crawl",
  "crazy",
  "cream",
  "credit",
  "creek",
  "crew",
  "cricket",
  "crime",
  "crisp",
  "critic",
  "crop",
  "cross",
  "crouch",
  "crowd",
  "crucial",
  "cruel",
  "cruise",
  "crumble",
  "crunch",
  "crush",
  "cry",
  "crystal",
  "cube",
  "culture",
  "cup",
  "cupboard",
  "curious",
  "current",
  "curtain",
  "curve",
  "cushion",
  "custom",
  "cute",
  "cycle",
  "dad",
  "damage",
  "damp",
  "dance",
  "danger",
  "daring",
  "dash",
  "daughter",
  "dawn",
  "day",
  "deal",
  "debate",
  "debris",
  "decade",
  "december",
  "decide",
  "decline",
  "decorate",
  "decrease",
  "deer",
  "defense",
  "define",
  "defy",
  "degree",
  "delay",
  "deliver",
  "demand",
  "demise",
  "denial",
  "dentist",
  "deny",
  "depart",
  "depend",
  "deposit",
  "depth",
  "deputy",
  "derive",
  "describe",
  "desert",
  "design",
  "desk",
  "despair",
  "destroy",
  "detail",
  "detect",
  "develop",
  "device",
  "devote",
  "diagram",
  "dial",
  "diamond",
  "diary",
  "dice",
  "diesel",
  "diet",
  "differ",
  "digital",
  "dignity",
  "dilemma",
  "dinner",
  "dinosaur",
  "direct",
  "dirt",
  "disagree",
  "discover",
  "disease",
  "dish",
  "dismiss",
  "disorder",
  "display",
  "distance",
  "divert",
  "divide",
  "divorce",
  "dizzy",
  "doctor",
  "document",
  "dog",
  "doll",
  "dolphin",
  "domain",
  "donate",
  "donkey",
  "donor",
  "door",
  "dose",
  "double",
  "dove",
  "draft",
  "dragon",
  "drama",
  "drastic",
  "draw",
  "dream",
  "dress",
  "drift",
  "drill",
  "drink",
  "drip",
  "drive",
  "drop",
  "drum",
  "dry",
  "duck",
  "dumb",
  "dune",
  "during",
  "dust",
  "dutch",
  "duty",
  "dwarf",
  "dynamic",
  "eager",
  "eagle",
  "early",
  "earn",
  "earth",
  "easily",
  "east",
  "easy",
  "echo",
  "ecology",
  "economy",
  "edge",
  "edit",
  "educate",
  "effort",
  "egg",
  "eight",
  "either",
  "elbow",
  "elder",
  "electric",
  "elegant",
  "element",
  "elephant",
  "elevator",
  "elite",
  "else",
  "embark",
  "embody",
  "embrace",
  "emerge",
  "emotion",
  "employ",
  "empower",
  "empty",
  "enable",
  "enact",
  "end",
  "endless",
  "endorse",
  "enemy",
  "energy",
  "enforce",
  "engage",
  "engine",
  "enhance",
  "enjoy",
  "enlist",
  "enough",
  "enrich",
  "enroll",
  "ensure",
  "enter",
  "entire",
  "entry",
  "envelope",
  "episode",
  "equal",
  "equip",
  "era",
  "erase",
  "erode",
  "erosion",
  "error",
  "erupt",
  "escape",
  "essay",
  "essence",
  "estate",
  "eternal",
  "ethics",
  "evidence",
  "evil",
  "evoke",
  "evolve",
  "exact",
  "example",
  "excess",
  "exchange",
  "excite",
  "exclude",
  "excuse",
  "execute",
  "exercise",
  "exhaust",
  "exhibit",
  "exile",
  "exist",
  "exit",
  "exotic",
  "expand",
  "expect",
  "expire",
  "explain",
  "expose",
  "express",
  "extend",
  "extra",
  "eye",
  "eyebrow",
  "fabric",
  "face",
  "faculty",
  "fade",
  "faint",
  "faith",
  "fall",
  "false",
  "fame",
  "family",
  "famous",
  "fan",
  "fancy",
  "fantasy",
  "farm",
  "fashion",
  "fat",
  "fatal",
  "father",
  "fatigue",
  "fault",
  "favorite",
  "feature",
  "february",
  "federal",
  "fee",
  "feed",
  "feel",
  "female",
  "fence",
  "festival",
  "fetch",
  "fever",
  "few",
  "fiber",
  "fiction",
  "field",
  "figure",
  "file",
  "film",
  "filter",
  "final",
  "find",
  "fine",
  "finger",
  "finish",
  "fire",
  "firm",
  "first",
  "fiscal",
  "fish",
  "fit",
  "fitness",
  "fix",
  "flag",
  "flame",
  "flash",
  "flat",
  "flavor",
  "flee",
  "flight",
  "flip",
  "float",
  "flock",
  "floor",
  "flower",
  "fluid",
  "flush",
  "fly",
  "foam",
  "focus",
  "fog",
  "foil",
  "fold",
  "follow",
  "food",
  "foot",
  "force",
  "forest",
  "forget",
  "fork",
  "fortune",
  "forum",
  "forward",
  "fossil",
  "foster",
  "found",
  "fox",
  "fragile",
  "frame",
  "frequent",
  "fresh",
  "friend",
  "fringe",
  "frog",
  "front",
  "frost",
  "frown",
  "frozen",
  "fruit",
  "fuel",
  "fun",
  "funny",
  "furnace",
  "fury",
  "future",
  "gadget",
  "gain",
  "galaxy",
  "gallery",
  "game",
  "gap",
  "garage",
  "garbage",
  "garden",
  "garlic",
  "garment",
  "gas",
  "gasp",
  "gate",
  "gather",
  "gauge",
  "gaze",
  "general",
  "genius",
  "genre",
  "gentle",
  "genuine",
  "gesture",
  "ghost",
  "giant",
  "gift",
  "giggle",
  "ginger",
  "giraffe",
  "girl",
  "give",
  "glad",
  "glance",
  "glare",
  "glass",
  "glide",
  "glimpse",
  "globe",
  "gloom",
  "glory",
  "glove",
  "glow",
  "glue",
  "goat",
  "goddess",
  "gold",
  "good",
  "goose",
  "gorilla",
  "gospel",
  "gossip",
  "govern",
  "gown",
  "grab",
  "grace",
  "grain",
  "grant",
  "grape",
  "grass",
  "gravity",
  "great",
  "green",
  "grid",
  "grief",
  "grit",
  "grocery",
  "group",
  "grow",
  "grunt",
  "guard",
  "guess",
  "guide",
  "guilt",
  "guitar",
  "gun",
  "gym",
  "habit",
  "hair",
  "half",
  "hammer",
  "hamster",
  "hand",
  "happy",
  "harbor",
  "hard",
  "harsh",
  "harvest",
  "hat",
  "have",
  "hawk",
  "hazard",
  "head",
  "health",
  "heart",
  "heavy",
  "hedgehog",
  "height",
  "hello",
  "helmet",
  "help",
  "hen",
  "hero",
  "hidden",
  "high",
  "hill",
  "hint",
  "hip",
  "hire",
  "history",
  "hobby",
  "hockey",
  "hold",
  "hole",
  "holiday",
  "hollow",
  "home",
  "honey",
  "hood",
  "hope",
  "horn",
  "horror",
  "horse",
  "hospital",
  "host",
  "hotel",
  "hour",
  "hover",
  "hub",
  "huge",
  "human",
  "humble",
  "humor",
  "hundred",
  "hungry",
  "hunt",
  "hurdle",
  "hurry",
  "hurt",
  "husband",
  "hybrid",
  "ice",
  "icon",
  "idea",
  "identify",
  "idle",
  "ignore",
  "ill",
  "illegal",
  "illness",
  "image",
  "imitate",
  "immense",
  "immune",
  "impact",
  "impose",
  "improve",
  "impulse",
  "inch",
  "include",
  "income",
  "increase",
  "index",
  "indicate",
  "indoor",
  "industry",
  "infant",
  "inflict",
  "inform",
  "inhale",
  "inherit",
  "initial",
  "inject",
  "injury",
  "inmate",
  "inner",
  "innocent",
  "input",
  "inquiry",
  "insane",
  "insect",
  "inside",
  "inspire",
  "install",
  "intact",
  "interest",
  "into",
  "invest",
  "invite",
  "involve",
  "iron",
  "island",
  "isolate",
  "issue",
  "item",
  "ivory",
  "jacket",
  "jaguar",
  "jar",
  "jazz",
  "jealous",
  "jeans",
  "jelly",
  "jewel",
  "job",
  "join",
  "joke",
  "journey",
  "joy",
  "judge",
  "juice",
  "jump",
  "jungle",
  "junior",
  "junk",
  "just",
  "kangaroo",
  "keen",
  "keep",
  "ketchup",
  "key",
  "kick",
  "kid",
  "kidney",
  "kind",
  "kingdom",
  "kiss",
  "kit",
  "kitchen",
  "kite",
  "kitten",
  "kiwi",
  "knee",
  "knife",
  "knock",
  "know",
  "lab",
  "label",
  "labor",
  "ladder",
  "lady",
  "lake",
  "lamp",
  "language",
  "laptop",
  "large",
  "later",
  "latin",
  "laugh",
  "laundry",
  "lava",
  "law",
  "lawn",
  "lawsuit",
  "layer",
  "lazy",
  "leader",
  "leaf",
  "learn",
  "leave",
  "lecture",
  "left",
  "leg",
  "legal",
  "legend",
  "leisure",
  "lemon",
  "lend",
  "length",
  "lens",
  "leopard",
  "lesson",
  "letter",
  "level",
  "liar",
  "liberty",
  "library",
  "license",
  "life",
  "lift",
  "light",
  "like",
  "limb",
  "limit",
  "link",
  "lion",
  "liquid",
  "list",
  "little",
  "live",
  "lizard",
  "load",
  "loan",
  "lobster",
  "local",
  "lock",
  "logic",
  "lonely",
  "long",
  "loop",
  "lottery",
  "loud",
  "lounge",
  "love",
  "loyal",
  "lucky",
  "luggage",
  "lumber",
  "lunar",
  "lunch",
  "luxury",
  "lyrics",
  "machine",
  "mad",
  "magic",
  "magnet",
  "maid",
  "mail",
  "main",
  "major",
  "make",
  "mammal",
  "man",
  "manage",
  "mandate",
  "mango",
  "mansion",
  "manual",
  "maple",
  "marble",
  "march",
  "margin",
  "marine",
  "market",
  "marriage",
  "mask",
  "mass",
  "master",
  "match",
  "material",
  "math",
  "matrix",
  "matter",
  "maximum",
  "maze",
  "meadow",
  "mean",
  "measure",
  "meat",
  "mechanic",
  "medal",
  "media",
  "melody",
  "melt",
  "member",
  "memory",
  "mention",
  "menu",
  "mercy",
  "merge",
  "merit",
  "merry",
  "mesh",
  "message",
  "metal",
  "method",
  "middle",
  "midnight",
  "milk",
  "million",
  "mimic",
  "mind",
  "minimum",
  "minor",
  "minute",
  "miracle",
  "mirror",
  "misery",
  "miss",
  "mistake",
  "mix",
  "mixed",
  "mixture",
  "mobile",
  "model",
  "modify",
  "mom",
  "moment",
  "monitor",
  "monkey",
  "monster",
  "month",
  "moon",
  "moral",
  "more",
  "morning",
  "mosquito",
  "mother",
  "motion",
  "motor",
  "mountain",
  "mouse",
  "move",
  "movie",
  "much",
  "muffin",
  "mule",
  "multiply",
  "muscle",
  "museum",
  "mushroom",
  "music",
  "must",
  "mutual",
  "myself",
  "mystery",
  "myth",
  "naive",
  "name",
  "napkin",
  "narrow",
  "nasty",
  "nation",
  "nature",
  "near",
  "neck",
  "need",
  "negative",
  "neglect",
  "neither",
  "nephew",
  "nerve",
  "nest",
  "net",
  "network",
  "neutral",
  "never",
  "news",
  "next",
  "nice",
  "night",
  "noble",
  "noise",
  "nominee",
  "noodle",
  "normal",
  "north",
  "nose",
  "notable",
  "note",
  "nothing",
  "notice",
  "novel",
  "now",
  "nuclear",
  "number",
  "nurse",
  "nut",
  "oak",
  "obey",
  "object",
  "oblige",
  "obscure",
  "observe",
  "obtain",
  "obvious",
  "occur",
  "ocean",
  "october",
  "odor",
  "off",
  "offer",
  "office",
  "often",
  "oil",
  "okay",
  "old",
  "olive",
  "olympic",
  "omit",
  "once",
  "one",
  "onion",
  "online",
  "only",
  "open",
  "opera",
  "opinion",
  "oppose",
  "option",
  "orange",
  "orbit",
  "orchard",
  "order",
  "ordinary",
  "organ",
  "orient",
  "original",
  "orphan",
  "ostrich",
  "other",
  "outdoor",
  "outer",
  "output",
  "outside",
  "oval",
  "oven",
  "over",
  "own",
  "owner",
  "oxygen",
  "oyster",
  "ozone",
  "pact",
  "paddle",
  "page",
  "pair",
  "palace",
  "palm",
  "panda",
  "panel",
  "panic",
  "panther",
  "paper",
  "parade",
  "parent",
  "park",
  "parrot",
  "party",
  "pass",
  "patch",
  "path",
  "patient",
  "patrol",
  "pattern",
  "pause",
  "pave",
  "payment",
  "peace",
  "peanut",
  "pear",
  "peasant",
  "pelican",
  "pen",
  "penalty",
  "pencil",
  "people",
  "pepper",
  "perfect",
  "permit",
  "person",
  "pet",
  "phone",
  "photo",
  "phrase",
  "physical",
  "piano",
  "picnic",
  "picture",
  "piece",
  "pig",
  "pigeon",
  "pill",
  "pilot",
  "pink",
  "pioneer",
  "pipe",
  "pistol",
  "pitch",
  "pizza",
  "place",
  "planet",
  "plastic",
  "plate",
  "play",
  "please",
  "pledge",
  "pluck",
  "plug",
  "plunge",
  "poem",
  "poet",
  "point",
  "polar",
  "pole",
  "police",
  "pond",
  "pony",
  "pool",
  "popular",
  "portion",
  "position",
  "possible",
  "post",
  "potato",
  "pottery",
  "poverty",
  "powder",
  "power",
  "practice",
  "praise",
  "predict",
  "prefer",
  "prepare",
  "present",
  "pretty",
  "prevent",
  "price",
  "pride",
  "primary",
  "print",
  "priority",
  "prison",
  "private",
  "prize",
  "problem",
  "process",
  "produce",
  "profit",
  "program",
  "project",
  "promote",
  "proof",
  "property",
  "prosper",
  "protect",
  "proud",
  "provide",
  "public",
  "pudding",
  "pull",
  "pulp",
  "pulse",
  "pumpkin",
  "punch",
  "pupil",
  "puppy",
  "purchase",
  "purity",
  "purpose",
  "purse",
  "push",
  "put",
  "puzzle",
  "pyramid",
  "quality",
  "quantum",
  "quarter",
  "question",
  "quick",
  "quit",
  "quiz",
  "quote",
  "rabbit",
  "raccoon",
  "race",
  "rack",
  "radar",
  "radio",
  "rail",
  "rain",
  "raise",
  "rally",
  "ramp",
  "ranch",
  "random",
  "range",
  "rapid",
  "rare",
  "rate",
  "rather",
  "raven",
  "raw",
  "razor",
  "ready",
  "real",
  "reason",
  "rebel",
  "rebuild",
  "recall",
  "receive",
  "recipe",
  "record",
  "recycle",
  "reduce",
  "reflect",
  "reform",
  "refuse",
  "region",
  "regret",
  "regular",
  "reject",
  "relax",
  "release",
  "relief",
  "rely",
  "remain",
  "remember",
  "remind",
  "remove",
  "render",
  "renew",
  "rent",
  "reopen",
  "repair",
  "repeat",
  "replace",
  "report",
  "require",
  "rescue",
  "resemble",
  "resist",
  "resource",
  "response",
  "result",
  "retire",
  "retreat",
  "return",
  "reunion",
  "reveal",
  "review",
  "reward",
  "rhythm",
  "rib",
  "ribbon",
  "rice",
  "rich",
  "ride",
  "ridge",
  "rifle",
  "right",
  "rigid",
  "ring",
  "riot",
  "ripple",
  "risk",
  "ritual",
  "rival",
  "river",
  "road",
  "roast",
  "robot",
  "robust",
  "rocket",
  "romance",
  "roof",
  "rookie",
  "room",
  "rose",
  "rotate",
  "rough",
  "round",
  "route",
  "royal",
  "rubber",
  "rude",
  "rug",
  "rule",
  "run",
  "runway",
  "rural",
  "sad",
  "saddle",
  "sadness",
  "safe",
  "sail",
  "salad",
  "salmon",
  "salon",
  "salt",
  "salute",
  "same",
  "sample",
  "sand",
  "satisfy",
  "satoshi",
  "sauce",
  "sausage",
  "save",
  "say",
  "scale",
  "scan",
  "scare",
  "scatter",
  "scene",
  "scheme",
  "school",
  "science",
  "scissors",
  "scorpion",
  "scout",
  "scrap",
  "screen",
  "script",
  "scrub",
  "sea",
  "search",
  "season",
  "seat",
  "second",
  "secret",
  "section",
  "security",
  "seed",
  "seek",
  "segment",
  "select",
  "sell",
  "seminar",
  "senior",
  "sense",
  "sentence",
  "series",
  "service",
  "session",
  "settle",
  "setup",
  "seven",
  "shadow",
  "shaft",
  "shallow",
  "share",
  "shed",
  "shell",
  "sheriff",
  "shield",
  "shift",
  "shine",
  "ship",
  "shiver",
  "shock",
  "shoe",
  "shoot",
  "shop",
  "short",
  "shoulder",
  "shove",
  "shrimp",
  "shrug",
  "shuffle",
  "shy",
  "sibling",
  "sick",
  "side",
  "siege",
  "sight",
  "sign",
  "silent",
  "silk",
  "silly",
  "silver",
  "similar",
  "simple",
  "since",
  "sing",
  "siren",
  "sister",
  "situate",
  "six",
  "size",
  "skate",
  "sketch",
  "ski",
  "skill",
  "skin",
  "skirt",
  "skull",
  "slab",
  "slam",
  "sleep",
  "slender",
  "slice",
  "slide",
  "slight",
  "slim",
  "slogan",
  "slot",
  "slow",
  "slush",
  "small",
  "smart",
  "smile",
  "smoke",
  "smooth",
  "snack",
  "snake",
  "snap",
  "sniff",
  "snow",
  "soap",
  "soccer",
  "social",
  "sock",
  "soda",
  "soft",
  "solar",
  "soldier",
  "solid",
  "solution",
  "solve",
  "someone",
  "song",
  "soon",
  "sorry",
  "sort",
  "soul",
  "sound",
  "soup",
  "source",
  "south",
  "space",
  "spare",
  "spatial",
  "spawn",
  "speak",
  "special",
  "speed",
  "spell",
  "spend",
  "sphere",
  "spice",
  "spider",
  "spike",
  "spin",
  "spirit",
  "split",
  "spoil",
  "sponsor",
  "spoon",
  "sport",
  "spot",
  "spray",
  "spread",
  "spring",
  "spy",
  "square",
  "squeeze",
  "squirrel",
  "stable",
  "stadium",
  "staff",
  "stage",
  "stairs",
  "stamp",
  "stand",
  "start",
  "state",
  "stay",
  "steak",
  "steel",
  "stem",
  "step",
  "stereo",
  "stick",
  "still",
  "sting",
  "stock",
  "stomach",
  "stone",
  "stool",
  "story",
  "stove",
  "strategy",
  "street",
  "strike",
  "strong",
  "struggle",
  "student",
  "stuff",
  "stumble",
  "style",
  "subject",
  "submit",
  "subway",
  "success",
  "such",
  "sudden",
  "suffer",
  "sugar",
  "suggest",
  "suit",
  "summer",
  "sun",
  "sunny",
  "sunset",
  "super",
  "supply",
  "supreme",
  "sure",
  "surface",
  "surge",
  "surprise",
  "surround",
  "survey",
  "suspect",
  "sustain",
  "swallow",
  "swamp",
  "swap",
  "swarm",
  "swear",
  "sweet",
  "swift",
  "swim",
  "swing",
  "switch",
  "sword",
  "symbol",
  "symptom",
  "syrup",
  "system",
  "table",
  "tackle",
  "tag",
  "tail",
  "talent",
  "talk",
  "tank",
  "tape",
  "target",
  "task",
  "taste",
  "tattoo",
  "taxi",
  "teach",
  "team",
  "tell",
  "ten",
  "tenant",
  "tennis",
  "tent",
  "term",
  "test",
  "text",
  "thank",
  "that",
  "theme",
  "then",
  "theory",
  "there",
  "they",
  "thing",
  "this",
  "thought",
  "three",
  "thrive",
  "throw",
  "thumb",
  "thunder",
  "ticket",
  "tide",
  "tiger",
  "tilt",
  "timber",
  "time",
  "tiny",
  "tip",
  "tired",
  "tissue",
  "title",
  "toast",
  "tobacco",
  "today",
  "toddler",
  "toe",
  "together",
  "toilet",
  "token",
  "tomato",
  "tomorrow",
  "tone",
  "tongue",
  "tonight",
  "tool",
  "tooth",
  "top",
  "topic",
  "topple",
  "torch",
  "tornado",
  "tortoise",
  "toss",
  "total",
  "tourist",
  "toward",
  "tower",
  "town",
  "toy",
  "track",
  "trade",
  "traffic",
  "tragic",
  "train",
  "transfer",
  "trap",
  "trash",
  "travel",
  "tray",
  "treat",
  "tree",
  "trend",
  "trial",
  "tribe",
  "trick",
  "trigger",
  "trim",
  "trip",
  "trophy",
  "trouble",
  "truck",
  "true",
  "truly",
  "trumpet",
  "trust",
  "truth",
  "try",
  "tube",
  "tuition",
  "tumble",
  "tuna",
  "tunnel",
  "turkey",
  "turn",
  "turtle",
  "twelve",
  "twenty",
  "twice",
  "twin",
  "twist",
  "two",
  "type",
  "typical",
  "ugly",
  "umbrella",
  "unable",
  "unaware",
  "uncle",
  "uncover",
  "under",
  "undo",
  "unfair",
  "unfold",
  "unhappy",
  "uniform",
  "unique",
  "unit",
  "universe",
  "unknown",
  "unlock",
  "until",
  "unusual",
  "unveil",
  "update",
  "upgrade",
  "uphold",
  "upon",
  "upper",
  "upset",
  "urban",
  "urge",
  "usage",
  "use",
  "used",
  "useful",
  "useless",
  "usual",
  "utility",
  "vacant",
  "vacuum",
  "vague",
  "valid",
  "valley",
  "valve",
  "van",
  "vanish",
  "vapor",
  "various",
  "vast",
  "vault",
  "vehicle",
  "velvet",
  "vendor",
  "venture",
  "venue",
  "verb",
  "verify",
  "version",
  "very",
  "vessel",
  "veteran",
  "viable",
  "vibrant",
  "vicious",
  "victory",
  "video",
  "view",
  "village",
  "vintage",
  "violin",
  "virtual",
  "virus",
  "visa",
  "visit",
  "visual",
  "vital",
  "vivid",
  "vocal",
  "voice",
  "void",
  "volcano",
  "volume",
  "vote",
  "voyage",
  "wage",
  "wagon",
  "wait",
  "walk",
  "wall",
  "walnut",
  "want",
  "warfare",
  "warm",
  "warrior",
  "wash",
  "wasp",
  "waste",
  "water",
  "wave",
  "way",
  "wealth",
  "weapon",
  "wear",
  "weasel",
  "weather",
  "web",
  "wedding",
  "weekend",
  "weird",
  "welcome",
  "west",
  "wet",
  "whale",
  "what",
  "wheat",
  "wheel",
  "when",
  "where",
  "whip",
  "whisper",
  "wide",
  "width",
  "wife",
  "wild",
  "will",
  "win",
  "window",
  "wine",
  "wing",
  "wink",
  "winner",
  "winter",
  "wire",
  "wisdom",
  "wise",
  "wish",
  "witness",
  "wolf",
  "woman",
  "wonder",
  "wood",
  "wool",
  "word",
  "work",
  "world",
  "worry",
  "worth",
  "wrap",
  "wreck",
  "wrestle",
  "wrist",
  "write",
  "wrong",
  "yard",
  "year",
  "yellow",
  "you",
  "young",
  "youth",
  "zebra",
  "zero",
  "zone",
  "zoo"
];

// node_modules/@fuel-ts/mnemonic/dist/index.mjs
var toUtf8Bytes2 = function(stri) {
  const str = stri.normalize("NFKD");
  const result = [];
  for (let i = 0;i < str.length; i += 1) {
    const c = str.charCodeAt(i);
    if (c < 128) {
      result.push(c);
    } else if (c < 2048) {
      result.push(c >> 6 | 192);
      result.push(c & 63 | 128);
    } else if ((c & 64512) === 55296) {
      i += 1;
      const c2 = str.charCodeAt(i);
      if (i >= str.length || (c2 & 64512) !== 56320) {
        throw new FuelError(ErrorCode.INVALID_INPUT_PARAMETERS, "Invalid UTF-8 in the input string.");
      }
      const pair = 65536 + ((c & 1023) << 10) + (c2 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c >> 12 | 224);
      result.push(c >> 6 & 63 | 128);
      result.push(c & 63 | 128);
    }
  }
  return Uint8Array.from(result);
};
var getLowerMask = function(bits) {
  return (1 << bits) - 1;
};
var getUpperMask = function(bits) {
  return (1 << bits) - 1 << 8 - bits;
};
var getWords = function(mnemonic) {
  if (!Array.isArray(mnemonic)) {
    return mnemonic.split(/\s+/);
  }
  return mnemonic;
};
var getPhrase = function(mnemonic) {
  if (Array.isArray(mnemonic)) {
    return mnemonic.join(" ");
  }
  return mnemonic;
};
var entropyToMnemonicIndices = function(entropy) {
  const indices = [0];
  let remainingBits = 11;
  for (let i = 0;i < entropy.length; i += 1) {
    if (remainingBits > 8) {
      indices[indices.length - 1] <<= 8;
      indices[indices.length - 1] |= entropy[i];
      remainingBits -= 8;
    } else {
      indices[indices.length - 1] <<= remainingBits;
      indices[indices.length - 1] |= entropy[i] >> 8 - remainingBits;
      indices.push(entropy[i] & getLowerMask(8 - remainingBits));
      remainingBits += 3;
    }
  }
  const checksumBits = entropy.length / 4;
  const checksum = getBytesCopy(sha2563(entropy))[0] & getUpperMask(checksumBits);
  indices[indices.length - 1] <<= checksumBits;
  indices[indices.length - 1] |= checksum >> 8 - checksumBits;
  return indices;
};
var mnemonicWordsToEntropy = function(words, wordlist) {
  const size = Math.ceil(11 * words.length / 8);
  const entropy = getBytesCopy(new Uint8Array(size));
  let offset = 0;
  for (let i = 0;i < words.length; i += 1) {
    const index = wordlist.indexOf(words[i].normalize("NFKD"));
    if (index === -1) {
      throw new FuelError(ErrorCode.INVALID_MNEMONIC, `Invalid mnemonic: the word '${words[i]}' is not found in the provided wordlist.`);
    }
    for (let bit = 0;bit < 11; bit += 1) {
      if (index & 1 << 10 - bit) {
        entropy[offset >> 3] |= 1 << 7 - offset % 8;
      }
      offset += 1;
    }
  }
  const entropyBits = 32 * words.length / 3;
  const checksumBits = words.length / 3;
  const checksumMask = getUpperMask(checksumBits);
  const checksum = getBytesCopy(sha2563(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
  if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {
    throw new FuelError(ErrorCode.INVALID_CHECKSUM, "Checksum validation failed for the provided mnemonic.");
  }
  return entropy.slice(0, entropyBits / 8);
};
var assertWordList = function(wordlist) {
  if (wordlist.length !== 2048) {
    throw new FuelError(ErrorCode.INVALID_WORD_LIST, `Expected word list length of 2048, but got ${wordlist.length}.`);
  }
};
var assertEntropy = function(entropy) {
  if (entropy.length % 4 !== 0 || entropy.length < 16 || entropy.length > 32) {
    throw new FuelError(ErrorCode.INVALID_ENTROPY, `Entropy should be between 16 and 32 bytes and a multiple of 4, but got ${entropy.length} bytes.`);
  }
};
var assertMnemonic = function(words) {
  if (!MNEMONIC_SIZES.includes(words.length)) {
    const errorMsg = `Invalid mnemonic size. Expected one of [${MNEMONIC_SIZES.join(", ")}] words, but got ${words.length}.`;
    throw new FuelError(ErrorCode.INVALID_MNEMONIC, errorMsg);
  }
};
var MasterSecret = toUtf8Bytes2("Bitcoin seed");
var MainnetPRV = "0x0488ade4";
var TestnetPRV = "0x04358394";
var MNEMONIC_SIZES = [12, 15, 18, 21, 24];
var Mnemonic = class {
  wordlist;
  constructor(wordlist = english) {
    this.wordlist = wordlist;
    assertWordList(this.wordlist);
  }
  mnemonicToEntropy(phrase) {
    return Mnemonic.mnemonicToEntropy(phrase, this.wordlist);
  }
  entropyToMnemonic(entropy) {
    return Mnemonic.entropyToMnemonic(entropy, this.wordlist);
  }
  static mnemonicToEntropy(phrase, wordlist = english) {
    const words = getWords(phrase);
    assertMnemonic(words);
    return hexlify(mnemonicWordsToEntropy(words, wordlist));
  }
  static entropyToMnemonic(entropy, wordlist = english) {
    const entropyBytes = getBytesCopy(entropy);
    assertWordList(wordlist);
    assertEntropy(entropyBytes);
    return entropyToMnemonicIndices(entropyBytes).map((i) => wordlist[i]).join(" ");
  }
  static mnemonicToSeed(phrase, passphrase = "") {
    assertMnemonic(getWords(phrase));
    const phraseBytes = toUtf8Bytes2(getPhrase(phrase));
    const salt = toUtf8Bytes2(`mnemonic${passphrase}`);
    return pbkdf23(phraseBytes, salt, 2048, 64, "sha512");
  }
  static mnemonicToMasterKeys(phrase, passphrase = "") {
    const seed = Mnemonic.mnemonicToSeed(phrase, passphrase);
    return Mnemonic.masterKeysFromSeed(seed);
  }
  static isMnemonicValid(phrase) {
    const words = getWords(phrase);
    let i = 0;
    try {
      assertMnemonic(words);
    } catch {
      return false;
    }
    while (i < words.length) {
      if (Mnemonic.binarySearch(words[i]) === false)
        return false;
      i += 1;
    }
    return true;
  }
  static binarySearch(target) {
    const words = english;
    let left = 0;
    let right = words.length - 1;
    while (left <= right) {
      const mid = Math.floor((left + right) / 2);
      if (words[mid] === target)
        return true;
      if (target < words[mid])
        right = mid - 1;
      else
        left = mid + 1;
    }
    return false;
  }
  static masterKeysFromSeed(seed) {
    const seedArray = getBytesCopy(seed);
    if (seedArray.length < 16 || seedArray.length > 64) {
      throw new FuelError(ErrorCode.INVALID_SEED, `Seed length should be between 16 and 64 bytes, but received ${seedArray.length} bytes.`);
    }
    return getBytesCopy(computeHmac("sha512", MasterSecret, seedArray));
  }
  static seedToExtendedKey(seed, testnet = false) {
    const masterKey = Mnemonic.masterKeysFromSeed(seed);
    const prefix = getBytesCopy(testnet ? TestnetPRV : MainnetPRV);
    const depth = "0x00";
    const fingerprint = "0x00000000";
    const index = "0x00000000";
    const chainCode = masterKey.slice(32);
    const privateKey = masterKey.slice(0, 32);
    const extendedKey = concat([
      prefix,
      depth,
      fingerprint,
      index,
      chainCode,
      concat(["0x00", privateKey])
    ]);
    const checksum = dataSlice(sha2563(sha2563(extendedKey)), 0, 4);
    return encodeBase58(concat([extendedKey, checksum]));
  }
  static generate(size = 32, extraEntropy = "") {
    const entropy = extraEntropy ? sha2563(concat([randomBytes22(size), getBytesCopy(extraEntropy)])) : randomBytes22(size);
    return Mnemonic.entropyToMnemonic(entropy);
  }
};
var mnemonic_default = Mnemonic;
// node_modules/@fuel-ts/signer/dist/index.mjs
var elliptic = __toESM(require_elliptic(), 1);
var getCurve = function() {
  return new EC("secp256k1");
};
var { ec: EC } = elliptic;
var Signer = class {
  address;
  publicKey;
  compressedPublicKey;
  privateKey;
  constructor(privateKey) {
    if (typeof privateKey === "string") {
      if (privateKey.match(/^[0-9a-f]*$/i) && privateKey.length === 64) {
        privateKey = `0x${privateKey}`;
      }
    }
    const privateKeyBytes = getBytesCopy(privateKey);
    const keyPair = getCurve().keyFromPrivate(privateKeyBytes, "hex");
    this.compressedPublicKey = hexlify(Uint8Array.from(keyPair.getPublic(true, "array")));
    this.publicKey = hexlify(Uint8Array.from(keyPair.getPublic(false, "array").slice(1)));
    this.privateKey = hexlify(privateKeyBytes);
    this.address = Address.fromPublicKey(this.publicKey);
  }
  sign(data3) {
    const keyPair = getCurve().keyFromPrivate(getBytesCopy(this.privateKey), "hex");
    const signature = keyPair.sign(getBytesCopy(data3), {
      canonical: true
    });
    const r = toBytes2(signature.r, 32);
    const s = toBytes2(signature.s, 32);
    s[0] |= (signature.recoveryParam || 0) << 7;
    return concat([r, s]);
  }
  addPoint(point) {
    const p02 = getCurve().keyFromPublic(getBytesCopy(this.compressedPublicKey));
    const p1 = getCurve().keyFromPublic(getBytesCopy(point));
    const result = p02.getPublic().add(p1.getPublic());
    return hexlify(Uint8Array.from(result.encode("array", true)));
  }
  static recoverPublicKey(data3, signature) {
    const signedMessageBytes = getBytesCopy(signature);
    const r = signedMessageBytes.slice(0, 32);
    const s = signedMessageBytes.slice(32, 64);
    const recoveryParam = (s[0] & 128) >> 7;
    s[0] &= 127;
    const publicKey = getCurve().recoverPubKey(getBytesCopy(data3), { r, s }, recoveryParam).encode("array", false).slice(1);
    return hexlify(Uint8Array.from(publicKey));
  }
  static recoverAddress(data3, signature) {
    return Address.fromPublicKey(Signer.recoverPublicKey(data3, signature));
  }
  static generatePrivateKey(entropy) {
    return entropy ? hash4(concat([randomBytes22(32), getBytesCopy(entropy)])) : randomBytes22(32);
  }
  static extendPublicKey(publicKey) {
    const keyPair = getCurve().keyFromPublic(getBytesCopy(publicKey));
    return hexlify(Uint8Array.from(keyPair.getPublic(false, "array").slice(1)));
  }
};
var signer_default = Signer;

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/stringify.js
function unsafeStringify(arr, offset = 0) {
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}
var byteToHex = [];
for (let i = 0;i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}

// node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// node_modules/uuid/dist/esm-browser/v4.js
var v4 = function(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0;i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
};
var v4_default = v4;
// node_modules/@fuel-ts/wallet/dist/index.mjs
async function encryptKeystoreWallet(privateKey, address8, password) {
  const privateKeyBuffer = bufferFromString2(removeHexPrefix(privateKey), "hex");
  const salt = randomBytes22(DEFAULT_KEY_SIZE);
  const key = scrypt22({
    password: bufferFromString2(password),
    salt,
    dklen: DEFAULT_KEY_SIZE,
    n: 2 ** DEFAULT_KDF_PARAMS_LOG_N,
    r: DEFAULT_KDF_PARAMS_R,
    p: DEFAULT_KDF_PARAMS_P
  });
  const iv = randomBytes22(DEFAULT_IV_SIZE);
  const ciphertext = await encryptJsonWalletData2(privateKeyBuffer, key, iv);
  const data3 = Uint8Array.from([...key.subarray(16, 32), ...ciphertext]);
  const macHashUint8Array = keccak25622(data3);
  const mac = stringFromBuffer2(macHashUint8Array, "hex");
  const keystore = {
    id: v4_default(),
    version: 3,
    address: removeHexPrefix(address8.toHexString()),
    crypto: {
      cipher: "aes-128-ctr",
      mac,
      cipherparams: { iv: stringFromBuffer2(iv, "hex") },
      ciphertext: stringFromBuffer2(ciphertext, "hex"),
      kdf: "scrypt",
      kdfparams: {
        dklen: DEFAULT_KEY_SIZE,
        n: 2 ** DEFAULT_KDF_PARAMS_LOG_N,
        p: DEFAULT_KDF_PARAMS_P,
        r: DEFAULT_KDF_PARAMS_R,
        salt: stringFromBuffer2(salt, "hex")
      }
    }
  };
  return JSON.stringify(keystore);
}
async function decryptKeystoreWallet(jsonWallet, password) {
  const keystoreWallet = JSON.parse(jsonWallet);
  const {
    crypto: {
      mac,
      ciphertext,
      cipherparams: { iv },
      kdfparams: { dklen, n, r, p, salt }
    }
  } = keystoreWallet;
  const ciphertextBuffer = bufferFromString2(ciphertext, "hex");
  const ivBuffer = bufferFromString2(iv, "hex");
  const saltBuffer = bufferFromString2(salt, "hex");
  const passwordBuffer = bufferFromString2(password);
  const key = scrypt22({
    password: passwordBuffer,
    salt: saltBuffer,
    n,
    p,
    r,
    dklen
  });
  const data3 = Uint8Array.from([...key.subarray(16, 32), ...ciphertextBuffer]);
  const macHashUint8Array = keccak25622(data3);
  const macHash = stringFromBuffer2(macHashUint8Array, "hex");
  if (mac !== macHash) {
    throw new FuelError(ErrorCode.INVALID_PASSWORD, "Failed to decrypt the keystore wallet, the provided password is incorrect.");
  }
  const buffer = await decryptJsonWalletData2(ciphertextBuffer, key, ivBuffer);
  const privateKey = hexlify(buffer);
  return privateKey;
}

// node_modules/@fuel-ts/hdwallet/dist/index.mjs
var base58check = function(data3) {
  return encodeBase58(concat([data3, dataSlice(sha2563(sha2563(data3)), 0, 4)]));
};
var getExtendedKeyPrefix = function(isPublic = false, testnet = false) {
  if (isPublic) {
    return testnet ? TestnetPUB : MainnetPUB;
  }
  return testnet ? TestnetPRV2 : MainnetPRV2;
};
var isPublicExtendedKey = function(extendedKey) {
  return [MainnetPUB, TestnetPUB].includes(hexlify(extendedKey.slice(0, 4)));
};
var isValidExtendedKey = function(extendedKey) {
  return [MainnetPRV2, TestnetPRV2, MainnetPUB, TestnetPUB].includes(hexlify(extendedKey.slice(0, 4)));
};
var parsePath = function(path, depth = 0) {
  const components = path.split("/");
  if (components.length === 0 || components[0] === "m" && depth !== 0) {
    throw new FuelError(ErrorCode.HD_WALLET_ERROR, `invalid path - ${path}`);
  }
  if (components[0] === "m") {
    components.shift();
  }
  return components.map((p) => ~p.indexOf(`'`) ? parseInt(p, 10) + HARDENED_INDEX : parseInt(p, 10));
};
var HARDENED_INDEX = 2147483648;
var MainnetPRV2 = hexlify("0x0488ade4");
var MainnetPUB = hexlify("0x0488b21e");
var TestnetPRV2 = hexlify("0x04358394");
var TestnetPUB = hexlify("0x043587cf");
var HDWallet = class {
  depth = 0;
  index = 0;
  fingerprint = hexlify("0x00000000");
  parentFingerprint = hexlify("0x00000000");
  privateKey;
  publicKey;
  chainCode;
  constructor(config) {
    if (config.privateKey) {
      const signer2 = new signer_default(config.privateKey);
      this.publicKey = hexlify(signer2.compressedPublicKey);
      this.privateKey = hexlify(config.privateKey);
    } else {
      if (!config.publicKey) {
        throw new FuelError(ErrorCode.HD_WALLET_ERROR, "Both public and private Key cannot be missing. At least one should be provided.");
      }
      this.publicKey = hexlify(config.publicKey);
    }
    this.parentFingerprint = config.parentFingerprint || this.parentFingerprint;
    this.fingerprint = dataSlice(ripemd1603(sha2563(this.publicKey)), 0, 4);
    this.depth = config.depth || this.depth;
    this.index = config.index || this.index;
    this.chainCode = config.chainCode;
  }
  get extendedKey() {
    return this.toExtendedKey();
  }
  deriveIndex(index) {
    const privateKey = this.privateKey && getBytesCopy(this.privateKey);
    const publicKey = getBytesCopy(this.publicKey);
    const chainCode = getBytesCopy(this.chainCode);
    const data3 = new Uint8Array(37);
    if (index & HARDENED_INDEX) {
      if (!privateKey) {
        throw new FuelError(ErrorCode.HD_WALLET_ERROR, "Cannot derive a hardened index without a private Key.");
      }
      data3.set(privateKey, 1);
    } else {
      data3.set(getBytesCopy(this.publicKey));
    }
    data3.set(toBytes2(index, 4), 33);
    const bytes3 = getBytesCopy(computeHmac("sha512", chainCode, data3));
    const IL = bytes3.slice(0, 32);
    const IR = bytes3.slice(32);
    if (privateKey) {
      const N = "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141";
      const ki = bn(IL).add(privateKey).mod(N).toBytes(32);
      return new HDWallet({
        privateKey: ki,
        chainCode: IR,
        index,
        depth: this.depth + 1,
        parentFingerprint: this.fingerprint
      });
    }
    const signer2 = new signer_default(hexlify(IL));
    const Ki = signer2.addPoint(publicKey);
    return new HDWallet({
      publicKey: Ki,
      chainCode: IR,
      index,
      depth: this.depth + 1,
      parentFingerprint: this.fingerprint
    });
  }
  derivePath(path) {
    const paths = parsePath(path, this.depth);
    return paths.reduce((hdwallet, index) => hdwallet.deriveIndex(index), this);
  }
  toExtendedKey(isPublic = false, testnet = false) {
    if (this.depth >= 256) {
      throw new FuelError(ErrorCode.HD_WALLET_ERROR, `Exceeded max depth of 255. Current depth: ${this.depth}.`);
    }
    const prefix = getExtendedKeyPrefix(this.privateKey == null || isPublic, testnet);
    const depth = hexlify(Uint8Array.from([this.depth]));
    const parentFingerprint = this.parentFingerprint;
    const index = toHex(this.index, 4);
    const chainCode = this.chainCode;
    const key = this.privateKey != null && !isPublic ? concat(["0x00", this.privateKey]) : this.publicKey;
    const extendedKey = getBytesCopy(concat([prefix, depth, parentFingerprint, index, chainCode, key]));
    return base58check(extendedKey);
  }
  static fromSeed(seed) {
    const masterKey = mnemonic_default.masterKeysFromSeed(seed);
    return new HDWallet({
      chainCode: getBytesCopy(masterKey.slice(32)),
      privateKey: getBytesCopy(masterKey.slice(0, 32))
    });
  }
  static fromExtendedKey(extendedKey) {
    const decoded = toBeHex(decodeBase58(extendedKey));
    const bytes3 = getBytesCopy(decoded);
    const validChecksum = base58check(bytes3.slice(0, 78)) === extendedKey;
    if (bytes3.length !== 82 || !isValidExtendedKey(bytes3)) {
      throw new FuelError(ErrorCode.HD_WALLET_ERROR, "Provided key is not a valid extended key.");
    }
    if (!validChecksum)
      throw new FuelError(ErrorCode.HD_WALLET_ERROR, "Provided key has an invalid checksum.");
    const depth = bytes3[4];
    const parentFingerprint = hexlify(bytes3.slice(5, 9));
    const index = parseInt(hexlify(bytes3.slice(9, 13)).substring(2), 16);
    const chainCode = hexlify(bytes3.slice(13, 45));
    const key = bytes3.slice(45, 78);
    if (depth === 0 && parentFingerprint !== "0x00000000" || depth === 0 && index !== 0) {
      throw new FuelError(ErrorCode.HD_WALLET_ERROR, "Inconsistency detected: Depth is zero but fingerprint/index is non-zero.");
    }
    if (isPublicExtendedKey(bytes3)) {
      if (key[0] !== 3) {
        throw new FuelError(ErrorCode.HD_WALLET_ERROR, "Invalid public extended key.");
      }
      return new HDWallet({
        publicKey: key,
        chainCode,
        index,
        depth,
        parentFingerprint
      });
    }
    if (key[0] !== 0) {
      throw new FuelError(ErrorCode.HD_WALLET_ERROR, "Invalid private extended key.");
    }
    return new HDWallet({
      privateKey: key.slice(1),
      chainCode,
      index,
      depth,
      parentFingerprint
    });
  }
};
var hdwallet_default = HDWallet;

// node_modules/@fuel-ts/wallet/dist/index.mjs
var __defProp7 = Object.defineProperty;
var __defNormalProp5 = (obj, key, value) => (key in obj) ? __defProp7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField5 = (obj, key, value) => {
  __defNormalProp5(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var composeScriptForTransferringToContract = async () => {
  await initWasm();
  const gtf2 = gtf(16, 0, GTFArgs.ScriptData);
  const addi2 = addi(17, 16, 32);
  const lw2 = lw(18, 17, 0);
  const addi22 = addi(19, 17, 8);
  const tr2 = tr(16, 18, 19);
  const ret2 = ret(1);
  const script = Uint8Array.from([
    ...gtf2.to_bytes(),
    ...addi2.to_bytes(),
    ...lw2.to_bytes(),
    ...addi22.to_bytes(),
    ...tr2.to_bytes(),
    ...ret2.to_bytes()
  ]);
  return script;
};
var formatScriptDataForTransferringToContract = (hexelifiedContractId, amountToTransfer, assetId) => {
  const numberCoder = new U64Coder;
  const encoded = numberCoder.encode(new BN(amountToTransfer).toNumber());
  const scriptData = Uint8Array.from([
    ...getBytesCopy(hexelifiedContractId),
    ...encoded,
    ...getBytesCopy(assetId)
  ]);
  return scriptData;
};
var Account = class extends AbstractAccount {
  address;
  provider;
  constructor(address8, provider) {
    super();
    this.provider = provider;
    this.address = Address.fromDynamicInput(address8);
  }
  connect(provider) {
    this.provider = provider;
    return this.provider;
  }
  async getResourcesToSpend(quantities, excludedIds) {
    return this.provider.getResourcesToSpend(this.address, quantities, excludedIds);
  }
  async getCoins(assetId) {
    const coins = [];
    const pageSize = 9999;
    let cursor;
    for (;; ) {
      const pageCoins = await this.provider.getCoins(this.address, assetId, {
        first: pageSize,
        after: cursor
      });
      coins.push(...pageCoins);
      const hasNextPage = pageCoins.length >= pageSize;
      if (!hasNextPage) {
        break;
      }
      throw new FuelError(ErrorCode.NOT_SUPPORTED, `Wallets containing more than ${pageSize} coins exceed the current supported limit.`);
    }
    return coins;
  }
  async getMessages() {
    const messages = [];
    const pageSize = 9999;
    let cursor;
    for (;; ) {
      const pageMessages = await this.provider.getMessages(this.address, {
        first: pageSize,
        after: cursor
      });
      messages.push(...pageMessages);
      const hasNextPage = pageMessages.length >= pageSize;
      if (!hasNextPage) {
        break;
      }
      throw new FuelError(ErrorCode.NOT_SUPPORTED, `Wallets containing more than ${pageSize} messages exceed the current supported limit.`);
    }
    return messages;
  }
  async getBalance(assetId = BaseAssetId) {
    const amount = await this.provider.getBalance(this.address, assetId);
    return amount;
  }
  async getBalances() {
    const balances = [];
    const pageSize = 9999;
    let cursor;
    for (;; ) {
      const pageBalances = await this.provider.getBalances(this.address, {
        first: pageSize,
        after: cursor
      });
      balances.push(...pageBalances);
      const hasNextPage = pageBalances.length >= pageSize;
      if (!hasNextPage) {
        break;
      }
      throw new FuelError(ErrorCode.NOT_SUPPORTED, `Wallets containing more than ${pageSize} balances exceed the current supported limit.`);
    }
    return balances;
  }
  async fund(request, quantities, fee) {
    addAmountToAsset({
      amount: fee,
      assetId: BaseAssetId,
      coinQuantities: quantities
    });
    const resources = await this.getResourcesToSpend(quantities);
    request.addResources(resources);
  }
  async transfer(destination, amount, assetId = BaseAssetId, txParams = {}) {
    const { maxGasPerTx } = this.provider.getGasConfig();
    const params = { gasLimit: maxGasPerTx, ...txParams };
    const request = new ScriptTransactionRequest(params);
    request.addCoinOutput(destination, amount, assetId);
    const { maxFee, requiredQuantities } = await this.provider.getTransactionCost(request);
    await this.fund(request, requiredQuantities, maxFee);
    return this.sendTransaction(request);
  }
  async transferToContract(contractId, amount, assetId = BaseAssetId, txParams = {}) {
    const script = await composeScriptForTransferringToContract();
    const scriptData = formatScriptDataForTransferringToContract(contractId.toB256(), amount, assetId);
    const { maxGasPerTx } = this.provider.getGasConfig();
    const request = new ScriptTransactionRequest({
      gasLimit: maxGasPerTx,
      ...txParams,
      script,
      scriptData
    });
    request.addContractInputAndOutput(contractId);
    const { maxFee, requiredQuantities } = await this.provider.getTransactionCost(request, [
      { amount: bn(amount), assetId: String(assetId) }
    ]);
    await this.fund(request, requiredQuantities, maxFee);
    return this.sendTransaction(request);
  }
  async withdrawToBaseLayer(recipient, amount, txParams = {}) {
    const recipientDataArray = getBytesCopy("0x".concat(recipient.toHexString().substring(2).padStart(64, "0")));
    const amountDataArray = getBytesCopy("0x".concat(bn(amount).toHex().substring(2).padStart(16, "0")));
    const script = new Uint8Array([
      ...getBytesCopy(withdrawScript.bytes),
      ...recipientDataArray,
      ...amountDataArray
    ]);
    const { maxGasPerTx } = this.provider.getGasConfig();
    const params = { script, gasLimit: maxGasPerTx, ...txParams };
    const request = new ScriptTransactionRequest(params);
    const { gasPriceFactor } = this.provider.getGasConfig();
    const fee = request.calculateFee(gasPriceFactor);
    let quantities = [];
    fee.amount = fee.amount.add(amount);
    quantities = [fee];
    const resources = await this.getResourcesToSpend(quantities);
    request.addResources(resources);
    return this.sendTransaction(request);
  }
  async sendTransaction(transactionRequestLike) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    await this.provider.estimateTxDependencies(transactionRequest);
    return this.provider.sendTransaction(transactionRequest);
  }
  async simulateTransaction(transactionRequestLike) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    await this.provider.estimateTxDependencies(transactionRequest);
    return this.provider.simulate(transactionRequest);
  }
};
var DEFAULT_KDF_PARAMS_LOG_N = 13;
var DEFAULT_KDF_PARAMS_R = 8;
var DEFAULT_KDF_PARAMS_P = 1;
var DEFAULT_KEY_SIZE = 32;
var DEFAULT_IV_SIZE = 16;
var removeHexPrefix = (hexString) => {
  if (/^0x/.test(hexString)) {
    return hexString.slice(2);
  }
  return hexString;
};
var BaseWalletUnlocked = class extends Account {
  provider;
  signer;
  constructor(privateKey, provider) {
    const signer4 = new signer_default(privateKey);
    super(signer4.address, provider);
    this.signer = () => signer4;
    this.provider = provider;
  }
  get privateKey() {
    return this.signer().privateKey;
  }
  get publicKey() {
    return this.signer().publicKey;
  }
  async signMessage(message) {
    const signedMessage = await this.signer().sign(hashMessage(message));
    return signedMessage;
  }
  async signTransaction(transactionRequestLike) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    const chainId = (await this.provider.getChain()).consensusParameters.chainId.toNumber();
    const hashedTransaction = hashTransaction(transactionRequest, chainId);
    const signature = await this.signer().sign(hashedTransaction);
    return signature;
  }
  async populateTransactionWitnessesSignature(transactionRequestLike) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    const signedTransaction = await this.signTransaction(transactionRequest);
    transactionRequest.updateWitnessByOwner(this.address, signedTransaction);
    return transactionRequest;
  }
  async sendTransaction(transactionRequestLike) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    await this.provider.estimateTxDependencies(transactionRequest);
    return this.provider.sendTransaction(await this.populateTransactionWitnessesSignature(transactionRequest));
  }
  async simulateTransaction(transactionRequestLike) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    await this.provider.estimateTxDependencies(transactionRequest);
    return this.provider.call(await this.populateTransactionWitnessesSignature(transactionRequest), {
      utxoValidation: true
    });
  }
  async encrypt(password) {
    return encryptKeystoreWallet(this.privateKey, this.address, password);
  }
};
__publicField5(BaseWalletUnlocked, "defaultPath", "m/44'/1179993420'/0'/0/0");
var WalletLocked = class extends Account {
  unlock(privateKey) {
    return new WalletUnlocked(privateKey, this.provider);
  }
};
var WalletUnlocked = class extends BaseWalletUnlocked {
  lock() {
    this.signer = () => new signer_default("0x00");
    return new WalletLocked(this.address, this.provider);
  }
  static generate(generateOptions) {
    const privateKey = signer_default.generatePrivateKey(generateOptions?.entropy);
    return new WalletUnlocked(privateKey, generateOptions?.provider);
  }
  static fromSeed(seed, provider, path) {
    const hdWallet = hdwallet_default.fromSeed(seed);
    const childWallet = hdWallet.derivePath(path || WalletUnlocked.defaultPath);
    return new WalletUnlocked(childWallet.privateKey, provider);
  }
  static fromMnemonic(mnemonic3, provider, path, passphrase) {
    const seed = mnemonic_default.mnemonicToSeed(mnemonic3, passphrase);
    const hdWallet = hdwallet_default.fromSeed(seed);
    const childWallet = hdWallet.derivePath(path || WalletUnlocked.defaultPath);
    return new WalletUnlocked(childWallet.privateKey, provider);
  }
  static fromExtendedKey(extendedKey, provider) {
    const hdWallet = hdwallet_default.fromExtendedKey(extendedKey);
    return new WalletUnlocked(hdWallet.privateKey, provider);
  }
  static async fromEncryptedJson(jsonWallet, password, provider) {
    const privateKey = await decryptKeystoreWallet(jsonWallet, password);
    return new WalletUnlocked(privateKey, provider);
  }
};
var Wallet = class {
  static fromAddress(address8, provider) {
    return new WalletLocked(address8, provider);
  }
  static fromPrivateKey(privateKey, provider) {
    return new WalletUnlocked(privateKey, provider);
  }
};
__publicField5(Wallet, "generate", WalletUnlocked.generate);
__publicField5(Wallet, "fromSeed", WalletUnlocked.fromSeed);
__publicField5(Wallet, "fromMnemonic", WalletUnlocked.fromMnemonic);
__publicField5(Wallet, "fromExtendedKey", WalletUnlocked.fromExtendedKey);
__publicField5(Wallet, "fromEncryptedJson", WalletUnlocked.fromEncryptedJson);

// node_modules/@fuel-ts/predicate/dist/index.mjs
var getPredicateRoot = (bytecode, chainId) => {
  const chunkSize = 16 * 1024;
  const bytes3 = getBytesCopy(bytecode);
  const chunks = chunkAndPadBytes(bytes3, chunkSize);
  const chainIdBytes = uint64ToBytesBE(chainId);
  const codeRoot = calcRoot(chunks.map((c) => hexlify(c)));
  const predicateRoot = hash4(concat(["0x4655454C", chainIdBytes, codeRoot]));
  return predicateRoot;
};
var Predicate = class extends Account {
  bytes;
  predicateData = Uint8Array.from([]);
  interface;
  constructor(bytes3, provider, jsonAbi, configurableConstants) {
    const { predicateBytes, predicateInterface } = Predicate.processPredicateData(bytes3, jsonAbi, configurableConstants);
    const chainId = provider.getChainId();
    const address9 = Address.fromB256(getPredicateRoot(predicateBytes, chainId));
    super(address9, provider);
    this.bytes = predicateBytes;
    this.interface = predicateInterface;
  }
  populateTransactionPredicateData(transactionRequestLike) {
    const request = transactionRequestify(transactionRequestLike);
    request.inputs?.forEach((input) => {
      if (input.type === InputType.Coin && hexlify(input.owner) === this.address.toB256()) {
        input.predicate = this.bytes;
        input.predicateData = this.predicateData;
      }
    });
    return request;
  }
  sendTransaction(transactionRequestLike) {
    const transactionRequest = this.populateTransactionPredicateData(transactionRequestLike);
    return super.sendTransaction(transactionRequest);
  }
  simulateTransaction(transactionRequestLike) {
    const transactionRequest = this.populateTransactionPredicateData(transactionRequestLike);
    return super.simulateTransaction(transactionRequest);
  }
  setData(...args) {
    const mainFn = this.interface?.functions.main;
    const paddedCode = new ByteArrayCoder(this.bytes.length).encode(this.bytes);
    const VM_TX_MEMORY = calculateVmTxMemory({
      maxInputs: this.provider.getChain().consensusParameters.maxInputs.toNumber()
    });
    const OFFSET = VM_TX_MEMORY + SCRIPT_FIXED_SIZE + INPUT_COIN_FIXED_SIZE + WORD_SIZE + paddedCode.byteLength;
    this.predicateData = mainFn?.encodeArguments(args, OFFSET) || new Uint8Array;
    return this;
  }
  static processPredicateData(bytes3, jsonAbi, configurableConstants) {
    let predicateBytes = getBytesCopy(bytes3);
    let abiInterface;
    if (jsonAbi) {
      abiInterface = new Interface(jsonAbi);
      if (abiInterface.functions.main === undefined) {
        throw new FuelError(ErrorCode.ABI_MAIN_METHOD_MISSING, 'Cannot use ABI without "main" function.');
      }
    }
    if (configurableConstants && Object.keys(configurableConstants).length) {
      predicateBytes = Predicate.setConfigurableConstants(predicateBytes, configurableConstants, abiInterface);
    }
    return {
      predicateBytes,
      predicateInterface: abiInterface
    };
  }
  static setConfigurableConstants(bytes3, configurableConstants, abiInterface) {
    const mutatedBytes = bytes3;
    try {
      if (!abiInterface) {
        throw new Error("Cannot validate configurable constants because the Predicate was instantiated without a JSON ABI");
      }
      if (Object.keys(abiInterface.configurables).length === 0) {
        throw new Error("Predicate has no configurable constants to be set");
      }
      Object.entries(configurableConstants).forEach(([key, value]) => {
        if (!abiInterface?.configurables[key]) {
          throw new Error(`No configurable constant named '${key}' found in the Predicate`);
        }
        const { offset } = abiInterface.configurables[key];
        const encoded = abiInterface.encodeConfigurable(key, value);
        mutatedBytes.set(encoded, offset);
      });
    } catch (err) {
      throw new FuelError(ErrorCode.INVALID_CONFIGURABLE_CONSTANTS, `Error setting configurable constants: ${err.message}.`);
    }
    return mutatedBytes;
  }
};
// node_modules/@fuel-ts/wallet/dist/configs.mjs
var FUEL_NETWORK_URL = typeof process !== "undefined" ? process?.env?.FUEL_NETWORK_URL || "http://127.0.0.1:4000/graphql" : "http://127.0.0.1:4000/graphql";
// src/index.fuel.ts
var bin = require_fuel();
var json = {
  types: [
    {
      typeId: 0,
      type: "[_; 2]",
      components: [
        {
          name: "__array_element",
          type: 1,
          typeArguments: null
        }
      ],
      typeParameters: null
    },
    {
      typeId: 1,
      type: "b256",
      components: null,
      typeParameters: null
    },
    {
      typeId: 2,
      type: "bool",
      components: null,
      typeParameters: null
    },
    {
      typeId: 3,
      type: "raw untyped ptr",
      components: null,
      typeParameters: null
    },
    {
      typeId: 4,
      type: "struct B512",
      components: [
        {
          name: "bytes",
          type: 0,
          typeArguments: null
        }
      ],
      typeParameters: null
    },
    {
      typeId: 5,
      type: "struct Bytes",
      components: [
        {
          name: "buf",
          type: 6,
          typeArguments: null
        },
        {
          name: "len",
          type: 7,
          typeArguments: null
        }
      ],
      typeParameters: null
    },
    {
      typeId: 6,
      type: "struct RawBytes",
      components: [
        {
          name: "ptr",
          type: 3,
          typeArguments: null
        },
        {
          name: "cap",
          type: 7,
          typeArguments: null
        }
      ],
      typeParameters: null
    },
    {
      typeId: 7,
      type: "u64",
      components: null,
      typeParameters: null
    }
  ],
  functions: [
    {
      inputs: [
        {
          name: "signature",
          type: 4,
          typeArguments: null
        },
        {
          name: "authid",
          type: 5,
          typeArguments: null
        },
        {
          name: "txid",
          type: 1,
          typeArguments: null
        },
        {
          name: "pre",
          type: 5,
          typeArguments: null
        },
        {
          name: "post",
          type: 5,
          typeArguments: null
        }
      ],
      name: "main",
      output: {
        name: "",
        type: 2,
        typeArguments: null
      },
      attributes: null
    }
  ],
  loggedTypes: [],
  messagesTypes: [],
  configurables: [
    {
      name: "ADDRESS",
      configurableType: {
        name: "",
        type: 1,
        typeArguments: null
      },
      offset: 4556
    }
  ]
};
async function build_and_try() {
  const configurable = {
    ADDRESS: "0xe1037e9229115834a823d6eee714f8eb89906a14a83074f4e9515d8a80e63d95"
  };
  const provider = await Provider.create("https://beta-4.fuel.network/graphql");
  const predicate3 = new Predicate(bin, provider, json, configurable);
  const signature = getBytesCopy("0xaec03df2a7c71bddc29c5593e9a6027b7393918a9342034613857be798a654a0183506c5a3c3f1cfac461a66090993e9e75136aa4664fbd3ddc0c489f2114faa");
  const authid = getBytesCopy("0x75a448b91bb82a255757e61ba3eb7afe282c09842485268d4d72a027ec0cffc80500000000");
  const txid = getBytesCopy("0xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855");
  const pre = getBytesCopy("0x7b2274797065223a22776562617574686e2e676574222c226368616c6c656e6765223a22");
  const post = getBytesCopy("0x222c226f726967696e223a2268747470733a2f2f6e6176696761746f722d69766f72792e76657263656c2e617070222c2263726f73734f726967696e223a66616c73657d");
  predicate3.setData(signature, authid, txid, pre, post);
  console.log(predicate3.address, predicate3);
}
export {
  build_and_try as default
};
